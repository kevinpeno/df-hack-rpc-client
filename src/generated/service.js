/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.EmptyMessage = (function() {

    /**
     * Properties of an EmptyMessage.
     * @exports IEmptyMessage
     * @interface IEmptyMessage
     */

    /**
     * Constructs a new EmptyMessage.
     * @exports EmptyMessage
     * @classdesc Represents an EmptyMessage.
     * @implements IEmptyMessage
     * @constructor
     * @param {IEmptyMessage=} [properties] Properties to set
     */
    function EmptyMessage(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new EmptyMessage instance using the specified properties.
     * @function create
     * @memberof EmptyMessage
     * @static
     * @param {IEmptyMessage=} [properties] Properties to set
     * @returns {EmptyMessage} EmptyMessage instance
     */
    EmptyMessage.create = function create(properties) {
        return new EmptyMessage(properties);
    };

    /**
     * Encodes the specified EmptyMessage message. Does not implicitly {@link EmptyMessage.verify|verify} messages.
     * @function encode
     * @memberof EmptyMessage
     * @static
     * @param {IEmptyMessage} message EmptyMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EmptyMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified EmptyMessage message, length delimited. Does not implicitly {@link EmptyMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EmptyMessage
     * @static
     * @param {IEmptyMessage} message EmptyMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EmptyMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EmptyMessage message from the specified reader or buffer.
     * @function decode
     * @memberof EmptyMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EmptyMessage} EmptyMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EmptyMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EmptyMessage();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EmptyMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EmptyMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EmptyMessage} EmptyMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EmptyMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EmptyMessage message.
     * @function verify
     * @memberof EmptyMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EmptyMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an EmptyMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EmptyMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EmptyMessage} EmptyMessage
     */
    EmptyMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.EmptyMessage)
            return object;
        return new $root.EmptyMessage();
    };

    /**
     * Creates a plain object from an EmptyMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EmptyMessage
     * @static
     * @param {EmptyMessage} message EmptyMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EmptyMessage.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this EmptyMessage to JSON.
     * @function toJSON
     * @memberof EmptyMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EmptyMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EmptyMessage;
})();

$root.HandshakeRequest = (function() {

    /**
     * Properties of a HandshakeRequest.
     * @exports IHandshakeRequest
     * @interface IHandshakeRequest
     * @property {string} message HandshakeRequest message
     */

    /**
     * Constructs a new HandshakeRequest.
     * @exports HandshakeRequest
     * @classdesc Represents a HandshakeRequest.
     * @implements IHandshakeRequest
     * @constructor
     * @param {IHandshakeRequest=} [properties] Properties to set
     */
    function HandshakeRequest(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HandshakeRequest message.
     * @member {string} message
     * @memberof HandshakeRequest
     * @instance
     */
    HandshakeRequest.prototype.message = "";

    /**
     * Creates a new HandshakeRequest instance using the specified properties.
     * @function create
     * @memberof HandshakeRequest
     * @static
     * @param {IHandshakeRequest=} [properties] Properties to set
     * @returns {HandshakeRequest} HandshakeRequest instance
     */
    HandshakeRequest.create = function create(properties) {
        return new HandshakeRequest(properties);
    };

    /**
     * Encodes the specified HandshakeRequest message. Does not implicitly {@link HandshakeRequest.verify|verify} messages.
     * @function encode
     * @memberof HandshakeRequest
     * @static
     * @param {IHandshakeRequest} message HandshakeRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HandshakeRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
        return writer;
    };

    /**
     * Encodes the specified HandshakeRequest message, length delimited. Does not implicitly {@link HandshakeRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HandshakeRequest
     * @static
     * @param {IHandshakeRequest} message HandshakeRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HandshakeRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HandshakeRequest message from the specified reader or buffer.
     * @function decode
     * @memberof HandshakeRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HandshakeRequest} HandshakeRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HandshakeRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HandshakeRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("message"))
            throw $util.ProtocolError("missing required 'message'", { instance: message });
        return message;
    };

    /**
     * Decodes a HandshakeRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HandshakeRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HandshakeRequest} HandshakeRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HandshakeRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HandshakeRequest message.
     * @function verify
     * @memberof HandshakeRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HandshakeRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isString(message.message))
            return "message: string expected";
        return null;
    };

    /**
     * Creates a HandshakeRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HandshakeRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HandshakeRequest} HandshakeRequest
     */
    HandshakeRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.HandshakeRequest)
            return object;
        var message = new $root.HandshakeRequest();
        if (object.message != null)
            message.message = String(object.message);
        return message;
    };

    /**
     * Creates a plain object from a HandshakeRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HandshakeRequest
     * @static
     * @param {HandshakeRequest} message HandshakeRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HandshakeRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.message = "";
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
        return object;
    };

    /**
     * Converts this HandshakeRequest to JSON.
     * @function toJSON
     * @memberof HandshakeRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HandshakeRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return HandshakeRequest;
})();

$root.HandshakeResponse = (function() {

    /**
     * Properties of a HandshakeResponse.
     * @exports IHandshakeResponse
     * @interface IHandshakeResponse
     * @property {string} message HandshakeResponse message
     */

    /**
     * Constructs a new HandshakeResponse.
     * @exports HandshakeResponse
     * @classdesc Represents a HandshakeResponse.
     * @implements IHandshakeResponse
     * @constructor
     * @param {IHandshakeResponse=} [properties] Properties to set
     */
    function HandshakeResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HandshakeResponse message.
     * @member {string} message
     * @memberof HandshakeResponse
     * @instance
     */
    HandshakeResponse.prototype.message = "";

    /**
     * Creates a new HandshakeResponse instance using the specified properties.
     * @function create
     * @memberof HandshakeResponse
     * @static
     * @param {IHandshakeResponse=} [properties] Properties to set
     * @returns {HandshakeResponse} HandshakeResponse instance
     */
    HandshakeResponse.create = function create(properties) {
        return new HandshakeResponse(properties);
    };

    /**
     * Encodes the specified HandshakeResponse message. Does not implicitly {@link HandshakeResponse.verify|verify} messages.
     * @function encode
     * @memberof HandshakeResponse
     * @static
     * @param {IHandshakeResponse} message HandshakeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HandshakeResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
        return writer;
    };

    /**
     * Encodes the specified HandshakeResponse message, length delimited. Does not implicitly {@link HandshakeResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HandshakeResponse
     * @static
     * @param {IHandshakeResponse} message HandshakeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HandshakeResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HandshakeResponse message from the specified reader or buffer.
     * @function decode
     * @memberof HandshakeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HandshakeResponse} HandshakeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HandshakeResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HandshakeResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("message"))
            throw $util.ProtocolError("missing required 'message'", { instance: message });
        return message;
    };

    /**
     * Decodes a HandshakeResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HandshakeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HandshakeResponse} HandshakeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HandshakeResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HandshakeResponse message.
     * @function verify
     * @memberof HandshakeResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HandshakeResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isString(message.message))
            return "message: string expected";
        return null;
    };

    /**
     * Creates a HandshakeResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HandshakeResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HandshakeResponse} HandshakeResponse
     */
    HandshakeResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.HandshakeResponse)
            return object;
        var message = new $root.HandshakeResponse();
        if (object.message != null)
            message.message = String(object.message);
        return message;
    };

    /**
     * Creates a plain object from a HandshakeResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HandshakeResponse
     * @static
     * @param {HandshakeResponse} message HandshakeResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HandshakeResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.message = "";
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
        return object;
    };

    /**
     * Converts this HandshakeResponse to JSON.
     * @function toJSON
     * @memberof HandshakeResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HandshakeResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return HandshakeResponse;
})();

$root.DFHackRPCService = (function() {

    /**
     * Constructs a new DFHackRPCService service.
     * @exports DFHackRPCService
     * @classdesc Represents a DFHackRPCService
     * @extends $protobuf.rpc.Service
     * @constructor
     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
     */
    function DFHackRPCService(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
    }

    (DFHackRPCService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DFHackRPCService;

    /**
     * Creates new DFHackRPCService service using the specified rpc implementation.
     * @function create
     * @memberof DFHackRPCService
     * @static
     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
     * @returns {DFHackRPCService} RPC service. Useful where requests and/or responses are streamed.
     */
    DFHackRPCService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
        return new this(rpcImpl, requestDelimited, responseDelimited);
    };

    /**
     * Callback as used by {@link DFHackRPCService#handshake}.
     * @memberof DFHackRPCService
     * @typedef HandshakeCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {HandshakeResponse} [response] HandshakeResponse
     */

    /**
     * Calls Handshake.
     * @function handshake
     * @memberof DFHackRPCService
     * @instance
     * @param {IHandshakeRequest} request HandshakeRequest message or plain object
     * @param {DFHackRPCService.HandshakeCallback} callback Node-style callback called with the error, if any, and HandshakeResponse
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.handshake = function handshake(request, callback) {
        return this.rpcCall(handshake, $root.HandshakeRequest, $root.HandshakeResponse, request, callback);
    }, "name", { value: "Handshake" });

    /**
     * Calls Handshake.
     * @function handshake
     * @memberof DFHackRPCService
     * @instance
     * @param {IHandshakeRequest} request HandshakeRequest message or plain object
     * @returns {Promise<HandshakeResponse>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getEmbarkTile}.
     * @memberof DFHackRPCService
     * @typedef GetEmbarkTileCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {isoworldremote.EmbarkTile} [response] EmbarkTile
     */

    /**
     * Calls GetEmbarkTile.
     * @function getEmbarkTile
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.ITileRequest} request TileRequest message or plain object
     * @param {DFHackRPCService.GetEmbarkTileCallback} callback Node-style callback called with the error, if any, and EmbarkTile
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getEmbarkTile = function getEmbarkTile(request, callback) {
        return this.rpcCall(getEmbarkTile, $root.isoworldremote.TileRequest, $root.isoworldremote.EmbarkTile, request, callback);
    }, "name", { value: "GetEmbarkTile" });

    /**
     * Calls GetEmbarkTile.
     * @function getEmbarkTile
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.ITileRequest} request TileRequest message or plain object
     * @returns {Promise<isoworldremote.EmbarkTile>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getEmbarkInfo}.
     * @memberof DFHackRPCService
     * @typedef GetEmbarkInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {isoworldremote.MapReply} [response] MapReply
     */

    /**
     * Calls GetEmbarkInfo.
     * @function getEmbarkInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @param {DFHackRPCService.GetEmbarkInfoCallback} callback Node-style callback called with the error, if any, and MapReply
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getEmbarkInfo = function getEmbarkInfo(request, callback) {
        return this.rpcCall(getEmbarkInfo, $root.isoworldremote.MapRequest, $root.isoworldremote.MapReply, request, callback);
    }, "name", { value: "GetEmbarkInfo" });

    /**
     * Calls GetEmbarkInfo.
     * @function getEmbarkInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @returns {Promise<isoworldremote.MapReply>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getRawNames}.
     * @memberof DFHackRPCService
     * @typedef GetRawNamesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {isoworldremote.RawNames} [response] RawNames
     */

    /**
     * Calls GetRawNames.
     * @function getRawNames
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @param {DFHackRPCService.GetRawNamesCallback} callback Node-style callback called with the error, if any, and RawNames
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getRawNames = function getRawNames(request, callback) {
        return this.rpcCall(getRawNames, $root.isoworldremote.MapRequest, $root.isoworldremote.RawNames, request, callback);
    }, "name", { value: "GetRawNames" });

    /**
     * Calls GetRawNames.
     * @function getRawNames
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @returns {Promise<isoworldremote.RawNames>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getMaterialList}.
     * @memberof DFHackRPCService
     * @typedef GetMaterialListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MaterialList} [response] MaterialList
     */

    /**
     * Calls GetMaterialList.
     * @function getMaterialList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetMaterialListCallback} callback Node-style callback called with the error, if any, and MaterialList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getMaterialList = function getMaterialList(request, callback) {
        return this.rpcCall(getMaterialList, $root.EmptyMessage, $root.RemoteFortressReader.MaterialList, request, callback);
    }, "name", { value: "GetMaterialList" });

    /**
     * Calls GetMaterialList.
     * @function getMaterialList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MaterialList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getGrowthList}.
     * @memberof DFHackRPCService
     * @typedef GetGrowthListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MaterialList} [response] MaterialList
     */

    /**
     * Calls GetGrowthList.
     * @function getGrowthList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetGrowthListCallback} callback Node-style callback called with the error, if any, and MaterialList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getGrowthList = function getGrowthList(request, callback) {
        return this.rpcCall(getGrowthList, $root.EmptyMessage, $root.RemoteFortressReader.MaterialList, request, callback);
    }, "name", { value: "GetGrowthList" });

    /**
     * Calls GetGrowthList.
     * @function getGrowthList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MaterialList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getBlockList}.
     * @memberof DFHackRPCService
     * @typedef GetBlockListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.BlockList} [response] BlockList
     */

    /**
     * Calls GetBlockList.
     * @function getBlockList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @param {DFHackRPCService.GetBlockListCallback} callback Node-style callback called with the error, if any, and BlockList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getBlockList = function getBlockList(request, callback) {
        return this.rpcCall(getBlockList, $root.RemoteFortressReader.BlockRequest, $root.RemoteFortressReader.BlockList, request, callback);
    }, "name", { value: "GetBlockList" });

    /**
     * Calls GetBlockList.
     * @function getBlockList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @returns {Promise<RemoteFortressReader.BlockList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#checkHashes}.
     * @memberof DFHackRPCService
     * @typedef CheckHashesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls CheckHashes.
     * @function checkHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.CheckHashesCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.checkHashes = function checkHashes(request, callback) {
        return this.rpcCall(checkHashes, $root.EmptyMessage, $root.EmptyMessage, request, callback);
    }, "name", { value: "CheckHashes" });

    /**
     * Calls CheckHashes.
     * @function checkHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getTiletypeList}.
     * @memberof DFHackRPCService
     * @typedef GetTiletypeListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.TiletypeList} [response] TiletypeList
     */

    /**
     * Calls GetTiletypeList.
     * @function getTiletypeList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetTiletypeListCallback} callback Node-style callback called with the error, if any, and TiletypeList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getTiletypeList = function getTiletypeList(request, callback) {
        return this.rpcCall(getTiletypeList, $root.EmptyMessage, $root.RemoteFortressReader.TiletypeList, request, callback);
    }, "name", { value: "GetTiletypeList" });

    /**
     * Calls GetTiletypeList.
     * @function getTiletypeList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.TiletypeList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPlantList}.
     * @memberof DFHackRPCService
     * @typedef GetPlantListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.PlantList} [response] PlantList
     */

    /**
     * Calls GetPlantList.
     * @function getPlantList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @param {DFHackRPCService.GetPlantListCallback} callback Node-style callback called with the error, if any, and PlantList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getPlantList = function getPlantList(request, callback) {
        return this.rpcCall(getPlantList, $root.RemoteFortressReader.BlockRequest, $root.RemoteFortressReader.PlantList, request, callback);
    }, "name", { value: "GetPlantList" });

    /**
     * Calls GetPlantList.
     * @function getPlantList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @returns {Promise<RemoteFortressReader.PlantList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getUnitList}.
     * @memberof DFHackRPCService
     * @typedef GetUnitListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.UnitList} [response] UnitList
     */

    /**
     * Calls GetUnitList.
     * @function getUnitList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetUnitListCallback} callback Node-style callback called with the error, if any, and UnitList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getUnitList = function getUnitList(request, callback) {
        return this.rpcCall(getUnitList, $root.EmptyMessage, $root.RemoteFortressReader.UnitList, request, callback);
    }, "name", { value: "GetUnitList" });

    /**
     * Calls GetUnitList.
     * @function getUnitList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.UnitList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getUnitListInside}.
     * @memberof DFHackRPCService
     * @typedef GetUnitListInsideCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.UnitList} [response] UnitList
     */

    /**
     * Calls GetUnitListInside.
     * @function getUnitListInside
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @param {DFHackRPCService.GetUnitListInsideCallback} callback Node-style callback called with the error, if any, and UnitList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getUnitListInside = function getUnitListInside(request, callback) {
        return this.rpcCall(getUnitListInside, $root.RemoteFortressReader.BlockRequest, $root.RemoteFortressReader.UnitList, request, callback);
    }, "name", { value: "GetUnitListInside" });

    /**
     * Calls GetUnitListInside.
     * @function getUnitListInside
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @returns {Promise<RemoteFortressReader.UnitList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getViewInfo}.
     * @memberof DFHackRPCService
     * @typedef GetViewInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.ViewInfo} [response] ViewInfo
     */

    /**
     * Calls GetViewInfo.
     * @function getViewInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetViewInfoCallback} callback Node-style callback called with the error, if any, and ViewInfo
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getViewInfo = function getViewInfo(request, callback) {
        return this.rpcCall(getViewInfo, $root.EmptyMessage, $root.RemoteFortressReader.ViewInfo, request, callback);
    }, "name", { value: "GetViewInfo" });

    /**
     * Calls GetViewInfo.
     * @function getViewInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.ViewInfo>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getMapInfo}.
     * @memberof DFHackRPCService
     * @typedef GetMapInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MapInfo} [response] MapInfo
     */

    /**
     * Calls GetMapInfo.
     * @function getMapInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetMapInfoCallback} callback Node-style callback called with the error, if any, and MapInfo
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getMapInfo = function getMapInfo(request, callback) {
        return this.rpcCall(getMapInfo, $root.EmptyMessage, $root.RemoteFortressReader.MapInfo, request, callback);
    }, "name", { value: "GetMapInfo" });

    /**
     * Calls GetMapInfo.
     * @function getMapInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MapInfo>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#resetMapHashes}.
     * @memberof DFHackRPCService
     * @typedef ResetMapHashesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls ResetMapHashes.
     * @function resetMapHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.ResetMapHashesCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.resetMapHashes = function resetMapHashes(request, callback) {
        return this.rpcCall(resetMapHashes, $root.EmptyMessage, $root.EmptyMessage, request, callback);
    }, "name", { value: "ResetMapHashes" });

    /**
     * Calls ResetMapHashes.
     * @function resetMapHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getItemList}.
     * @memberof DFHackRPCService
     * @typedef GetItemListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MaterialList} [response] MaterialList
     */

    /**
     * Calls GetItemList.
     * @function getItemList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetItemListCallback} callback Node-style callback called with the error, if any, and MaterialList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getItemList = function getItemList(request, callback) {
        return this.rpcCall(getItemList, $root.EmptyMessage, $root.RemoteFortressReader.MaterialList, request, callback);
    }, "name", { value: "GetItemList" });

    /**
     * Calls GetItemList.
     * @function getItemList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MaterialList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getBuildingDefList}.
     * @memberof DFHackRPCService
     * @typedef GetBuildingDefListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.BuildingList} [response] BuildingList
     */

    /**
     * Calls GetBuildingDefList.
     * @function getBuildingDefList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetBuildingDefListCallback} callback Node-style callback called with the error, if any, and BuildingList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getBuildingDefList = function getBuildingDefList(request, callback) {
        return this.rpcCall(getBuildingDefList, $root.EmptyMessage, $root.RemoteFortressReader.BuildingList, request, callback);
    }, "name", { value: "GetBuildingDefList" });

    /**
     * Calls GetBuildingDefList.
     * @function getBuildingDefList
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.BuildingList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getWorldMap}.
     * @memberof DFHackRPCService
     * @typedef GetWorldMapCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.WorldMap} [response] WorldMap
     */

    /**
     * Calls GetWorldMap.
     * @function getWorldMap
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetWorldMapCallback} callback Node-style callback called with the error, if any, and WorldMap
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getWorldMap = function getWorldMap(request, callback) {
        return this.rpcCall(getWorldMap, $root.EmptyMessage, $root.RemoteFortressReader.WorldMap, request, callback);
    }, "name", { value: "GetWorldMap" });

    /**
     * Calls GetWorldMap.
     * @function getWorldMap
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.WorldMap>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getWorldMapNew}.
     * @memberof DFHackRPCService
     * @typedef GetWorldMapNewCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.WorldMap} [response] WorldMap
     */

    /**
     * Calls GetWorldMapNew.
     * @function getWorldMapNew
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetWorldMapNewCallback} callback Node-style callback called with the error, if any, and WorldMap
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getWorldMapNew = function getWorldMapNew(request, callback) {
        return this.rpcCall(getWorldMapNew, $root.EmptyMessage, $root.RemoteFortressReader.WorldMap, request, callback);
    }, "name", { value: "GetWorldMapNew" });

    /**
     * Calls GetWorldMapNew.
     * @function getWorldMapNew
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.WorldMap>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getRegionMaps}.
     * @memberof DFHackRPCService
     * @typedef GetRegionMapsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.RegionMaps} [response] RegionMaps
     */

    /**
     * Calls GetRegionMaps.
     * @function getRegionMaps
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetRegionMapsCallback} callback Node-style callback called with the error, if any, and RegionMaps
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getRegionMaps = function getRegionMaps(request, callback) {
        return this.rpcCall(getRegionMaps, $root.EmptyMessage, $root.RemoteFortressReader.RegionMaps, request, callback);
    }, "name", { value: "GetRegionMaps" });

    /**
     * Calls GetRegionMaps.
     * @function getRegionMaps
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.RegionMaps>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getRegionMapsNew}.
     * @memberof DFHackRPCService
     * @typedef GetRegionMapsNewCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.RegionMaps} [response] RegionMaps
     */

    /**
     * Calls GetRegionMapsNew.
     * @function getRegionMapsNew
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetRegionMapsNewCallback} callback Node-style callback called with the error, if any, and RegionMaps
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getRegionMapsNew = function getRegionMapsNew(request, callback) {
        return this.rpcCall(getRegionMapsNew, $root.EmptyMessage, $root.RemoteFortressReader.RegionMaps, request, callback);
    }, "name", { value: "GetRegionMapsNew" });

    /**
     * Calls GetRegionMapsNew.
     * @function getRegionMapsNew
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.RegionMaps>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getCreatureRaws}.
     * @memberof DFHackRPCService
     * @typedef GetCreatureRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.CreatureRawList} [response] CreatureRawList
     */

    /**
     * Calls GetCreatureRaws.
     * @function getCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetCreatureRawsCallback} callback Node-style callback called with the error, if any, and CreatureRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getCreatureRaws = function getCreatureRaws(request, callback) {
        return this.rpcCall(getCreatureRaws, $root.EmptyMessage, $root.RemoteFortressReader.CreatureRawList, request, callback);
    }, "name", { value: "GetCreatureRaws" });

    /**
     * Calls GetCreatureRaws.
     * @function getCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.CreatureRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPartialCreatureRaws}.
     * @memberof DFHackRPCService
     * @typedef GetPartialCreatureRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.CreatureRawList} [response] CreatureRawList
     */

    /**
     * Calls GetPartialCreatureRaws.
     * @function getPartialCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @param {DFHackRPCService.GetPartialCreatureRawsCallback} callback Node-style callback called with the error, if any, and CreatureRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getPartialCreatureRaws = function getPartialCreatureRaws(request, callback) {
        return this.rpcCall(getPartialCreatureRaws, $root.RemoteFortressReader.ListRequest, $root.RemoteFortressReader.CreatureRawList, request, callback);
    }, "name", { value: "GetPartialCreatureRaws" });

    /**
     * Calls GetPartialCreatureRaws.
     * @function getPartialCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @returns {Promise<RemoteFortressReader.CreatureRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getWorldMapCenter}.
     * @memberof DFHackRPCService
     * @typedef GetWorldMapCenterCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.WorldMap} [response] WorldMap
     */

    /**
     * Calls GetWorldMapCenter.
     * @function getWorldMapCenter
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetWorldMapCenterCallback} callback Node-style callback called with the error, if any, and WorldMap
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getWorldMapCenter = function getWorldMapCenter(request, callback) {
        return this.rpcCall(getWorldMapCenter, $root.EmptyMessage, $root.RemoteFortressReader.WorldMap, request, callback);
    }, "name", { value: "GetWorldMapCenter" });

    /**
     * Calls GetWorldMapCenter.
     * @function getWorldMapCenter
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.WorldMap>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPlantRaws}.
     * @memberof DFHackRPCService
     * @typedef GetPlantRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.PlantRawList} [response] PlantRawList
     */

    /**
     * Calls GetPlantRaws.
     * @function getPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetPlantRawsCallback} callback Node-style callback called with the error, if any, and PlantRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getPlantRaws = function getPlantRaws(request, callback) {
        return this.rpcCall(getPlantRaws, $root.EmptyMessage, $root.RemoteFortressReader.PlantRawList, request, callback);
    }, "name", { value: "GetPlantRaws" });

    /**
     * Calls GetPlantRaws.
     * @function getPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.PlantRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPartialPlantRaws}.
     * @memberof DFHackRPCService
     * @typedef GetPartialPlantRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.PlantRawList} [response] PlantRawList
     */

    /**
     * Calls GetPartialPlantRaws.
     * @function getPartialPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @param {DFHackRPCService.GetPartialPlantRawsCallback} callback Node-style callback called with the error, if any, and PlantRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getPartialPlantRaws = function getPartialPlantRaws(request, callback) {
        return this.rpcCall(getPartialPlantRaws, $root.RemoteFortressReader.ListRequest, $root.RemoteFortressReader.PlantRawList, request, callback);
    }, "name", { value: "GetPartialPlantRaws" });

    /**
     * Calls GetPartialPlantRaws.
     * @function getPartialPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @returns {Promise<RemoteFortressReader.PlantRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#copyScreen}.
     * @memberof DFHackRPCService
     * @typedef CopyScreenCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.ScreenCapture} [response] ScreenCapture
     */

    /**
     * Calls CopyScreen.
     * @function copyScreen
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.CopyScreenCallback} callback Node-style callback called with the error, if any, and ScreenCapture
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.copyScreen = function copyScreen(request, callback) {
        return this.rpcCall(copyScreen, $root.EmptyMessage, $root.RemoteFortressReader.ScreenCapture, request, callback);
    }, "name", { value: "CopyScreen" });

    /**
     * Calls CopyScreen.
     * @function copyScreen
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.ScreenCapture>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#passKeyboardEvent}.
     * @memberof DFHackRPCService
     * @typedef PassKeyboardEventCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls PassKeyboardEvent.
     * @function passKeyboardEvent
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IKeyboardEvent} request KeyboardEvent message or plain object
     * @param {DFHackRPCService.PassKeyboardEventCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.passKeyboardEvent = function passKeyboardEvent(request, callback) {
        return this.rpcCall(passKeyboardEvent, $root.RemoteFortressReader.KeyboardEvent, $root.EmptyMessage, request, callback);
    }, "name", { value: "PassKeyboardEvent" });

    /**
     * Calls PassKeyboardEvent.
     * @function passKeyboardEvent
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IKeyboardEvent} request KeyboardEvent message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#sendDigCommand}.
     * @memberof DFHackRPCService
     * @typedef SendDigCommandCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls SendDigCommand.
     * @function sendDigCommand
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IDigCommand} request DigCommand message or plain object
     * @param {DFHackRPCService.SendDigCommandCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.sendDigCommand = function sendDigCommand(request, callback) {
        return this.rpcCall(sendDigCommand, $root.RemoteFortressReader.DigCommand, $root.EmptyMessage, request, callback);
    }, "name", { value: "SendDigCommand" });

    /**
     * Calls SendDigCommand.
     * @function sendDigCommand
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IDigCommand} request DigCommand message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#setPauseState}.
     * @memberof DFHackRPCService
     * @typedef SetPauseStateCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls SetPauseState.
     * @function setPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.ISingleBool} request SingleBool message or plain object
     * @param {DFHackRPCService.SetPauseStateCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.setPauseState = function setPauseState(request, callback) {
        return this.rpcCall(setPauseState, $root.RemoteFortressReader.SingleBool, $root.EmptyMessage, request, callback);
    }, "name", { value: "SetPauseState" });

    /**
     * Calls SetPauseState.
     * @function setPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.ISingleBool} request SingleBool message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPauseState}.
     * @memberof DFHackRPCService
     * @typedef GetPauseStateCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.SingleBool} [response] SingleBool
     */

    /**
     * Calls GetPauseState.
     * @function getPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetPauseStateCallback} callback Node-style callback called with the error, if any, and SingleBool
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getPauseState = function getPauseState(request, callback) {
        return this.rpcCall(getPauseState, $root.EmptyMessage, $root.RemoteFortressReader.SingleBool, request, callback);
    }, "name", { value: "GetPauseState" });

    /**
     * Calls GetPauseState.
     * @function getPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.SingleBool>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getVersionInfo}.
     * @memberof DFHackRPCService
     * @typedef GetVersionInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.VersionInfo} [response] VersionInfo
     */

    /**
     * Calls GetVersionInfo.
     * @function getVersionInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetVersionInfoCallback} callback Node-style callback called with the error, if any, and VersionInfo
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getVersionInfo = function getVersionInfo(request, callback) {
        return this.rpcCall(getVersionInfo, $root.EmptyMessage, $root.RemoteFortressReader.VersionInfo, request, callback);
    }, "name", { value: "GetVersionInfo" });

    /**
     * Calls GetVersionInfo.
     * @function getVersionInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.VersionInfo>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getReports}.
     * @memberof DFHackRPCService
     * @typedef GetReportsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.Status} [response] Status
     */

    /**
     * Calls GetReports.
     * @function getReports
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetReportsCallback} callback Node-style callback called with the error, if any, and Status
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getReports = function getReports(request, callback) {
        return this.rpcCall(getReports, $root.EmptyMessage, $root.RemoteFortressReader.Status, request, callback);
    }, "name", { value: "GetReports" });

    /**
     * Calls GetReports.
     * @function getReports
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.Status>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getLanguage}.
     * @memberof DFHackRPCService
     * @typedef GetLanguageCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.Language} [response] Language
     */

    /**
     * Calls GetLanguage.
     * @function getLanguage
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetLanguageCallback} callback Node-style callback called with the error, if any, and Language
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.getLanguage = function getLanguage(request, callback) {
        return this.rpcCall(getLanguage, $root.EmptyMessage, $root.RemoteFortressReader.Language, request, callback);
    }, "name", { value: "GetLanguage" });

    /**
     * Calls GetLanguage.
     * @function getLanguage
     * @memberof DFHackRPCService
     * @instance
     * @param {IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.Language>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#renameSquad}.
     * @memberof DFHackRPCService
     * @typedef RenameSquadCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls RenameSquad.
     * @function renameSquad
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameSquadIn} request RenameSquadIn message or plain object
     * @param {DFHackRPCService.RenameSquadCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.renameSquad = function renameSquad(request, callback) {
        return this.rpcCall(renameSquad, $root.dfproto.RenameSquadIn, $root.EmptyMessage, request, callback);
    }, "name", { value: "RenameSquad" });

    /**
     * Calls RenameSquad.
     * @function renameSquad
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameSquadIn} request RenameSquadIn message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#renameUnit}.
     * @memberof DFHackRPCService
     * @typedef RenameUnitCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls RenameUnit.
     * @function renameUnit
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameUnitIn} request RenameUnitIn message or plain object
     * @param {DFHackRPCService.RenameUnitCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.renameUnit = function renameUnit(request, callback) {
        return this.rpcCall(renameUnit, $root.dfproto.RenameUnitIn, $root.EmptyMessage, request, callback);
    }, "name", { value: "RenameUnit" });

    /**
     * Calls RenameUnit.
     * @function renameUnit
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameUnitIn} request RenameUnitIn message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#renameBuilding}.
     * @memberof DFHackRPCService
     * @typedef RenameBuildingCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls RenameBuilding.
     * @function renameBuilding
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameBuildingIn} request RenameBuildingIn message or plain object
     * @param {DFHackRPCService.RenameBuildingCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperty(DFHackRPCService.prototype.renameBuilding = function renameBuilding(request, callback) {
        return this.rpcCall(renameBuilding, $root.dfproto.RenameBuildingIn, $root.EmptyMessage, request, callback);
    }, "name", { value: "RenameBuilding" });

    /**
     * Calls RenameBuilding.
     * @function renameBuilding
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameBuildingIn} request RenameBuildingIn message or plain object
     * @returns {Promise<EmptyMessage>} Promise
     * @variation 2
     */

    return DFHackRPCService;
})();

$root.isoworldremote = (function() {

    /**
     * Namespace isoworldremote.
     * @exports isoworldremote
     * @namespace
     */
    var isoworldremote = {};

    /**
     * BasicMaterial enum.
     * @name isoworldremote.BasicMaterial
     * @enum {string}
     * @property {number} AIR=0 AIR value
     * @property {number} OTHER=1 OTHER value
     * @property {number} INORGANIC=2 INORGANIC value
     * @property {number} LIQUID=3 LIQUID value
     * @property {number} PLANT=4 PLANT value
     * @property {number} WOOD=5 WOOD value
     */
    isoworldremote.BasicMaterial = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AIR"] = 0;
        values[valuesById[1] = "OTHER"] = 1;
        values[valuesById[2] = "INORGANIC"] = 2;
        values[valuesById[3] = "LIQUID"] = 3;
        values[valuesById[4] = "PLANT"] = 4;
        values[valuesById[5] = "WOOD"] = 5;
        return values;
    })();

    /**
     * LiquidType enum.
     * @name isoworldremote.LiquidType
     * @enum {string}
     * @property {number} ICE=0 ICE value
     * @property {number} WATER=1 WATER value
     * @property {number} MAGMA=2 MAGMA value
     */
    isoworldremote.LiquidType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ICE"] = 0;
        values[valuesById[1] = "WATER"] = 1;
        values[valuesById[2] = "MAGMA"] = 2;
        return values;
    })();

    /**
     * BasicShape enum.
     * @name isoworldremote.BasicShape
     * @enum {string}
     * @property {number} NONE=0 NONE value
     * @property {number} OPEN=1 OPEN value
     * @property {number} WALL=3 WALL value
     * @property {number} FLOOR=4 FLOOR value
     * @property {number} RAMP_UP=5 RAMP_UP value
     * @property {number} RAMP_DOWN=6 RAMP_DOWN value
     */
    isoworldremote.BasicShape = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "OPEN"] = 1;
        values[valuesById[3] = "WALL"] = 3;
        values[valuesById[4] = "FLOOR"] = 4;
        values[valuesById[5] = "RAMP_UP"] = 5;
        values[valuesById[6] = "RAMP_DOWN"] = 6;
        return values;
    })();

    isoworldremote.ColorDefinition = (function() {

        /**
         * Properties of a ColorDefinition.
         * @memberof isoworldremote
         * @interface IColorDefinition
         * @property {number} red ColorDefinition red
         * @property {number} green ColorDefinition green
         * @property {number} blue ColorDefinition blue
         */

        /**
         * Constructs a new ColorDefinition.
         * @memberof isoworldremote
         * @classdesc Represents a ColorDefinition.
         * @implements IColorDefinition
         * @constructor
         * @param {isoworldremote.IColorDefinition=} [properties] Properties to set
         */
        function ColorDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorDefinition red.
         * @member {number} red
         * @memberof isoworldremote.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.red = 0;

        /**
         * ColorDefinition green.
         * @member {number} green
         * @memberof isoworldremote.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.green = 0;

        /**
         * ColorDefinition blue.
         * @member {number} blue
         * @memberof isoworldremote.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.blue = 0;

        /**
         * Creates a new ColorDefinition instance using the specified properties.
         * @function create
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.IColorDefinition=} [properties] Properties to set
         * @returns {isoworldremote.ColorDefinition} ColorDefinition instance
         */
        ColorDefinition.create = function create(properties) {
            return new ColorDefinition(properties);
        };

        /**
         * Encodes the specified ColorDefinition message. Does not implicitly {@link isoworldremote.ColorDefinition.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.red);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.green);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blue);
            return writer;
        };

        /**
         * Encodes the specified ColorDefinition message, length delimited. Does not implicitly {@link isoworldremote.ColorDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.ColorDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.red = reader.int32();
                    break;
                case 2:
                    message.green = reader.int32();
                    break;
                case 3:
                    message.blue = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("red"))
                throw $util.ProtocolError("missing required 'red'", { instance: message });
            if (!message.hasOwnProperty("green"))
                throw $util.ProtocolError("missing required 'green'", { instance: message });
            if (!message.hasOwnProperty("blue"))
                throw $util.ProtocolError("missing required 'blue'", { instance: message });
            return message;
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorDefinition message.
         * @function verify
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.red))
                return "red: integer expected";
            if (!$util.isInteger(message.green))
                return "green: integer expected";
            if (!$util.isInteger(message.blue))
                return "blue: integer expected";
            return null;
        };

        /**
         * Creates a ColorDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.ColorDefinition} ColorDefinition
         */
        ColorDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.ColorDefinition)
                return object;
            var message = new $root.isoworldremote.ColorDefinition();
            if (object.red != null)
                message.red = object.red | 0;
            if (object.green != null)
                message.green = object.green | 0;
            if (object.blue != null)
                message.blue = object.blue | 0;
            return message;
        };

        /**
         * Creates a plain object from a ColorDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.ColorDefinition} message ColorDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.red = 0;
                object.green = 0;
                object.blue = 0;
            }
            if (message.red != null && message.hasOwnProperty("red"))
                object.red = message.red;
            if (message.green != null && message.hasOwnProperty("green"))
                object.green = message.green;
            if (message.blue != null && message.hasOwnProperty("blue"))
                object.blue = message.blue;
            return object;
        };

        /**
         * Converts this ColorDefinition to JSON.
         * @function toJSON
         * @memberof isoworldremote.ColorDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ColorDefinition;
    })();

    isoworldremote.EmbarkTileLayer = (function() {

        /**
         * Properties of an EmbarkTileLayer.
         * @memberof isoworldremote
         * @interface IEmbarkTileLayer
         * @property {Array.<isoworldremote.BasicMaterial>|null} [matTypeTable] EmbarkTileLayer matTypeTable
         * @property {Array.<number>|null} [matSubtypeTable] EmbarkTileLayer matSubtypeTable
         * @property {Array.<isoworldremote.BasicShape>|null} [tileShapeTable] EmbarkTileLayer tileShapeTable
         * @property {Array.<isoworldremote.IColorDefinition>|null} [tileColorTable] EmbarkTileLayer tileColorTable
         */

        /**
         * Constructs a new EmbarkTileLayer.
         * @memberof isoworldremote
         * @classdesc Represents an EmbarkTileLayer.
         * @implements IEmbarkTileLayer
         * @constructor
         * @param {isoworldremote.IEmbarkTileLayer=} [properties] Properties to set
         */
        function EmbarkTileLayer(properties) {
            this.matTypeTable = [];
            this.matSubtypeTable = [];
            this.tileShapeTable = [];
            this.tileColorTable = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmbarkTileLayer matTypeTable.
         * @member {Array.<isoworldremote.BasicMaterial>} matTypeTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.matTypeTable = $util.emptyArray;

        /**
         * EmbarkTileLayer matSubtypeTable.
         * @member {Array.<number>} matSubtypeTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.matSubtypeTable = $util.emptyArray;

        /**
         * EmbarkTileLayer tileShapeTable.
         * @member {Array.<isoworldremote.BasicShape>} tileShapeTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.tileShapeTable = $util.emptyArray;

        /**
         * EmbarkTileLayer tileColorTable.
         * @member {Array.<isoworldremote.IColorDefinition>} tileColorTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.tileColorTable = $util.emptyArray;

        /**
         * Creates a new EmbarkTileLayer instance using the specified properties.
         * @function create
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.IEmbarkTileLayer=} [properties] Properties to set
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer instance
         */
        EmbarkTileLayer.create = function create(properties) {
            return new EmbarkTileLayer(properties);
        };

        /**
         * Encodes the specified EmbarkTileLayer message. Does not implicitly {@link isoworldremote.EmbarkTileLayer.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.IEmbarkTileLayer} message EmbarkTileLayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTileLayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.matTypeTable != null && message.matTypeTable.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.matTypeTable.length; ++i)
                    writer.int32(message.matTypeTable[i]);
                writer.ldelim();
            }
            if (message.matSubtypeTable != null && message.matSubtypeTable.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.matSubtypeTable.length; ++i)
                    writer.int32(message.matSubtypeTable[i]);
                writer.ldelim();
            }
            if (message.tileShapeTable != null && message.tileShapeTable.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (var i = 0; i < message.tileShapeTable.length; ++i)
                    writer.int32(message.tileShapeTable[i]);
                writer.ldelim();
            }
            if (message.tileColorTable != null && message.tileColorTable.length)
                for (var i = 0; i < message.tileColorTable.length; ++i)
                    $root.isoworldremote.ColorDefinition.encode(message.tileColorTable[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EmbarkTileLayer message, length delimited. Does not implicitly {@link isoworldremote.EmbarkTileLayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.IEmbarkTileLayer} message EmbarkTileLayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTileLayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmbarkTileLayer message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTileLayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.EmbarkTileLayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    if (!(message.matTypeTable && message.matTypeTable.length))
                        message.matTypeTable = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.matTypeTable.push(reader.int32());
                    } else
                        message.matTypeTable.push(reader.int32());
                    break;
                case 5:
                    if (!(message.matSubtypeTable && message.matSubtypeTable.length))
                        message.matSubtypeTable = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.matSubtypeTable.push(reader.int32());
                    } else
                        message.matSubtypeTable.push(reader.int32());
                    break;
                case 6:
                    if (!(message.tileShapeTable && message.tileShapeTable.length))
                        message.tileShapeTable = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileShapeTable.push(reader.int32());
                    } else
                        message.tileShapeTable.push(reader.int32());
                    break;
                case 7:
                    if (!(message.tileColorTable && message.tileColorTable.length))
                        message.tileColorTable = [];
                    message.tileColorTable.push($root.isoworldremote.ColorDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmbarkTileLayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTileLayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmbarkTileLayer message.
         * @function verify
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmbarkTileLayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.matTypeTable != null && message.hasOwnProperty("matTypeTable")) {
                if (!Array.isArray(message.matTypeTable))
                    return "matTypeTable: array expected";
                for (var i = 0; i < message.matTypeTable.length; ++i)
                    switch (message.matTypeTable[i]) {
                    default:
                        return "matTypeTable: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
            }
            if (message.matSubtypeTable != null && message.hasOwnProperty("matSubtypeTable")) {
                if (!Array.isArray(message.matSubtypeTable))
                    return "matSubtypeTable: array expected";
                for (var i = 0; i < message.matSubtypeTable.length; ++i)
                    if (!$util.isInteger(message.matSubtypeTable[i]))
                        return "matSubtypeTable: integer[] expected";
            }
            if (message.tileShapeTable != null && message.hasOwnProperty("tileShapeTable")) {
                if (!Array.isArray(message.tileShapeTable))
                    return "tileShapeTable: array expected";
                for (var i = 0; i < message.tileShapeTable.length; ++i)
                    switch (message.tileShapeTable[i]) {
                    default:
                        return "tileShapeTable: enum value[] expected";
                    case 0:
                    case 1:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
            }
            if (message.tileColorTable != null && message.hasOwnProperty("tileColorTable")) {
                if (!Array.isArray(message.tileColorTable))
                    return "tileColorTable: array expected";
                for (var i = 0; i < message.tileColorTable.length; ++i) {
                    var error = $root.isoworldremote.ColorDefinition.verify(message.tileColorTable[i]);
                    if (error)
                        return "tileColorTable." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EmbarkTileLayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer
         */
        EmbarkTileLayer.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.EmbarkTileLayer)
                return object;
            var message = new $root.isoworldremote.EmbarkTileLayer();
            if (object.matTypeTable) {
                if (!Array.isArray(object.matTypeTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.matTypeTable: array expected");
                message.matTypeTable = [];
                for (var i = 0; i < object.matTypeTable.length; ++i)
                    switch (object.matTypeTable[i]) {
                    default:
                    case "AIR":
                    case 0:
                        message.matTypeTable[i] = 0;
                        break;
                    case "OTHER":
                    case 1:
                        message.matTypeTable[i] = 1;
                        break;
                    case "INORGANIC":
                    case 2:
                        message.matTypeTable[i] = 2;
                        break;
                    case "LIQUID":
                    case 3:
                        message.matTypeTable[i] = 3;
                        break;
                    case "PLANT":
                    case 4:
                        message.matTypeTable[i] = 4;
                        break;
                    case "WOOD":
                    case 5:
                        message.matTypeTable[i] = 5;
                        break;
                    }
            }
            if (object.matSubtypeTable) {
                if (!Array.isArray(object.matSubtypeTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.matSubtypeTable: array expected");
                message.matSubtypeTable = [];
                for (var i = 0; i < object.matSubtypeTable.length; ++i)
                    message.matSubtypeTable[i] = object.matSubtypeTable[i] | 0;
            }
            if (object.tileShapeTable) {
                if (!Array.isArray(object.tileShapeTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.tileShapeTable: array expected");
                message.tileShapeTable = [];
                for (var i = 0; i < object.tileShapeTable.length; ++i)
                    switch (object.tileShapeTable[i]) {
                    default:
                    case "NONE":
                    case 0:
                        message.tileShapeTable[i] = 0;
                        break;
                    case "OPEN":
                    case 1:
                        message.tileShapeTable[i] = 1;
                        break;
                    case "WALL":
                    case 3:
                        message.tileShapeTable[i] = 3;
                        break;
                    case "FLOOR":
                    case 4:
                        message.tileShapeTable[i] = 4;
                        break;
                    case "RAMP_UP":
                    case 5:
                        message.tileShapeTable[i] = 5;
                        break;
                    case "RAMP_DOWN":
                    case 6:
                        message.tileShapeTable[i] = 6;
                        break;
                    }
            }
            if (object.tileColorTable) {
                if (!Array.isArray(object.tileColorTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.tileColorTable: array expected");
                message.tileColorTable = [];
                for (var i = 0; i < object.tileColorTable.length; ++i) {
                    if (typeof object.tileColorTable[i] !== "object")
                        throw TypeError(".isoworldremote.EmbarkTileLayer.tileColorTable: object expected");
                    message.tileColorTable[i] = $root.isoworldremote.ColorDefinition.fromObject(object.tileColorTable[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an EmbarkTileLayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.EmbarkTileLayer} message EmbarkTileLayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmbarkTileLayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.matTypeTable = [];
                object.matSubtypeTable = [];
                object.tileShapeTable = [];
                object.tileColorTable = [];
            }
            if (message.matTypeTable && message.matTypeTable.length) {
                object.matTypeTable = [];
                for (var j = 0; j < message.matTypeTable.length; ++j)
                    object.matTypeTable[j] = options.enums === String ? $root.isoworldremote.BasicMaterial[message.matTypeTable[j]] : message.matTypeTable[j];
            }
            if (message.matSubtypeTable && message.matSubtypeTable.length) {
                object.matSubtypeTable = [];
                for (var j = 0; j < message.matSubtypeTable.length; ++j)
                    object.matSubtypeTable[j] = message.matSubtypeTable[j];
            }
            if (message.tileShapeTable && message.tileShapeTable.length) {
                object.tileShapeTable = [];
                for (var j = 0; j < message.tileShapeTable.length; ++j)
                    object.tileShapeTable[j] = options.enums === String ? $root.isoworldremote.BasicShape[message.tileShapeTable[j]] : message.tileShapeTable[j];
            }
            if (message.tileColorTable && message.tileColorTable.length) {
                object.tileColorTable = [];
                for (var j = 0; j < message.tileColorTable.length; ++j)
                    object.tileColorTable[j] = $root.isoworldremote.ColorDefinition.toObject(message.tileColorTable[j], options);
            }
            return object;
        };

        /**
         * Converts this EmbarkTileLayer to JSON.
         * @function toJSON
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmbarkTileLayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmbarkTileLayer;
    })();

    isoworldremote.EmbarkTile = (function() {

        /**
         * Properties of an EmbarkTile.
         * @memberof isoworldremote
         * @interface IEmbarkTile
         * @property {number} worldX EmbarkTile worldX
         * @property {number} worldY EmbarkTile worldY
         * @property {number} worldZ EmbarkTile worldZ
         * @property {Array.<isoworldremote.IEmbarkTileLayer>|null} [tileLayer] EmbarkTile tileLayer
         * @property {number|null} [currentYear] EmbarkTile currentYear
         * @property {number|null} [currentSeason] EmbarkTile currentSeason
         * @property {boolean|null} [isValid] EmbarkTile isValid
         */

        /**
         * Constructs a new EmbarkTile.
         * @memberof isoworldremote
         * @classdesc Represents an EmbarkTile.
         * @implements IEmbarkTile
         * @constructor
         * @param {isoworldremote.IEmbarkTile=} [properties] Properties to set
         */
        function EmbarkTile(properties) {
            this.tileLayer = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmbarkTile worldX.
         * @member {number} worldX
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.worldX = 0;

        /**
         * EmbarkTile worldY.
         * @member {number} worldY
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.worldY = 0;

        /**
         * EmbarkTile worldZ.
         * @member {number} worldZ
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.worldZ = 0;

        /**
         * EmbarkTile tileLayer.
         * @member {Array.<isoworldremote.IEmbarkTileLayer>} tileLayer
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.tileLayer = $util.emptyArray;

        /**
         * EmbarkTile currentYear.
         * @member {number} currentYear
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.currentYear = 0;

        /**
         * EmbarkTile currentSeason.
         * @member {number} currentSeason
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.currentSeason = 0;

        /**
         * EmbarkTile isValid.
         * @member {boolean} isValid
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.isValid = false;

        /**
         * Creates a new EmbarkTile instance using the specified properties.
         * @function create
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.IEmbarkTile=} [properties] Properties to set
         * @returns {isoworldremote.EmbarkTile} EmbarkTile instance
         */
        EmbarkTile.create = function create(properties) {
            return new EmbarkTile(properties);
        };

        /**
         * Encodes the specified EmbarkTile message. Does not implicitly {@link isoworldremote.EmbarkTile.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.IEmbarkTile} message EmbarkTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.worldX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.worldY);
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.worldZ);
            if (message.tileLayer != null && message.tileLayer.length)
                for (var i = 0; i < message.tileLayer.length; ++i)
                    $root.isoworldremote.EmbarkTileLayer.encode(message.tileLayer[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.currentYear);
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.currentSeason);
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isValid);
            return writer;
        };

        /**
         * Encodes the specified EmbarkTile message, length delimited. Does not implicitly {@link isoworldremote.EmbarkTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.IEmbarkTile} message EmbarkTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmbarkTile message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.EmbarkTile} EmbarkTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.EmbarkTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldX = reader.int32();
                    break;
                case 2:
                    message.worldY = reader.int32();
                    break;
                case 3:
                    message.worldZ = reader.sint32();
                    break;
                case 4:
                    if (!(message.tileLayer && message.tileLayer.length))
                        message.tileLayer = [];
                    message.tileLayer.push($root.isoworldremote.EmbarkTileLayer.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.currentYear = reader.int32();
                    break;
                case 6:
                    message.currentSeason = reader.int32();
                    break;
                case 7:
                    message.isValid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("worldX"))
                throw $util.ProtocolError("missing required 'worldX'", { instance: message });
            if (!message.hasOwnProperty("worldY"))
                throw $util.ProtocolError("missing required 'worldY'", { instance: message });
            if (!message.hasOwnProperty("worldZ"))
                throw $util.ProtocolError("missing required 'worldZ'", { instance: message });
            return message;
        };

        /**
         * Decodes an EmbarkTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.EmbarkTile} EmbarkTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmbarkTile message.
         * @function verify
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmbarkTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.worldX))
                return "worldX: integer expected";
            if (!$util.isInteger(message.worldY))
                return "worldY: integer expected";
            if (!$util.isInteger(message.worldZ))
                return "worldZ: integer expected";
            if (message.tileLayer != null && message.hasOwnProperty("tileLayer")) {
                if (!Array.isArray(message.tileLayer))
                    return "tileLayer: array expected";
                for (var i = 0; i < message.tileLayer.length; ++i) {
                    var error = $root.isoworldremote.EmbarkTileLayer.verify(message.tileLayer[i]);
                    if (error)
                        return "tileLayer." + error;
                }
            }
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                if (!$util.isInteger(message.currentYear))
                    return "currentYear: integer expected";
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                if (!$util.isInteger(message.currentSeason))
                    return "currentSeason: integer expected";
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                if (typeof message.isValid !== "boolean")
                    return "isValid: boolean expected";
            return null;
        };

        /**
         * Creates an EmbarkTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.EmbarkTile} EmbarkTile
         */
        EmbarkTile.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.EmbarkTile)
                return object;
            var message = new $root.isoworldremote.EmbarkTile();
            if (object.worldX != null)
                message.worldX = object.worldX | 0;
            if (object.worldY != null)
                message.worldY = object.worldY | 0;
            if (object.worldZ != null)
                message.worldZ = object.worldZ | 0;
            if (object.tileLayer) {
                if (!Array.isArray(object.tileLayer))
                    throw TypeError(".isoworldremote.EmbarkTile.tileLayer: array expected");
                message.tileLayer = [];
                for (var i = 0; i < object.tileLayer.length; ++i) {
                    if (typeof object.tileLayer[i] !== "object")
                        throw TypeError(".isoworldremote.EmbarkTile.tileLayer: object expected");
                    message.tileLayer[i] = $root.isoworldremote.EmbarkTileLayer.fromObject(object.tileLayer[i]);
                }
            }
            if (object.currentYear != null)
                message.currentYear = object.currentYear | 0;
            if (object.currentSeason != null)
                message.currentSeason = object.currentSeason | 0;
            if (object.isValid != null)
                message.isValid = Boolean(object.isValid);
            return message;
        };

        /**
         * Creates a plain object from an EmbarkTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.EmbarkTile} message EmbarkTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmbarkTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tileLayer = [];
            if (options.defaults) {
                object.worldX = 0;
                object.worldY = 0;
                object.worldZ = 0;
                object.currentYear = 0;
                object.currentSeason = 0;
                object.isValid = false;
            }
            if (message.worldX != null && message.hasOwnProperty("worldX"))
                object.worldX = message.worldX;
            if (message.worldY != null && message.hasOwnProperty("worldY"))
                object.worldY = message.worldY;
            if (message.worldZ != null && message.hasOwnProperty("worldZ"))
                object.worldZ = message.worldZ;
            if (message.tileLayer && message.tileLayer.length) {
                object.tileLayer = [];
                for (var j = 0; j < message.tileLayer.length; ++j)
                    object.tileLayer[j] = $root.isoworldremote.EmbarkTileLayer.toObject(message.tileLayer[j], options);
            }
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                object.currentYear = message.currentYear;
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                object.currentSeason = message.currentSeason;
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                object.isValid = message.isValid;
            return object;
        };

        /**
         * Converts this EmbarkTile to JSON.
         * @function toJSON
         * @memberof isoworldremote.EmbarkTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmbarkTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmbarkTile;
    })();

    isoworldremote.TileRequest = (function() {

        /**
         * Properties of a TileRequest.
         * @memberof isoworldremote
         * @interface ITileRequest
         * @property {number|null} [wantX] TileRequest wantX
         * @property {number|null} [wantY] TileRequest wantY
         */

        /**
         * Constructs a new TileRequest.
         * @memberof isoworldremote
         * @classdesc Represents a TileRequest.
         * @implements ITileRequest
         * @constructor
         * @param {isoworldremote.ITileRequest=} [properties] Properties to set
         */
        function TileRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TileRequest wantX.
         * @member {number} wantX
         * @memberof isoworldremote.TileRequest
         * @instance
         */
        TileRequest.prototype.wantX = 0;

        /**
         * TileRequest wantY.
         * @member {number} wantY
         * @memberof isoworldremote.TileRequest
         * @instance
         */
        TileRequest.prototype.wantY = 0;

        /**
         * Creates a new TileRequest instance using the specified properties.
         * @function create
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.ITileRequest=} [properties] Properties to set
         * @returns {isoworldremote.TileRequest} TileRequest instance
         */
        TileRequest.create = function create(properties) {
            return new TileRequest(properties);
        };

        /**
         * Encodes the specified TileRequest message. Does not implicitly {@link isoworldremote.TileRequest.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.ITileRequest} message TileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TileRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wantX != null && message.hasOwnProperty("wantX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.wantX);
            if (message.wantY != null && message.hasOwnProperty("wantY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.wantY);
            return writer;
        };

        /**
         * Encodes the specified TileRequest message, length delimited. Does not implicitly {@link isoworldremote.TileRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.ITileRequest} message TileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TileRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TileRequest message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.TileRequest} TileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TileRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.TileRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.wantX = reader.int32();
                    break;
                case 2:
                    message.wantY = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TileRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.TileRequest} TileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TileRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TileRequest message.
         * @function verify
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TileRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wantX != null && message.hasOwnProperty("wantX"))
                if (!$util.isInteger(message.wantX))
                    return "wantX: integer expected";
            if (message.wantY != null && message.hasOwnProperty("wantY"))
                if (!$util.isInteger(message.wantY))
                    return "wantY: integer expected";
            return null;
        };

        /**
         * Creates a TileRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.TileRequest} TileRequest
         */
        TileRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.TileRequest)
                return object;
            var message = new $root.isoworldremote.TileRequest();
            if (object.wantX != null)
                message.wantX = object.wantX | 0;
            if (object.wantY != null)
                message.wantY = object.wantY | 0;
            return message;
        };

        /**
         * Creates a plain object from a TileRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.TileRequest} message TileRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TileRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.wantX = 0;
                object.wantY = 0;
            }
            if (message.wantX != null && message.hasOwnProperty("wantX"))
                object.wantX = message.wantX;
            if (message.wantY != null && message.hasOwnProperty("wantY"))
                object.wantY = message.wantY;
            return object;
        };

        /**
         * Converts this TileRequest to JSON.
         * @function toJSON
         * @memberof isoworldremote.TileRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TileRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TileRequest;
    })();

    isoworldremote.MapRequest = (function() {

        /**
         * Properties of a MapRequest.
         * @memberof isoworldremote
         * @interface IMapRequest
         * @property {string|null} [saveFolder] MapRequest saveFolder
         */

        /**
         * Constructs a new MapRequest.
         * @memberof isoworldremote
         * @classdesc Represents a MapRequest.
         * @implements IMapRequest
         * @constructor
         * @param {isoworldremote.IMapRequest=} [properties] Properties to set
         */
        function MapRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapRequest saveFolder.
         * @member {string} saveFolder
         * @memberof isoworldremote.MapRequest
         * @instance
         */
        MapRequest.prototype.saveFolder = "";

        /**
         * Creates a new MapRequest instance using the specified properties.
         * @function create
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.IMapRequest=} [properties] Properties to set
         * @returns {isoworldremote.MapRequest} MapRequest instance
         */
        MapRequest.create = function create(properties) {
            return new MapRequest(properties);
        };

        /**
         * Encodes the specified MapRequest message. Does not implicitly {@link isoworldremote.MapRequest.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.IMapRequest} message MapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.saveFolder != null && message.hasOwnProperty("saveFolder"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.saveFolder);
            return writer;
        };

        /**
         * Encodes the specified MapRequest message, length delimited. Does not implicitly {@link isoworldremote.MapRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.IMapRequest} message MapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapRequest message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.MapRequest} MapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.MapRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.saveFolder = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.MapRequest} MapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapRequest message.
         * @function verify
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.saveFolder != null && message.hasOwnProperty("saveFolder"))
                if (!$util.isString(message.saveFolder))
                    return "saveFolder: string expected";
            return null;
        };

        /**
         * Creates a MapRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.MapRequest} MapRequest
         */
        MapRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.MapRequest)
                return object;
            var message = new $root.isoworldremote.MapRequest();
            if (object.saveFolder != null)
                message.saveFolder = String(object.saveFolder);
            return message;
        };

        /**
         * Creates a plain object from a MapRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.MapRequest} message MapRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.saveFolder = "";
            if (message.saveFolder != null && message.hasOwnProperty("saveFolder"))
                object.saveFolder = message.saveFolder;
            return object;
        };

        /**
         * Converts this MapRequest to JSON.
         * @function toJSON
         * @memberof isoworldremote.MapRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapRequest;
    })();

    isoworldremote.MapReply = (function() {

        /**
         * Properties of a MapReply.
         * @memberof isoworldremote
         * @interface IMapReply
         * @property {boolean} available MapReply available
         * @property {number|null} [regionX] MapReply regionX
         * @property {number|null} [regionY] MapReply regionY
         * @property {number|null} [regionSizeX] MapReply regionSizeX
         * @property {number|null} [regionSizeY] MapReply regionSizeY
         * @property {number|null} [currentYear] MapReply currentYear
         * @property {number|null} [currentSeason] MapReply currentSeason
         */

        /**
         * Constructs a new MapReply.
         * @memberof isoworldremote
         * @classdesc Represents a MapReply.
         * @implements IMapReply
         * @constructor
         * @param {isoworldremote.IMapReply=} [properties] Properties to set
         */
        function MapReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapReply available.
         * @member {boolean} available
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.available = false;

        /**
         * MapReply regionX.
         * @member {number} regionX
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionX = 0;

        /**
         * MapReply regionY.
         * @member {number} regionY
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionY = 0;

        /**
         * MapReply regionSizeX.
         * @member {number} regionSizeX
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionSizeX = 0;

        /**
         * MapReply regionSizeY.
         * @member {number} regionSizeY
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionSizeY = 0;

        /**
         * MapReply currentYear.
         * @member {number} currentYear
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.currentYear = 0;

        /**
         * MapReply currentSeason.
         * @member {number} currentSeason
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.currentSeason = 0;

        /**
         * Creates a new MapReply instance using the specified properties.
         * @function create
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.IMapReply=} [properties] Properties to set
         * @returns {isoworldremote.MapReply} MapReply instance
         */
        MapReply.create = function create(properties) {
            return new MapReply(properties);
        };

        /**
         * Encodes the specified MapReply message. Does not implicitly {@link isoworldremote.MapReply.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.IMapReply} message MapReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.available);
            if (message.regionX != null && message.hasOwnProperty("regionX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.regionX);
            if (message.regionY != null && message.hasOwnProperty("regionY"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.regionY);
            if (message.regionSizeX != null && message.hasOwnProperty("regionSizeX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.regionSizeX);
            if (message.regionSizeY != null && message.hasOwnProperty("regionSizeY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.regionSizeY);
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.currentYear);
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.currentSeason);
            return writer;
        };

        /**
         * Encodes the specified MapReply message, length delimited. Does not implicitly {@link isoworldremote.MapReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.IMapReply} message MapReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapReply message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.MapReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.MapReply} MapReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.MapReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.available = reader.bool();
                    break;
                case 2:
                    message.regionX = reader.int32();
                    break;
                case 3:
                    message.regionY = reader.int32();
                    break;
                case 4:
                    message.regionSizeX = reader.int32();
                    break;
                case 5:
                    message.regionSizeY = reader.int32();
                    break;
                case 6:
                    message.currentYear = reader.int32();
                    break;
                case 7:
                    message.currentSeason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("available"))
                throw $util.ProtocolError("missing required 'available'", { instance: message });
            return message;
        };

        /**
         * Decodes a MapReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.MapReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.MapReply} MapReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapReply message.
         * @function verify
         * @memberof isoworldremote.MapReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.available !== "boolean")
                return "available: boolean expected";
            if (message.regionX != null && message.hasOwnProperty("regionX"))
                if (!$util.isInteger(message.regionX))
                    return "regionX: integer expected";
            if (message.regionY != null && message.hasOwnProperty("regionY"))
                if (!$util.isInteger(message.regionY))
                    return "regionY: integer expected";
            if (message.regionSizeX != null && message.hasOwnProperty("regionSizeX"))
                if (!$util.isInteger(message.regionSizeX))
                    return "regionSizeX: integer expected";
            if (message.regionSizeY != null && message.hasOwnProperty("regionSizeY"))
                if (!$util.isInteger(message.regionSizeY))
                    return "regionSizeY: integer expected";
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                if (!$util.isInteger(message.currentYear))
                    return "currentYear: integer expected";
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                if (!$util.isInteger(message.currentSeason))
                    return "currentSeason: integer expected";
            return null;
        };

        /**
         * Creates a MapReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.MapReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.MapReply} MapReply
         */
        MapReply.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.MapReply)
                return object;
            var message = new $root.isoworldremote.MapReply();
            if (object.available != null)
                message.available = Boolean(object.available);
            if (object.regionX != null)
                message.regionX = object.regionX | 0;
            if (object.regionY != null)
                message.regionY = object.regionY | 0;
            if (object.regionSizeX != null)
                message.regionSizeX = object.regionSizeX | 0;
            if (object.regionSizeY != null)
                message.regionSizeY = object.regionSizeY | 0;
            if (object.currentYear != null)
                message.currentYear = object.currentYear | 0;
            if (object.currentSeason != null)
                message.currentSeason = object.currentSeason | 0;
            return message;
        };

        /**
         * Creates a plain object from a MapReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.MapReply} message MapReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.available = false;
                object.regionX = 0;
                object.regionY = 0;
                object.regionSizeX = 0;
                object.regionSizeY = 0;
                object.currentYear = 0;
                object.currentSeason = 0;
            }
            if (message.available != null && message.hasOwnProperty("available"))
                object.available = message.available;
            if (message.regionX != null && message.hasOwnProperty("regionX"))
                object.regionX = message.regionX;
            if (message.regionY != null && message.hasOwnProperty("regionY"))
                object.regionY = message.regionY;
            if (message.regionSizeX != null && message.hasOwnProperty("regionSizeX"))
                object.regionSizeX = message.regionSizeX;
            if (message.regionSizeY != null && message.hasOwnProperty("regionSizeY"))
                object.regionSizeY = message.regionSizeY;
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                object.currentYear = message.currentYear;
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                object.currentSeason = message.currentSeason;
            return object;
        };

        /**
         * Converts this MapReply to JSON.
         * @function toJSON
         * @memberof isoworldremote.MapReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapReply;
    })();

    isoworldremote.RawNames = (function() {

        /**
         * Properties of a RawNames.
         * @memberof isoworldremote
         * @interface IRawNames
         * @property {boolean} available RawNames available
         * @property {Array.<string>|null} [inorganic] RawNames inorganic
         * @property {Array.<string>|null} [organic] RawNames organic
         */

        /**
         * Constructs a new RawNames.
         * @memberof isoworldremote
         * @classdesc Represents a RawNames.
         * @implements IRawNames
         * @constructor
         * @param {isoworldremote.IRawNames=} [properties] Properties to set
         */
        function RawNames(properties) {
            this.inorganic = [];
            this.organic = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RawNames available.
         * @member {boolean} available
         * @memberof isoworldremote.RawNames
         * @instance
         */
        RawNames.prototype.available = false;

        /**
         * RawNames inorganic.
         * @member {Array.<string>} inorganic
         * @memberof isoworldremote.RawNames
         * @instance
         */
        RawNames.prototype.inorganic = $util.emptyArray;

        /**
         * RawNames organic.
         * @member {Array.<string>} organic
         * @memberof isoworldremote.RawNames
         * @instance
         */
        RawNames.prototype.organic = $util.emptyArray;

        /**
         * Creates a new RawNames instance using the specified properties.
         * @function create
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.IRawNames=} [properties] Properties to set
         * @returns {isoworldremote.RawNames} RawNames instance
         */
        RawNames.create = function create(properties) {
            return new RawNames(properties);
        };

        /**
         * Encodes the specified RawNames message. Does not implicitly {@link isoworldremote.RawNames.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.IRawNames} message RawNames message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RawNames.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.available);
            if (message.inorganic != null && message.inorganic.length)
                for (var i = 0; i < message.inorganic.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inorganic[i]);
            if (message.organic != null && message.organic.length)
                for (var i = 0; i < message.organic.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.organic[i]);
            return writer;
        };

        /**
         * Encodes the specified RawNames message, length delimited. Does not implicitly {@link isoworldremote.RawNames.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.IRawNames} message RawNames message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RawNames.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RawNames message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.RawNames
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.RawNames} RawNames
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RawNames.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.RawNames();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.available = reader.bool();
                    break;
                case 2:
                    if (!(message.inorganic && message.inorganic.length))
                        message.inorganic = [];
                    message.inorganic.push(reader.string());
                    break;
                case 3:
                    if (!(message.organic && message.organic.length))
                        message.organic = [];
                    message.organic.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("available"))
                throw $util.ProtocolError("missing required 'available'", { instance: message });
            return message;
        };

        /**
         * Decodes a RawNames message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.RawNames
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.RawNames} RawNames
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RawNames.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RawNames message.
         * @function verify
         * @memberof isoworldremote.RawNames
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RawNames.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.available !== "boolean")
                return "available: boolean expected";
            if (message.inorganic != null && message.hasOwnProperty("inorganic")) {
                if (!Array.isArray(message.inorganic))
                    return "inorganic: array expected";
                for (var i = 0; i < message.inorganic.length; ++i)
                    if (!$util.isString(message.inorganic[i]))
                        return "inorganic: string[] expected";
            }
            if (message.organic != null && message.hasOwnProperty("organic")) {
                if (!Array.isArray(message.organic))
                    return "organic: array expected";
                for (var i = 0; i < message.organic.length; ++i)
                    if (!$util.isString(message.organic[i]))
                        return "organic: string[] expected";
            }
            return null;
        };

        /**
         * Creates a RawNames message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.RawNames
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.RawNames} RawNames
         */
        RawNames.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.RawNames)
                return object;
            var message = new $root.isoworldremote.RawNames();
            if (object.available != null)
                message.available = Boolean(object.available);
            if (object.inorganic) {
                if (!Array.isArray(object.inorganic))
                    throw TypeError(".isoworldremote.RawNames.inorganic: array expected");
                message.inorganic = [];
                for (var i = 0; i < object.inorganic.length; ++i)
                    message.inorganic[i] = String(object.inorganic[i]);
            }
            if (object.organic) {
                if (!Array.isArray(object.organic))
                    throw TypeError(".isoworldremote.RawNames.organic: array expected");
                message.organic = [];
                for (var i = 0; i < object.organic.length; ++i)
                    message.organic[i] = String(object.organic[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a RawNames message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.RawNames} message RawNames
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RawNames.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.inorganic = [];
                object.organic = [];
            }
            if (options.defaults)
                object.available = false;
            if (message.available != null && message.hasOwnProperty("available"))
                object.available = message.available;
            if (message.inorganic && message.inorganic.length) {
                object.inorganic = [];
                for (var j = 0; j < message.inorganic.length; ++j)
                    object.inorganic[j] = message.inorganic[j];
            }
            if (message.organic && message.organic.length) {
                object.organic = [];
                for (var j = 0; j < message.organic.length; ++j)
                    object.organic[j] = message.organic[j];
            }
            return object;
        };

        /**
         * Converts this RawNames to JSON.
         * @function toJSON
         * @memberof isoworldremote.RawNames
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RawNames.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RawNames;
    })();

    return isoworldremote;
})();

$root.RemoteFortressReader = (function() {

    /**
     * Namespace RemoteFortressReader.
     * @exports RemoteFortressReader
     * @namespace
     */
    var RemoteFortressReader = {};

    /**
     * TiletypeShape enum.
     * @name RemoteFortressReader.TiletypeShape
     * @enum {string}
     * @property {number} NO_SHAPE=-1 NO_SHAPE value
     * @property {number} EMPTY=0 EMPTY value
     * @property {number} FLOOR=1 FLOOR value
     * @property {number} BOULDER=2 BOULDER value
     * @property {number} PEBBLES=3 PEBBLES value
     * @property {number} WALL=4 WALL value
     * @property {number} FORTIFICATION=5 FORTIFICATION value
     * @property {number} STAIR_UP=6 STAIR_UP value
     * @property {number} STAIR_DOWN=7 STAIR_DOWN value
     * @property {number} STAIR_UPDOWN=8 STAIR_UPDOWN value
     * @property {number} RAMP=9 RAMP value
     * @property {number} RAMP_TOP=10 RAMP_TOP value
     * @property {number} BROOK_BED=11 BROOK_BED value
     * @property {number} BROOK_TOP=12 BROOK_TOP value
     * @property {number} TREE_SHAPE=13 TREE_SHAPE value
     * @property {number} SAPLING=14 SAPLING value
     * @property {number} SHRUB=15 SHRUB value
     * @property {number} ENDLESS_PIT=16 ENDLESS_PIT value
     * @property {number} BRANCH=17 BRANCH value
     * @property {number} TRUNK_BRANCH=18 TRUNK_BRANCH value
     * @property {number} TWIG=19 TWIG value
     */
    RemoteFortressReader.TiletypeShape = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_SHAPE"] = -1;
        values[valuesById[0] = "EMPTY"] = 0;
        values[valuesById[1] = "FLOOR"] = 1;
        values[valuesById[2] = "BOULDER"] = 2;
        values[valuesById[3] = "PEBBLES"] = 3;
        values[valuesById[4] = "WALL"] = 4;
        values[valuesById[5] = "FORTIFICATION"] = 5;
        values[valuesById[6] = "STAIR_UP"] = 6;
        values[valuesById[7] = "STAIR_DOWN"] = 7;
        values[valuesById[8] = "STAIR_UPDOWN"] = 8;
        values[valuesById[9] = "RAMP"] = 9;
        values[valuesById[10] = "RAMP_TOP"] = 10;
        values[valuesById[11] = "BROOK_BED"] = 11;
        values[valuesById[12] = "BROOK_TOP"] = 12;
        values[valuesById[13] = "TREE_SHAPE"] = 13;
        values[valuesById[14] = "SAPLING"] = 14;
        values[valuesById[15] = "SHRUB"] = 15;
        values[valuesById[16] = "ENDLESS_PIT"] = 16;
        values[valuesById[17] = "BRANCH"] = 17;
        values[valuesById[18] = "TRUNK_BRANCH"] = 18;
        values[valuesById[19] = "TWIG"] = 19;
        return values;
    })();

    /**
     * TiletypeSpecial enum.
     * @name RemoteFortressReader.TiletypeSpecial
     * @enum {string}
     * @property {number} NO_SPECIAL=-1 NO_SPECIAL value
     * @property {number} NORMAL=0 NORMAL value
     * @property {number} RIVER_SOURCE=1 RIVER_SOURCE value
     * @property {number} WATERFALL=2 WATERFALL value
     * @property {number} SMOOTH=3 SMOOTH value
     * @property {number} FURROWED=4 FURROWED value
     * @property {number} WET=5 WET value
     * @property {number} DEAD=6 DEAD value
     * @property {number} WORN_1=7 WORN_1 value
     * @property {number} WORN_2=8 WORN_2 value
     * @property {number} WORN_3=9 WORN_3 value
     * @property {number} TRACK=10 TRACK value
     * @property {number} SMOOTH_DEAD=11 SMOOTH_DEAD value
     */
    RemoteFortressReader.TiletypeSpecial = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_SPECIAL"] = -1;
        values[valuesById[0] = "NORMAL"] = 0;
        values[valuesById[1] = "RIVER_SOURCE"] = 1;
        values[valuesById[2] = "WATERFALL"] = 2;
        values[valuesById[3] = "SMOOTH"] = 3;
        values[valuesById[4] = "FURROWED"] = 4;
        values[valuesById[5] = "WET"] = 5;
        values[valuesById[6] = "DEAD"] = 6;
        values[valuesById[7] = "WORN_1"] = 7;
        values[valuesById[8] = "WORN_2"] = 8;
        values[valuesById[9] = "WORN_3"] = 9;
        values[valuesById[10] = "TRACK"] = 10;
        values[valuesById[11] = "SMOOTH_DEAD"] = 11;
        return values;
    })();

    /**
     * TiletypeMaterial enum.
     * @name RemoteFortressReader.TiletypeMaterial
     * @enum {string}
     * @property {number} NO_MATERIAL=-1 NO_MATERIAL value
     * @property {number} AIR=0 AIR value
     * @property {number} SOIL=1 SOIL value
     * @property {number} STONE=2 STONE value
     * @property {number} FEATURE=3 FEATURE value
     * @property {number} LAVA_STONE=4 LAVA_STONE value
     * @property {number} MINERAL=5 MINERAL value
     * @property {number} FROZEN_LIQUID=6 FROZEN_LIQUID value
     * @property {number} CONSTRUCTION=7 CONSTRUCTION value
     * @property {number} GRASS_LIGHT=8 GRASS_LIGHT value
     * @property {number} GRASS_DARK=9 GRASS_DARK value
     * @property {number} GRASS_DRY=10 GRASS_DRY value
     * @property {number} GRASS_DEAD=11 GRASS_DEAD value
     * @property {number} PLANT=12 PLANT value
     * @property {number} HFS=13 HFS value
     * @property {number} CAMPFIRE=14 CAMPFIRE value
     * @property {number} FIRE=15 FIRE value
     * @property {number} ASHES=16 ASHES value
     * @property {number} MAGMA=17 MAGMA value
     * @property {number} DRIFTWOOD=18 DRIFTWOOD value
     * @property {number} POOL=19 POOL value
     * @property {number} BROOK=20 BROOK value
     * @property {number} RIVER=21 RIVER value
     * @property {number} ROOT=22 ROOT value
     * @property {number} TREE_MATERIAL=23 TREE_MATERIAL value
     * @property {number} MUSHROOM=24 MUSHROOM value
     * @property {number} UNDERWORLD_GATE=25 UNDERWORLD_GATE value
     */
    RemoteFortressReader.TiletypeMaterial = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_MATERIAL"] = -1;
        values[valuesById[0] = "AIR"] = 0;
        values[valuesById[1] = "SOIL"] = 1;
        values[valuesById[2] = "STONE"] = 2;
        values[valuesById[3] = "FEATURE"] = 3;
        values[valuesById[4] = "LAVA_STONE"] = 4;
        values[valuesById[5] = "MINERAL"] = 5;
        values[valuesById[6] = "FROZEN_LIQUID"] = 6;
        values[valuesById[7] = "CONSTRUCTION"] = 7;
        values[valuesById[8] = "GRASS_LIGHT"] = 8;
        values[valuesById[9] = "GRASS_DARK"] = 9;
        values[valuesById[10] = "GRASS_DRY"] = 10;
        values[valuesById[11] = "GRASS_DEAD"] = 11;
        values[valuesById[12] = "PLANT"] = 12;
        values[valuesById[13] = "HFS"] = 13;
        values[valuesById[14] = "CAMPFIRE"] = 14;
        values[valuesById[15] = "FIRE"] = 15;
        values[valuesById[16] = "ASHES"] = 16;
        values[valuesById[17] = "MAGMA"] = 17;
        values[valuesById[18] = "DRIFTWOOD"] = 18;
        values[valuesById[19] = "POOL"] = 19;
        values[valuesById[20] = "BROOK"] = 20;
        values[valuesById[21] = "RIVER"] = 21;
        values[valuesById[22] = "ROOT"] = 22;
        values[valuesById[23] = "TREE_MATERIAL"] = 23;
        values[valuesById[24] = "MUSHROOM"] = 24;
        values[valuesById[25] = "UNDERWORLD_GATE"] = 25;
        return values;
    })();

    /**
     * TiletypeVariant enum.
     * @name RemoteFortressReader.TiletypeVariant
     * @enum {string}
     * @property {number} NO_VARIANT=-1 NO_VARIANT value
     * @property {number} VAR_1=0 VAR_1 value
     * @property {number} VAR_2=1 VAR_2 value
     * @property {number} VAR_3=2 VAR_3 value
     * @property {number} VAR_4=3 VAR_4 value
     */
    RemoteFortressReader.TiletypeVariant = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_VARIANT"] = -1;
        values[valuesById[0] = "VAR_1"] = 0;
        values[valuesById[1] = "VAR_2"] = 1;
        values[valuesById[2] = "VAR_3"] = 2;
        values[valuesById[3] = "VAR_4"] = 3;
        return values;
    })();

    /**
     * WorldPoles enum.
     * @name RemoteFortressReader.WorldPoles
     * @enum {string}
     * @property {number} NO_POLES=0 NO_POLES value
     * @property {number} NORTH_POLE=1 NORTH_POLE value
     * @property {number} SOUTH_POLE=2 SOUTH_POLE value
     * @property {number} BOTH_POLES=3 BOTH_POLES value
     */
    RemoteFortressReader.WorldPoles = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_POLES"] = 0;
        values[valuesById[1] = "NORTH_POLE"] = 1;
        values[valuesById[2] = "SOUTH_POLE"] = 2;
        values[valuesById[3] = "BOTH_POLES"] = 3;
        return values;
    })();

    /**
     * BuildingDirection enum.
     * @name RemoteFortressReader.BuildingDirection
     * @enum {string}
     * @property {number} NORTH=0 NORTH value
     * @property {number} EAST=1 EAST value
     * @property {number} SOUTH=2 SOUTH value
     * @property {number} WEST=3 WEST value
     * @property {number} NONE=4 NONE value
     */
    RemoteFortressReader.BuildingDirection = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NORTH"] = 0;
        values[valuesById[1] = "EAST"] = 1;
        values[valuesById[2] = "SOUTH"] = 2;
        values[valuesById[3] = "WEST"] = 3;
        values[valuesById[4] = "NONE"] = 4;
        return values;
    })();

    /**
     * TileDigDesignation enum.
     * @name RemoteFortressReader.TileDigDesignation
     * @enum {string}
     * @property {number} NO_DIG=0 no designation
     * @property {number} DEFAULT_DIG=1 dig walls, remove stairs and ramps, gather plants, fell trees
     * @property {number} UP_DOWN_STAIR_DIG=2 UP_DOWN_STAIR_DIG value
     * @property {number} CHANNEL_DIG=3 CHANNEL_DIG value
     * @property {number} RAMP_DIG=4 RAMP_DIG value
     * @property {number} DOWN_STAIR_DIG=5 DOWN_STAIR_DIG value
     * @property {number} UP_STAIR_DIG=6 UP_STAIR_DIG value
     */
    RemoteFortressReader.TileDigDesignation = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_DIG"] = 0;
        values[valuesById[1] = "DEFAULT_DIG"] = 1;
        values[valuesById[2] = "UP_DOWN_STAIR_DIG"] = 2;
        values[valuesById[3] = "CHANNEL_DIG"] = 3;
        values[valuesById[4] = "RAMP_DIG"] = 4;
        values[valuesById[5] = "DOWN_STAIR_DIG"] = 5;
        values[valuesById[6] = "UP_STAIR_DIG"] = 6;
        return values;
    })();

    /**
     * HairStyle enum.
     * @name RemoteFortressReader.HairStyle
     * @enum {string}
     * @property {number} UNKEMPT=-1 UNKEMPT value
     * @property {number} NEATLY_COMBED=0 NEATLY_COMBED value
     * @property {number} BRAIDED=1 BRAIDED value
     * @property {number} DOUBLE_BRAID=2 DOUBLE_BRAID value
     * @property {number} PONY_TAILS=3 PONY_TAILS value
     * @property {number} CLEAN_SHAVEN=4 CLEAN_SHAVEN value
     */
    RemoteFortressReader.HairStyle = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "UNKEMPT"] = -1;
        values[valuesById[0] = "NEATLY_COMBED"] = 0;
        values[valuesById[1] = "BRAIDED"] = 1;
        values[valuesById[2] = "DOUBLE_BRAID"] = 2;
        values[valuesById[3] = "PONY_TAILS"] = 3;
        values[valuesById[4] = "CLEAN_SHAVEN"] = 4;
        return values;
    })();

    /**
     * InventoryMode enum.
     * @name RemoteFortressReader.InventoryMode
     * @enum {string}
     * @property {number} Hauled=0 Hauled value
     * @property {number} Weapon=1 also shield, crutch
     * @property {number} Worn=2 quiver
     * @property {number} Piercing=3 Piercing value
     * @property {number} Flask=4 attached to clothing
     * @property {number} WrappedAround=5 e.g. bandage
     * @property {number} StuckIn=6 StuckIn value
     * @property {number} InMouth=7 string descr like Worn
     * @property {number} Pet=8 Left shoulder, right shoulder, or head, selected randomly using pet_seed
     * @property {number} SewnInto=9 SewnInto value
     * @property {number} Strapped=10 Strapped value
     */
    RemoteFortressReader.InventoryMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Hauled"] = 0;
        values[valuesById[1] = "Weapon"] = 1;
        values[valuesById[2] = "Worn"] = 2;
        values[valuesById[3] = "Piercing"] = 3;
        values[valuesById[4] = "Flask"] = 4;
        values[valuesById[5] = "WrappedAround"] = 5;
        values[valuesById[6] = "StuckIn"] = 6;
        values[valuesById[7] = "InMouth"] = 7;
        values[valuesById[8] = "Pet"] = 8;
        values[valuesById[9] = "SewnInto"] = 9;
        values[valuesById[10] = "Strapped"] = 10;
        return values;
    })();

    RemoteFortressReader.Coord = (function() {

        /**
         * Properties of a Coord.
         * @memberof RemoteFortressReader
         * @interface ICoord
         * @property {number|null} [x] Coord x
         * @property {number|null} [y] Coord y
         * @property {number|null} [z] Coord z
         */

        /**
         * Constructs a new Coord.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Coord.
         * @implements ICoord
         * @constructor
         * @param {RemoteFortressReader.ICoord=} [properties] Properties to set
         */
        function Coord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coord x.
         * @member {number} x
         * @memberof RemoteFortressReader.Coord
         * @instance
         */
        Coord.prototype.x = 0;

        /**
         * Coord y.
         * @member {number} y
         * @memberof RemoteFortressReader.Coord
         * @instance
         */
        Coord.prototype.y = 0;

        /**
         * Coord z.
         * @member {number} z
         * @memberof RemoteFortressReader.Coord
         * @instance
         */
        Coord.prototype.z = 0;

        /**
         * Creates a new Coord instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.ICoord=} [properties] Properties to set
         * @returns {RemoteFortressReader.Coord} Coord instance
         */
        Coord.create = function create(properties) {
            return new Coord(properties);
        };

        /**
         * Encodes the specified Coord message. Does not implicitly {@link RemoteFortressReader.Coord.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.ICoord} message Coord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.z != null && message.hasOwnProperty("z"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.z);
            return writer;
        };

        /**
         * Encodes the specified Coord message, length delimited. Does not implicitly {@link RemoteFortressReader.Coord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.ICoord} message Coord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coord message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Coord} Coord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Coord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.z = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Coord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Coord} Coord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coord message.
         * @function verify
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            return null;
        };

        /**
         * Creates a Coord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Coord} Coord
         */
        Coord.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Coord)
                return object;
            var message = new $root.RemoteFortressReader.Coord();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.z != null)
                message.z = object.z | 0;
            return message;
        };

        /**
         * Creates a plain object from a Coord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.Coord} message Coord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            return object;
        };

        /**
         * Converts this Coord to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Coord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coord;
    })();

    RemoteFortressReader.Tiletype = (function() {

        /**
         * Properties of a Tiletype.
         * @memberof RemoteFortressReader
         * @interface ITiletype
         * @property {number} id Tiletype id
         * @property {string|null} [name] Tiletype name
         * @property {string|null} [caption] Tiletype caption
         * @property {RemoteFortressReader.TiletypeShape|null} [shape] Tiletype shape
         * @property {RemoteFortressReader.TiletypeSpecial|null} [special] Tiletype special
         * @property {RemoteFortressReader.TiletypeMaterial|null} [material] Tiletype material
         * @property {RemoteFortressReader.TiletypeVariant|null} [variant] Tiletype variant
         * @property {string|null} [direction] Tiletype direction
         */

        /**
         * Constructs a new Tiletype.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Tiletype.
         * @implements ITiletype
         * @constructor
         * @param {RemoteFortressReader.ITiletype=} [properties] Properties to set
         */
        function Tiletype(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tiletype id.
         * @member {number} id
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.id = 0;

        /**
         * Tiletype name.
         * @member {string} name
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.name = "";

        /**
         * Tiletype caption.
         * @member {string} caption
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.caption = "";

        /**
         * Tiletype shape.
         * @member {RemoteFortressReader.TiletypeShape} shape
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.shape = -1;

        /**
         * Tiletype special.
         * @member {RemoteFortressReader.TiletypeSpecial} special
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.special = -1;

        /**
         * Tiletype material.
         * @member {RemoteFortressReader.TiletypeMaterial} material
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.material = -1;

        /**
         * Tiletype variant.
         * @member {RemoteFortressReader.TiletypeVariant} variant
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.variant = -1;

        /**
         * Tiletype direction.
         * @member {string} direction
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.direction = "";

        /**
         * Creates a new Tiletype instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.ITiletype=} [properties] Properties to set
         * @returns {RemoteFortressReader.Tiletype} Tiletype instance
         */
        Tiletype.create = function create(properties) {
            return new Tiletype(properties);
        };

        /**
         * Encodes the specified Tiletype message. Does not implicitly {@link RemoteFortressReader.Tiletype.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.ITiletype} message Tiletype message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tiletype.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.caption != null && message.hasOwnProperty("caption"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
            if (message.shape != null && message.hasOwnProperty("shape"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.shape);
            if (message.special != null && message.hasOwnProperty("special"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.special);
            if (message.material != null && message.hasOwnProperty("material"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.material);
            if (message.variant != null && message.hasOwnProperty("variant"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.variant);
            if (message.direction != null && message.hasOwnProperty("direction"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.direction);
            return writer;
        };

        /**
         * Encodes the specified Tiletype message, length delimited. Does not implicitly {@link RemoteFortressReader.Tiletype.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.ITiletype} message Tiletype message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tiletype.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tiletype message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Tiletype} Tiletype
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tiletype.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Tiletype();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.caption = reader.string();
                    break;
                case 4:
                    message.shape = reader.int32();
                    break;
                case 5:
                    message.special = reader.int32();
                    break;
                case 6:
                    message.material = reader.int32();
                    break;
                case 7:
                    message.variant = reader.int32();
                    break;
                case 8:
                    message.direction = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a Tiletype message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Tiletype} Tiletype
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tiletype.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tiletype message.
         * @function verify
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tiletype.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.shape != null && message.hasOwnProperty("shape"))
                switch (message.shape) {
                default:
                    return "shape: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                    break;
                }
            if (message.special != null && message.hasOwnProperty("special"))
                switch (message.special) {
                default:
                    return "special: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.material != null && message.hasOwnProperty("material"))
                switch (message.material) {
                default:
                    return "material: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                    break;
                }
            if (message.variant != null && message.hasOwnProperty("variant"))
                switch (message.variant) {
                default:
                    return "variant: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.direction != null && message.hasOwnProperty("direction"))
                if (!$util.isString(message.direction))
                    return "direction: string expected";
            return null;
        };

        /**
         * Creates a Tiletype message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Tiletype} Tiletype
         */
        Tiletype.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Tiletype)
                return object;
            var message = new $root.RemoteFortressReader.Tiletype();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.caption != null)
                message.caption = String(object.caption);
            switch (object.shape) {
            case "NO_SHAPE":
            case -1:
                message.shape = -1;
                break;
            case "EMPTY":
            case 0:
                message.shape = 0;
                break;
            case "FLOOR":
            case 1:
                message.shape = 1;
                break;
            case "BOULDER":
            case 2:
                message.shape = 2;
                break;
            case "PEBBLES":
            case 3:
                message.shape = 3;
                break;
            case "WALL":
            case 4:
                message.shape = 4;
                break;
            case "FORTIFICATION":
            case 5:
                message.shape = 5;
                break;
            case "STAIR_UP":
            case 6:
                message.shape = 6;
                break;
            case "STAIR_DOWN":
            case 7:
                message.shape = 7;
                break;
            case "STAIR_UPDOWN":
            case 8:
                message.shape = 8;
                break;
            case "RAMP":
            case 9:
                message.shape = 9;
                break;
            case "RAMP_TOP":
            case 10:
                message.shape = 10;
                break;
            case "BROOK_BED":
            case 11:
                message.shape = 11;
                break;
            case "BROOK_TOP":
            case 12:
                message.shape = 12;
                break;
            case "TREE_SHAPE":
            case 13:
                message.shape = 13;
                break;
            case "SAPLING":
            case 14:
                message.shape = 14;
                break;
            case "SHRUB":
            case 15:
                message.shape = 15;
                break;
            case "ENDLESS_PIT":
            case 16:
                message.shape = 16;
                break;
            case "BRANCH":
            case 17:
                message.shape = 17;
                break;
            case "TRUNK_BRANCH":
            case 18:
                message.shape = 18;
                break;
            case "TWIG":
            case 19:
                message.shape = 19;
                break;
            }
            switch (object.special) {
            case "NO_SPECIAL":
            case -1:
                message.special = -1;
                break;
            case "NORMAL":
            case 0:
                message.special = 0;
                break;
            case "RIVER_SOURCE":
            case 1:
                message.special = 1;
                break;
            case "WATERFALL":
            case 2:
                message.special = 2;
                break;
            case "SMOOTH":
            case 3:
                message.special = 3;
                break;
            case "FURROWED":
            case 4:
                message.special = 4;
                break;
            case "WET":
            case 5:
                message.special = 5;
                break;
            case "DEAD":
            case 6:
                message.special = 6;
                break;
            case "WORN_1":
            case 7:
                message.special = 7;
                break;
            case "WORN_2":
            case 8:
                message.special = 8;
                break;
            case "WORN_3":
            case 9:
                message.special = 9;
                break;
            case "TRACK":
            case 10:
                message.special = 10;
                break;
            case "SMOOTH_DEAD":
            case 11:
                message.special = 11;
                break;
            }
            switch (object.material) {
            case "NO_MATERIAL":
            case -1:
                message.material = -1;
                break;
            case "AIR":
            case 0:
                message.material = 0;
                break;
            case "SOIL":
            case 1:
                message.material = 1;
                break;
            case "STONE":
            case 2:
                message.material = 2;
                break;
            case "FEATURE":
            case 3:
                message.material = 3;
                break;
            case "LAVA_STONE":
            case 4:
                message.material = 4;
                break;
            case "MINERAL":
            case 5:
                message.material = 5;
                break;
            case "FROZEN_LIQUID":
            case 6:
                message.material = 6;
                break;
            case "CONSTRUCTION":
            case 7:
                message.material = 7;
                break;
            case "GRASS_LIGHT":
            case 8:
                message.material = 8;
                break;
            case "GRASS_DARK":
            case 9:
                message.material = 9;
                break;
            case "GRASS_DRY":
            case 10:
                message.material = 10;
                break;
            case "GRASS_DEAD":
            case 11:
                message.material = 11;
                break;
            case "PLANT":
            case 12:
                message.material = 12;
                break;
            case "HFS":
            case 13:
                message.material = 13;
                break;
            case "CAMPFIRE":
            case 14:
                message.material = 14;
                break;
            case "FIRE":
            case 15:
                message.material = 15;
                break;
            case "ASHES":
            case 16:
                message.material = 16;
                break;
            case "MAGMA":
            case 17:
                message.material = 17;
                break;
            case "DRIFTWOOD":
            case 18:
                message.material = 18;
                break;
            case "POOL":
            case 19:
                message.material = 19;
                break;
            case "BROOK":
            case 20:
                message.material = 20;
                break;
            case "RIVER":
            case 21:
                message.material = 21;
                break;
            case "ROOT":
            case 22:
                message.material = 22;
                break;
            case "TREE_MATERIAL":
            case 23:
                message.material = 23;
                break;
            case "MUSHROOM":
            case 24:
                message.material = 24;
                break;
            case "UNDERWORLD_GATE":
            case 25:
                message.material = 25;
                break;
            }
            switch (object.variant) {
            case "NO_VARIANT":
            case -1:
                message.variant = -1;
                break;
            case "VAR_1":
            case 0:
                message.variant = 0;
                break;
            case "VAR_2":
            case 1:
                message.variant = 1;
                break;
            case "VAR_3":
            case 2:
                message.variant = 2;
                break;
            case "VAR_4":
            case 3:
                message.variant = 3;
                break;
            }
            if (object.direction != null)
                message.direction = String(object.direction);
            return message;
        };

        /**
         * Creates a plain object from a Tiletype message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.Tiletype} message Tiletype
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tiletype.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.name = "";
                object.caption = "";
                object.shape = options.enums === String ? "NO_SHAPE" : -1;
                object.special = options.enums === String ? "NO_SPECIAL" : -1;
                object.material = options.enums === String ? "NO_MATERIAL" : -1;
                object.variant = options.enums === String ? "NO_VARIANT" : -1;
                object.direction = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = options.enums === String ? $root.RemoteFortressReader.TiletypeShape[message.shape] : message.shape;
            if (message.special != null && message.hasOwnProperty("special"))
                object.special = options.enums === String ? $root.RemoteFortressReader.TiletypeSpecial[message.special] : message.special;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = options.enums === String ? $root.RemoteFortressReader.TiletypeMaterial[message.material] : message.material;
            if (message.variant != null && message.hasOwnProperty("variant"))
                object.variant = options.enums === String ? $root.RemoteFortressReader.TiletypeVariant[message.variant] : message.variant;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = message.direction;
            return object;
        };

        /**
         * Converts this Tiletype to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tiletype.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tiletype;
    })();

    RemoteFortressReader.TiletypeList = (function() {

        /**
         * Properties of a TiletypeList.
         * @memberof RemoteFortressReader
         * @interface ITiletypeList
         * @property {Array.<RemoteFortressReader.ITiletype>|null} [tiletypeList] TiletypeList tiletypeList
         */

        /**
         * Constructs a new TiletypeList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TiletypeList.
         * @implements ITiletypeList
         * @constructor
         * @param {RemoteFortressReader.ITiletypeList=} [properties] Properties to set
         */
        function TiletypeList(properties) {
            this.tiletypeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TiletypeList tiletypeList.
         * @member {Array.<RemoteFortressReader.ITiletype>} tiletypeList
         * @memberof RemoteFortressReader.TiletypeList
         * @instance
         */
        TiletypeList.prototype.tiletypeList = $util.emptyArray;

        /**
         * Creates a new TiletypeList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.ITiletypeList=} [properties] Properties to set
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList instance
         */
        TiletypeList.create = function create(properties) {
            return new TiletypeList(properties);
        };

        /**
         * Encodes the specified TiletypeList message. Does not implicitly {@link RemoteFortressReader.TiletypeList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.ITiletypeList} message TiletypeList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiletypeList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tiletypeList != null && message.tiletypeList.length)
                for (var i = 0; i < message.tiletypeList.length; ++i)
                    $root.RemoteFortressReader.Tiletype.encode(message.tiletypeList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TiletypeList message, length delimited. Does not implicitly {@link RemoteFortressReader.TiletypeList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.ITiletypeList} message TiletypeList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiletypeList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TiletypeList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiletypeList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TiletypeList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tiletypeList && message.tiletypeList.length))
                        message.tiletypeList = [];
                    message.tiletypeList.push($root.RemoteFortressReader.Tiletype.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TiletypeList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiletypeList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TiletypeList message.
         * @function verify
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TiletypeList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tiletypeList != null && message.hasOwnProperty("tiletypeList")) {
                if (!Array.isArray(message.tiletypeList))
                    return "tiletypeList: array expected";
                for (var i = 0; i < message.tiletypeList.length; ++i) {
                    var error = $root.RemoteFortressReader.Tiletype.verify(message.tiletypeList[i]);
                    if (error)
                        return "tiletypeList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TiletypeList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList
         */
        TiletypeList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TiletypeList)
                return object;
            var message = new $root.RemoteFortressReader.TiletypeList();
            if (object.tiletypeList) {
                if (!Array.isArray(object.tiletypeList))
                    throw TypeError(".RemoteFortressReader.TiletypeList.tiletypeList: array expected");
                message.tiletypeList = [];
                for (var i = 0; i < object.tiletypeList.length; ++i) {
                    if (typeof object.tiletypeList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.TiletypeList.tiletypeList: object expected");
                    message.tiletypeList[i] = $root.RemoteFortressReader.Tiletype.fromObject(object.tiletypeList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TiletypeList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.TiletypeList} message TiletypeList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TiletypeList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tiletypeList = [];
            if (message.tiletypeList && message.tiletypeList.length) {
                object.tiletypeList = [];
                for (var j = 0; j < message.tiletypeList.length; ++j)
                    object.tiletypeList[j] = $root.RemoteFortressReader.Tiletype.toObject(message.tiletypeList[j], options);
            }
            return object;
        };

        /**
         * Converts this TiletypeList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TiletypeList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TiletypeList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TiletypeList;
    })();

    RemoteFortressReader.BuildingExtents = (function() {

        /**
         * Properties of a BuildingExtents.
         * @memberof RemoteFortressReader
         * @interface IBuildingExtents
         * @property {number} posX BuildingExtents posX
         * @property {number} posY BuildingExtents posY
         * @property {number} width BuildingExtents width
         * @property {number} height BuildingExtents height
         * @property {Array.<number>|null} [extents] BuildingExtents extents
         */

        /**
         * Constructs a new BuildingExtents.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingExtents.
         * @implements IBuildingExtents
         * @constructor
         * @param {RemoteFortressReader.IBuildingExtents=} [properties] Properties to set
         */
        function BuildingExtents(properties) {
            this.extents = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingExtents posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.posX = 0;

        /**
         * BuildingExtents posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.posY = 0;

        /**
         * BuildingExtents width.
         * @member {number} width
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.width = 0;

        /**
         * BuildingExtents height.
         * @member {number} height
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.height = 0;

        /**
         * BuildingExtents extents.
         * @member {Array.<number>} extents
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.extents = $util.emptyArray;

        /**
         * Creates a new BuildingExtents instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.IBuildingExtents=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents instance
         */
        BuildingExtents.create = function create(properties) {
            return new BuildingExtents(properties);
        };

        /**
         * Encodes the specified BuildingExtents message. Does not implicitly {@link RemoteFortressReader.BuildingExtents.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.IBuildingExtents} message BuildingExtents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingExtents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.height);
            if (message.extents != null && message.extents.length)
                for (var i = 0; i < message.extents.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.extents[i]);
            return writer;
        };

        /**
         * Encodes the specified BuildingExtents message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingExtents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.IBuildingExtents} message BuildingExtents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingExtents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingExtents message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingExtents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingExtents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.posX = reader.int32();
                    break;
                case 2:
                    message.posY = reader.int32();
                    break;
                case 3:
                    message.width = reader.int32();
                    break;
                case 4:
                    message.height = reader.int32();
                    break;
                case 5:
                    if (!(message.extents && message.extents.length))
                        message.extents = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.extents.push(reader.int32());
                    } else
                        message.extents.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("posX"))
                throw $util.ProtocolError("missing required 'posX'", { instance: message });
            if (!message.hasOwnProperty("posY"))
                throw $util.ProtocolError("missing required 'posY'", { instance: message });
            if (!message.hasOwnProperty("width"))
                throw $util.ProtocolError("missing required 'width'", { instance: message });
            if (!message.hasOwnProperty("height"))
                throw $util.ProtocolError("missing required 'height'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingExtents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingExtents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingExtents message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingExtents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
            if (!$util.isInteger(message.width))
                return "width: integer expected";
            if (!$util.isInteger(message.height))
                return "height: integer expected";
            if (message.extents != null && message.hasOwnProperty("extents")) {
                if (!Array.isArray(message.extents))
                    return "extents: array expected";
                for (var i = 0; i < message.extents.length; ++i)
                    if (!$util.isInteger(message.extents[i]))
                        return "extents: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BuildingExtents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents
         */
        BuildingExtents.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingExtents)
                return object;
            var message = new $root.RemoteFortressReader.BuildingExtents();
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.width != null)
                message.width = object.width | 0;
            if (object.height != null)
                message.height = object.height | 0;
            if (object.extents) {
                if (!Array.isArray(object.extents))
                    throw TypeError(".RemoteFortressReader.BuildingExtents.extents: array expected");
                message.extents = [];
                for (var i = 0; i < object.extents.length; ++i)
                    message.extents[i] = object.extents[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BuildingExtents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.BuildingExtents} message BuildingExtents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingExtents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.extents = [];
            if (options.defaults) {
                object.posX = 0;
                object.posY = 0;
                object.width = 0;
                object.height = 0;
            }
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.extents && message.extents.length) {
                object.extents = [];
                for (var j = 0; j < message.extents.length; ++j)
                    object.extents[j] = message.extents[j];
            }
            return object;
        };

        /**
         * Converts this BuildingExtents to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingExtents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingExtents;
    })();

    RemoteFortressReader.BuildingItem = (function() {

        /**
         * Properties of a BuildingItem.
         * @memberof RemoteFortressReader
         * @interface IBuildingItem
         * @property {RemoteFortressReader.IItem|null} [item] BuildingItem item
         * @property {number|null} [mode] BuildingItem mode
         */

        /**
         * Constructs a new BuildingItem.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingItem.
         * @implements IBuildingItem
         * @constructor
         * @param {RemoteFortressReader.IBuildingItem=} [properties] Properties to set
         */
        function BuildingItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingItem item.
         * @member {RemoteFortressReader.IItem|null|undefined} item
         * @memberof RemoteFortressReader.BuildingItem
         * @instance
         */
        BuildingItem.prototype.item = null;

        /**
         * BuildingItem mode.
         * @member {number} mode
         * @memberof RemoteFortressReader.BuildingItem
         * @instance
         */
        BuildingItem.prototype.mode = 0;

        /**
         * Creates a new BuildingItem instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.IBuildingItem=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem instance
         */
        BuildingItem.create = function create(properties) {
            return new BuildingItem(properties);
        };

        /**
         * Encodes the specified BuildingItem message. Does not implicitly {@link RemoteFortressReader.BuildingItem.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.IBuildingItem} message BuildingItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && message.hasOwnProperty("item"))
                $root.RemoteFortressReader.Item.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mode != null && message.hasOwnProperty("mode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
            return writer;
        };

        /**
         * Encodes the specified BuildingItem message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.IBuildingItem} message BuildingItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingItem message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.RemoteFortressReader.Item.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuildingItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingItem message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.Item.verify(message.item);
                if (error)
                    return "item." + error;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                if (!$util.isInteger(message.mode))
                    return "mode: integer expected";
            return null;
        };

        /**
         * Creates a BuildingItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem
         */
        BuildingItem.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingItem)
                return object;
            var message = new $root.RemoteFortressReader.BuildingItem();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingItem.item: object expected");
                message.item = $root.RemoteFortressReader.Item.fromObject(object.item);
            }
            if (object.mode != null)
                message.mode = object.mode | 0;
            return message;
        };

        /**
         * Creates a plain object from a BuildingItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.BuildingItem} message BuildingItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item = null;
                object.mode = 0;
            }
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.Item.toObject(message.item, options);
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = message.mode;
            return object;
        };

        /**
         * Converts this BuildingItem to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingItem;
    })();

    RemoteFortressReader.BuildingInstance = (function() {

        /**
         * Properties of a BuildingInstance.
         * @memberof RemoteFortressReader
         * @interface IBuildingInstance
         * @property {number} index BuildingInstance index
         * @property {number|null} [posXMin] BuildingInstance posXMin
         * @property {number|null} [posYMin] BuildingInstance posYMin
         * @property {number|null} [posZMin] BuildingInstance posZMin
         * @property {number|null} [posXMax] BuildingInstance posXMax
         * @property {number|null} [posYMax] BuildingInstance posYMax
         * @property {number|null} [posZMax] BuildingInstance posZMax
         * @property {RemoteFortressReader.IBuildingType|null} [buildingType] BuildingInstance buildingType
         * @property {RemoteFortressReader.IMatPair|null} [material] BuildingInstance material
         * @property {number|null} [buildingFlags] BuildingInstance buildingFlags
         * @property {boolean|null} [isRoom] BuildingInstance isRoom
         * @property {RemoteFortressReader.IBuildingExtents|null} [room] BuildingInstance room
         * @property {RemoteFortressReader.BuildingDirection|null} [direction] BuildingInstance direction
         * @property {Array.<RemoteFortressReader.IBuildingItem>|null} [items] BuildingInstance items
         * @property {number|null} [active] BuildingInstance active
         */

        /**
         * Constructs a new BuildingInstance.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingInstance.
         * @implements IBuildingInstance
         * @constructor
         * @param {RemoteFortressReader.IBuildingInstance=} [properties] Properties to set
         */
        function BuildingInstance(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingInstance index.
         * @member {number} index
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.index = 0;

        /**
         * BuildingInstance posXMin.
         * @member {number} posXMin
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posXMin = 0;

        /**
         * BuildingInstance posYMin.
         * @member {number} posYMin
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posYMin = 0;

        /**
         * BuildingInstance posZMin.
         * @member {number} posZMin
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posZMin = 0;

        /**
         * BuildingInstance posXMax.
         * @member {number} posXMax
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posXMax = 0;

        /**
         * BuildingInstance posYMax.
         * @member {number} posYMax
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posYMax = 0;

        /**
         * BuildingInstance posZMax.
         * @member {number} posZMax
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posZMax = 0;

        /**
         * BuildingInstance buildingType.
         * @member {RemoteFortressReader.IBuildingType|null|undefined} buildingType
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.buildingType = null;

        /**
         * BuildingInstance material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.material = null;

        /**
         * BuildingInstance buildingFlags.
         * @member {number} buildingFlags
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.buildingFlags = 0;

        /**
         * BuildingInstance isRoom.
         * @member {boolean} isRoom
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.isRoom = false;

        /**
         * BuildingInstance room.
         * @member {RemoteFortressReader.IBuildingExtents|null|undefined} room
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.room = null;

        /**
         * BuildingInstance direction.
         * @member {RemoteFortressReader.BuildingDirection} direction
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.direction = 0;

        /**
         * BuildingInstance items.
         * @member {Array.<RemoteFortressReader.IBuildingItem>} items
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.items = $util.emptyArray;

        /**
         * BuildingInstance active.
         * @member {number} active
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.active = 0;

        /**
         * Creates a new BuildingInstance instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.IBuildingInstance=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance instance
         */
        BuildingInstance.create = function create(properties) {
            return new BuildingInstance(properties);
        };

        /**
         * Encodes the specified BuildingInstance message. Does not implicitly {@link RemoteFortressReader.BuildingInstance.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.IBuildingInstance} message BuildingInstance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingInstance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.posXMin != null && message.hasOwnProperty("posXMin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posXMin);
            if (message.posYMin != null && message.hasOwnProperty("posYMin"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posYMin);
            if (message.posZMin != null && message.hasOwnProperty("posZMin"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.posZMin);
            if (message.posXMax != null && message.hasOwnProperty("posXMax"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.posXMax);
            if (message.posYMax != null && message.hasOwnProperty("posYMax"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.posYMax);
            if (message.posZMax != null && message.hasOwnProperty("posZMax"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.posZMax);
            if (message.buildingType != null && message.hasOwnProperty("buildingType"))
                $root.RemoteFortressReader.BuildingType.encode(message.buildingType, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.buildingFlags != null && message.hasOwnProperty("buildingFlags"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.buildingFlags);
            if (message.isRoom != null && message.hasOwnProperty("isRoom"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isRoom);
            if (message.room != null && message.hasOwnProperty("room"))
                $root.RemoteFortressReader.BuildingExtents.encode(message.room, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.direction != null && message.hasOwnProperty("direction"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.direction);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.RemoteFortressReader.BuildingItem.encode(message.items[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.active);
            return writer;
        };

        /**
         * Encodes the specified BuildingInstance message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingInstance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.IBuildingInstance} message BuildingInstance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingInstance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingInstance message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingInstance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingInstance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.posXMin = reader.int32();
                    break;
                case 3:
                    message.posYMin = reader.int32();
                    break;
                case 4:
                    message.posZMin = reader.int32();
                    break;
                case 5:
                    message.posXMax = reader.int32();
                    break;
                case 6:
                    message.posYMax = reader.int32();
                    break;
                case 7:
                    message.posZMax = reader.int32();
                    break;
                case 8:
                    message.buildingType = $root.RemoteFortressReader.BuildingType.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.buildingFlags = reader.uint32();
                    break;
                case 11:
                    message.isRoom = reader.bool();
                    break;
                case 12:
                    message.room = $root.RemoteFortressReader.BuildingExtents.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.direction = reader.int32();
                    break;
                case 14:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.RemoteFortressReader.BuildingItem.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.active = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingInstance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingInstance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingInstance message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingInstance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            if (message.posXMin != null && message.hasOwnProperty("posXMin"))
                if (!$util.isInteger(message.posXMin))
                    return "posXMin: integer expected";
            if (message.posYMin != null && message.hasOwnProperty("posYMin"))
                if (!$util.isInteger(message.posYMin))
                    return "posYMin: integer expected";
            if (message.posZMin != null && message.hasOwnProperty("posZMin"))
                if (!$util.isInteger(message.posZMin))
                    return "posZMin: integer expected";
            if (message.posXMax != null && message.hasOwnProperty("posXMax"))
                if (!$util.isInteger(message.posXMax))
                    return "posXMax: integer expected";
            if (message.posYMax != null && message.hasOwnProperty("posYMax"))
                if (!$util.isInteger(message.posYMax))
                    return "posYMax: integer expected";
            if (message.posZMax != null && message.hasOwnProperty("posZMax"))
                if (!$util.isInteger(message.posZMax))
                    return "posZMax: integer expected";
            if (message.buildingType != null && message.hasOwnProperty("buildingType")) {
                var error = $root.RemoteFortressReader.BuildingType.verify(message.buildingType);
                if (error)
                    return "buildingType." + error;
            }
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.buildingFlags != null && message.hasOwnProperty("buildingFlags"))
                if (!$util.isInteger(message.buildingFlags))
                    return "buildingFlags: integer expected";
            if (message.isRoom != null && message.hasOwnProperty("isRoom"))
                if (typeof message.isRoom !== "boolean")
                    return "isRoom: boolean expected";
            if (message.room != null && message.hasOwnProperty("room")) {
                var error = $root.RemoteFortressReader.BuildingExtents.verify(message.room);
                if (error)
                    return "room." + error;
            }
            if (message.direction != null && message.hasOwnProperty("direction"))
                switch (message.direction) {
                default:
                    return "direction: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.RemoteFortressReader.BuildingItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.active != null && message.hasOwnProperty("active"))
                if (!$util.isInteger(message.active))
                    return "active: integer expected";
            return null;
        };

        /**
         * Creates a BuildingInstance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance
         */
        BuildingInstance.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingInstance)
                return object;
            var message = new $root.RemoteFortressReader.BuildingInstance();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.posXMin != null)
                message.posXMin = object.posXMin | 0;
            if (object.posYMin != null)
                message.posYMin = object.posYMin | 0;
            if (object.posZMin != null)
                message.posZMin = object.posZMin | 0;
            if (object.posXMax != null)
                message.posXMax = object.posXMax | 0;
            if (object.posYMax != null)
                message.posYMax = object.posYMax | 0;
            if (object.posZMax != null)
                message.posZMax = object.posZMax | 0;
            if (object.buildingType != null) {
                if (typeof object.buildingType !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingInstance.buildingType: object expected");
                message.buildingType = $root.RemoteFortressReader.BuildingType.fromObject(object.buildingType);
            }
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingInstance.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.buildingFlags != null)
                message.buildingFlags = object.buildingFlags >>> 0;
            if (object.isRoom != null)
                message.isRoom = Boolean(object.isRoom);
            if (object.room != null) {
                if (typeof object.room !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingInstance.room: object expected");
                message.room = $root.RemoteFortressReader.BuildingExtents.fromObject(object.room);
            }
            switch (object.direction) {
            case "NORTH":
            case 0:
                message.direction = 0;
                break;
            case "EAST":
            case 1:
                message.direction = 1;
                break;
            case "SOUTH":
            case 2:
                message.direction = 2;
                break;
            case "WEST":
            case 3:
                message.direction = 3;
                break;
            case "NONE":
            case 4:
                message.direction = 4;
                break;
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".RemoteFortressReader.BuildingInstance.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BuildingInstance.items: object expected");
                    message.items[i] = $root.RemoteFortressReader.BuildingItem.fromObject(object.items[i]);
                }
            }
            if (object.active != null)
                message.active = object.active | 0;
            return message;
        };

        /**
         * Creates a plain object from a BuildingInstance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.BuildingInstance} message BuildingInstance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingInstance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.index = 0;
                object.posXMin = 0;
                object.posYMin = 0;
                object.posZMin = 0;
                object.posXMax = 0;
                object.posYMax = 0;
                object.posZMax = 0;
                object.buildingType = null;
                object.material = null;
                object.buildingFlags = 0;
                object.isRoom = false;
                object.room = null;
                object.direction = options.enums === String ? "NORTH" : 0;
                object.active = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.posXMin != null && message.hasOwnProperty("posXMin"))
                object.posXMin = message.posXMin;
            if (message.posYMin != null && message.hasOwnProperty("posYMin"))
                object.posYMin = message.posYMin;
            if (message.posZMin != null && message.hasOwnProperty("posZMin"))
                object.posZMin = message.posZMin;
            if (message.posXMax != null && message.hasOwnProperty("posXMax"))
                object.posXMax = message.posXMax;
            if (message.posYMax != null && message.hasOwnProperty("posYMax"))
                object.posYMax = message.posYMax;
            if (message.posZMax != null && message.hasOwnProperty("posZMax"))
                object.posZMax = message.posZMax;
            if (message.buildingType != null && message.hasOwnProperty("buildingType"))
                object.buildingType = $root.RemoteFortressReader.BuildingType.toObject(message.buildingType, options);
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.buildingFlags != null && message.hasOwnProperty("buildingFlags"))
                object.buildingFlags = message.buildingFlags;
            if (message.isRoom != null && message.hasOwnProperty("isRoom"))
                object.isRoom = message.isRoom;
            if (message.room != null && message.hasOwnProperty("room"))
                object.room = $root.RemoteFortressReader.BuildingExtents.toObject(message.room, options);
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = options.enums === String ? $root.RemoteFortressReader.BuildingDirection[message.direction] : message.direction;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.RemoteFortressReader.BuildingItem.toObject(message.items[j], options);
            }
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            return object;
        };

        /**
         * Converts this BuildingInstance to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingInstance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingInstance;
    })();

    RemoteFortressReader.RiverEdge = (function() {

        /**
         * Properties of a RiverEdge.
         * @memberof RemoteFortressReader
         * @interface IRiverEdge
         * @property {number|null} [minPos] RiverEdge minPos
         * @property {number|null} [maxPos] RiverEdge maxPos
         * @property {number|null} [active] RiverEdge active
         * @property {number|null} [elevation] RiverEdge elevation
         */

        /**
         * Constructs a new RiverEdge.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RiverEdge.
         * @implements IRiverEdge
         * @constructor
         * @param {RemoteFortressReader.IRiverEdge=} [properties] Properties to set
         */
        function RiverEdge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RiverEdge minPos.
         * @member {number} minPos
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.minPos = 0;

        /**
         * RiverEdge maxPos.
         * @member {number} maxPos
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.maxPos = 0;

        /**
         * RiverEdge active.
         * @member {number} active
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.active = 0;

        /**
         * RiverEdge elevation.
         * @member {number} elevation
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.elevation = 0;

        /**
         * Creates a new RiverEdge instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.IRiverEdge=} [properties] Properties to set
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge instance
         */
        RiverEdge.create = function create(properties) {
            return new RiverEdge(properties);
        };

        /**
         * Encodes the specified RiverEdge message. Does not implicitly {@link RemoteFortressReader.RiverEdge.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.IRiverEdge} message RiverEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverEdge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minPos != null && message.hasOwnProperty("minPos"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minPos);
            if (message.maxPos != null && message.hasOwnProperty("maxPos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxPos);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.active);
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.elevation);
            return writer;
        };

        /**
         * Encodes the specified RiverEdge message, length delimited. Does not implicitly {@link RemoteFortressReader.RiverEdge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.IRiverEdge} message RiverEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverEdge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RiverEdge message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverEdge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RiverEdge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.minPos = reader.int32();
                    break;
                case 2:
                    message.maxPos = reader.int32();
                    break;
                case 3:
                    message.active = reader.int32();
                    break;
                case 4:
                    message.elevation = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RiverEdge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverEdge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RiverEdge message.
         * @function verify
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RiverEdge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minPos != null && message.hasOwnProperty("minPos"))
                if (!$util.isInteger(message.minPos))
                    return "minPos: integer expected";
            if (message.maxPos != null && message.hasOwnProperty("maxPos"))
                if (!$util.isInteger(message.maxPos))
                    return "maxPos: integer expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (!$util.isInteger(message.active))
                    return "active: integer expected";
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                if (!$util.isInteger(message.elevation))
                    return "elevation: integer expected";
            return null;
        };

        /**
         * Creates a RiverEdge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge
         */
        RiverEdge.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RiverEdge)
                return object;
            var message = new $root.RemoteFortressReader.RiverEdge();
            if (object.minPos != null)
                message.minPos = object.minPos | 0;
            if (object.maxPos != null)
                message.maxPos = object.maxPos | 0;
            if (object.active != null)
                message.active = object.active | 0;
            if (object.elevation != null)
                message.elevation = object.elevation | 0;
            return message;
        };

        /**
         * Creates a plain object from a RiverEdge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.RiverEdge} message RiverEdge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RiverEdge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.minPos = 0;
                object.maxPos = 0;
                object.active = 0;
                object.elevation = 0;
            }
            if (message.minPos != null && message.hasOwnProperty("minPos"))
                object.minPos = message.minPos;
            if (message.maxPos != null && message.hasOwnProperty("maxPos"))
                object.maxPos = message.maxPos;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                object.elevation = message.elevation;
            return object;
        };

        /**
         * Converts this RiverEdge to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RiverEdge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RiverEdge;
    })();

    RemoteFortressReader.RiverTile = (function() {

        /**
         * Properties of a RiverTile.
         * @memberof RemoteFortressReader
         * @interface IRiverTile
         * @property {RemoteFortressReader.IRiverEdge|null} [north] RiverTile north
         * @property {RemoteFortressReader.IRiverEdge|null} [south] RiverTile south
         * @property {RemoteFortressReader.IRiverEdge|null} [east] RiverTile east
         * @property {RemoteFortressReader.IRiverEdge|null} [west] RiverTile west
         */

        /**
         * Constructs a new RiverTile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RiverTile.
         * @implements IRiverTile
         * @constructor
         * @param {RemoteFortressReader.IRiverTile=} [properties] Properties to set
         */
        function RiverTile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RiverTile north.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} north
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.north = null;

        /**
         * RiverTile south.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} south
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.south = null;

        /**
         * RiverTile east.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} east
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.east = null;

        /**
         * RiverTile west.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} west
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.west = null;

        /**
         * Creates a new RiverTile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.IRiverTile=} [properties] Properties to set
         * @returns {RemoteFortressReader.RiverTile} RiverTile instance
         */
        RiverTile.create = function create(properties) {
            return new RiverTile(properties);
        };

        /**
         * Encodes the specified RiverTile message. Does not implicitly {@link RemoteFortressReader.RiverTile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.IRiverTile} message RiverTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.north != null && message.hasOwnProperty("north"))
                $root.RemoteFortressReader.RiverEdge.encode(message.north, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.south != null && message.hasOwnProperty("south"))
                $root.RemoteFortressReader.RiverEdge.encode(message.south, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.east != null && message.hasOwnProperty("east"))
                $root.RemoteFortressReader.RiverEdge.encode(message.east, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.west != null && message.hasOwnProperty("west"))
                $root.RemoteFortressReader.RiverEdge.encode(message.west, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RiverTile message, length delimited. Does not implicitly {@link RemoteFortressReader.RiverTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.IRiverTile} message RiverTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RiverTile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RiverTile} RiverTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RiverTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.north = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.south = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.east = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.west = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RiverTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RiverTile} RiverTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RiverTile message.
         * @function verify
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RiverTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.north != null && message.hasOwnProperty("north")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.north);
                if (error)
                    return "north." + error;
            }
            if (message.south != null && message.hasOwnProperty("south")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.south);
                if (error)
                    return "south." + error;
            }
            if (message.east != null && message.hasOwnProperty("east")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.east);
                if (error)
                    return "east." + error;
            }
            if (message.west != null && message.hasOwnProperty("west")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.west);
                if (error)
                    return "west." + error;
            }
            return null;
        };

        /**
         * Creates a RiverTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RiverTile} RiverTile
         */
        RiverTile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RiverTile)
                return object;
            var message = new $root.RemoteFortressReader.RiverTile();
            if (object.north != null) {
                if (typeof object.north !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.north: object expected");
                message.north = $root.RemoteFortressReader.RiverEdge.fromObject(object.north);
            }
            if (object.south != null) {
                if (typeof object.south !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.south: object expected");
                message.south = $root.RemoteFortressReader.RiverEdge.fromObject(object.south);
            }
            if (object.east != null) {
                if (typeof object.east !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.east: object expected");
                message.east = $root.RemoteFortressReader.RiverEdge.fromObject(object.east);
            }
            if (object.west != null) {
                if (typeof object.west !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.west: object expected");
                message.west = $root.RemoteFortressReader.RiverEdge.fromObject(object.west);
            }
            return message;
        };

        /**
         * Creates a plain object from a RiverTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.RiverTile} message RiverTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RiverTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.north = null;
                object.south = null;
                object.east = null;
                object.west = null;
            }
            if (message.north != null && message.hasOwnProperty("north"))
                object.north = $root.RemoteFortressReader.RiverEdge.toObject(message.north, options);
            if (message.south != null && message.hasOwnProperty("south"))
                object.south = $root.RemoteFortressReader.RiverEdge.toObject(message.south, options);
            if (message.east != null && message.hasOwnProperty("east"))
                object.east = $root.RemoteFortressReader.RiverEdge.toObject(message.east, options);
            if (message.west != null && message.hasOwnProperty("west"))
                object.west = $root.RemoteFortressReader.RiverEdge.toObject(message.west, options);
            return object;
        };

        /**
         * Converts this RiverTile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RiverTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RiverTile;
    })();

    /**
     * MatterState enum.
     * @name RemoteFortressReader.MatterState
     * @enum {string}
     * @property {number} Solid=0 Solid value
     * @property {number} Liquid=1 Liquid value
     * @property {number} Gas=2 Gas value
     * @property {number} Powder=3 Powder value
     * @property {number} Paste=4 Paste value
     * @property {number} Pressed=5 Pressed value
     */
    RemoteFortressReader.MatterState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Solid"] = 0;
        values[valuesById[1] = "Liquid"] = 1;
        values[valuesById[2] = "Gas"] = 2;
        values[valuesById[3] = "Powder"] = 3;
        values[valuesById[4] = "Paste"] = 4;
        values[valuesById[5] = "Pressed"] = 5;
        return values;
    })();

    RemoteFortressReader.Spatter = (function() {

        /**
         * Properties of a Spatter.
         * @memberof RemoteFortressReader
         * @interface ISpatter
         * @property {RemoteFortressReader.IMatPair|null} [material] Spatter material
         * @property {number|null} [amount] Spatter amount
         * @property {RemoteFortressReader.MatterState|null} [state] Spatter state
         * @property {RemoteFortressReader.IMatPair|null} [item] Spatter item
         */

        /**
         * Constructs a new Spatter.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Spatter.
         * @implements ISpatter
         * @constructor
         * @param {RemoteFortressReader.ISpatter=} [properties] Properties to set
         */
        function Spatter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Spatter material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.material = null;

        /**
         * Spatter amount.
         * @member {number} amount
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.amount = 0;

        /**
         * Spatter state.
         * @member {RemoteFortressReader.MatterState} state
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.state = 0;

        /**
         * Spatter item.
         * @member {RemoteFortressReader.IMatPair|null|undefined} item
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.item = null;

        /**
         * Creates a new Spatter instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.ISpatter=} [properties] Properties to set
         * @returns {RemoteFortressReader.Spatter} Spatter instance
         */
        Spatter.create = function create(properties) {
            return new Spatter(properties);
        };

        /**
         * Encodes the specified Spatter message. Does not implicitly {@link RemoteFortressReader.Spatter.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.ISpatter} message Spatter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spatter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.amount);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
            if (message.item != null && message.hasOwnProperty("item"))
                $root.RemoteFortressReader.MatPair.encode(message.item, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Spatter message, length delimited. Does not implicitly {@link RemoteFortressReader.Spatter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.ISpatter} message Spatter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spatter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Spatter message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Spatter} Spatter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spatter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Spatter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.amount = reader.int32();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.item = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Spatter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Spatter} Spatter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spatter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Spatter message.
         * @function verify
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Spatter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a Spatter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Spatter} Spatter
         */
        Spatter.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Spatter)
                return object;
            var message = new $root.RemoteFortressReader.Spatter();
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.Spatter.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.amount != null)
                message.amount = object.amount | 0;
            switch (object.state) {
            case "Solid":
            case 0:
                message.state = 0;
                break;
            case "Liquid":
            case 1:
                message.state = 1;
                break;
            case "Gas":
            case 2:
                message.state = 2;
                break;
            case "Powder":
            case 3:
                message.state = 3;
                break;
            case "Paste":
            case 4:
                message.state = 4;
                break;
            case "Pressed":
            case 5:
                message.state = 5;
                break;
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.Spatter.item: object expected");
                message.item = $root.RemoteFortressReader.MatPair.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a Spatter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.Spatter} message Spatter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Spatter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.material = null;
                object.amount = 0;
                object.state = options.enums === String ? "Solid" : 0;
                object.item = null;
            }
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.RemoteFortressReader.MatterState[message.state] : message.state;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.MatPair.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this Spatter to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Spatter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Spatter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Spatter;
    })();

    RemoteFortressReader.SpatterPile = (function() {

        /**
         * Properties of a SpatterPile.
         * @memberof RemoteFortressReader
         * @interface ISpatterPile
         * @property {Array.<RemoteFortressReader.ISpatter>|null} [spatters] SpatterPile spatters
         */

        /**
         * Constructs a new SpatterPile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SpatterPile.
         * @implements ISpatterPile
         * @constructor
         * @param {RemoteFortressReader.ISpatterPile=} [properties] Properties to set
         */
        function SpatterPile(properties) {
            this.spatters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpatterPile spatters.
         * @member {Array.<RemoteFortressReader.ISpatter>} spatters
         * @memberof RemoteFortressReader.SpatterPile
         * @instance
         */
        SpatterPile.prototype.spatters = $util.emptyArray;

        /**
         * Creates a new SpatterPile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.ISpatterPile=} [properties] Properties to set
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile instance
         */
        SpatterPile.create = function create(properties) {
            return new SpatterPile(properties);
        };

        /**
         * Encodes the specified SpatterPile message. Does not implicitly {@link RemoteFortressReader.SpatterPile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.ISpatterPile} message SpatterPile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatterPile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spatters != null && message.spatters.length)
                for (var i = 0; i < message.spatters.length; ++i)
                    $root.RemoteFortressReader.Spatter.encode(message.spatters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SpatterPile message, length delimited. Does not implicitly {@link RemoteFortressReader.SpatterPile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.ISpatterPile} message SpatterPile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatterPile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpatterPile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatterPile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SpatterPile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.spatters && message.spatters.length))
                        message.spatters = [];
                    message.spatters.push($root.RemoteFortressReader.Spatter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpatterPile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatterPile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpatterPile message.
         * @function verify
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpatterPile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spatters != null && message.hasOwnProperty("spatters")) {
                if (!Array.isArray(message.spatters))
                    return "spatters: array expected";
                for (var i = 0; i < message.spatters.length; ++i) {
                    var error = $root.RemoteFortressReader.Spatter.verify(message.spatters[i]);
                    if (error)
                        return "spatters." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SpatterPile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile
         */
        SpatterPile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SpatterPile)
                return object;
            var message = new $root.RemoteFortressReader.SpatterPile();
            if (object.spatters) {
                if (!Array.isArray(object.spatters))
                    throw TypeError(".RemoteFortressReader.SpatterPile.spatters: array expected");
                message.spatters = [];
                for (var i = 0; i < object.spatters.length; ++i) {
                    if (typeof object.spatters[i] !== "object")
                        throw TypeError(".RemoteFortressReader.SpatterPile.spatters: object expected");
                    message.spatters[i] = $root.RemoteFortressReader.Spatter.fromObject(object.spatters[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SpatterPile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.SpatterPile} message SpatterPile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpatterPile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.spatters = [];
            if (message.spatters && message.spatters.length) {
                object.spatters = [];
                for (var j = 0; j < message.spatters.length; ++j)
                    object.spatters[j] = $root.RemoteFortressReader.Spatter.toObject(message.spatters[j], options);
            }
            return object;
        };

        /**
         * Converts this SpatterPile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SpatterPile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpatterPile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SpatterPile;
    })();

    RemoteFortressReader.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof RemoteFortressReader
         * @interface IItem
         * @property {number|null} [id] Item id
         * @property {RemoteFortressReader.ICoord|null} [pos] Item pos
         * @property {number|null} [flags1] Item flags1
         * @property {number|null} [flags2] Item flags2
         * @property {RemoteFortressReader.IMatPair|null} [type] Item type
         * @property {RemoteFortressReader.IMatPair|null} [material] Item material
         * @property {RemoteFortressReader.IColorDefinition|null} [dye] Item dye
         * @property {number|null} [stackSize] Item stackSize
         * @property {number|null} [subposX] Item subposX
         * @property {number|null} [subposY] Item subposY
         * @property {number|null} [subposZ] Item subposZ
         * @property {boolean|null} [projectile] Item projectile
         * @property {number|null} [velocityX] Item velocityX
         * @property {number|null} [velocityY] Item velocityY
         * @property {number|null} [velocityZ] Item velocityZ
         * @property {number|null} [volume] Item volume
         * @property {Array.<RemoteFortressReader.IItemImprovement>|null} [improvements] Item improvements
         * @property {RemoteFortressReader.IArtImage|null} [image] Item image
         */

        /**
         * Constructs a new Item.
         * @memberof RemoteFortressReader
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {RemoteFortressReader.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            this.improvements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item id.
         * @member {number} id
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.id = 0;

        /**
         * Item pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.pos = null;

        /**
         * Item flags1.
         * @member {number} flags1
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.flags1 = 0;

        /**
         * Item flags2.
         * @member {number} flags2
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.flags2 = 0;

        /**
         * Item type.
         * @member {RemoteFortressReader.IMatPair|null|undefined} type
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.type = null;

        /**
         * Item material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.material = null;

        /**
         * Item dye.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} dye
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.dye = null;

        /**
         * Item stackSize.
         * @member {number} stackSize
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.stackSize = 0;

        /**
         * Item subposX.
         * @member {number} subposX
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.subposX = 0;

        /**
         * Item subposY.
         * @member {number} subposY
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.subposY = 0;

        /**
         * Item subposZ.
         * @member {number} subposZ
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.subposZ = 0;

        /**
         * Item projectile.
         * @member {boolean} projectile
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.projectile = false;

        /**
         * Item velocityX.
         * @member {number} velocityX
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.velocityX = 0;

        /**
         * Item velocityY.
         * @member {number} velocityY
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.velocityY = 0;

        /**
         * Item velocityZ.
         * @member {number} velocityZ
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.velocityZ = 0;

        /**
         * Item volume.
         * @member {number} volume
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.volume = 0;

        /**
         * Item improvements.
         * @member {Array.<RemoteFortressReader.IItemImprovement>} improvements
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.improvements = $util.emptyArray;

        /**
         * Item image.
         * @member {RemoteFortressReader.IArtImage|null|undefined} image
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.image = null;

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.IItem=} [properties] Properties to set
         * @returns {RemoteFortressReader.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link RemoteFortressReader.Item.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags1);
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.flags2);
            if (message.type != null && message.hasOwnProperty("type"))
                $root.RemoteFortressReader.MatPair.encode(message.type, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.dye != null && message.hasOwnProperty("dye"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.dye, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.stackSize != null && message.hasOwnProperty("stackSize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.stackSize);
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.subposX);
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.subposY);
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                writer.uint32(/* id 11, wireType 5 =*/93).float(message.subposZ);
            if (message.projectile != null && message.hasOwnProperty("projectile"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.projectile);
            if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.velocityX);
            if (message.velocityY != null && message.hasOwnProperty("velocityY"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.velocityY);
            if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.velocityZ);
            if (message.volume != null && message.hasOwnProperty("volume"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.volume);
            if (message.improvements != null && message.improvements.length)
                for (var i = 0; i < message.improvements.length; ++i)
                    $root.RemoteFortressReader.ItemImprovement.encode(message.improvements[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.image != null && message.hasOwnProperty("image"))
                $root.RemoteFortressReader.ArtImage.encode(message.image, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link RemoteFortressReader.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.flags1 = reader.uint32();
                    break;
                case 4:
                    message.flags2 = reader.uint32();
                    break;
                case 5:
                    message.type = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.dye = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.stackSize = reader.int32();
                    break;
                case 9:
                    message.subposX = reader.float();
                    break;
                case 10:
                    message.subposY = reader.float();
                    break;
                case 11:
                    message.subposZ = reader.float();
                    break;
                case 12:
                    message.projectile = reader.bool();
                    break;
                case 13:
                    message.velocityX = reader.float();
                    break;
                case 14:
                    message.velocityY = reader.float();
                    break;
                case 15:
                    message.velocityZ = reader.float();
                    break;
                case 16:
                    message.volume = reader.int32();
                    break;
                case 17:
                    if (!(message.improvements && message.improvements.length))
                        message.improvements = [];
                    message.improvements.push($root.RemoteFortressReader.ItemImprovement.decode(reader, reader.uint32()));
                    break;
                case 18:
                    message.image = $root.RemoteFortressReader.ArtImage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                if (!$util.isInteger(message.flags1))
                    return "flags1: integer expected";
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                if (!$util.isInteger(message.flags2))
                    return "flags2: integer expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.type);
                if (error)
                    return "type." + error;
            }
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.dye != null && message.hasOwnProperty("dye")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.dye);
                if (error)
                    return "dye." + error;
            }
            if (message.stackSize != null && message.hasOwnProperty("stackSize"))
                if (!$util.isInteger(message.stackSize))
                    return "stackSize: integer expected";
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                if (typeof message.subposX !== "number")
                    return "subposX: number expected";
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                if (typeof message.subposY !== "number")
                    return "subposY: number expected";
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                if (typeof message.subposZ !== "number")
                    return "subposZ: number expected";
            if (message.projectile != null && message.hasOwnProperty("projectile"))
                if (typeof message.projectile !== "boolean")
                    return "projectile: boolean expected";
            if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                if (typeof message.velocityX !== "number")
                    return "velocityX: number expected";
            if (message.velocityY != null && message.hasOwnProperty("velocityY"))
                if (typeof message.velocityY !== "number")
                    return "velocityY: number expected";
            if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                if (typeof message.velocityZ !== "number")
                    return "velocityZ: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume))
                    return "volume: integer expected";
            if (message.improvements != null && message.hasOwnProperty("improvements")) {
                if (!Array.isArray(message.improvements))
                    return "improvements: array expected";
                for (var i = 0; i < message.improvements.length; ++i) {
                    var error = $root.RemoteFortressReader.ItemImprovement.verify(message.improvements[i]);
                    if (error)
                        return "improvements." + error;
                }
            }
            if (message.image != null && message.hasOwnProperty("image")) {
                var error = $root.RemoteFortressReader.ArtImage.verify(message.image);
                if (error)
                    return "image." + error;
            }
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Item)
                return object;
            var message = new $root.RemoteFortressReader.Item();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Item.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.flags1 != null)
                message.flags1 = object.flags1 >>> 0;
            if (object.flags2 != null)
                message.flags2 = object.flags2 >>> 0;
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".RemoteFortressReader.Item.type: object expected");
                message.type = $root.RemoteFortressReader.MatPair.fromObject(object.type);
            }
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.Item.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.dye != null) {
                if (typeof object.dye !== "object")
                    throw TypeError(".RemoteFortressReader.Item.dye: object expected");
                message.dye = $root.RemoteFortressReader.ColorDefinition.fromObject(object.dye);
            }
            if (object.stackSize != null)
                message.stackSize = object.stackSize | 0;
            if (object.subposX != null)
                message.subposX = Number(object.subposX);
            if (object.subposY != null)
                message.subposY = Number(object.subposY);
            if (object.subposZ != null)
                message.subposZ = Number(object.subposZ);
            if (object.projectile != null)
                message.projectile = Boolean(object.projectile);
            if (object.velocityX != null)
                message.velocityX = Number(object.velocityX);
            if (object.velocityY != null)
                message.velocityY = Number(object.velocityY);
            if (object.velocityZ != null)
                message.velocityZ = Number(object.velocityZ);
            if (object.volume != null)
                message.volume = object.volume | 0;
            if (object.improvements) {
                if (!Array.isArray(object.improvements))
                    throw TypeError(".RemoteFortressReader.Item.improvements: array expected");
                message.improvements = [];
                for (var i = 0; i < object.improvements.length; ++i) {
                    if (typeof object.improvements[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Item.improvements: object expected");
                    message.improvements[i] = $root.RemoteFortressReader.ItemImprovement.fromObject(object.improvements[i]);
                }
            }
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".RemoteFortressReader.Item.image: object expected");
                message.image = $root.RemoteFortressReader.ArtImage.fromObject(object.image);
            }
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.improvements = [];
            if (options.defaults) {
                object.id = 0;
                object.pos = null;
                object.flags1 = 0;
                object.flags2 = 0;
                object.type = null;
                object.material = null;
                object.dye = null;
                object.stackSize = 0;
                object.subposX = 0;
                object.subposY = 0;
                object.subposZ = 0;
                object.projectile = false;
                object.velocityX = 0;
                object.velocityY = 0;
                object.velocityZ = 0;
                object.volume = 0;
                object.image = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                object.flags1 = message.flags1;
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                object.flags2 = message.flags2;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.RemoteFortressReader.MatPair.toObject(message.type, options);
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.dye != null && message.hasOwnProperty("dye"))
                object.dye = $root.RemoteFortressReader.ColorDefinition.toObject(message.dye, options);
            if (message.stackSize != null && message.hasOwnProperty("stackSize"))
                object.stackSize = message.stackSize;
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                object.subposX = options.json && !isFinite(message.subposX) ? String(message.subposX) : message.subposX;
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                object.subposY = options.json && !isFinite(message.subposY) ? String(message.subposY) : message.subposY;
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                object.subposZ = options.json && !isFinite(message.subposZ) ? String(message.subposZ) : message.subposZ;
            if (message.projectile != null && message.hasOwnProperty("projectile"))
                object.projectile = message.projectile;
            if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                object.velocityX = options.json && !isFinite(message.velocityX) ? String(message.velocityX) : message.velocityX;
            if (message.velocityY != null && message.hasOwnProperty("velocityY"))
                object.velocityY = options.json && !isFinite(message.velocityY) ? String(message.velocityY) : message.velocityY;
            if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                object.velocityZ = options.json && !isFinite(message.velocityZ) ? String(message.velocityZ) : message.velocityZ;
            if (message.volume != null && message.hasOwnProperty("volume"))
                object.volume = message.volume;
            if (message.improvements && message.improvements.length) {
                object.improvements = [];
                for (var j = 0; j < message.improvements.length; ++j)
                    object.improvements[j] = $root.RemoteFortressReader.ItemImprovement.toObject(message.improvements[j], options);
            }
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.RemoteFortressReader.ArtImage.toObject(message.image, options);
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Item;
    })();

    RemoteFortressReader.MapBlock = (function() {

        /**
         * Properties of a MapBlock.
         * @memberof RemoteFortressReader
         * @interface IMapBlock
         * @property {number} mapX MapBlock mapX
         * @property {number} mapY MapBlock mapY
         * @property {number} mapZ MapBlock mapZ
         * @property {Array.<number>|null} [tiles] MapBlock tiles
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [materials] MapBlock materials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [layerMaterials] MapBlock layerMaterials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [veinMaterials] MapBlock veinMaterials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [baseMaterials] MapBlock baseMaterials
         * @property {Array.<number>|null} [magma] MapBlock magma
         * @property {Array.<number>|null} [water] MapBlock water
         * @property {Array.<boolean>|null} [hidden] MapBlock hidden
         * @property {Array.<boolean>|null} [light] MapBlock light
         * @property {Array.<boolean>|null} [subterranean] MapBlock subterranean
         * @property {Array.<boolean>|null} [outside] MapBlock outside
         * @property {Array.<boolean>|null} [aquifer] MapBlock aquifer
         * @property {Array.<boolean>|null} [waterStagnant] MapBlock waterStagnant
         * @property {Array.<boolean>|null} [waterSalt] MapBlock waterSalt
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [constructionItems] MapBlock constructionItems
         * @property {Array.<RemoteFortressReader.IBuildingInstance>|null} [buildings] MapBlock buildings
         * @property {Array.<number>|null} [treePercent] MapBlock treePercent
         * @property {Array.<number>|null} [treeX] MapBlock treeX
         * @property {Array.<number>|null} [treeY] MapBlock treeY
         * @property {Array.<number>|null} [treeZ] MapBlock treeZ
         * @property {Array.<RemoteFortressReader.TileDigDesignation>|null} [tileDigDesignation] MapBlock tileDigDesignation
         * @property {Array.<RemoteFortressReader.ISpatterPile>|null} [spatterPile] MapBlock spatterPile
         * @property {Array.<RemoteFortressReader.IItem>|null} [items] MapBlock items
         * @property {Array.<boolean>|null} [tileDigDesignationMarker] MapBlock tileDigDesignationMarker
         * @property {Array.<boolean>|null} [tileDigDesignationAuto] MapBlock tileDigDesignationAuto
         * @property {Array.<number>|null} [grassPercent] MapBlock grassPercent
         * @property {Array.<RemoteFortressReader.IFlowInfo>|null} [flows] MapBlock flows
         */

        /**
         * Constructs a new MapBlock.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MapBlock.
         * @implements IMapBlock
         * @constructor
         * @param {RemoteFortressReader.IMapBlock=} [properties] Properties to set
         */
        function MapBlock(properties) {
            this.tiles = [];
            this.materials = [];
            this.layerMaterials = [];
            this.veinMaterials = [];
            this.baseMaterials = [];
            this.magma = [];
            this.water = [];
            this.hidden = [];
            this.light = [];
            this.subterranean = [];
            this.outside = [];
            this.aquifer = [];
            this.waterStagnant = [];
            this.waterSalt = [];
            this.constructionItems = [];
            this.buildings = [];
            this.treePercent = [];
            this.treeX = [];
            this.treeY = [];
            this.treeZ = [];
            this.tileDigDesignation = [];
            this.spatterPile = [];
            this.items = [];
            this.tileDigDesignationMarker = [];
            this.tileDigDesignationAuto = [];
            this.grassPercent = [];
            this.flows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapBlock mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.mapX = 0;

        /**
         * MapBlock mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.mapY = 0;

        /**
         * MapBlock mapZ.
         * @member {number} mapZ
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.mapZ = 0;

        /**
         * MapBlock tiles.
         * @member {Array.<number>} tiles
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tiles = $util.emptyArray;

        /**
         * MapBlock materials.
         * @member {Array.<RemoteFortressReader.IMatPair>} materials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.materials = $util.emptyArray;

        /**
         * MapBlock layerMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} layerMaterials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.layerMaterials = $util.emptyArray;

        /**
         * MapBlock veinMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} veinMaterials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.veinMaterials = $util.emptyArray;

        /**
         * MapBlock baseMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} baseMaterials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.baseMaterials = $util.emptyArray;

        /**
         * MapBlock magma.
         * @member {Array.<number>} magma
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.magma = $util.emptyArray;

        /**
         * MapBlock water.
         * @member {Array.<number>} water
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.water = $util.emptyArray;

        /**
         * MapBlock hidden.
         * @member {Array.<boolean>} hidden
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.hidden = $util.emptyArray;

        /**
         * MapBlock light.
         * @member {Array.<boolean>} light
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.light = $util.emptyArray;

        /**
         * MapBlock subterranean.
         * @member {Array.<boolean>} subterranean
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.subterranean = $util.emptyArray;

        /**
         * MapBlock outside.
         * @member {Array.<boolean>} outside
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.outside = $util.emptyArray;

        /**
         * MapBlock aquifer.
         * @member {Array.<boolean>} aquifer
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.aquifer = $util.emptyArray;

        /**
         * MapBlock waterStagnant.
         * @member {Array.<boolean>} waterStagnant
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.waterStagnant = $util.emptyArray;

        /**
         * MapBlock waterSalt.
         * @member {Array.<boolean>} waterSalt
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.waterSalt = $util.emptyArray;

        /**
         * MapBlock constructionItems.
         * @member {Array.<RemoteFortressReader.IMatPair>} constructionItems
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.constructionItems = $util.emptyArray;

        /**
         * MapBlock buildings.
         * @member {Array.<RemoteFortressReader.IBuildingInstance>} buildings
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.buildings = $util.emptyArray;

        /**
         * MapBlock treePercent.
         * @member {Array.<number>} treePercent
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treePercent = $util.emptyArray;

        /**
         * MapBlock treeX.
         * @member {Array.<number>} treeX
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treeX = $util.emptyArray;

        /**
         * MapBlock treeY.
         * @member {Array.<number>} treeY
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treeY = $util.emptyArray;

        /**
         * MapBlock treeZ.
         * @member {Array.<number>} treeZ
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treeZ = $util.emptyArray;

        /**
         * MapBlock tileDigDesignation.
         * @member {Array.<RemoteFortressReader.TileDigDesignation>} tileDigDesignation
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tileDigDesignation = $util.emptyArray;

        /**
         * MapBlock spatterPile.
         * @member {Array.<RemoteFortressReader.ISpatterPile>} spatterPile
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.spatterPile = $util.emptyArray;

        /**
         * MapBlock items.
         * @member {Array.<RemoteFortressReader.IItem>} items
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.items = $util.emptyArray;

        /**
         * MapBlock tileDigDesignationMarker.
         * @member {Array.<boolean>} tileDigDesignationMarker
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tileDigDesignationMarker = $util.emptyArray;

        /**
         * MapBlock tileDigDesignationAuto.
         * @member {Array.<boolean>} tileDigDesignationAuto
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tileDigDesignationAuto = $util.emptyArray;

        /**
         * MapBlock grassPercent.
         * @member {Array.<number>} grassPercent
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.grassPercent = $util.emptyArray;

        /**
         * MapBlock flows.
         * @member {Array.<RemoteFortressReader.IFlowInfo>} flows
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.flows = $util.emptyArray;

        /**
         * Creates a new MapBlock instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.IMapBlock=} [properties] Properties to set
         * @returns {RemoteFortressReader.MapBlock} MapBlock instance
         */
        MapBlock.create = function create(properties) {
            return new MapBlock(properties);
        };

        /**
         * Encodes the specified MapBlock message. Does not implicitly {@link RemoteFortressReader.MapBlock.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.IMapBlock} message MapBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapBlock.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mapX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapY);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mapZ);
            if (message.tiles != null && message.tiles.length)
                for (var i = 0; i < message.tiles.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tiles[i]);
            if (message.materials != null && message.materials.length)
                for (var i = 0; i < message.materials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.materials[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.layerMaterials != null && message.layerMaterials.length)
                for (var i = 0; i < message.layerMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.layerMaterials[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.veinMaterials != null && message.veinMaterials.length)
                for (var i = 0; i < message.veinMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.veinMaterials[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.baseMaterials != null && message.baseMaterials.length)
                for (var i = 0; i < message.baseMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.baseMaterials[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.magma != null && message.magma.length)
                for (var i = 0; i < message.magma.length; ++i)
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.magma[i]);
            if (message.water != null && message.water.length)
                for (var i = 0; i < message.water.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.water[i]);
            if (message.hidden != null && message.hidden.length)
                for (var i = 0; i < message.hidden.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.hidden[i]);
            if (message.light != null && message.light.length)
                for (var i = 0; i < message.light.length; ++i)
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.light[i]);
            if (message.subterranean != null && message.subterranean.length)
                for (var i = 0; i < message.subterranean.length; ++i)
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.subterranean[i]);
            if (message.outside != null && message.outside.length)
                for (var i = 0; i < message.outside.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.outside[i]);
            if (message.aquifer != null && message.aquifer.length)
                for (var i = 0; i < message.aquifer.length; ++i)
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.aquifer[i]);
            if (message.waterStagnant != null && message.waterStagnant.length)
                for (var i = 0; i < message.waterStagnant.length; ++i)
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.waterStagnant[i]);
            if (message.waterSalt != null && message.waterSalt.length)
                for (var i = 0; i < message.waterSalt.length; ++i)
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.waterSalt[i]);
            if (message.constructionItems != null && message.constructionItems.length)
                for (var i = 0; i < message.constructionItems.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.constructionItems[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.buildings != null && message.buildings.length)
                for (var i = 0; i < message.buildings.length; ++i)
                    $root.RemoteFortressReader.BuildingInstance.encode(message.buildings[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.treePercent != null && message.treePercent.length)
                for (var i = 0; i < message.treePercent.length; ++i)
                    writer.uint32(/* id 20, wireType 0 =*/160).int32(message.treePercent[i]);
            if (message.treeX != null && message.treeX.length)
                for (var i = 0; i < message.treeX.length; ++i)
                    writer.uint32(/* id 21, wireType 0 =*/168).int32(message.treeX[i]);
            if (message.treeY != null && message.treeY.length)
                for (var i = 0; i < message.treeY.length; ++i)
                    writer.uint32(/* id 22, wireType 0 =*/176).int32(message.treeY[i]);
            if (message.treeZ != null && message.treeZ.length)
                for (var i = 0; i < message.treeZ.length; ++i)
                    writer.uint32(/* id 23, wireType 0 =*/184).int32(message.treeZ[i]);
            if (message.tileDigDesignation != null && message.tileDigDesignation.length)
                for (var i = 0; i < message.tileDigDesignation.length; ++i)
                    writer.uint32(/* id 24, wireType 0 =*/192).int32(message.tileDigDesignation[i]);
            if (message.spatterPile != null && message.spatterPile.length)
                for (var i = 0; i < message.spatterPile.length; ++i)
                    $root.RemoteFortressReader.SpatterPile.encode(message.spatterPile[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.RemoteFortressReader.Item.encode(message.items[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.tileDigDesignationMarker != null && message.tileDigDesignationMarker.length)
                for (var i = 0; i < message.tileDigDesignationMarker.length; ++i)
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.tileDigDesignationMarker[i]);
            if (message.tileDigDesignationAuto != null && message.tileDigDesignationAuto.length)
                for (var i = 0; i < message.tileDigDesignationAuto.length; ++i)
                    writer.uint32(/* id 28, wireType 0 =*/224).bool(message.tileDigDesignationAuto[i]);
            if (message.grassPercent != null && message.grassPercent.length)
                for (var i = 0; i < message.grassPercent.length; ++i)
                    writer.uint32(/* id 29, wireType 0 =*/232).int32(message.grassPercent[i]);
            if (message.flows != null && message.flows.length)
                for (var i = 0; i < message.flows.length; ++i)
                    $root.RemoteFortressReader.FlowInfo.encode(message.flows[i], writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MapBlock message, length delimited. Does not implicitly {@link RemoteFortressReader.MapBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.IMapBlock} message MapBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapBlock.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapBlock message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MapBlock} MapBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapBlock.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MapBlock();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mapX = reader.int32();
                    break;
                case 2:
                    message.mapY = reader.int32();
                    break;
                case 3:
                    message.mapZ = reader.int32();
                    break;
                case 4:
                    if (!(message.tiles && message.tiles.length))
                        message.tiles = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tiles.push(reader.int32());
                    } else
                        message.tiles.push(reader.int32());
                    break;
                case 5:
                    if (!(message.materials && message.materials.length))
                        message.materials = [];
                    message.materials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.layerMaterials && message.layerMaterials.length))
                        message.layerMaterials = [];
                    message.layerMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.veinMaterials && message.veinMaterials.length))
                        message.veinMaterials = [];
                    message.veinMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.baseMaterials && message.baseMaterials.length))
                        message.baseMaterials = [];
                    message.baseMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.magma && message.magma.length))
                        message.magma = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.magma.push(reader.int32());
                    } else
                        message.magma.push(reader.int32());
                    break;
                case 10:
                    if (!(message.water && message.water.length))
                        message.water = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.water.push(reader.int32());
                    } else
                        message.water.push(reader.int32());
                    break;
                case 11:
                    if (!(message.hidden && message.hidden.length))
                        message.hidden = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.hidden.push(reader.bool());
                    } else
                        message.hidden.push(reader.bool());
                    break;
                case 12:
                    if (!(message.light && message.light.length))
                        message.light = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.light.push(reader.bool());
                    } else
                        message.light.push(reader.bool());
                    break;
                case 13:
                    if (!(message.subterranean && message.subterranean.length))
                        message.subterranean = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.subterranean.push(reader.bool());
                    } else
                        message.subterranean.push(reader.bool());
                    break;
                case 14:
                    if (!(message.outside && message.outside.length))
                        message.outside = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.outside.push(reader.bool());
                    } else
                        message.outside.push(reader.bool());
                    break;
                case 15:
                    if (!(message.aquifer && message.aquifer.length))
                        message.aquifer = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.aquifer.push(reader.bool());
                    } else
                        message.aquifer.push(reader.bool());
                    break;
                case 16:
                    if (!(message.waterStagnant && message.waterStagnant.length))
                        message.waterStagnant = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waterStagnant.push(reader.bool());
                    } else
                        message.waterStagnant.push(reader.bool());
                    break;
                case 17:
                    if (!(message.waterSalt && message.waterSalt.length))
                        message.waterSalt = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waterSalt.push(reader.bool());
                    } else
                        message.waterSalt.push(reader.bool());
                    break;
                case 18:
                    if (!(message.constructionItems && message.constructionItems.length))
                        message.constructionItems = [];
                    message.constructionItems.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 19:
                    if (!(message.buildings && message.buildings.length))
                        message.buildings = [];
                    message.buildings.push($root.RemoteFortressReader.BuildingInstance.decode(reader, reader.uint32()));
                    break;
                case 20:
                    if (!(message.treePercent && message.treePercent.length))
                        message.treePercent = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treePercent.push(reader.int32());
                    } else
                        message.treePercent.push(reader.int32());
                    break;
                case 21:
                    if (!(message.treeX && message.treeX.length))
                        message.treeX = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treeX.push(reader.int32());
                    } else
                        message.treeX.push(reader.int32());
                    break;
                case 22:
                    if (!(message.treeY && message.treeY.length))
                        message.treeY = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treeY.push(reader.int32());
                    } else
                        message.treeY.push(reader.int32());
                    break;
                case 23:
                    if (!(message.treeZ && message.treeZ.length))
                        message.treeZ = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treeZ.push(reader.int32());
                    } else
                        message.treeZ.push(reader.int32());
                    break;
                case 24:
                    if (!(message.tileDigDesignation && message.tileDigDesignation.length))
                        message.tileDigDesignation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileDigDesignation.push(reader.int32());
                    } else
                        message.tileDigDesignation.push(reader.int32());
                    break;
                case 25:
                    if (!(message.spatterPile && message.spatterPile.length))
                        message.spatterPile = [];
                    message.spatterPile.push($root.RemoteFortressReader.SpatterPile.decode(reader, reader.uint32()));
                    break;
                case 26:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.RemoteFortressReader.Item.decode(reader, reader.uint32()));
                    break;
                case 27:
                    if (!(message.tileDigDesignationMarker && message.tileDigDesignationMarker.length))
                        message.tileDigDesignationMarker = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileDigDesignationMarker.push(reader.bool());
                    } else
                        message.tileDigDesignationMarker.push(reader.bool());
                    break;
                case 28:
                    if (!(message.tileDigDesignationAuto && message.tileDigDesignationAuto.length))
                        message.tileDigDesignationAuto = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileDigDesignationAuto.push(reader.bool());
                    } else
                        message.tileDigDesignationAuto.push(reader.bool());
                    break;
                case 29:
                    if (!(message.grassPercent && message.grassPercent.length))
                        message.grassPercent = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.grassPercent.push(reader.int32());
                    } else
                        message.grassPercent.push(reader.int32());
                    break;
                case 30:
                    if (!(message.flows && message.flows.length))
                        message.flows = [];
                    message.flows.push($root.RemoteFortressReader.FlowInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("mapX"))
                throw $util.ProtocolError("missing required 'mapX'", { instance: message });
            if (!message.hasOwnProperty("mapY"))
                throw $util.ProtocolError("missing required 'mapY'", { instance: message });
            if (!message.hasOwnProperty("mapZ"))
                throw $util.ProtocolError("missing required 'mapZ'", { instance: message });
            return message;
        };

        /**
         * Decodes a MapBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MapBlock} MapBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapBlock.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapBlock message.
         * @function verify
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapBlock.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.mapX))
                return "mapX: integer expected";
            if (!$util.isInteger(message.mapY))
                return "mapY: integer expected";
            if (!$util.isInteger(message.mapZ))
                return "mapZ: integer expected";
            if (message.tiles != null && message.hasOwnProperty("tiles")) {
                if (!Array.isArray(message.tiles))
                    return "tiles: array expected";
                for (var i = 0; i < message.tiles.length; ++i)
                    if (!$util.isInteger(message.tiles[i]))
                        return "tiles: integer[] expected";
            }
            if (message.materials != null && message.hasOwnProperty("materials")) {
                if (!Array.isArray(message.materials))
                    return "materials: array expected";
                for (var i = 0; i < message.materials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.materials[i]);
                    if (error)
                        return "materials." + error;
                }
            }
            if (message.layerMaterials != null && message.hasOwnProperty("layerMaterials")) {
                if (!Array.isArray(message.layerMaterials))
                    return "layerMaterials: array expected";
                for (var i = 0; i < message.layerMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.layerMaterials[i]);
                    if (error)
                        return "layerMaterials." + error;
                }
            }
            if (message.veinMaterials != null && message.hasOwnProperty("veinMaterials")) {
                if (!Array.isArray(message.veinMaterials))
                    return "veinMaterials: array expected";
                for (var i = 0; i < message.veinMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.veinMaterials[i]);
                    if (error)
                        return "veinMaterials." + error;
                }
            }
            if (message.baseMaterials != null && message.hasOwnProperty("baseMaterials")) {
                if (!Array.isArray(message.baseMaterials))
                    return "baseMaterials: array expected";
                for (var i = 0; i < message.baseMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.baseMaterials[i]);
                    if (error)
                        return "baseMaterials." + error;
                }
            }
            if (message.magma != null && message.hasOwnProperty("magma")) {
                if (!Array.isArray(message.magma))
                    return "magma: array expected";
                for (var i = 0; i < message.magma.length; ++i)
                    if (!$util.isInteger(message.magma[i]))
                        return "magma: integer[] expected";
            }
            if (message.water != null && message.hasOwnProperty("water")) {
                if (!Array.isArray(message.water))
                    return "water: array expected";
                for (var i = 0; i < message.water.length; ++i)
                    if (!$util.isInteger(message.water[i]))
                        return "water: integer[] expected";
            }
            if (message.hidden != null && message.hasOwnProperty("hidden")) {
                if (!Array.isArray(message.hidden))
                    return "hidden: array expected";
                for (var i = 0; i < message.hidden.length; ++i)
                    if (typeof message.hidden[i] !== "boolean")
                        return "hidden: boolean[] expected";
            }
            if (message.light != null && message.hasOwnProperty("light")) {
                if (!Array.isArray(message.light))
                    return "light: array expected";
                for (var i = 0; i < message.light.length; ++i)
                    if (typeof message.light[i] !== "boolean")
                        return "light: boolean[] expected";
            }
            if (message.subterranean != null && message.hasOwnProperty("subterranean")) {
                if (!Array.isArray(message.subterranean))
                    return "subterranean: array expected";
                for (var i = 0; i < message.subterranean.length; ++i)
                    if (typeof message.subterranean[i] !== "boolean")
                        return "subterranean: boolean[] expected";
            }
            if (message.outside != null && message.hasOwnProperty("outside")) {
                if (!Array.isArray(message.outside))
                    return "outside: array expected";
                for (var i = 0; i < message.outside.length; ++i)
                    if (typeof message.outside[i] !== "boolean")
                        return "outside: boolean[] expected";
            }
            if (message.aquifer != null && message.hasOwnProperty("aquifer")) {
                if (!Array.isArray(message.aquifer))
                    return "aquifer: array expected";
                for (var i = 0; i < message.aquifer.length; ++i)
                    if (typeof message.aquifer[i] !== "boolean")
                        return "aquifer: boolean[] expected";
            }
            if (message.waterStagnant != null && message.hasOwnProperty("waterStagnant")) {
                if (!Array.isArray(message.waterStagnant))
                    return "waterStagnant: array expected";
                for (var i = 0; i < message.waterStagnant.length; ++i)
                    if (typeof message.waterStagnant[i] !== "boolean")
                        return "waterStagnant: boolean[] expected";
            }
            if (message.waterSalt != null && message.hasOwnProperty("waterSalt")) {
                if (!Array.isArray(message.waterSalt))
                    return "waterSalt: array expected";
                for (var i = 0; i < message.waterSalt.length; ++i)
                    if (typeof message.waterSalt[i] !== "boolean")
                        return "waterSalt: boolean[] expected";
            }
            if (message.constructionItems != null && message.hasOwnProperty("constructionItems")) {
                if (!Array.isArray(message.constructionItems))
                    return "constructionItems: array expected";
                for (var i = 0; i < message.constructionItems.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.constructionItems[i]);
                    if (error)
                        return "constructionItems." + error;
                }
            }
            if (message.buildings != null && message.hasOwnProperty("buildings")) {
                if (!Array.isArray(message.buildings))
                    return "buildings: array expected";
                for (var i = 0; i < message.buildings.length; ++i) {
                    var error = $root.RemoteFortressReader.BuildingInstance.verify(message.buildings[i]);
                    if (error)
                        return "buildings." + error;
                }
            }
            if (message.treePercent != null && message.hasOwnProperty("treePercent")) {
                if (!Array.isArray(message.treePercent))
                    return "treePercent: array expected";
                for (var i = 0; i < message.treePercent.length; ++i)
                    if (!$util.isInteger(message.treePercent[i]))
                        return "treePercent: integer[] expected";
            }
            if (message.treeX != null && message.hasOwnProperty("treeX")) {
                if (!Array.isArray(message.treeX))
                    return "treeX: array expected";
                for (var i = 0; i < message.treeX.length; ++i)
                    if (!$util.isInteger(message.treeX[i]))
                        return "treeX: integer[] expected";
            }
            if (message.treeY != null && message.hasOwnProperty("treeY")) {
                if (!Array.isArray(message.treeY))
                    return "treeY: array expected";
                for (var i = 0; i < message.treeY.length; ++i)
                    if (!$util.isInteger(message.treeY[i]))
                        return "treeY: integer[] expected";
            }
            if (message.treeZ != null && message.hasOwnProperty("treeZ")) {
                if (!Array.isArray(message.treeZ))
                    return "treeZ: array expected";
                for (var i = 0; i < message.treeZ.length; ++i)
                    if (!$util.isInteger(message.treeZ[i]))
                        return "treeZ: integer[] expected";
            }
            if (message.tileDigDesignation != null && message.hasOwnProperty("tileDigDesignation")) {
                if (!Array.isArray(message.tileDigDesignation))
                    return "tileDigDesignation: array expected";
                for (var i = 0; i < message.tileDigDesignation.length; ++i)
                    switch (message.tileDigDesignation[i]) {
                    default:
                        return "tileDigDesignation: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
            }
            if (message.spatterPile != null && message.hasOwnProperty("spatterPile")) {
                if (!Array.isArray(message.spatterPile))
                    return "spatterPile: array expected";
                for (var i = 0; i < message.spatterPile.length; ++i) {
                    var error = $root.RemoteFortressReader.SpatterPile.verify(message.spatterPile[i]);
                    if (error)
                        return "spatterPile." + error;
                }
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.RemoteFortressReader.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.tileDigDesignationMarker != null && message.hasOwnProperty("tileDigDesignationMarker")) {
                if (!Array.isArray(message.tileDigDesignationMarker))
                    return "tileDigDesignationMarker: array expected";
                for (var i = 0; i < message.tileDigDesignationMarker.length; ++i)
                    if (typeof message.tileDigDesignationMarker[i] !== "boolean")
                        return "tileDigDesignationMarker: boolean[] expected";
            }
            if (message.tileDigDesignationAuto != null && message.hasOwnProperty("tileDigDesignationAuto")) {
                if (!Array.isArray(message.tileDigDesignationAuto))
                    return "tileDigDesignationAuto: array expected";
                for (var i = 0; i < message.tileDigDesignationAuto.length; ++i)
                    if (typeof message.tileDigDesignationAuto[i] !== "boolean")
                        return "tileDigDesignationAuto: boolean[] expected";
            }
            if (message.grassPercent != null && message.hasOwnProperty("grassPercent")) {
                if (!Array.isArray(message.grassPercent))
                    return "grassPercent: array expected";
                for (var i = 0; i < message.grassPercent.length; ++i)
                    if (!$util.isInteger(message.grassPercent[i]))
                        return "grassPercent: integer[] expected";
            }
            if (message.flows != null && message.hasOwnProperty("flows")) {
                if (!Array.isArray(message.flows))
                    return "flows: array expected";
                for (var i = 0; i < message.flows.length; ++i) {
                    var error = $root.RemoteFortressReader.FlowInfo.verify(message.flows[i]);
                    if (error)
                        return "flows." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MapBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MapBlock} MapBlock
         */
        MapBlock.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MapBlock)
                return object;
            var message = new $root.RemoteFortressReader.MapBlock();
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.mapZ != null)
                message.mapZ = object.mapZ | 0;
            if (object.tiles) {
                if (!Array.isArray(object.tiles))
                    throw TypeError(".RemoteFortressReader.MapBlock.tiles: array expected");
                message.tiles = [];
                for (var i = 0; i < object.tiles.length; ++i)
                    message.tiles[i] = object.tiles[i] | 0;
            }
            if (object.materials) {
                if (!Array.isArray(object.materials))
                    throw TypeError(".RemoteFortressReader.MapBlock.materials: array expected");
                message.materials = [];
                for (var i = 0; i < object.materials.length; ++i) {
                    if (typeof object.materials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.materials: object expected");
                    message.materials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.materials[i]);
                }
            }
            if (object.layerMaterials) {
                if (!Array.isArray(object.layerMaterials))
                    throw TypeError(".RemoteFortressReader.MapBlock.layerMaterials: array expected");
                message.layerMaterials = [];
                for (var i = 0; i < object.layerMaterials.length; ++i) {
                    if (typeof object.layerMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.layerMaterials: object expected");
                    message.layerMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.layerMaterials[i]);
                }
            }
            if (object.veinMaterials) {
                if (!Array.isArray(object.veinMaterials))
                    throw TypeError(".RemoteFortressReader.MapBlock.veinMaterials: array expected");
                message.veinMaterials = [];
                for (var i = 0; i < object.veinMaterials.length; ++i) {
                    if (typeof object.veinMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.veinMaterials: object expected");
                    message.veinMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.veinMaterials[i]);
                }
            }
            if (object.baseMaterials) {
                if (!Array.isArray(object.baseMaterials))
                    throw TypeError(".RemoteFortressReader.MapBlock.baseMaterials: array expected");
                message.baseMaterials = [];
                for (var i = 0; i < object.baseMaterials.length; ++i) {
                    if (typeof object.baseMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.baseMaterials: object expected");
                    message.baseMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.baseMaterials[i]);
                }
            }
            if (object.magma) {
                if (!Array.isArray(object.magma))
                    throw TypeError(".RemoteFortressReader.MapBlock.magma: array expected");
                message.magma = [];
                for (var i = 0; i < object.magma.length; ++i)
                    message.magma[i] = object.magma[i] | 0;
            }
            if (object.water) {
                if (!Array.isArray(object.water))
                    throw TypeError(".RemoteFortressReader.MapBlock.water: array expected");
                message.water = [];
                for (var i = 0; i < object.water.length; ++i)
                    message.water[i] = object.water[i] | 0;
            }
            if (object.hidden) {
                if (!Array.isArray(object.hidden))
                    throw TypeError(".RemoteFortressReader.MapBlock.hidden: array expected");
                message.hidden = [];
                for (var i = 0; i < object.hidden.length; ++i)
                    message.hidden[i] = Boolean(object.hidden[i]);
            }
            if (object.light) {
                if (!Array.isArray(object.light))
                    throw TypeError(".RemoteFortressReader.MapBlock.light: array expected");
                message.light = [];
                for (var i = 0; i < object.light.length; ++i)
                    message.light[i] = Boolean(object.light[i]);
            }
            if (object.subterranean) {
                if (!Array.isArray(object.subterranean))
                    throw TypeError(".RemoteFortressReader.MapBlock.subterranean: array expected");
                message.subterranean = [];
                for (var i = 0; i < object.subterranean.length; ++i)
                    message.subterranean[i] = Boolean(object.subterranean[i]);
            }
            if (object.outside) {
                if (!Array.isArray(object.outside))
                    throw TypeError(".RemoteFortressReader.MapBlock.outside: array expected");
                message.outside = [];
                for (var i = 0; i < object.outside.length; ++i)
                    message.outside[i] = Boolean(object.outside[i]);
            }
            if (object.aquifer) {
                if (!Array.isArray(object.aquifer))
                    throw TypeError(".RemoteFortressReader.MapBlock.aquifer: array expected");
                message.aquifer = [];
                for (var i = 0; i < object.aquifer.length; ++i)
                    message.aquifer[i] = Boolean(object.aquifer[i]);
            }
            if (object.waterStagnant) {
                if (!Array.isArray(object.waterStagnant))
                    throw TypeError(".RemoteFortressReader.MapBlock.waterStagnant: array expected");
                message.waterStagnant = [];
                for (var i = 0; i < object.waterStagnant.length; ++i)
                    message.waterStagnant[i] = Boolean(object.waterStagnant[i]);
            }
            if (object.waterSalt) {
                if (!Array.isArray(object.waterSalt))
                    throw TypeError(".RemoteFortressReader.MapBlock.waterSalt: array expected");
                message.waterSalt = [];
                for (var i = 0; i < object.waterSalt.length; ++i)
                    message.waterSalt[i] = Boolean(object.waterSalt[i]);
            }
            if (object.constructionItems) {
                if (!Array.isArray(object.constructionItems))
                    throw TypeError(".RemoteFortressReader.MapBlock.constructionItems: array expected");
                message.constructionItems = [];
                for (var i = 0; i < object.constructionItems.length; ++i) {
                    if (typeof object.constructionItems[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.constructionItems: object expected");
                    message.constructionItems[i] = $root.RemoteFortressReader.MatPair.fromObject(object.constructionItems[i]);
                }
            }
            if (object.buildings) {
                if (!Array.isArray(object.buildings))
                    throw TypeError(".RemoteFortressReader.MapBlock.buildings: array expected");
                message.buildings = [];
                for (var i = 0; i < object.buildings.length; ++i) {
                    if (typeof object.buildings[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.buildings: object expected");
                    message.buildings[i] = $root.RemoteFortressReader.BuildingInstance.fromObject(object.buildings[i]);
                }
            }
            if (object.treePercent) {
                if (!Array.isArray(object.treePercent))
                    throw TypeError(".RemoteFortressReader.MapBlock.treePercent: array expected");
                message.treePercent = [];
                for (var i = 0; i < object.treePercent.length; ++i)
                    message.treePercent[i] = object.treePercent[i] | 0;
            }
            if (object.treeX) {
                if (!Array.isArray(object.treeX))
                    throw TypeError(".RemoteFortressReader.MapBlock.treeX: array expected");
                message.treeX = [];
                for (var i = 0; i < object.treeX.length; ++i)
                    message.treeX[i] = object.treeX[i] | 0;
            }
            if (object.treeY) {
                if (!Array.isArray(object.treeY))
                    throw TypeError(".RemoteFortressReader.MapBlock.treeY: array expected");
                message.treeY = [];
                for (var i = 0; i < object.treeY.length; ++i)
                    message.treeY[i] = object.treeY[i] | 0;
            }
            if (object.treeZ) {
                if (!Array.isArray(object.treeZ))
                    throw TypeError(".RemoteFortressReader.MapBlock.treeZ: array expected");
                message.treeZ = [];
                for (var i = 0; i < object.treeZ.length; ++i)
                    message.treeZ[i] = object.treeZ[i] | 0;
            }
            if (object.tileDigDesignation) {
                if (!Array.isArray(object.tileDigDesignation))
                    throw TypeError(".RemoteFortressReader.MapBlock.tileDigDesignation: array expected");
                message.tileDigDesignation = [];
                for (var i = 0; i < object.tileDigDesignation.length; ++i)
                    switch (object.tileDigDesignation[i]) {
                    default:
                    case "NO_DIG":
                    case 0:
                        message.tileDigDesignation[i] = 0;
                        break;
                    case "DEFAULT_DIG":
                    case 1:
                        message.tileDigDesignation[i] = 1;
                        break;
                    case "UP_DOWN_STAIR_DIG":
                    case 2:
                        message.tileDigDesignation[i] = 2;
                        break;
                    case "CHANNEL_DIG":
                    case 3:
                        message.tileDigDesignation[i] = 3;
                        break;
                    case "RAMP_DIG":
                    case 4:
                        message.tileDigDesignation[i] = 4;
                        break;
                    case "DOWN_STAIR_DIG":
                    case 5:
                        message.tileDigDesignation[i] = 5;
                        break;
                    case "UP_STAIR_DIG":
                    case 6:
                        message.tileDigDesignation[i] = 6;
                        break;
                    }
            }
            if (object.spatterPile) {
                if (!Array.isArray(object.spatterPile))
                    throw TypeError(".RemoteFortressReader.MapBlock.spatterPile: array expected");
                message.spatterPile = [];
                for (var i = 0; i < object.spatterPile.length; ++i) {
                    if (typeof object.spatterPile[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.spatterPile: object expected");
                    message.spatterPile[i] = $root.RemoteFortressReader.SpatterPile.fromObject(object.spatterPile[i]);
                }
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".RemoteFortressReader.MapBlock.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.items: object expected");
                    message.items[i] = $root.RemoteFortressReader.Item.fromObject(object.items[i]);
                }
            }
            if (object.tileDigDesignationMarker) {
                if (!Array.isArray(object.tileDigDesignationMarker))
                    throw TypeError(".RemoteFortressReader.MapBlock.tileDigDesignationMarker: array expected");
                message.tileDigDesignationMarker = [];
                for (var i = 0; i < object.tileDigDesignationMarker.length; ++i)
                    message.tileDigDesignationMarker[i] = Boolean(object.tileDigDesignationMarker[i]);
            }
            if (object.tileDigDesignationAuto) {
                if (!Array.isArray(object.tileDigDesignationAuto))
                    throw TypeError(".RemoteFortressReader.MapBlock.tileDigDesignationAuto: array expected");
                message.tileDigDesignationAuto = [];
                for (var i = 0; i < object.tileDigDesignationAuto.length; ++i)
                    message.tileDigDesignationAuto[i] = Boolean(object.tileDigDesignationAuto[i]);
            }
            if (object.grassPercent) {
                if (!Array.isArray(object.grassPercent))
                    throw TypeError(".RemoteFortressReader.MapBlock.grassPercent: array expected");
                message.grassPercent = [];
                for (var i = 0; i < object.grassPercent.length; ++i)
                    message.grassPercent[i] = object.grassPercent[i] | 0;
            }
            if (object.flows) {
                if (!Array.isArray(object.flows))
                    throw TypeError(".RemoteFortressReader.MapBlock.flows: array expected");
                message.flows = [];
                for (var i = 0; i < object.flows.length; ++i) {
                    if (typeof object.flows[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.flows: object expected");
                    message.flows[i] = $root.RemoteFortressReader.FlowInfo.fromObject(object.flows[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MapBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.MapBlock} message MapBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapBlock.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.tiles = [];
                object.materials = [];
                object.layerMaterials = [];
                object.veinMaterials = [];
                object.baseMaterials = [];
                object.magma = [];
                object.water = [];
                object.hidden = [];
                object.light = [];
                object.subterranean = [];
                object.outside = [];
                object.aquifer = [];
                object.waterStagnant = [];
                object.waterSalt = [];
                object.constructionItems = [];
                object.buildings = [];
                object.treePercent = [];
                object.treeX = [];
                object.treeY = [];
                object.treeZ = [];
                object.tileDigDesignation = [];
                object.spatterPile = [];
                object.items = [];
                object.tileDigDesignationMarker = [];
                object.tileDigDesignationAuto = [];
                object.grassPercent = [];
                object.flows = [];
            }
            if (options.defaults) {
                object.mapX = 0;
                object.mapY = 0;
                object.mapZ = 0;
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.mapZ != null && message.hasOwnProperty("mapZ"))
                object.mapZ = message.mapZ;
            if (message.tiles && message.tiles.length) {
                object.tiles = [];
                for (var j = 0; j < message.tiles.length; ++j)
                    object.tiles[j] = message.tiles[j];
            }
            if (message.materials && message.materials.length) {
                object.materials = [];
                for (var j = 0; j < message.materials.length; ++j)
                    object.materials[j] = $root.RemoteFortressReader.MatPair.toObject(message.materials[j], options);
            }
            if (message.layerMaterials && message.layerMaterials.length) {
                object.layerMaterials = [];
                for (var j = 0; j < message.layerMaterials.length; ++j)
                    object.layerMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.layerMaterials[j], options);
            }
            if (message.veinMaterials && message.veinMaterials.length) {
                object.veinMaterials = [];
                for (var j = 0; j < message.veinMaterials.length; ++j)
                    object.veinMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.veinMaterials[j], options);
            }
            if (message.baseMaterials && message.baseMaterials.length) {
                object.baseMaterials = [];
                for (var j = 0; j < message.baseMaterials.length; ++j)
                    object.baseMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.baseMaterials[j], options);
            }
            if (message.magma && message.magma.length) {
                object.magma = [];
                for (var j = 0; j < message.magma.length; ++j)
                    object.magma[j] = message.magma[j];
            }
            if (message.water && message.water.length) {
                object.water = [];
                for (var j = 0; j < message.water.length; ++j)
                    object.water[j] = message.water[j];
            }
            if (message.hidden && message.hidden.length) {
                object.hidden = [];
                for (var j = 0; j < message.hidden.length; ++j)
                    object.hidden[j] = message.hidden[j];
            }
            if (message.light && message.light.length) {
                object.light = [];
                for (var j = 0; j < message.light.length; ++j)
                    object.light[j] = message.light[j];
            }
            if (message.subterranean && message.subterranean.length) {
                object.subterranean = [];
                for (var j = 0; j < message.subterranean.length; ++j)
                    object.subterranean[j] = message.subterranean[j];
            }
            if (message.outside && message.outside.length) {
                object.outside = [];
                for (var j = 0; j < message.outside.length; ++j)
                    object.outside[j] = message.outside[j];
            }
            if (message.aquifer && message.aquifer.length) {
                object.aquifer = [];
                for (var j = 0; j < message.aquifer.length; ++j)
                    object.aquifer[j] = message.aquifer[j];
            }
            if (message.waterStagnant && message.waterStagnant.length) {
                object.waterStagnant = [];
                for (var j = 0; j < message.waterStagnant.length; ++j)
                    object.waterStagnant[j] = message.waterStagnant[j];
            }
            if (message.waterSalt && message.waterSalt.length) {
                object.waterSalt = [];
                for (var j = 0; j < message.waterSalt.length; ++j)
                    object.waterSalt[j] = message.waterSalt[j];
            }
            if (message.constructionItems && message.constructionItems.length) {
                object.constructionItems = [];
                for (var j = 0; j < message.constructionItems.length; ++j)
                    object.constructionItems[j] = $root.RemoteFortressReader.MatPair.toObject(message.constructionItems[j], options);
            }
            if (message.buildings && message.buildings.length) {
                object.buildings = [];
                for (var j = 0; j < message.buildings.length; ++j)
                    object.buildings[j] = $root.RemoteFortressReader.BuildingInstance.toObject(message.buildings[j], options);
            }
            if (message.treePercent && message.treePercent.length) {
                object.treePercent = [];
                for (var j = 0; j < message.treePercent.length; ++j)
                    object.treePercent[j] = message.treePercent[j];
            }
            if (message.treeX && message.treeX.length) {
                object.treeX = [];
                for (var j = 0; j < message.treeX.length; ++j)
                    object.treeX[j] = message.treeX[j];
            }
            if (message.treeY && message.treeY.length) {
                object.treeY = [];
                for (var j = 0; j < message.treeY.length; ++j)
                    object.treeY[j] = message.treeY[j];
            }
            if (message.treeZ && message.treeZ.length) {
                object.treeZ = [];
                for (var j = 0; j < message.treeZ.length; ++j)
                    object.treeZ[j] = message.treeZ[j];
            }
            if (message.tileDigDesignation && message.tileDigDesignation.length) {
                object.tileDigDesignation = [];
                for (var j = 0; j < message.tileDigDesignation.length; ++j)
                    object.tileDigDesignation[j] = options.enums === String ? $root.RemoteFortressReader.TileDigDesignation[message.tileDigDesignation[j]] : message.tileDigDesignation[j];
            }
            if (message.spatterPile && message.spatterPile.length) {
                object.spatterPile = [];
                for (var j = 0; j < message.spatterPile.length; ++j)
                    object.spatterPile[j] = $root.RemoteFortressReader.SpatterPile.toObject(message.spatterPile[j], options);
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.RemoteFortressReader.Item.toObject(message.items[j], options);
            }
            if (message.tileDigDesignationMarker && message.tileDigDesignationMarker.length) {
                object.tileDigDesignationMarker = [];
                for (var j = 0; j < message.tileDigDesignationMarker.length; ++j)
                    object.tileDigDesignationMarker[j] = message.tileDigDesignationMarker[j];
            }
            if (message.tileDigDesignationAuto && message.tileDigDesignationAuto.length) {
                object.tileDigDesignationAuto = [];
                for (var j = 0; j < message.tileDigDesignationAuto.length; ++j)
                    object.tileDigDesignationAuto[j] = message.tileDigDesignationAuto[j];
            }
            if (message.grassPercent && message.grassPercent.length) {
                object.grassPercent = [];
                for (var j = 0; j < message.grassPercent.length; ++j)
                    object.grassPercent[j] = message.grassPercent[j];
            }
            if (message.flows && message.flows.length) {
                object.flows = [];
                for (var j = 0; j < message.flows.length; ++j)
                    object.flows[j] = $root.RemoteFortressReader.FlowInfo.toObject(message.flows[j], options);
            }
            return object;
        };

        /**
         * Converts this MapBlock to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapBlock.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapBlock;
    })();

    RemoteFortressReader.MatPair = (function() {

        /**
         * Properties of a MatPair.
         * @memberof RemoteFortressReader
         * @interface IMatPair
         * @property {number} matType MatPair matType
         * @property {number} matIndex MatPair matIndex
         */

        /**
         * Constructs a new MatPair.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MatPair.
         * @implements IMatPair
         * @constructor
         * @param {RemoteFortressReader.IMatPair=} [properties] Properties to set
         */
        function MatPair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatPair matType.
         * @member {number} matType
         * @memberof RemoteFortressReader.MatPair
         * @instance
         */
        MatPair.prototype.matType = 0;

        /**
         * MatPair matIndex.
         * @member {number} matIndex
         * @memberof RemoteFortressReader.MatPair
         * @instance
         */
        MatPair.prototype.matIndex = 0;

        /**
         * Creates a new MatPair instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.IMatPair=} [properties] Properties to set
         * @returns {RemoteFortressReader.MatPair} MatPair instance
         */
        MatPair.create = function create(properties) {
            return new MatPair(properties);
        };

        /**
         * Encodes the specified MatPair message. Does not implicitly {@link RemoteFortressReader.MatPair.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.IMatPair} message MatPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatPair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.matType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.matIndex);
            return writer;
        };

        /**
         * Encodes the specified MatPair message, length delimited. Does not implicitly {@link RemoteFortressReader.MatPair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.IMatPair} message MatPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatPair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatPair message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MatPair} MatPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatPair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MatPair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.matType = reader.int32();
                    break;
                case 2:
                    message.matIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("matType"))
                throw $util.ProtocolError("missing required 'matType'", { instance: message });
            if (!message.hasOwnProperty("matIndex"))
                throw $util.ProtocolError("missing required 'matIndex'", { instance: message });
            return message;
        };

        /**
         * Decodes a MatPair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MatPair} MatPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatPair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatPair message.
         * @function verify
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatPair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.matType))
                return "matType: integer expected";
            if (!$util.isInteger(message.matIndex))
                return "matIndex: integer expected";
            return null;
        };

        /**
         * Creates a MatPair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MatPair} MatPair
         */
        MatPair.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MatPair)
                return object;
            var message = new $root.RemoteFortressReader.MatPair();
            if (object.matType != null)
                message.matType = object.matType | 0;
            if (object.matIndex != null)
                message.matIndex = object.matIndex | 0;
            return message;
        };

        /**
         * Creates a plain object from a MatPair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.MatPair} message MatPair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MatPair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.matType = 0;
                object.matIndex = 0;
            }
            if (message.matType != null && message.hasOwnProperty("matType"))
                object.matType = message.matType;
            if (message.matIndex != null && message.hasOwnProperty("matIndex"))
                object.matIndex = message.matIndex;
            return object;
        };

        /**
         * Converts this MatPair to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MatPair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MatPair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MatPair;
    })();

    RemoteFortressReader.ColorDefinition = (function() {

        /**
         * Properties of a ColorDefinition.
         * @memberof RemoteFortressReader
         * @interface IColorDefinition
         * @property {number} red ColorDefinition red
         * @property {number} green ColorDefinition green
         * @property {number} blue ColorDefinition blue
         */

        /**
         * Constructs a new ColorDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ColorDefinition.
         * @implements IColorDefinition
         * @constructor
         * @param {RemoteFortressReader.IColorDefinition=} [properties] Properties to set
         */
        function ColorDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorDefinition red.
         * @member {number} red
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.red = 0;

        /**
         * ColorDefinition green.
         * @member {number} green
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.green = 0;

        /**
         * ColorDefinition blue.
         * @member {number} blue
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.blue = 0;

        /**
         * Creates a new ColorDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.IColorDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition instance
         */
        ColorDefinition.create = function create(properties) {
            return new ColorDefinition(properties);
        };

        /**
         * Encodes the specified ColorDefinition message. Does not implicitly {@link RemoteFortressReader.ColorDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.red);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.green);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blue);
            return writer;
        };

        /**
         * Encodes the specified ColorDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.ColorDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ColorDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.red = reader.int32();
                    break;
                case 2:
                    message.green = reader.int32();
                    break;
                case 3:
                    message.blue = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("red"))
                throw $util.ProtocolError("missing required 'red'", { instance: message });
            if (!message.hasOwnProperty("green"))
                throw $util.ProtocolError("missing required 'green'", { instance: message });
            if (!message.hasOwnProperty("blue"))
                throw $util.ProtocolError("missing required 'blue'", { instance: message });
            return message;
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.red))
                return "red: integer expected";
            if (!$util.isInteger(message.green))
                return "green: integer expected";
            if (!$util.isInteger(message.blue))
                return "blue: integer expected";
            return null;
        };

        /**
         * Creates a ColorDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition
         */
        ColorDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ColorDefinition)
                return object;
            var message = new $root.RemoteFortressReader.ColorDefinition();
            if (object.red != null)
                message.red = object.red | 0;
            if (object.green != null)
                message.green = object.green | 0;
            if (object.blue != null)
                message.blue = object.blue | 0;
            return message;
        };

        /**
         * Creates a plain object from a ColorDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.ColorDefinition} message ColorDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.red = 0;
                object.green = 0;
                object.blue = 0;
            }
            if (message.red != null && message.hasOwnProperty("red"))
                object.red = message.red;
            if (message.green != null && message.hasOwnProperty("green"))
                object.green = message.green;
            if (message.blue != null && message.hasOwnProperty("blue"))
                object.blue = message.blue;
            return object;
        };

        /**
         * Converts this ColorDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ColorDefinition;
    })();

    RemoteFortressReader.MaterialDefinition = (function() {

        /**
         * Properties of a MaterialDefinition.
         * @memberof RemoteFortressReader
         * @interface IMaterialDefinition
         * @property {RemoteFortressReader.IMatPair} matPair MaterialDefinition matPair
         * @property {string|null} [id] MaterialDefinition id
         * @property {string|null} [name] MaterialDefinition name
         * @property {RemoteFortressReader.IColorDefinition|null} [stateColor] MaterialDefinition stateColor
         * @property {ItemdefInstrument.IInstrumentDef|null} [instrument] MaterialDefinition instrument
         */

        /**
         * Constructs a new MaterialDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MaterialDefinition.
         * @implements IMaterialDefinition
         * @constructor
         * @param {RemoteFortressReader.IMaterialDefinition=} [properties] Properties to set
         */
        function MaterialDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaterialDefinition matPair.
         * @member {RemoteFortressReader.IMatPair} matPair
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.matPair = null;

        /**
         * MaterialDefinition id.
         * @member {string} id
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.id = "";

        /**
         * MaterialDefinition name.
         * @member {string} name
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.name = "";

        /**
         * MaterialDefinition stateColor.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} stateColor
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.stateColor = null;

        /**
         * MaterialDefinition instrument.
         * @member {ItemdefInstrument.IInstrumentDef|null|undefined} instrument
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.instrument = null;

        /**
         * Creates a new MaterialDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.IMaterialDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition instance
         */
        MaterialDefinition.create = function create(properties) {
            return new MaterialDefinition(properties);
        };

        /**
         * Encodes the specified MaterialDefinition message. Does not implicitly {@link RemoteFortressReader.MaterialDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.IMaterialDefinition} message MaterialDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.RemoteFortressReader.MatPair.encode(message.matPair, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.stateColor != null && message.hasOwnProperty("stateColor"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.stateColor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.instrument != null && message.hasOwnProperty("instrument"))
                $root.ItemdefInstrument.InstrumentDef.encode(message.instrument, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MaterialDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.MaterialDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.IMaterialDefinition} message MaterialDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaterialDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MaterialDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.matPair = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.stateColor = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.instrument = $root.ItemdefInstrument.InstrumentDef.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("matPair"))
                throw $util.ProtocolError("missing required 'matPair'", { instance: message });
            return message;
        };

        /**
         * Decodes a MaterialDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaterialDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaterialDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.RemoteFortressReader.MatPair.verify(message.matPair);
                if (error)
                    return "matPair." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.stateColor != null && message.hasOwnProperty("stateColor")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.stateColor);
                if (error)
                    return "stateColor." + error;
            }
            if (message.instrument != null && message.hasOwnProperty("instrument")) {
                var error = $root.ItemdefInstrument.InstrumentDef.verify(message.instrument);
                if (error)
                    return "instrument." + error;
            }
            return null;
        };

        /**
         * Creates a MaterialDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition
         */
        MaterialDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MaterialDefinition)
                return object;
            var message = new $root.RemoteFortressReader.MaterialDefinition();
            if (object.matPair != null) {
                if (typeof object.matPair !== "object")
                    throw TypeError(".RemoteFortressReader.MaterialDefinition.matPair: object expected");
                message.matPair = $root.RemoteFortressReader.MatPair.fromObject(object.matPair);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.stateColor != null) {
                if (typeof object.stateColor !== "object")
                    throw TypeError(".RemoteFortressReader.MaterialDefinition.stateColor: object expected");
                message.stateColor = $root.RemoteFortressReader.ColorDefinition.fromObject(object.stateColor);
            }
            if (object.instrument != null) {
                if (typeof object.instrument !== "object")
                    throw TypeError(".RemoteFortressReader.MaterialDefinition.instrument: object expected");
                message.instrument = $root.ItemdefInstrument.InstrumentDef.fromObject(object.instrument);
            }
            return message;
        };

        /**
         * Creates a plain object from a MaterialDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.MaterialDefinition} message MaterialDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaterialDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.matPair = null;
                object.id = "";
                object.name = "";
                object.stateColor = null;
                object.instrument = null;
            }
            if (message.matPair != null && message.hasOwnProperty("matPair"))
                object.matPair = $root.RemoteFortressReader.MatPair.toObject(message.matPair, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.stateColor != null && message.hasOwnProperty("stateColor"))
                object.stateColor = $root.RemoteFortressReader.ColorDefinition.toObject(message.stateColor, options);
            if (message.instrument != null && message.hasOwnProperty("instrument"))
                object.instrument = $root.ItemdefInstrument.InstrumentDef.toObject(message.instrument, options);
            return object;
        };

        /**
         * Converts this MaterialDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaterialDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MaterialDefinition;
    })();

    RemoteFortressReader.BuildingType = (function() {

        /**
         * Properties of a BuildingType.
         * @memberof RemoteFortressReader
         * @interface IBuildingType
         * @property {number} buildingType BuildingType buildingType
         * @property {number} buildingSubtype BuildingType buildingSubtype
         * @property {number} buildingCustom BuildingType buildingCustom
         */

        /**
         * Constructs a new BuildingType.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingType.
         * @implements IBuildingType
         * @constructor
         * @param {RemoteFortressReader.IBuildingType=} [properties] Properties to set
         */
        function BuildingType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingType buildingType.
         * @member {number} buildingType
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         */
        BuildingType.prototype.buildingType = 0;

        /**
         * BuildingType buildingSubtype.
         * @member {number} buildingSubtype
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         */
        BuildingType.prototype.buildingSubtype = 0;

        /**
         * BuildingType buildingCustom.
         * @member {number} buildingCustom
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         */
        BuildingType.prototype.buildingCustom = 0;

        /**
         * Creates a new BuildingType instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.IBuildingType=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingType} BuildingType instance
         */
        BuildingType.create = function create(properties) {
            return new BuildingType(properties);
        };

        /**
         * Encodes the specified BuildingType message. Does not implicitly {@link RemoteFortressReader.BuildingType.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.IBuildingType} message BuildingType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buildingType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buildingSubtype);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.buildingCustom);
            return writer;
        };

        /**
         * Encodes the specified BuildingType message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.IBuildingType} message BuildingType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingType message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingType} BuildingType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buildingType = reader.int32();
                    break;
                case 2:
                    message.buildingSubtype = reader.int32();
                    break;
                case 3:
                    message.buildingCustom = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("buildingType"))
                throw $util.ProtocolError("missing required 'buildingType'", { instance: message });
            if (!message.hasOwnProperty("buildingSubtype"))
                throw $util.ProtocolError("missing required 'buildingSubtype'", { instance: message });
            if (!message.hasOwnProperty("buildingCustom"))
                throw $util.ProtocolError("missing required 'buildingCustom'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingType} BuildingType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingType message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.buildingType))
                return "buildingType: integer expected";
            if (!$util.isInteger(message.buildingSubtype))
                return "buildingSubtype: integer expected";
            if (!$util.isInteger(message.buildingCustom))
                return "buildingCustom: integer expected";
            return null;
        };

        /**
         * Creates a BuildingType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingType} BuildingType
         */
        BuildingType.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingType)
                return object;
            var message = new $root.RemoteFortressReader.BuildingType();
            if (object.buildingType != null)
                message.buildingType = object.buildingType | 0;
            if (object.buildingSubtype != null)
                message.buildingSubtype = object.buildingSubtype | 0;
            if (object.buildingCustom != null)
                message.buildingCustom = object.buildingCustom | 0;
            return message;
        };

        /**
         * Creates a plain object from a BuildingType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.BuildingType} message BuildingType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buildingType = 0;
                object.buildingSubtype = 0;
                object.buildingCustom = 0;
            }
            if (message.buildingType != null && message.hasOwnProperty("buildingType"))
                object.buildingType = message.buildingType;
            if (message.buildingSubtype != null && message.hasOwnProperty("buildingSubtype"))
                object.buildingSubtype = message.buildingSubtype;
            if (message.buildingCustom != null && message.hasOwnProperty("buildingCustom"))
                object.buildingCustom = message.buildingCustom;
            return object;
        };

        /**
         * Converts this BuildingType to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingType;
    })();

    RemoteFortressReader.BuildingDefinition = (function() {

        /**
         * Properties of a BuildingDefinition.
         * @memberof RemoteFortressReader
         * @interface IBuildingDefinition
         * @property {RemoteFortressReader.IBuildingType} buildingType BuildingDefinition buildingType
         * @property {string|null} [id] BuildingDefinition id
         * @property {string|null} [name] BuildingDefinition name
         */

        /**
         * Constructs a new BuildingDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingDefinition.
         * @implements IBuildingDefinition
         * @constructor
         * @param {RemoteFortressReader.IBuildingDefinition=} [properties] Properties to set
         */
        function BuildingDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingDefinition buildingType.
         * @member {RemoteFortressReader.IBuildingType} buildingType
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         */
        BuildingDefinition.prototype.buildingType = null;

        /**
         * BuildingDefinition id.
         * @member {string} id
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         */
        BuildingDefinition.prototype.id = "";

        /**
         * BuildingDefinition name.
         * @member {string} name
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         */
        BuildingDefinition.prototype.name = "";

        /**
         * Creates a new BuildingDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.IBuildingDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition instance
         */
        BuildingDefinition.create = function create(properties) {
            return new BuildingDefinition(properties);
        };

        /**
         * Encodes the specified BuildingDefinition message. Does not implicitly {@link RemoteFortressReader.BuildingDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.IBuildingDefinition} message BuildingDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.RemoteFortressReader.BuildingType.encode(message.buildingType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified BuildingDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.IBuildingDefinition} message BuildingDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buildingType = $root.RemoteFortressReader.BuildingType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("buildingType"))
                throw $util.ProtocolError("missing required 'buildingType'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.RemoteFortressReader.BuildingType.verify(message.buildingType);
                if (error)
                    return "buildingType." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a BuildingDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition
         */
        BuildingDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingDefinition)
                return object;
            var message = new $root.RemoteFortressReader.BuildingDefinition();
            if (object.buildingType != null) {
                if (typeof object.buildingType !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingDefinition.buildingType: object expected");
                message.buildingType = $root.RemoteFortressReader.BuildingType.fromObject(object.buildingType);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a BuildingDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.BuildingDefinition} message BuildingDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buildingType = null;
                object.id = "";
                object.name = "";
            }
            if (message.buildingType != null && message.hasOwnProperty("buildingType"))
                object.buildingType = $root.RemoteFortressReader.BuildingType.toObject(message.buildingType, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this BuildingDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingDefinition;
    })();

    RemoteFortressReader.BuildingList = (function() {

        /**
         * Properties of a BuildingList.
         * @memberof RemoteFortressReader
         * @interface IBuildingList
         * @property {Array.<RemoteFortressReader.IBuildingDefinition>|null} [buildingList] BuildingList buildingList
         */

        /**
         * Constructs a new BuildingList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingList.
         * @implements IBuildingList
         * @constructor
         * @param {RemoteFortressReader.IBuildingList=} [properties] Properties to set
         */
        function BuildingList(properties) {
            this.buildingList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingList buildingList.
         * @member {Array.<RemoteFortressReader.IBuildingDefinition>} buildingList
         * @memberof RemoteFortressReader.BuildingList
         * @instance
         */
        BuildingList.prototype.buildingList = $util.emptyArray;

        /**
         * Creates a new BuildingList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.IBuildingList=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingList} BuildingList instance
         */
        BuildingList.create = function create(properties) {
            return new BuildingList(properties);
        };

        /**
         * Encodes the specified BuildingList message. Does not implicitly {@link RemoteFortressReader.BuildingList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.IBuildingList} message BuildingList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buildingList != null && message.buildingList.length)
                for (var i = 0; i < message.buildingList.length; ++i)
                    $root.RemoteFortressReader.BuildingDefinition.encode(message.buildingList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BuildingList message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.IBuildingList} message BuildingList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingList} BuildingList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.buildingList && message.buildingList.length))
                        message.buildingList = [];
                    message.buildingList.push($root.RemoteFortressReader.BuildingDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuildingList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingList} BuildingList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingList message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buildingList != null && message.hasOwnProperty("buildingList")) {
                if (!Array.isArray(message.buildingList))
                    return "buildingList: array expected";
                for (var i = 0; i < message.buildingList.length; ++i) {
                    var error = $root.RemoteFortressReader.BuildingDefinition.verify(message.buildingList[i]);
                    if (error)
                        return "buildingList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BuildingList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingList} BuildingList
         */
        BuildingList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingList)
                return object;
            var message = new $root.RemoteFortressReader.BuildingList();
            if (object.buildingList) {
                if (!Array.isArray(object.buildingList))
                    throw TypeError(".RemoteFortressReader.BuildingList.buildingList: array expected");
                message.buildingList = [];
                for (var i = 0; i < object.buildingList.length; ++i) {
                    if (typeof object.buildingList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BuildingList.buildingList: object expected");
                    message.buildingList[i] = $root.RemoteFortressReader.BuildingDefinition.fromObject(object.buildingList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BuildingList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.BuildingList} message BuildingList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buildingList = [];
            if (message.buildingList && message.buildingList.length) {
                object.buildingList = [];
                for (var j = 0; j < message.buildingList.length; ++j)
                    object.buildingList[j] = $root.RemoteFortressReader.BuildingDefinition.toObject(message.buildingList[j], options);
            }
            return object;
        };

        /**
         * Converts this BuildingList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingList;
    })();

    RemoteFortressReader.MaterialList = (function() {

        /**
         * Properties of a MaterialList.
         * @memberof RemoteFortressReader
         * @interface IMaterialList
         * @property {Array.<RemoteFortressReader.IMaterialDefinition>|null} [materialList] MaterialList materialList
         */

        /**
         * Constructs a new MaterialList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MaterialList.
         * @implements IMaterialList
         * @constructor
         * @param {RemoteFortressReader.IMaterialList=} [properties] Properties to set
         */
        function MaterialList(properties) {
            this.materialList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaterialList materialList.
         * @member {Array.<RemoteFortressReader.IMaterialDefinition>} materialList
         * @memberof RemoteFortressReader.MaterialList
         * @instance
         */
        MaterialList.prototype.materialList = $util.emptyArray;

        /**
         * Creates a new MaterialList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.IMaterialList=} [properties] Properties to set
         * @returns {RemoteFortressReader.MaterialList} MaterialList instance
         */
        MaterialList.create = function create(properties) {
            return new MaterialList(properties);
        };

        /**
         * Encodes the specified MaterialList message. Does not implicitly {@link RemoteFortressReader.MaterialList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.IMaterialList} message MaterialList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.materialList != null && message.materialList.length)
                for (var i = 0; i < message.materialList.length; ++i)
                    $root.RemoteFortressReader.MaterialDefinition.encode(message.materialList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MaterialList message, length delimited. Does not implicitly {@link RemoteFortressReader.MaterialList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.IMaterialList} message MaterialList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaterialList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MaterialList} MaterialList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MaterialList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.materialList && message.materialList.length))
                        message.materialList = [];
                    message.materialList.push($root.RemoteFortressReader.MaterialDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MaterialList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MaterialList} MaterialList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaterialList message.
         * @function verify
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaterialList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.materialList != null && message.hasOwnProperty("materialList")) {
                if (!Array.isArray(message.materialList))
                    return "materialList: array expected";
                for (var i = 0; i < message.materialList.length; ++i) {
                    var error = $root.RemoteFortressReader.MaterialDefinition.verify(message.materialList[i]);
                    if (error)
                        return "materialList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MaterialList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MaterialList} MaterialList
         */
        MaterialList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MaterialList)
                return object;
            var message = new $root.RemoteFortressReader.MaterialList();
            if (object.materialList) {
                if (!Array.isArray(object.materialList))
                    throw TypeError(".RemoteFortressReader.MaterialList.materialList: array expected");
                message.materialList = [];
                for (var i = 0; i < object.materialList.length; ++i) {
                    if (typeof object.materialList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MaterialList.materialList: object expected");
                    message.materialList[i] = $root.RemoteFortressReader.MaterialDefinition.fromObject(object.materialList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MaterialList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.MaterialList} message MaterialList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaterialList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.materialList = [];
            if (message.materialList && message.materialList.length) {
                object.materialList = [];
                for (var j = 0; j < message.materialList.length; ++j)
                    object.materialList[j] = $root.RemoteFortressReader.MaterialDefinition.toObject(message.materialList[j], options);
            }
            return object;
        };

        /**
         * Converts this MaterialList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MaterialList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaterialList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MaterialList;
    })();

    RemoteFortressReader.Hair = (function() {

        /**
         * Properties of a Hair.
         * @memberof RemoteFortressReader
         * @interface IHair
         * @property {number|null} [length] Hair length
         * @property {RemoteFortressReader.HairStyle|null} [style] Hair style
         */

        /**
         * Constructs a new Hair.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Hair.
         * @implements IHair
         * @constructor
         * @param {RemoteFortressReader.IHair=} [properties] Properties to set
         */
        function Hair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hair length.
         * @member {number} length
         * @memberof RemoteFortressReader.Hair
         * @instance
         */
        Hair.prototype.length = 0;

        /**
         * Hair style.
         * @member {RemoteFortressReader.HairStyle} style
         * @memberof RemoteFortressReader.Hair
         * @instance
         */
        Hair.prototype.style = -1;

        /**
         * Creates a new Hair instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.IHair=} [properties] Properties to set
         * @returns {RemoteFortressReader.Hair} Hair instance
         */
        Hair.create = function create(properties) {
            return new Hair(properties);
        };

        /**
         * Encodes the specified Hair message. Does not implicitly {@link RemoteFortressReader.Hair.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.IHair} message Hair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && message.hasOwnProperty("length"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.length);
            if (message.style != null && message.hasOwnProperty("style"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.style);
            return writer;
        };

        /**
         * Encodes the specified Hair message, length delimited. Does not implicitly {@link RemoteFortressReader.Hair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.IHair} message Hair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hair message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Hair} Hair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Hair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.length = reader.int32();
                    break;
                case 2:
                    message.style = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Hair} Hair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hair message.
         * @function verify
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length"))
                if (!$util.isInteger(message.length))
                    return "length: integer expected";
            if (message.style != null && message.hasOwnProperty("style"))
                switch (message.style) {
                default:
                    return "style: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a Hair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Hair} Hair
         */
        Hair.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Hair)
                return object;
            var message = new $root.RemoteFortressReader.Hair();
            if (object.length != null)
                message.length = object.length | 0;
            switch (object.style) {
            case "UNKEMPT":
            case -1:
                message.style = -1;
                break;
            case "NEATLY_COMBED":
            case 0:
                message.style = 0;
                break;
            case "BRAIDED":
            case 1:
                message.style = 1;
                break;
            case "DOUBLE_BRAID":
            case 2:
                message.style = 2;
                break;
            case "PONY_TAILS":
            case 3:
                message.style = 3;
                break;
            case "CLEAN_SHAVEN":
            case 4:
                message.style = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Hair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.Hair} message Hair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.length = 0;
                object.style = options.enums === String ? "UNKEMPT" : -1;
            }
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = message.length;
            if (message.style != null && message.hasOwnProperty("style"))
                object.style = options.enums === String ? $root.RemoteFortressReader.HairStyle[message.style] : message.style;
            return object;
        };

        /**
         * Converts this Hair to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Hair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Hair;
    })();

    RemoteFortressReader.BodySizeInfo = (function() {

        /**
         * Properties of a BodySizeInfo.
         * @memberof RemoteFortressReader
         * @interface IBodySizeInfo
         * @property {number|null} [sizeCur] BodySizeInfo sizeCur
         * @property {number|null} [sizeBase] BodySizeInfo sizeBase
         * @property {number|null} [areaCur] BodySizeInfo areaCur
         * @property {number|null} [areaBase] BodySizeInfo areaBase
         * @property {number|null} [lengthCur] BodySizeInfo lengthCur
         * @property {number|null} [lengthBase] BodySizeInfo lengthBase
         */

        /**
         * Constructs a new BodySizeInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BodySizeInfo.
         * @implements IBodySizeInfo
         * @constructor
         * @param {RemoteFortressReader.IBodySizeInfo=} [properties] Properties to set
         */
        function BodySizeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BodySizeInfo sizeCur.
         * @member {number} sizeCur
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.sizeCur = 0;

        /**
         * BodySizeInfo sizeBase.
         * @member {number} sizeBase
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.sizeBase = 0;

        /**
         * BodySizeInfo areaCur.
         * @member {number} areaCur
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.areaCur = 0;

        /**
         * BodySizeInfo areaBase.
         * @member {number} areaBase
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.areaBase = 0;

        /**
         * BodySizeInfo lengthCur.
         * @member {number} lengthCur
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.lengthCur = 0;

        /**
         * BodySizeInfo lengthBase.
         * @member {number} lengthBase
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.lengthBase = 0;

        /**
         * Creates a new BodySizeInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.IBodySizeInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo instance
         */
        BodySizeInfo.create = function create(properties) {
            return new BodySizeInfo(properties);
        };

        /**
         * Encodes the specified BodySizeInfo message. Does not implicitly {@link RemoteFortressReader.BodySizeInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.IBodySizeInfo} message BodySizeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodySizeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sizeCur != null && message.hasOwnProperty("sizeCur"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sizeCur);
            if (message.sizeBase != null && message.hasOwnProperty("sizeBase"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sizeBase);
            if (message.areaCur != null && message.hasOwnProperty("areaCur"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.areaCur);
            if (message.areaBase != null && message.hasOwnProperty("areaBase"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.areaBase);
            if (message.lengthCur != null && message.hasOwnProperty("lengthCur"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lengthCur);
            if (message.lengthBase != null && message.hasOwnProperty("lengthBase"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lengthBase);
            return writer;
        };

        /**
         * Encodes the specified BodySizeInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.BodySizeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.IBodySizeInfo} message BodySizeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodySizeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BodySizeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodySizeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BodySizeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sizeCur = reader.int32();
                    break;
                case 2:
                    message.sizeBase = reader.int32();
                    break;
                case 3:
                    message.areaCur = reader.int32();
                    break;
                case 4:
                    message.areaBase = reader.int32();
                    break;
                case 5:
                    message.lengthCur = reader.int32();
                    break;
                case 6:
                    message.lengthBase = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BodySizeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodySizeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BodySizeInfo message.
         * @function verify
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BodySizeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sizeCur != null && message.hasOwnProperty("sizeCur"))
                if (!$util.isInteger(message.sizeCur))
                    return "sizeCur: integer expected";
            if (message.sizeBase != null && message.hasOwnProperty("sizeBase"))
                if (!$util.isInteger(message.sizeBase))
                    return "sizeBase: integer expected";
            if (message.areaCur != null && message.hasOwnProperty("areaCur"))
                if (!$util.isInteger(message.areaCur))
                    return "areaCur: integer expected";
            if (message.areaBase != null && message.hasOwnProperty("areaBase"))
                if (!$util.isInteger(message.areaBase))
                    return "areaBase: integer expected";
            if (message.lengthCur != null && message.hasOwnProperty("lengthCur"))
                if (!$util.isInteger(message.lengthCur))
                    return "lengthCur: integer expected";
            if (message.lengthBase != null && message.hasOwnProperty("lengthBase"))
                if (!$util.isInteger(message.lengthBase))
                    return "lengthBase: integer expected";
            return null;
        };

        /**
         * Creates a BodySizeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo
         */
        BodySizeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BodySizeInfo)
                return object;
            var message = new $root.RemoteFortressReader.BodySizeInfo();
            if (object.sizeCur != null)
                message.sizeCur = object.sizeCur | 0;
            if (object.sizeBase != null)
                message.sizeBase = object.sizeBase | 0;
            if (object.areaCur != null)
                message.areaCur = object.areaCur | 0;
            if (object.areaBase != null)
                message.areaBase = object.areaBase | 0;
            if (object.lengthCur != null)
                message.lengthCur = object.lengthCur | 0;
            if (object.lengthBase != null)
                message.lengthBase = object.lengthBase | 0;
            return message;
        };

        /**
         * Creates a plain object from a BodySizeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.BodySizeInfo} message BodySizeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BodySizeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sizeCur = 0;
                object.sizeBase = 0;
                object.areaCur = 0;
                object.areaBase = 0;
                object.lengthCur = 0;
                object.lengthBase = 0;
            }
            if (message.sizeCur != null && message.hasOwnProperty("sizeCur"))
                object.sizeCur = message.sizeCur;
            if (message.sizeBase != null && message.hasOwnProperty("sizeBase"))
                object.sizeBase = message.sizeBase;
            if (message.areaCur != null && message.hasOwnProperty("areaCur"))
                object.areaCur = message.areaCur;
            if (message.areaBase != null && message.hasOwnProperty("areaBase"))
                object.areaBase = message.areaBase;
            if (message.lengthCur != null && message.hasOwnProperty("lengthCur"))
                object.lengthCur = message.lengthCur;
            if (message.lengthBase != null && message.hasOwnProperty("lengthBase"))
                object.lengthBase = message.lengthBase;
            return object;
        };

        /**
         * Converts this BodySizeInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BodySizeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BodySizeInfo;
    })();

    RemoteFortressReader.UnitAppearance = (function() {

        /**
         * Properties of an UnitAppearance.
         * @memberof RemoteFortressReader
         * @interface IUnitAppearance
         * @property {Array.<number>|null} [bodyModifiers] UnitAppearance bodyModifiers
         * @property {Array.<number>|null} [bpModifiers] UnitAppearance bpModifiers
         * @property {number|null} [sizeModifier] UnitAppearance sizeModifier
         * @property {Array.<number>|null} [colors] UnitAppearance colors
         * @property {RemoteFortressReader.IHair|null} [hair] UnitAppearance hair
         * @property {RemoteFortressReader.IHair|null} [beard] UnitAppearance beard
         * @property {RemoteFortressReader.IHair|null} [moustache] UnitAppearance moustache
         * @property {RemoteFortressReader.IHair|null} [sideburns] UnitAppearance sideburns
         */

        /**
         * Constructs a new UnitAppearance.
         * @memberof RemoteFortressReader
         * @classdesc Represents an UnitAppearance.
         * @implements IUnitAppearance
         * @constructor
         * @param {RemoteFortressReader.IUnitAppearance=} [properties] Properties to set
         */
        function UnitAppearance(properties) {
            this.bodyModifiers = [];
            this.bpModifiers = [];
            this.colors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitAppearance bodyModifiers.
         * @member {Array.<number>} bodyModifiers
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.bodyModifiers = $util.emptyArray;

        /**
         * UnitAppearance bpModifiers.
         * @member {Array.<number>} bpModifiers
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.bpModifiers = $util.emptyArray;

        /**
         * UnitAppearance sizeModifier.
         * @member {number} sizeModifier
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.sizeModifier = 0;

        /**
         * UnitAppearance colors.
         * @member {Array.<number>} colors
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.colors = $util.emptyArray;

        /**
         * UnitAppearance hair.
         * @member {RemoteFortressReader.IHair|null|undefined} hair
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.hair = null;

        /**
         * UnitAppearance beard.
         * @member {RemoteFortressReader.IHair|null|undefined} beard
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.beard = null;

        /**
         * UnitAppearance moustache.
         * @member {RemoteFortressReader.IHair|null|undefined} moustache
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.moustache = null;

        /**
         * UnitAppearance sideburns.
         * @member {RemoteFortressReader.IHair|null|undefined} sideburns
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.sideburns = null;

        /**
         * Creates a new UnitAppearance instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.IUnitAppearance=} [properties] Properties to set
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance instance
         */
        UnitAppearance.create = function create(properties) {
            return new UnitAppearance(properties);
        };

        /**
         * Encodes the specified UnitAppearance message. Does not implicitly {@link RemoteFortressReader.UnitAppearance.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.IUnitAppearance} message UnitAppearance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitAppearance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bodyModifiers != null && message.bodyModifiers.length)
                for (var i = 0; i < message.bodyModifiers.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bodyModifiers[i]);
            if (message.bpModifiers != null && message.bpModifiers.length)
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bpModifiers[i]);
            if (message.sizeModifier != null && message.hasOwnProperty("sizeModifier"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sizeModifier);
            if (message.colors != null && message.colors.length)
                for (var i = 0; i < message.colors.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.colors[i]);
            if (message.hair != null && message.hasOwnProperty("hair"))
                $root.RemoteFortressReader.Hair.encode(message.hair, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.beard != null && message.hasOwnProperty("beard"))
                $root.RemoteFortressReader.Hair.encode(message.beard, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.moustache != null && message.hasOwnProperty("moustache"))
                $root.RemoteFortressReader.Hair.encode(message.moustache, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.sideburns != null && message.hasOwnProperty("sideburns"))
                $root.RemoteFortressReader.Hair.encode(message.sideburns, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnitAppearance message, length delimited. Does not implicitly {@link RemoteFortressReader.UnitAppearance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.IUnitAppearance} message UnitAppearance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitAppearance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitAppearance message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitAppearance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.UnitAppearance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.bodyModifiers && message.bodyModifiers.length))
                        message.bodyModifiers = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bodyModifiers.push(reader.int32());
                    } else
                        message.bodyModifiers.push(reader.int32());
                    break;
                case 2:
                    if (!(message.bpModifiers && message.bpModifiers.length))
                        message.bpModifiers = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bpModifiers.push(reader.int32());
                    } else
                        message.bpModifiers.push(reader.int32());
                    break;
                case 3:
                    message.sizeModifier = reader.int32();
                    break;
                case 4:
                    if (!(message.colors && message.colors.length))
                        message.colors = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.colors.push(reader.int32());
                    } else
                        message.colors.push(reader.int32());
                    break;
                case 5:
                    message.hair = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.beard = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.moustache = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.sideburns = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnitAppearance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitAppearance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitAppearance message.
         * @function verify
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitAppearance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bodyModifiers != null && message.hasOwnProperty("bodyModifiers")) {
                if (!Array.isArray(message.bodyModifiers))
                    return "bodyModifiers: array expected";
                for (var i = 0; i < message.bodyModifiers.length; ++i)
                    if (!$util.isInteger(message.bodyModifiers[i]))
                        return "bodyModifiers: integer[] expected";
            }
            if (message.bpModifiers != null && message.hasOwnProperty("bpModifiers")) {
                if (!Array.isArray(message.bpModifiers))
                    return "bpModifiers: array expected";
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    if (!$util.isInteger(message.bpModifiers[i]))
                        return "bpModifiers: integer[] expected";
            }
            if (message.sizeModifier != null && message.hasOwnProperty("sizeModifier"))
                if (!$util.isInteger(message.sizeModifier))
                    return "sizeModifier: integer expected";
            if (message.colors != null && message.hasOwnProperty("colors")) {
                if (!Array.isArray(message.colors))
                    return "colors: array expected";
                for (var i = 0; i < message.colors.length; ++i)
                    if (!$util.isInteger(message.colors[i]))
                        return "colors: integer[] expected";
            }
            if (message.hair != null && message.hasOwnProperty("hair")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.hair);
                if (error)
                    return "hair." + error;
            }
            if (message.beard != null && message.hasOwnProperty("beard")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.beard);
                if (error)
                    return "beard." + error;
            }
            if (message.moustache != null && message.hasOwnProperty("moustache")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.moustache);
                if (error)
                    return "moustache." + error;
            }
            if (message.sideburns != null && message.hasOwnProperty("sideburns")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.sideburns);
                if (error)
                    return "sideburns." + error;
            }
            return null;
        };

        /**
         * Creates an UnitAppearance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance
         */
        UnitAppearance.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.UnitAppearance)
                return object;
            var message = new $root.RemoteFortressReader.UnitAppearance();
            if (object.bodyModifiers) {
                if (!Array.isArray(object.bodyModifiers))
                    throw TypeError(".RemoteFortressReader.UnitAppearance.bodyModifiers: array expected");
                message.bodyModifiers = [];
                for (var i = 0; i < object.bodyModifiers.length; ++i)
                    message.bodyModifiers[i] = object.bodyModifiers[i] | 0;
            }
            if (object.bpModifiers) {
                if (!Array.isArray(object.bpModifiers))
                    throw TypeError(".RemoteFortressReader.UnitAppearance.bpModifiers: array expected");
                message.bpModifiers = [];
                for (var i = 0; i < object.bpModifiers.length; ++i)
                    message.bpModifiers[i] = object.bpModifiers[i] | 0;
            }
            if (object.sizeModifier != null)
                message.sizeModifier = object.sizeModifier | 0;
            if (object.colors) {
                if (!Array.isArray(object.colors))
                    throw TypeError(".RemoteFortressReader.UnitAppearance.colors: array expected");
                message.colors = [];
                for (var i = 0; i < object.colors.length; ++i)
                    message.colors[i] = object.colors[i] | 0;
            }
            if (object.hair != null) {
                if (typeof object.hair !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.hair: object expected");
                message.hair = $root.RemoteFortressReader.Hair.fromObject(object.hair);
            }
            if (object.beard != null) {
                if (typeof object.beard !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.beard: object expected");
                message.beard = $root.RemoteFortressReader.Hair.fromObject(object.beard);
            }
            if (object.moustache != null) {
                if (typeof object.moustache !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.moustache: object expected");
                message.moustache = $root.RemoteFortressReader.Hair.fromObject(object.moustache);
            }
            if (object.sideburns != null) {
                if (typeof object.sideburns !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.sideburns: object expected");
                message.sideburns = $root.RemoteFortressReader.Hair.fromObject(object.sideburns);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnitAppearance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.UnitAppearance} message UnitAppearance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitAppearance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.bodyModifiers = [];
                object.bpModifiers = [];
                object.colors = [];
            }
            if (options.defaults) {
                object.sizeModifier = 0;
                object.hair = null;
                object.beard = null;
                object.moustache = null;
                object.sideburns = null;
            }
            if (message.bodyModifiers && message.bodyModifiers.length) {
                object.bodyModifiers = [];
                for (var j = 0; j < message.bodyModifiers.length; ++j)
                    object.bodyModifiers[j] = message.bodyModifiers[j];
            }
            if (message.bpModifiers && message.bpModifiers.length) {
                object.bpModifiers = [];
                for (var j = 0; j < message.bpModifiers.length; ++j)
                    object.bpModifiers[j] = message.bpModifiers[j];
            }
            if (message.sizeModifier != null && message.hasOwnProperty("sizeModifier"))
                object.sizeModifier = message.sizeModifier;
            if (message.colors && message.colors.length) {
                object.colors = [];
                for (var j = 0; j < message.colors.length; ++j)
                    object.colors[j] = message.colors[j];
            }
            if (message.hair != null && message.hasOwnProperty("hair"))
                object.hair = $root.RemoteFortressReader.Hair.toObject(message.hair, options);
            if (message.beard != null && message.hasOwnProperty("beard"))
                object.beard = $root.RemoteFortressReader.Hair.toObject(message.beard, options);
            if (message.moustache != null && message.hasOwnProperty("moustache"))
                object.moustache = $root.RemoteFortressReader.Hair.toObject(message.moustache, options);
            if (message.sideburns != null && message.hasOwnProperty("sideburns"))
                object.sideburns = $root.RemoteFortressReader.Hair.toObject(message.sideburns, options);
            return object;
        };

        /**
         * Converts this UnitAppearance to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitAppearance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitAppearance;
    })();

    RemoteFortressReader.InventoryItem = (function() {

        /**
         * Properties of an InventoryItem.
         * @memberof RemoteFortressReader
         * @interface IInventoryItem
         * @property {RemoteFortressReader.InventoryMode|null} [mode] InventoryItem mode
         * @property {RemoteFortressReader.IItem|null} [item] InventoryItem item
         */

        /**
         * Constructs a new InventoryItem.
         * @memberof RemoteFortressReader
         * @classdesc Represents an InventoryItem.
         * @implements IInventoryItem
         * @constructor
         * @param {RemoteFortressReader.IInventoryItem=} [properties] Properties to set
         */
        function InventoryItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InventoryItem mode.
         * @member {RemoteFortressReader.InventoryMode} mode
         * @memberof RemoteFortressReader.InventoryItem
         * @instance
         */
        InventoryItem.prototype.mode = 0;

        /**
         * InventoryItem item.
         * @member {RemoteFortressReader.IItem|null|undefined} item
         * @memberof RemoteFortressReader.InventoryItem
         * @instance
         */
        InventoryItem.prototype.item = null;

        /**
         * Creates a new InventoryItem instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.IInventoryItem=} [properties] Properties to set
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem instance
         */
        InventoryItem.create = function create(properties) {
            return new InventoryItem(properties);
        };

        /**
         * Encodes the specified InventoryItem message. Does not implicitly {@link RemoteFortressReader.InventoryItem.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.IInventoryItem} message InventoryItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InventoryItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && message.hasOwnProperty("mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            if (message.item != null && message.hasOwnProperty("item"))
                $root.RemoteFortressReader.Item.encode(message.item, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InventoryItem message, length delimited. Does not implicitly {@link RemoteFortressReader.InventoryItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.IInventoryItem} message InventoryItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InventoryItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InventoryItem message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InventoryItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.InventoryItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                case 2:
                    message.item = $root.RemoteFortressReader.Item.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InventoryItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InventoryItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InventoryItem message.
         * @function verify
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InventoryItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                default:
                    return "mode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.Item.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates an InventoryItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem
         */
        InventoryItem.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.InventoryItem)
                return object;
            var message = new $root.RemoteFortressReader.InventoryItem();
            switch (object.mode) {
            case "Hauled":
            case 0:
                message.mode = 0;
                break;
            case "Weapon":
            case 1:
                message.mode = 1;
                break;
            case "Worn":
            case 2:
                message.mode = 2;
                break;
            case "Piercing":
            case 3:
                message.mode = 3;
                break;
            case "Flask":
            case 4:
                message.mode = 4;
                break;
            case "WrappedAround":
            case 5:
                message.mode = 5;
                break;
            case "StuckIn":
            case 6:
                message.mode = 6;
                break;
            case "InMouth":
            case 7:
                message.mode = 7;
                break;
            case "Pet":
            case 8:
                message.mode = 8;
                break;
            case "SewnInto":
            case 9:
                message.mode = 9;
                break;
            case "Strapped":
            case 10:
                message.mode = 10;
                break;
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.InventoryItem.item: object expected");
                message.item = $root.RemoteFortressReader.Item.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from an InventoryItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.InventoryItem} message InventoryItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InventoryItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mode = options.enums === String ? "Hauled" : 0;
                object.item = null;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.RemoteFortressReader.InventoryMode[message.mode] : message.mode;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.Item.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this InventoryItem to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.InventoryItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InventoryItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InventoryItem;
    })();

    RemoteFortressReader.UnitDefinition = (function() {

        /**
         * Properties of an UnitDefinition.
         * @memberof RemoteFortressReader
         * @interface IUnitDefinition
         * @property {number} id UnitDefinition id
         * @property {boolean|null} [isValid] UnitDefinition isValid
         * @property {number|null} [posX] UnitDefinition posX
         * @property {number|null} [posY] UnitDefinition posY
         * @property {number|null} [posZ] UnitDefinition posZ
         * @property {RemoteFortressReader.IMatPair|null} [race] UnitDefinition race
         * @property {RemoteFortressReader.IColorDefinition|null} [professionColor] UnitDefinition professionColor
         * @property {number|null} [flags1] UnitDefinition flags1
         * @property {number|null} [flags2] UnitDefinition flags2
         * @property {number|null} [flags3] UnitDefinition flags3
         * @property {boolean|null} [isSoldier] UnitDefinition isSoldier
         * @property {RemoteFortressReader.IBodySizeInfo|null} [sizeInfo] UnitDefinition sizeInfo
         * @property {string|null} [name] UnitDefinition name
         * @property {number|null} [bloodMax] UnitDefinition bloodMax
         * @property {number|null} [bloodCount] UnitDefinition bloodCount
         * @property {RemoteFortressReader.IUnitAppearance|null} [appearance] UnitDefinition appearance
         * @property {number|null} [professionId] UnitDefinition professionId
         * @property {Array.<string>|null} [noblePositions] UnitDefinition noblePositions
         * @property {number|null} [riderId] UnitDefinition riderId
         * @property {Array.<RemoteFortressReader.IInventoryItem>|null} [inventory] UnitDefinition inventory
         * @property {number|null} [subposX] UnitDefinition subposX
         * @property {number|null} [subposY] UnitDefinition subposY
         * @property {number|null} [subposZ] UnitDefinition subposZ
         */

        /**
         * Constructs a new UnitDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents an UnitDefinition.
         * @implements IUnitDefinition
         * @constructor
         * @param {RemoteFortressReader.IUnitDefinition=} [properties] Properties to set
         */
        function UnitDefinition(properties) {
            this.noblePositions = [];
            this.inventory = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitDefinition id.
         * @member {number} id
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.id = 0;

        /**
         * UnitDefinition isValid.
         * @member {boolean} isValid
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.isValid = false;

        /**
         * UnitDefinition posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.posX = 0;

        /**
         * UnitDefinition posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.posY = 0;

        /**
         * UnitDefinition posZ.
         * @member {number} posZ
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.posZ = 0;

        /**
         * UnitDefinition race.
         * @member {RemoteFortressReader.IMatPair|null|undefined} race
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.race = null;

        /**
         * UnitDefinition professionColor.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} professionColor
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.professionColor = null;

        /**
         * UnitDefinition flags1.
         * @member {number} flags1
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.flags1 = 0;

        /**
         * UnitDefinition flags2.
         * @member {number} flags2
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.flags2 = 0;

        /**
         * UnitDefinition flags3.
         * @member {number} flags3
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.flags3 = 0;

        /**
         * UnitDefinition isSoldier.
         * @member {boolean} isSoldier
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.isSoldier = false;

        /**
         * UnitDefinition sizeInfo.
         * @member {RemoteFortressReader.IBodySizeInfo|null|undefined} sizeInfo
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.sizeInfo = null;

        /**
         * UnitDefinition name.
         * @member {string} name
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.name = "";

        /**
         * UnitDefinition bloodMax.
         * @member {number} bloodMax
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.bloodMax = 0;

        /**
         * UnitDefinition bloodCount.
         * @member {number} bloodCount
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.bloodCount = 0;

        /**
         * UnitDefinition appearance.
         * @member {RemoteFortressReader.IUnitAppearance|null|undefined} appearance
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.appearance = null;

        /**
         * UnitDefinition professionId.
         * @member {number} professionId
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.professionId = 0;

        /**
         * UnitDefinition noblePositions.
         * @member {Array.<string>} noblePositions
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.noblePositions = $util.emptyArray;

        /**
         * UnitDefinition riderId.
         * @member {number} riderId
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.riderId = 0;

        /**
         * UnitDefinition inventory.
         * @member {Array.<RemoteFortressReader.IInventoryItem>} inventory
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.inventory = $util.emptyArray;

        /**
         * UnitDefinition subposX.
         * @member {number} subposX
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.subposX = 0;

        /**
         * UnitDefinition subposY.
         * @member {number} subposY
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.subposY = 0;

        /**
         * UnitDefinition subposZ.
         * @member {number} subposZ
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.subposZ = 0;

        /**
         * Creates a new UnitDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.IUnitDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition instance
         */
        UnitDefinition.create = function create(properties) {
            return new UnitDefinition(properties);
        };

        /**
         * Encodes the specified UnitDefinition message. Does not implicitly {@link RemoteFortressReader.UnitDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.IUnitDefinition} message UnitDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isValid);
            if (message.posX != null && message.hasOwnProperty("posX"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posX);
            if (message.posY != null && message.hasOwnProperty("posY"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.posY);
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.posZ);
            if (message.race != null && message.hasOwnProperty("race"))
                $root.RemoteFortressReader.MatPair.encode(message.race, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.professionColor != null && message.hasOwnProperty("professionColor"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.professionColor, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags1);
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags2);
            if (message.flags3 != null && message.hasOwnProperty("flags3"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.flags3);
            if (message.isSoldier != null && message.hasOwnProperty("isSoldier"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isSoldier);
            if (message.sizeInfo != null && message.hasOwnProperty("sizeInfo"))
                $root.RemoteFortressReader.BodySizeInfo.encode(message.sizeInfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.name);
            if (message.bloodMax != null && message.hasOwnProperty("bloodMax"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.bloodMax);
            if (message.bloodCount != null && message.hasOwnProperty("bloodCount"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.bloodCount);
            if (message.appearance != null && message.hasOwnProperty("appearance"))
                $root.RemoteFortressReader.UnitAppearance.encode(message.appearance, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.professionId != null && message.hasOwnProperty("professionId"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.professionId);
            if (message.noblePositions != null && message.noblePositions.length)
                for (var i = 0; i < message.noblePositions.length; ++i)
                    writer.uint32(/* id 18, wireType 2 =*/146).string(message.noblePositions[i]);
            if (message.riderId != null && message.hasOwnProperty("riderId"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.riderId);
            if (message.inventory != null && message.inventory.length)
                for (var i = 0; i < message.inventory.length; ++i)
                    $root.RemoteFortressReader.InventoryItem.encode(message.inventory[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.subposX);
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.subposY);
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.subposZ);
            return writer;
        };

        /**
         * Encodes the specified UnitDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.UnitDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.IUnitDefinition} message UnitDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.UnitDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.isValid = reader.bool();
                    break;
                case 3:
                    message.posX = reader.int32();
                    break;
                case 4:
                    message.posY = reader.int32();
                    break;
                case 5:
                    message.posZ = reader.int32();
                    break;
                case 6:
                    message.race = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.professionColor = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.flags1 = reader.uint32();
                    break;
                case 9:
                    message.flags2 = reader.uint32();
                    break;
                case 10:
                    message.flags3 = reader.uint32();
                    break;
                case 11:
                    message.isSoldier = reader.bool();
                    break;
                case 12:
                    message.sizeInfo = $root.RemoteFortressReader.BodySizeInfo.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.name = reader.string();
                    break;
                case 14:
                    message.bloodMax = reader.int32();
                    break;
                case 15:
                    message.bloodCount = reader.int32();
                    break;
                case 16:
                    message.appearance = $root.RemoteFortressReader.UnitAppearance.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.professionId = reader.int32();
                    break;
                case 18:
                    if (!(message.noblePositions && message.noblePositions.length))
                        message.noblePositions = [];
                    message.noblePositions.push(reader.string());
                    break;
                case 19:
                    message.riderId = reader.int32();
                    break;
                case 20:
                    if (!(message.inventory && message.inventory.length))
                        message.inventory = [];
                    message.inventory.push($root.RemoteFortressReader.InventoryItem.decode(reader, reader.uint32()));
                    break;
                case 21:
                    message.subposX = reader.float();
                    break;
                case 22:
                    message.subposY = reader.float();
                    break;
                case 23:
                    message.subposZ = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnitDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                if (typeof message.isValid !== "boolean")
                    return "isValid: boolean expected";
            if (message.posX != null && message.hasOwnProperty("posX"))
                if (!$util.isInteger(message.posX))
                    return "posX: integer expected";
            if (message.posY != null && message.hasOwnProperty("posY"))
                if (!$util.isInteger(message.posY))
                    return "posY: integer expected";
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                if (!$util.isInteger(message.posZ))
                    return "posZ: integer expected";
            if (message.race != null && message.hasOwnProperty("race")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.race);
                if (error)
                    return "race." + error;
            }
            if (message.professionColor != null && message.hasOwnProperty("professionColor")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.professionColor);
                if (error)
                    return "professionColor." + error;
            }
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                if (!$util.isInteger(message.flags1))
                    return "flags1: integer expected";
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                if (!$util.isInteger(message.flags2))
                    return "flags2: integer expected";
            if (message.flags3 != null && message.hasOwnProperty("flags3"))
                if (!$util.isInteger(message.flags3))
                    return "flags3: integer expected";
            if (message.isSoldier != null && message.hasOwnProperty("isSoldier"))
                if (typeof message.isSoldier !== "boolean")
                    return "isSoldier: boolean expected";
            if (message.sizeInfo != null && message.hasOwnProperty("sizeInfo")) {
                var error = $root.RemoteFortressReader.BodySizeInfo.verify(message.sizeInfo);
                if (error)
                    return "sizeInfo." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.bloodMax != null && message.hasOwnProperty("bloodMax"))
                if (!$util.isInteger(message.bloodMax))
                    return "bloodMax: integer expected";
            if (message.bloodCount != null && message.hasOwnProperty("bloodCount"))
                if (!$util.isInteger(message.bloodCount))
                    return "bloodCount: integer expected";
            if (message.appearance != null && message.hasOwnProperty("appearance")) {
                var error = $root.RemoteFortressReader.UnitAppearance.verify(message.appearance);
                if (error)
                    return "appearance." + error;
            }
            if (message.professionId != null && message.hasOwnProperty("professionId"))
                if (!$util.isInteger(message.professionId))
                    return "professionId: integer expected";
            if (message.noblePositions != null && message.hasOwnProperty("noblePositions")) {
                if (!Array.isArray(message.noblePositions))
                    return "noblePositions: array expected";
                for (var i = 0; i < message.noblePositions.length; ++i)
                    if (!$util.isString(message.noblePositions[i]))
                        return "noblePositions: string[] expected";
            }
            if (message.riderId != null && message.hasOwnProperty("riderId"))
                if (!$util.isInteger(message.riderId))
                    return "riderId: integer expected";
            if (message.inventory != null && message.hasOwnProperty("inventory")) {
                if (!Array.isArray(message.inventory))
                    return "inventory: array expected";
                for (var i = 0; i < message.inventory.length; ++i) {
                    var error = $root.RemoteFortressReader.InventoryItem.verify(message.inventory[i]);
                    if (error)
                        return "inventory." + error;
                }
            }
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                if (typeof message.subposX !== "number")
                    return "subposX: number expected";
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                if (typeof message.subposY !== "number")
                    return "subposY: number expected";
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                if (typeof message.subposZ !== "number")
                    return "subposZ: number expected";
            return null;
        };

        /**
         * Creates an UnitDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition
         */
        UnitDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.UnitDefinition)
                return object;
            var message = new $root.RemoteFortressReader.UnitDefinition();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.isValid != null)
                message.isValid = Boolean(object.isValid);
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.posZ != null)
                message.posZ = object.posZ | 0;
            if (object.race != null) {
                if (typeof object.race !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.race: object expected");
                message.race = $root.RemoteFortressReader.MatPair.fromObject(object.race);
            }
            if (object.professionColor != null) {
                if (typeof object.professionColor !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.professionColor: object expected");
                message.professionColor = $root.RemoteFortressReader.ColorDefinition.fromObject(object.professionColor);
            }
            if (object.flags1 != null)
                message.flags1 = object.flags1 >>> 0;
            if (object.flags2 != null)
                message.flags2 = object.flags2 >>> 0;
            if (object.flags3 != null)
                message.flags3 = object.flags3 >>> 0;
            if (object.isSoldier != null)
                message.isSoldier = Boolean(object.isSoldier);
            if (object.sizeInfo != null) {
                if (typeof object.sizeInfo !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.sizeInfo: object expected");
                message.sizeInfo = $root.RemoteFortressReader.BodySizeInfo.fromObject(object.sizeInfo);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.bloodMax != null)
                message.bloodMax = object.bloodMax | 0;
            if (object.bloodCount != null)
                message.bloodCount = object.bloodCount | 0;
            if (object.appearance != null) {
                if (typeof object.appearance !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.appearance: object expected");
                message.appearance = $root.RemoteFortressReader.UnitAppearance.fromObject(object.appearance);
            }
            if (object.professionId != null)
                message.professionId = object.professionId | 0;
            if (object.noblePositions) {
                if (!Array.isArray(object.noblePositions))
                    throw TypeError(".RemoteFortressReader.UnitDefinition.noblePositions: array expected");
                message.noblePositions = [];
                for (var i = 0; i < object.noblePositions.length; ++i)
                    message.noblePositions[i] = String(object.noblePositions[i]);
            }
            if (object.riderId != null)
                message.riderId = object.riderId | 0;
            if (object.inventory) {
                if (!Array.isArray(object.inventory))
                    throw TypeError(".RemoteFortressReader.UnitDefinition.inventory: array expected");
                message.inventory = [];
                for (var i = 0; i < object.inventory.length; ++i) {
                    if (typeof object.inventory[i] !== "object")
                        throw TypeError(".RemoteFortressReader.UnitDefinition.inventory: object expected");
                    message.inventory[i] = $root.RemoteFortressReader.InventoryItem.fromObject(object.inventory[i]);
                }
            }
            if (object.subposX != null)
                message.subposX = Number(object.subposX);
            if (object.subposY != null)
                message.subposY = Number(object.subposY);
            if (object.subposZ != null)
                message.subposZ = Number(object.subposZ);
            return message;
        };

        /**
         * Creates a plain object from an UnitDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.UnitDefinition} message UnitDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.noblePositions = [];
                object.inventory = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.isValid = false;
                object.posX = 0;
                object.posY = 0;
                object.posZ = 0;
                object.race = null;
                object.professionColor = null;
                object.flags1 = 0;
                object.flags2 = 0;
                object.flags3 = 0;
                object.isSoldier = false;
                object.sizeInfo = null;
                object.name = "";
                object.bloodMax = 0;
                object.bloodCount = 0;
                object.appearance = null;
                object.professionId = 0;
                object.riderId = 0;
                object.subposX = 0;
                object.subposY = 0;
                object.subposZ = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                object.isValid = message.isValid;
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                object.posZ = message.posZ;
            if (message.race != null && message.hasOwnProperty("race"))
                object.race = $root.RemoteFortressReader.MatPair.toObject(message.race, options);
            if (message.professionColor != null && message.hasOwnProperty("professionColor"))
                object.professionColor = $root.RemoteFortressReader.ColorDefinition.toObject(message.professionColor, options);
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                object.flags1 = message.flags1;
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                object.flags2 = message.flags2;
            if (message.flags3 != null && message.hasOwnProperty("flags3"))
                object.flags3 = message.flags3;
            if (message.isSoldier != null && message.hasOwnProperty("isSoldier"))
                object.isSoldier = message.isSoldier;
            if (message.sizeInfo != null && message.hasOwnProperty("sizeInfo"))
                object.sizeInfo = $root.RemoteFortressReader.BodySizeInfo.toObject(message.sizeInfo, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.bloodMax != null && message.hasOwnProperty("bloodMax"))
                object.bloodMax = message.bloodMax;
            if (message.bloodCount != null && message.hasOwnProperty("bloodCount"))
                object.bloodCount = message.bloodCount;
            if (message.appearance != null && message.hasOwnProperty("appearance"))
                object.appearance = $root.RemoteFortressReader.UnitAppearance.toObject(message.appearance, options);
            if (message.professionId != null && message.hasOwnProperty("professionId"))
                object.professionId = message.professionId;
            if (message.noblePositions && message.noblePositions.length) {
                object.noblePositions = [];
                for (var j = 0; j < message.noblePositions.length; ++j)
                    object.noblePositions[j] = message.noblePositions[j];
            }
            if (message.riderId != null && message.hasOwnProperty("riderId"))
                object.riderId = message.riderId;
            if (message.inventory && message.inventory.length) {
                object.inventory = [];
                for (var j = 0; j < message.inventory.length; ++j)
                    object.inventory[j] = $root.RemoteFortressReader.InventoryItem.toObject(message.inventory[j], options);
            }
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                object.subposX = options.json && !isFinite(message.subposX) ? String(message.subposX) : message.subposX;
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                object.subposY = options.json && !isFinite(message.subposY) ? String(message.subposY) : message.subposY;
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                object.subposZ = options.json && !isFinite(message.subposZ) ? String(message.subposZ) : message.subposZ;
            return object;
        };

        /**
         * Converts this UnitDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitDefinition;
    })();

    RemoteFortressReader.UnitList = (function() {

        /**
         * Properties of an UnitList.
         * @memberof RemoteFortressReader
         * @interface IUnitList
         * @property {Array.<RemoteFortressReader.IUnitDefinition>|null} [creatureList] UnitList creatureList
         */

        /**
         * Constructs a new UnitList.
         * @memberof RemoteFortressReader
         * @classdesc Represents an UnitList.
         * @implements IUnitList
         * @constructor
         * @param {RemoteFortressReader.IUnitList=} [properties] Properties to set
         */
        function UnitList(properties) {
            this.creatureList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitList creatureList.
         * @member {Array.<RemoteFortressReader.IUnitDefinition>} creatureList
         * @memberof RemoteFortressReader.UnitList
         * @instance
         */
        UnitList.prototype.creatureList = $util.emptyArray;

        /**
         * Creates a new UnitList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.IUnitList=} [properties] Properties to set
         * @returns {RemoteFortressReader.UnitList} UnitList instance
         */
        UnitList.create = function create(properties) {
            return new UnitList(properties);
        };

        /**
         * Encodes the specified UnitList message. Does not implicitly {@link RemoteFortressReader.UnitList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.IUnitList} message UnitList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creatureList != null && message.creatureList.length)
                for (var i = 0; i < message.creatureList.length; ++i)
                    $root.RemoteFortressReader.UnitDefinition.encode(message.creatureList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnitList message, length delimited. Does not implicitly {@link RemoteFortressReader.UnitList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.IUnitList} message UnitList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.UnitList} UnitList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.UnitList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.creatureList && message.creatureList.length))
                        message.creatureList = [];
                    message.creatureList.push($root.RemoteFortressReader.UnitDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnitList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.UnitList} UnitList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitList message.
         * @function verify
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creatureList != null && message.hasOwnProperty("creatureList")) {
                if (!Array.isArray(message.creatureList))
                    return "creatureList: array expected";
                for (var i = 0; i < message.creatureList.length; ++i) {
                    var error = $root.RemoteFortressReader.UnitDefinition.verify(message.creatureList[i]);
                    if (error)
                        return "creatureList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UnitList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.UnitList} UnitList
         */
        UnitList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.UnitList)
                return object;
            var message = new $root.RemoteFortressReader.UnitList();
            if (object.creatureList) {
                if (!Array.isArray(object.creatureList))
                    throw TypeError(".RemoteFortressReader.UnitList.creatureList: array expected");
                message.creatureList = [];
                for (var i = 0; i < object.creatureList.length; ++i) {
                    if (typeof object.creatureList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.UnitList.creatureList: object expected");
                    message.creatureList[i] = $root.RemoteFortressReader.UnitDefinition.fromObject(object.creatureList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UnitList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.UnitList} message UnitList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.creatureList = [];
            if (message.creatureList && message.creatureList.length) {
                object.creatureList = [];
                for (var j = 0; j < message.creatureList.length; ++j)
                    object.creatureList[j] = $root.RemoteFortressReader.UnitDefinition.toObject(message.creatureList[j], options);
            }
            return object;
        };

        /**
         * Converts this UnitList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.UnitList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitList;
    })();

    RemoteFortressReader.BlockRequest = (function() {

        /**
         * Properties of a BlockRequest.
         * @memberof RemoteFortressReader
         * @interface IBlockRequest
         * @property {number|null} [blocksNeeded] BlockRequest blocksNeeded
         * @property {number|null} [minX] BlockRequest minX
         * @property {number|null} [maxX] BlockRequest maxX
         * @property {number|null} [minY] BlockRequest minY
         * @property {number|null} [maxY] BlockRequest maxY
         * @property {number|null} [minZ] BlockRequest minZ
         * @property {number|null} [maxZ] BlockRequest maxZ
         */

        /**
         * Constructs a new BlockRequest.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BlockRequest.
         * @implements IBlockRequest
         * @constructor
         * @param {RemoteFortressReader.IBlockRequest=} [properties] Properties to set
         */
        function BlockRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockRequest blocksNeeded.
         * @member {number} blocksNeeded
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.blocksNeeded = 0;

        /**
         * BlockRequest minX.
         * @member {number} minX
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.minX = 0;

        /**
         * BlockRequest maxX.
         * @member {number} maxX
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.maxX = 0;

        /**
         * BlockRequest minY.
         * @member {number} minY
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.minY = 0;

        /**
         * BlockRequest maxY.
         * @member {number} maxY
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.maxY = 0;

        /**
         * BlockRequest minZ.
         * @member {number} minZ
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.minZ = 0;

        /**
         * BlockRequest maxZ.
         * @member {number} maxZ
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.maxZ = 0;

        /**
         * Creates a new BlockRequest instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.IBlockRequest=} [properties] Properties to set
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest instance
         */
        BlockRequest.create = function create(properties) {
            return new BlockRequest(properties);
        };

        /**
         * Encodes the specified BlockRequest message. Does not implicitly {@link RemoteFortressReader.BlockRequest.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.IBlockRequest} message BlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blocksNeeded != null && message.hasOwnProperty("blocksNeeded"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.blocksNeeded);
            if (message.minX != null && message.hasOwnProperty("minX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minX);
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxX);
            if (message.minY != null && message.hasOwnProperty("minY"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minY);
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxY);
            if (message.minZ != null && message.hasOwnProperty("minZ"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minZ);
            if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxZ);
            return writer;
        };

        /**
         * Encodes the specified BlockRequest message, length delimited. Does not implicitly {@link RemoteFortressReader.BlockRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.IBlockRequest} message BlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockRequest message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BlockRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blocksNeeded = reader.int32();
                    break;
                case 2:
                    message.minX = reader.int32();
                    break;
                case 3:
                    message.maxX = reader.int32();
                    break;
                case 4:
                    message.minY = reader.int32();
                    break;
                case 5:
                    message.maxY = reader.int32();
                    break;
                case 6:
                    message.minZ = reader.int32();
                    break;
                case 7:
                    message.maxZ = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockRequest message.
         * @function verify
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blocksNeeded != null && message.hasOwnProperty("blocksNeeded"))
                if (!$util.isInteger(message.blocksNeeded))
                    return "blocksNeeded: integer expected";
            if (message.minX != null && message.hasOwnProperty("minX"))
                if (!$util.isInteger(message.minX))
                    return "minX: integer expected";
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                if (!$util.isInteger(message.maxX))
                    return "maxX: integer expected";
            if (message.minY != null && message.hasOwnProperty("minY"))
                if (!$util.isInteger(message.minY))
                    return "minY: integer expected";
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                if (!$util.isInteger(message.maxY))
                    return "maxY: integer expected";
            if (message.minZ != null && message.hasOwnProperty("minZ"))
                if (!$util.isInteger(message.minZ))
                    return "minZ: integer expected";
            if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                if (!$util.isInteger(message.maxZ))
                    return "maxZ: integer expected";
            return null;
        };

        /**
         * Creates a BlockRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest
         */
        BlockRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BlockRequest)
                return object;
            var message = new $root.RemoteFortressReader.BlockRequest();
            if (object.blocksNeeded != null)
                message.blocksNeeded = object.blocksNeeded | 0;
            if (object.minX != null)
                message.minX = object.minX | 0;
            if (object.maxX != null)
                message.maxX = object.maxX | 0;
            if (object.minY != null)
                message.minY = object.minY | 0;
            if (object.maxY != null)
                message.maxY = object.maxY | 0;
            if (object.minZ != null)
                message.minZ = object.minZ | 0;
            if (object.maxZ != null)
                message.maxZ = object.maxZ | 0;
            return message;
        };

        /**
         * Creates a plain object from a BlockRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.BlockRequest} message BlockRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.blocksNeeded = 0;
                object.minX = 0;
                object.maxX = 0;
                object.minY = 0;
                object.maxY = 0;
                object.minZ = 0;
                object.maxZ = 0;
            }
            if (message.blocksNeeded != null && message.hasOwnProperty("blocksNeeded"))
                object.blocksNeeded = message.blocksNeeded;
            if (message.minX != null && message.hasOwnProperty("minX"))
                object.minX = message.minX;
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                object.maxX = message.maxX;
            if (message.minY != null && message.hasOwnProperty("minY"))
                object.minY = message.minY;
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                object.maxY = message.maxY;
            if (message.minZ != null && message.hasOwnProperty("minZ"))
                object.minZ = message.minZ;
            if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                object.maxZ = message.maxZ;
            return object;
        };

        /**
         * Converts this BlockRequest to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockRequest;
    })();

    RemoteFortressReader.BlockList = (function() {

        /**
         * Properties of a BlockList.
         * @memberof RemoteFortressReader
         * @interface IBlockList
         * @property {Array.<RemoteFortressReader.IMapBlock>|null} [mapBlocks] BlockList mapBlocks
         * @property {number|null} [mapX] BlockList mapX
         * @property {number|null} [mapY] BlockList mapY
         * @property {Array.<RemoteFortressReader.IEngraving>|null} [engravings] BlockList engravings
         * @property {Array.<RemoteFortressReader.IWave>|null} [oceanWaves] BlockList oceanWaves
         */

        /**
         * Constructs a new BlockList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BlockList.
         * @implements IBlockList
         * @constructor
         * @param {RemoteFortressReader.IBlockList=} [properties] Properties to set
         */
        function BlockList(properties) {
            this.mapBlocks = [];
            this.engravings = [];
            this.oceanWaves = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockList mapBlocks.
         * @member {Array.<RemoteFortressReader.IMapBlock>} mapBlocks
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.mapBlocks = $util.emptyArray;

        /**
         * BlockList mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.mapX = 0;

        /**
         * BlockList mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.mapY = 0;

        /**
         * BlockList engravings.
         * @member {Array.<RemoteFortressReader.IEngraving>} engravings
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.engravings = $util.emptyArray;

        /**
         * BlockList oceanWaves.
         * @member {Array.<RemoteFortressReader.IWave>} oceanWaves
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.oceanWaves = $util.emptyArray;

        /**
         * Creates a new BlockList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.IBlockList=} [properties] Properties to set
         * @returns {RemoteFortressReader.BlockList} BlockList instance
         */
        BlockList.create = function create(properties) {
            return new BlockList(properties);
        };

        /**
         * Encodes the specified BlockList message. Does not implicitly {@link RemoteFortressReader.BlockList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.IBlockList} message BlockList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapBlocks != null && message.mapBlocks.length)
                for (var i = 0; i < message.mapBlocks.length; ++i)
                    $root.RemoteFortressReader.MapBlock.encode(message.mapBlocks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapX);
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mapY);
            if (message.engravings != null && message.engravings.length)
                for (var i = 0; i < message.engravings.length; ++i)
                    $root.RemoteFortressReader.Engraving.encode(message.engravings[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.oceanWaves != null && message.oceanWaves.length)
                for (var i = 0; i < message.oceanWaves.length; ++i)
                    $root.RemoteFortressReader.Wave.encode(message.oceanWaves[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BlockList message, length delimited. Does not implicitly {@link RemoteFortressReader.BlockList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.IBlockList} message BlockList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BlockList} BlockList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BlockList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mapBlocks && message.mapBlocks.length))
                        message.mapBlocks = [];
                    message.mapBlocks.push($root.RemoteFortressReader.MapBlock.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.mapX = reader.int32();
                    break;
                case 3:
                    message.mapY = reader.int32();
                    break;
                case 4:
                    if (!(message.engravings && message.engravings.length))
                        message.engravings = [];
                    message.engravings.push($root.RemoteFortressReader.Engraving.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.oceanWaves && message.oceanWaves.length))
                        message.oceanWaves = [];
                    message.oceanWaves.push($root.RemoteFortressReader.Wave.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BlockList} BlockList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockList message.
         * @function verify
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapBlocks != null && message.hasOwnProperty("mapBlocks")) {
                if (!Array.isArray(message.mapBlocks))
                    return "mapBlocks: array expected";
                for (var i = 0; i < message.mapBlocks.length; ++i) {
                    var error = $root.RemoteFortressReader.MapBlock.verify(message.mapBlocks[i]);
                    if (error)
                        return "mapBlocks." + error;
                }
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                if (!$util.isInteger(message.mapX))
                    return "mapX: integer expected";
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                if (!$util.isInteger(message.mapY))
                    return "mapY: integer expected";
            if (message.engravings != null && message.hasOwnProperty("engravings")) {
                if (!Array.isArray(message.engravings))
                    return "engravings: array expected";
                for (var i = 0; i < message.engravings.length; ++i) {
                    var error = $root.RemoteFortressReader.Engraving.verify(message.engravings[i]);
                    if (error)
                        return "engravings." + error;
                }
            }
            if (message.oceanWaves != null && message.hasOwnProperty("oceanWaves")) {
                if (!Array.isArray(message.oceanWaves))
                    return "oceanWaves: array expected";
                for (var i = 0; i < message.oceanWaves.length; ++i) {
                    var error = $root.RemoteFortressReader.Wave.verify(message.oceanWaves[i]);
                    if (error)
                        return "oceanWaves." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BlockList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BlockList} BlockList
         */
        BlockList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BlockList)
                return object;
            var message = new $root.RemoteFortressReader.BlockList();
            if (object.mapBlocks) {
                if (!Array.isArray(object.mapBlocks))
                    throw TypeError(".RemoteFortressReader.BlockList.mapBlocks: array expected");
                message.mapBlocks = [];
                for (var i = 0; i < object.mapBlocks.length; ++i) {
                    if (typeof object.mapBlocks[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BlockList.mapBlocks: object expected");
                    message.mapBlocks[i] = $root.RemoteFortressReader.MapBlock.fromObject(object.mapBlocks[i]);
                }
            }
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.engravings) {
                if (!Array.isArray(object.engravings))
                    throw TypeError(".RemoteFortressReader.BlockList.engravings: array expected");
                message.engravings = [];
                for (var i = 0; i < object.engravings.length; ++i) {
                    if (typeof object.engravings[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BlockList.engravings: object expected");
                    message.engravings[i] = $root.RemoteFortressReader.Engraving.fromObject(object.engravings[i]);
                }
            }
            if (object.oceanWaves) {
                if (!Array.isArray(object.oceanWaves))
                    throw TypeError(".RemoteFortressReader.BlockList.oceanWaves: array expected");
                message.oceanWaves = [];
                for (var i = 0; i < object.oceanWaves.length; ++i) {
                    if (typeof object.oceanWaves[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BlockList.oceanWaves: object expected");
                    message.oceanWaves[i] = $root.RemoteFortressReader.Wave.fromObject(object.oceanWaves[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.BlockList} message BlockList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.mapBlocks = [];
                object.engravings = [];
                object.oceanWaves = [];
            }
            if (options.defaults) {
                object.mapX = 0;
                object.mapY = 0;
            }
            if (message.mapBlocks && message.mapBlocks.length) {
                object.mapBlocks = [];
                for (var j = 0; j < message.mapBlocks.length; ++j)
                    object.mapBlocks[j] = $root.RemoteFortressReader.MapBlock.toObject(message.mapBlocks[j], options);
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.engravings && message.engravings.length) {
                object.engravings = [];
                for (var j = 0; j < message.engravings.length; ++j)
                    object.engravings[j] = $root.RemoteFortressReader.Engraving.toObject(message.engravings[j], options);
            }
            if (message.oceanWaves && message.oceanWaves.length) {
                object.oceanWaves = [];
                for (var j = 0; j < message.oceanWaves.length; ++j)
                    object.oceanWaves[j] = $root.RemoteFortressReader.Wave.toObject(message.oceanWaves[j], options);
            }
            return object;
        };

        /**
         * Converts this BlockList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BlockList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockList;
    })();

    RemoteFortressReader.PlantDef = (function() {

        /**
         * Properties of a PlantDef.
         * @memberof RemoteFortressReader
         * @interface IPlantDef
         * @property {number} posX PlantDef posX
         * @property {number} posY PlantDef posY
         * @property {number} posZ PlantDef posZ
         * @property {number} index PlantDef index
         */

        /**
         * Constructs a new PlantDef.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantDef.
         * @implements IPlantDef
         * @constructor
         * @param {RemoteFortressReader.IPlantDef=} [properties] Properties to set
         */
        function PlantDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantDef posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.posX = 0;

        /**
         * PlantDef posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.posY = 0;

        /**
         * PlantDef posZ.
         * @member {number} posZ
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.posZ = 0;

        /**
         * PlantDef index.
         * @member {number} index
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.index = 0;

        /**
         * Creates a new PlantDef instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.IPlantDef=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantDef} PlantDef instance
         */
        PlantDef.create = function create(properties) {
            return new PlantDef(properties);
        };

        /**
         * Encodes the specified PlantDef message. Does not implicitly {@link RemoteFortressReader.PlantDef.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.IPlantDef} message PlantDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posZ);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified PlantDef message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.IPlantDef} message PlantDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantDef message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantDef} PlantDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.posX = reader.int32();
                    break;
                case 2:
                    message.posY = reader.int32();
                    break;
                case 3:
                    message.posZ = reader.int32();
                    break;
                case 4:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("posX"))
                throw $util.ProtocolError("missing required 'posX'", { instance: message });
            if (!message.hasOwnProperty("posY"))
                throw $util.ProtocolError("missing required 'posY'", { instance: message });
            if (!message.hasOwnProperty("posZ"))
                throw $util.ProtocolError("missing required 'posZ'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };

        /**
         * Decodes a PlantDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantDef} PlantDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantDef message.
         * @function verify
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
            if (!$util.isInteger(message.posZ))
                return "posZ: integer expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            return null;
        };

        /**
         * Creates a PlantDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantDef} PlantDef
         */
        PlantDef.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantDef)
                return object;
            var message = new $root.RemoteFortressReader.PlantDef();
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.posZ != null)
                message.posZ = object.posZ | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlantDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.PlantDef} message PlantDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.posX = 0;
                object.posY = 0;
                object.posZ = 0;
                object.index = 0;
            }
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                object.posZ = message.posZ;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this PlantDef to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantDef;
    })();

    RemoteFortressReader.PlantList = (function() {

        /**
         * Properties of a PlantList.
         * @memberof RemoteFortressReader
         * @interface IPlantList
         * @property {Array.<RemoteFortressReader.IPlantDef>|null} [plantList] PlantList plantList
         */

        /**
         * Constructs a new PlantList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantList.
         * @implements IPlantList
         * @constructor
         * @param {RemoteFortressReader.IPlantList=} [properties] Properties to set
         */
        function PlantList(properties) {
            this.plantList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantList plantList.
         * @member {Array.<RemoteFortressReader.IPlantDef>} plantList
         * @memberof RemoteFortressReader.PlantList
         * @instance
         */
        PlantList.prototype.plantList = $util.emptyArray;

        /**
         * Creates a new PlantList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.IPlantList=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantList} PlantList instance
         */
        PlantList.create = function create(properties) {
            return new PlantList(properties);
        };

        /**
         * Encodes the specified PlantList message. Does not implicitly {@link RemoteFortressReader.PlantList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.IPlantList} message PlantList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.plantList != null && message.plantList.length)
                for (var i = 0; i < message.plantList.length; ++i)
                    $root.RemoteFortressReader.PlantDef.encode(message.plantList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlantList message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.IPlantList} message PlantList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantList} PlantList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.plantList && message.plantList.length))
                        message.plantList = [];
                    message.plantList.push($root.RemoteFortressReader.PlantDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlantList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantList} PlantList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantList message.
         * @function verify
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.plantList != null && message.hasOwnProperty("plantList")) {
                if (!Array.isArray(message.plantList))
                    return "plantList: array expected";
                for (var i = 0; i < message.plantList.length; ++i) {
                    var error = $root.RemoteFortressReader.PlantDef.verify(message.plantList[i]);
                    if (error)
                        return "plantList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PlantList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantList} PlantList
         */
        PlantList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantList)
                return object;
            var message = new $root.RemoteFortressReader.PlantList();
            if (object.plantList) {
                if (!Array.isArray(object.plantList))
                    throw TypeError(".RemoteFortressReader.PlantList.plantList: array expected");
                message.plantList = [];
                for (var i = 0; i < object.plantList.length; ++i) {
                    if (typeof object.plantList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PlantList.plantList: object expected");
                    message.plantList[i] = $root.RemoteFortressReader.PlantDef.fromObject(object.plantList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PlantList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.PlantList} message PlantList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plantList = [];
            if (message.plantList && message.plantList.length) {
                object.plantList = [];
                for (var j = 0; j < message.plantList.length; ++j)
                    object.plantList[j] = $root.RemoteFortressReader.PlantDef.toObject(message.plantList[j], options);
            }
            return object;
        };

        /**
         * Converts this PlantList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantList;
    })();

    RemoteFortressReader.ViewInfo = (function() {

        /**
         * Properties of a ViewInfo.
         * @memberof RemoteFortressReader
         * @interface IViewInfo
         * @property {number|null} [viewPosX] ViewInfo viewPosX
         * @property {number|null} [viewPosY] ViewInfo viewPosY
         * @property {number|null} [viewPosZ] ViewInfo viewPosZ
         * @property {number|null} [viewSizeX] ViewInfo viewSizeX
         * @property {number|null} [viewSizeY] ViewInfo viewSizeY
         * @property {number|null} [cursorPosX] ViewInfo cursorPosX
         * @property {number|null} [cursorPosY] ViewInfo cursorPosY
         * @property {number|null} [cursorPosZ] ViewInfo cursorPosZ
         * @property {number|null} [followUnitId] ViewInfo followUnitId
         * @property {number|null} [followItemId] ViewInfo followItemId
         */

        /**
         * Constructs a new ViewInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ViewInfo.
         * @implements IViewInfo
         * @constructor
         * @param {RemoteFortressReader.IViewInfo=} [properties] Properties to set
         */
        function ViewInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ViewInfo viewPosX.
         * @member {number} viewPosX
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewPosX = 0;

        /**
         * ViewInfo viewPosY.
         * @member {number} viewPosY
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewPosY = 0;

        /**
         * ViewInfo viewPosZ.
         * @member {number} viewPosZ
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewPosZ = 0;

        /**
         * ViewInfo viewSizeX.
         * @member {number} viewSizeX
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewSizeX = 0;

        /**
         * ViewInfo viewSizeY.
         * @member {number} viewSizeY
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewSizeY = 0;

        /**
         * ViewInfo cursorPosX.
         * @member {number} cursorPosX
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.cursorPosX = 0;

        /**
         * ViewInfo cursorPosY.
         * @member {number} cursorPosY
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.cursorPosY = 0;

        /**
         * ViewInfo cursorPosZ.
         * @member {number} cursorPosZ
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.cursorPosZ = 0;

        /**
         * ViewInfo followUnitId.
         * @member {number} followUnitId
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.followUnitId = -1;

        /**
         * ViewInfo followItemId.
         * @member {number} followItemId
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.followItemId = -1;

        /**
         * Creates a new ViewInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.IViewInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo instance
         */
        ViewInfo.create = function create(properties) {
            return new ViewInfo(properties);
        };

        /**
         * Encodes the specified ViewInfo message. Does not implicitly {@link RemoteFortressReader.ViewInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.IViewInfo} message ViewInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ViewInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.viewPosX != null && message.hasOwnProperty("viewPosX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.viewPosX);
            if (message.viewPosY != null && message.hasOwnProperty("viewPosY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.viewPosY);
            if (message.viewPosZ != null && message.hasOwnProperty("viewPosZ"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.viewPosZ);
            if (message.viewSizeX != null && message.hasOwnProperty("viewSizeX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.viewSizeX);
            if (message.viewSizeY != null && message.hasOwnProperty("viewSizeY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.viewSizeY);
            if (message.cursorPosX != null && message.hasOwnProperty("cursorPosX"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cursorPosX);
            if (message.cursorPosY != null && message.hasOwnProperty("cursorPosY"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.cursorPosY);
            if (message.cursorPosZ != null && message.hasOwnProperty("cursorPosZ"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.cursorPosZ);
            if (message.followUnitId != null && message.hasOwnProperty("followUnitId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.followUnitId);
            if (message.followItemId != null && message.hasOwnProperty("followItemId"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.followItemId);
            return writer;
        };

        /**
         * Encodes the specified ViewInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.ViewInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.IViewInfo} message ViewInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ViewInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ViewInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ViewInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ViewInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.viewPosX = reader.int32();
                    break;
                case 2:
                    message.viewPosY = reader.int32();
                    break;
                case 3:
                    message.viewPosZ = reader.int32();
                    break;
                case 4:
                    message.viewSizeX = reader.int32();
                    break;
                case 5:
                    message.viewSizeY = reader.int32();
                    break;
                case 6:
                    message.cursorPosX = reader.int32();
                    break;
                case 7:
                    message.cursorPosY = reader.int32();
                    break;
                case 8:
                    message.cursorPosZ = reader.int32();
                    break;
                case 9:
                    message.followUnitId = reader.int32();
                    break;
                case 10:
                    message.followItemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ViewInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ViewInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ViewInfo message.
         * @function verify
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ViewInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.viewPosX != null && message.hasOwnProperty("viewPosX"))
                if (!$util.isInteger(message.viewPosX))
                    return "viewPosX: integer expected";
            if (message.viewPosY != null && message.hasOwnProperty("viewPosY"))
                if (!$util.isInteger(message.viewPosY))
                    return "viewPosY: integer expected";
            if (message.viewPosZ != null && message.hasOwnProperty("viewPosZ"))
                if (!$util.isInteger(message.viewPosZ))
                    return "viewPosZ: integer expected";
            if (message.viewSizeX != null && message.hasOwnProperty("viewSizeX"))
                if (!$util.isInteger(message.viewSizeX))
                    return "viewSizeX: integer expected";
            if (message.viewSizeY != null && message.hasOwnProperty("viewSizeY"))
                if (!$util.isInteger(message.viewSizeY))
                    return "viewSizeY: integer expected";
            if (message.cursorPosX != null && message.hasOwnProperty("cursorPosX"))
                if (!$util.isInteger(message.cursorPosX))
                    return "cursorPosX: integer expected";
            if (message.cursorPosY != null && message.hasOwnProperty("cursorPosY"))
                if (!$util.isInteger(message.cursorPosY))
                    return "cursorPosY: integer expected";
            if (message.cursorPosZ != null && message.hasOwnProperty("cursorPosZ"))
                if (!$util.isInteger(message.cursorPosZ))
                    return "cursorPosZ: integer expected";
            if (message.followUnitId != null && message.hasOwnProperty("followUnitId"))
                if (!$util.isInteger(message.followUnitId))
                    return "followUnitId: integer expected";
            if (message.followItemId != null && message.hasOwnProperty("followItemId"))
                if (!$util.isInteger(message.followItemId))
                    return "followItemId: integer expected";
            return null;
        };

        /**
         * Creates a ViewInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo
         */
        ViewInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ViewInfo)
                return object;
            var message = new $root.RemoteFortressReader.ViewInfo();
            if (object.viewPosX != null)
                message.viewPosX = object.viewPosX | 0;
            if (object.viewPosY != null)
                message.viewPosY = object.viewPosY | 0;
            if (object.viewPosZ != null)
                message.viewPosZ = object.viewPosZ | 0;
            if (object.viewSizeX != null)
                message.viewSizeX = object.viewSizeX | 0;
            if (object.viewSizeY != null)
                message.viewSizeY = object.viewSizeY | 0;
            if (object.cursorPosX != null)
                message.cursorPosX = object.cursorPosX | 0;
            if (object.cursorPosY != null)
                message.cursorPosY = object.cursorPosY | 0;
            if (object.cursorPosZ != null)
                message.cursorPosZ = object.cursorPosZ | 0;
            if (object.followUnitId != null)
                message.followUnitId = object.followUnitId | 0;
            if (object.followItemId != null)
                message.followItemId = object.followItemId | 0;
            return message;
        };

        /**
         * Creates a plain object from a ViewInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.ViewInfo} message ViewInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ViewInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.viewPosX = 0;
                object.viewPosY = 0;
                object.viewPosZ = 0;
                object.viewSizeX = 0;
                object.viewSizeY = 0;
                object.cursorPosX = 0;
                object.cursorPosY = 0;
                object.cursorPosZ = 0;
                object.followUnitId = -1;
                object.followItemId = -1;
            }
            if (message.viewPosX != null && message.hasOwnProperty("viewPosX"))
                object.viewPosX = message.viewPosX;
            if (message.viewPosY != null && message.hasOwnProperty("viewPosY"))
                object.viewPosY = message.viewPosY;
            if (message.viewPosZ != null && message.hasOwnProperty("viewPosZ"))
                object.viewPosZ = message.viewPosZ;
            if (message.viewSizeX != null && message.hasOwnProperty("viewSizeX"))
                object.viewSizeX = message.viewSizeX;
            if (message.viewSizeY != null && message.hasOwnProperty("viewSizeY"))
                object.viewSizeY = message.viewSizeY;
            if (message.cursorPosX != null && message.hasOwnProperty("cursorPosX"))
                object.cursorPosX = message.cursorPosX;
            if (message.cursorPosY != null && message.hasOwnProperty("cursorPosY"))
                object.cursorPosY = message.cursorPosY;
            if (message.cursorPosZ != null && message.hasOwnProperty("cursorPosZ"))
                object.cursorPosZ = message.cursorPosZ;
            if (message.followUnitId != null && message.hasOwnProperty("followUnitId"))
                object.followUnitId = message.followUnitId;
            if (message.followItemId != null && message.hasOwnProperty("followItemId"))
                object.followItemId = message.followItemId;
            return object;
        };

        /**
         * Converts this ViewInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ViewInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ViewInfo;
    })();

    RemoteFortressReader.MapInfo = (function() {

        /**
         * Properties of a MapInfo.
         * @memberof RemoteFortressReader
         * @interface IMapInfo
         * @property {number|null} [blockSizeX] MapInfo blockSizeX
         * @property {number|null} [blockSizeY] MapInfo blockSizeY
         * @property {number|null} [blockSizeZ] MapInfo blockSizeZ
         * @property {number|null} [blockPosX] MapInfo blockPosX
         * @property {number|null} [blockPosY] MapInfo blockPosY
         * @property {number|null} [blockPosZ] MapInfo blockPosZ
         * @property {string|null} [worldName] MapInfo worldName
         * @property {string|null} [worldNameEnglish] MapInfo worldNameEnglish
         * @property {string|null} [saveName] MapInfo saveName
         */

        /**
         * Constructs a new MapInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MapInfo.
         * @implements IMapInfo
         * @constructor
         * @param {RemoteFortressReader.IMapInfo=} [properties] Properties to set
         */
        function MapInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapInfo blockSizeX.
         * @member {number} blockSizeX
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockSizeX = 0;

        /**
         * MapInfo blockSizeY.
         * @member {number} blockSizeY
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockSizeY = 0;

        /**
         * MapInfo blockSizeZ.
         * @member {number} blockSizeZ
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockSizeZ = 0;

        /**
         * MapInfo blockPosX.
         * @member {number} blockPosX
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockPosX = 0;

        /**
         * MapInfo blockPosY.
         * @member {number} blockPosY
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockPosY = 0;

        /**
         * MapInfo blockPosZ.
         * @member {number} blockPosZ
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockPosZ = 0;

        /**
         * MapInfo worldName.
         * @member {string} worldName
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.worldName = "";

        /**
         * MapInfo worldNameEnglish.
         * @member {string} worldNameEnglish
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.worldNameEnglish = "";

        /**
         * MapInfo saveName.
         * @member {string} saveName
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.saveName = "";

        /**
         * Creates a new MapInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.IMapInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.MapInfo} MapInfo instance
         */
        MapInfo.create = function create(properties) {
            return new MapInfo(properties);
        };

        /**
         * Encodes the specified MapInfo message. Does not implicitly {@link RemoteFortressReader.MapInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.IMapInfo} message MapInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSizeX != null && message.hasOwnProperty("blockSizeX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.blockSizeX);
            if (message.blockSizeY != null && message.hasOwnProperty("blockSizeY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.blockSizeY);
            if (message.blockSizeZ != null && message.hasOwnProperty("blockSizeZ"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blockSizeZ);
            if (message.blockPosX != null && message.hasOwnProperty("blockPosX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.blockPosX);
            if (message.blockPosY != null && message.hasOwnProperty("blockPosY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blockPosY);
            if (message.blockPosZ != null && message.hasOwnProperty("blockPosZ"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.blockPosZ);
            if (message.worldName != null && message.hasOwnProperty("worldName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.worldName);
            if (message.worldNameEnglish != null && message.hasOwnProperty("worldNameEnglish"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.worldNameEnglish);
            if (message.saveName != null && message.hasOwnProperty("saveName"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.saveName);
            return writer;
        };

        /**
         * Encodes the specified MapInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.MapInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.IMapInfo} message MapInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MapInfo} MapInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MapInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSizeX = reader.int32();
                    break;
                case 2:
                    message.blockSizeY = reader.int32();
                    break;
                case 3:
                    message.blockSizeZ = reader.int32();
                    break;
                case 4:
                    message.blockPosX = reader.int32();
                    break;
                case 5:
                    message.blockPosY = reader.int32();
                    break;
                case 6:
                    message.blockPosZ = reader.int32();
                    break;
                case 7:
                    message.worldName = reader.string();
                    break;
                case 8:
                    message.worldNameEnglish = reader.string();
                    break;
                case 9:
                    message.saveName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MapInfo} MapInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapInfo message.
         * @function verify
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSizeX != null && message.hasOwnProperty("blockSizeX"))
                if (!$util.isInteger(message.blockSizeX))
                    return "blockSizeX: integer expected";
            if (message.blockSizeY != null && message.hasOwnProperty("blockSizeY"))
                if (!$util.isInteger(message.blockSizeY))
                    return "blockSizeY: integer expected";
            if (message.blockSizeZ != null && message.hasOwnProperty("blockSizeZ"))
                if (!$util.isInteger(message.blockSizeZ))
                    return "blockSizeZ: integer expected";
            if (message.blockPosX != null && message.hasOwnProperty("blockPosX"))
                if (!$util.isInteger(message.blockPosX))
                    return "blockPosX: integer expected";
            if (message.blockPosY != null && message.hasOwnProperty("blockPosY"))
                if (!$util.isInteger(message.blockPosY))
                    return "blockPosY: integer expected";
            if (message.blockPosZ != null && message.hasOwnProperty("blockPosZ"))
                if (!$util.isInteger(message.blockPosZ))
                    return "blockPosZ: integer expected";
            if (message.worldName != null && message.hasOwnProperty("worldName"))
                if (!$util.isString(message.worldName))
                    return "worldName: string expected";
            if (message.worldNameEnglish != null && message.hasOwnProperty("worldNameEnglish"))
                if (!$util.isString(message.worldNameEnglish))
                    return "worldNameEnglish: string expected";
            if (message.saveName != null && message.hasOwnProperty("saveName"))
                if (!$util.isString(message.saveName))
                    return "saveName: string expected";
            return null;
        };

        /**
         * Creates a MapInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MapInfo} MapInfo
         */
        MapInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MapInfo)
                return object;
            var message = new $root.RemoteFortressReader.MapInfo();
            if (object.blockSizeX != null)
                message.blockSizeX = object.blockSizeX | 0;
            if (object.blockSizeY != null)
                message.blockSizeY = object.blockSizeY | 0;
            if (object.blockSizeZ != null)
                message.blockSizeZ = object.blockSizeZ | 0;
            if (object.blockPosX != null)
                message.blockPosX = object.blockPosX | 0;
            if (object.blockPosY != null)
                message.blockPosY = object.blockPosY | 0;
            if (object.blockPosZ != null)
                message.blockPosZ = object.blockPosZ | 0;
            if (object.worldName != null)
                message.worldName = String(object.worldName);
            if (object.worldNameEnglish != null)
                message.worldNameEnglish = String(object.worldNameEnglish);
            if (object.saveName != null)
                message.saveName = String(object.saveName);
            return message;
        };

        /**
         * Creates a plain object from a MapInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.MapInfo} message MapInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.blockSizeX = 0;
                object.blockSizeY = 0;
                object.blockSizeZ = 0;
                object.blockPosX = 0;
                object.blockPosY = 0;
                object.blockPosZ = 0;
                object.worldName = "";
                object.worldNameEnglish = "";
                object.saveName = "";
            }
            if (message.blockSizeX != null && message.hasOwnProperty("blockSizeX"))
                object.blockSizeX = message.blockSizeX;
            if (message.blockSizeY != null && message.hasOwnProperty("blockSizeY"))
                object.blockSizeY = message.blockSizeY;
            if (message.blockSizeZ != null && message.hasOwnProperty("blockSizeZ"))
                object.blockSizeZ = message.blockSizeZ;
            if (message.blockPosX != null && message.hasOwnProperty("blockPosX"))
                object.blockPosX = message.blockPosX;
            if (message.blockPosY != null && message.hasOwnProperty("blockPosY"))
                object.blockPosY = message.blockPosY;
            if (message.blockPosZ != null && message.hasOwnProperty("blockPosZ"))
                object.blockPosZ = message.blockPosZ;
            if (message.worldName != null && message.hasOwnProperty("worldName"))
                object.worldName = message.worldName;
            if (message.worldNameEnglish != null && message.hasOwnProperty("worldNameEnglish"))
                object.worldNameEnglish = message.worldNameEnglish;
            if (message.saveName != null && message.hasOwnProperty("saveName"))
                object.saveName = message.saveName;
            return object;
        };

        /**
         * Converts this MapInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapInfo;
    })();

    /**
     * FrontType enum.
     * @name RemoteFortressReader.FrontType
     * @enum {string}
     * @property {number} FRONT_NONE=0 FRONT_NONE value
     * @property {number} FRONT_WARM=1 FRONT_WARM value
     * @property {number} FRONT_COLD=2 FRONT_COLD value
     * @property {number} FRONT_OCCLUDED=3 FRONT_OCCLUDED value
     */
    RemoteFortressReader.FrontType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FRONT_NONE"] = 0;
        values[valuesById[1] = "FRONT_WARM"] = 1;
        values[valuesById[2] = "FRONT_COLD"] = 2;
        values[valuesById[3] = "FRONT_OCCLUDED"] = 3;
        return values;
    })();

    /**
     * CumulusType enum.
     * @name RemoteFortressReader.CumulusType
     * @enum {string}
     * @property {number} CUMULUS_NONE=0 CUMULUS_NONE value
     * @property {number} CUMULUS_MEDIUM=1 CUMULUS_MEDIUM value
     * @property {number} CUMULUS_MULTI=2 CUMULUS_MULTI value
     * @property {number} CUMULUS_NIMBUS=3 CUMULUS_NIMBUS value
     */
    RemoteFortressReader.CumulusType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CUMULUS_NONE"] = 0;
        values[valuesById[1] = "CUMULUS_MEDIUM"] = 1;
        values[valuesById[2] = "CUMULUS_MULTI"] = 2;
        values[valuesById[3] = "CUMULUS_NIMBUS"] = 3;
        return values;
    })();

    /**
     * StratusType enum.
     * @name RemoteFortressReader.StratusType
     * @enum {string}
     * @property {number} STRATUS_NONE=0 STRATUS_NONE value
     * @property {number} STRATUS_ALTO=1 STRATUS_ALTO value
     * @property {number} STRATUS_PROPER=2 STRATUS_PROPER value
     * @property {number} STRATUS_NIMBUS=3 STRATUS_NIMBUS value
     */
    RemoteFortressReader.StratusType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "STRATUS_NONE"] = 0;
        values[valuesById[1] = "STRATUS_ALTO"] = 1;
        values[valuesById[2] = "STRATUS_PROPER"] = 2;
        values[valuesById[3] = "STRATUS_NIMBUS"] = 3;
        return values;
    })();

    /**
     * FogType enum.
     * @name RemoteFortressReader.FogType
     * @enum {string}
     * @property {number} FOG_NONE=0 FOG_NONE value
     * @property {number} FOG_MIST=1 FOG_MIST value
     * @property {number} FOG_NORMAL=2 FOG_NORMAL value
     * @property {number} F0G_THICK=3 F0G_THICK value
     */
    RemoteFortressReader.FogType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FOG_NONE"] = 0;
        values[valuesById[1] = "FOG_MIST"] = 1;
        values[valuesById[2] = "FOG_NORMAL"] = 2;
        values[valuesById[3] = "F0G_THICK"] = 3;
        return values;
    })();

    RemoteFortressReader.Cloud = (function() {

        /**
         * Properties of a Cloud.
         * @memberof RemoteFortressReader
         * @interface ICloud
         * @property {RemoteFortressReader.FrontType|null} [front] Cloud front
         * @property {RemoteFortressReader.CumulusType|null} [cumulus] Cloud cumulus
         * @property {boolean|null} [cirrus] Cloud cirrus
         * @property {RemoteFortressReader.StratusType|null} [stratus] Cloud stratus
         * @property {RemoteFortressReader.FogType|null} [fog] Cloud fog
         */

        /**
         * Constructs a new Cloud.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Cloud.
         * @implements ICloud
         * @constructor
         * @param {RemoteFortressReader.ICloud=} [properties] Properties to set
         */
        function Cloud(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Cloud front.
         * @member {RemoteFortressReader.FrontType} front
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.front = 0;

        /**
         * Cloud cumulus.
         * @member {RemoteFortressReader.CumulusType} cumulus
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.cumulus = 0;

        /**
         * Cloud cirrus.
         * @member {boolean} cirrus
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.cirrus = false;

        /**
         * Cloud stratus.
         * @member {RemoteFortressReader.StratusType} stratus
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.stratus = 0;

        /**
         * Cloud fog.
         * @member {RemoteFortressReader.FogType} fog
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.fog = 0;

        /**
         * Creates a new Cloud instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.ICloud=} [properties] Properties to set
         * @returns {RemoteFortressReader.Cloud} Cloud instance
         */
        Cloud.create = function create(properties) {
            return new Cloud(properties);
        };

        /**
         * Encodes the specified Cloud message. Does not implicitly {@link RemoteFortressReader.Cloud.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.ICloud} message Cloud message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cloud.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.front != null && message.hasOwnProperty("front"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.front);
            if (message.cumulus != null && message.hasOwnProperty("cumulus"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cumulus);
            if (message.cirrus != null && message.hasOwnProperty("cirrus"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.cirrus);
            if (message.stratus != null && message.hasOwnProperty("stratus"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.stratus);
            if (message.fog != null && message.hasOwnProperty("fog"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.fog);
            return writer;
        };

        /**
         * Encodes the specified Cloud message, length delimited. Does not implicitly {@link RemoteFortressReader.Cloud.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.ICloud} message Cloud message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cloud.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Cloud message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Cloud} Cloud
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cloud.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Cloud();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.front = reader.int32();
                    break;
                case 2:
                    message.cumulus = reader.int32();
                    break;
                case 3:
                    message.cirrus = reader.bool();
                    break;
                case 4:
                    message.stratus = reader.int32();
                    break;
                case 5:
                    message.fog = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Cloud message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Cloud} Cloud
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cloud.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Cloud message.
         * @function verify
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Cloud.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.front != null && message.hasOwnProperty("front"))
                switch (message.front) {
                default:
                    return "front: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.cumulus != null && message.hasOwnProperty("cumulus"))
                switch (message.cumulus) {
                default:
                    return "cumulus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.cirrus != null && message.hasOwnProperty("cirrus"))
                if (typeof message.cirrus !== "boolean")
                    return "cirrus: boolean expected";
            if (message.stratus != null && message.hasOwnProperty("stratus"))
                switch (message.stratus) {
                default:
                    return "stratus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.fog != null && message.hasOwnProperty("fog"))
                switch (message.fog) {
                default:
                    return "fog: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Cloud message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Cloud} Cloud
         */
        Cloud.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Cloud)
                return object;
            var message = new $root.RemoteFortressReader.Cloud();
            switch (object.front) {
            case "FRONT_NONE":
            case 0:
                message.front = 0;
                break;
            case "FRONT_WARM":
            case 1:
                message.front = 1;
                break;
            case "FRONT_COLD":
            case 2:
                message.front = 2;
                break;
            case "FRONT_OCCLUDED":
            case 3:
                message.front = 3;
                break;
            }
            switch (object.cumulus) {
            case "CUMULUS_NONE":
            case 0:
                message.cumulus = 0;
                break;
            case "CUMULUS_MEDIUM":
            case 1:
                message.cumulus = 1;
                break;
            case "CUMULUS_MULTI":
            case 2:
                message.cumulus = 2;
                break;
            case "CUMULUS_NIMBUS":
            case 3:
                message.cumulus = 3;
                break;
            }
            if (object.cirrus != null)
                message.cirrus = Boolean(object.cirrus);
            switch (object.stratus) {
            case "STRATUS_NONE":
            case 0:
                message.stratus = 0;
                break;
            case "STRATUS_ALTO":
            case 1:
                message.stratus = 1;
                break;
            case "STRATUS_PROPER":
            case 2:
                message.stratus = 2;
                break;
            case "STRATUS_NIMBUS":
            case 3:
                message.stratus = 3;
                break;
            }
            switch (object.fog) {
            case "FOG_NONE":
            case 0:
                message.fog = 0;
                break;
            case "FOG_MIST":
            case 1:
                message.fog = 1;
                break;
            case "FOG_NORMAL":
            case 2:
                message.fog = 2;
                break;
            case "F0G_THICK":
            case 3:
                message.fog = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Cloud message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.Cloud} message Cloud
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Cloud.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.front = options.enums === String ? "FRONT_NONE" : 0;
                object.cumulus = options.enums === String ? "CUMULUS_NONE" : 0;
                object.cirrus = false;
                object.stratus = options.enums === String ? "STRATUS_NONE" : 0;
                object.fog = options.enums === String ? "FOG_NONE" : 0;
            }
            if (message.front != null && message.hasOwnProperty("front"))
                object.front = options.enums === String ? $root.RemoteFortressReader.FrontType[message.front] : message.front;
            if (message.cumulus != null && message.hasOwnProperty("cumulus"))
                object.cumulus = options.enums === String ? $root.RemoteFortressReader.CumulusType[message.cumulus] : message.cumulus;
            if (message.cirrus != null && message.hasOwnProperty("cirrus"))
                object.cirrus = message.cirrus;
            if (message.stratus != null && message.hasOwnProperty("stratus"))
                object.stratus = options.enums === String ? $root.RemoteFortressReader.StratusType[message.stratus] : message.stratus;
            if (message.fog != null && message.hasOwnProperty("fog"))
                object.fog = options.enums === String ? $root.RemoteFortressReader.FogType[message.fog] : message.fog;
            return object;
        };

        /**
         * Converts this Cloud to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Cloud
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Cloud.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Cloud;
    })();

    RemoteFortressReader.WorldMap = (function() {

        /**
         * Properties of a WorldMap.
         * @memberof RemoteFortressReader
         * @interface IWorldMap
         * @property {number} worldWidth WorldMap worldWidth
         * @property {number} worldHeight WorldMap worldHeight
         * @property {string|null} [name] WorldMap name
         * @property {string|null} [nameEnglish] WorldMap nameEnglish
         * @property {Array.<number>|null} [elevation] WorldMap elevation
         * @property {Array.<number>|null} [rainfall] WorldMap rainfall
         * @property {Array.<number>|null} [vegetation] WorldMap vegetation
         * @property {Array.<number>|null} [temperature] WorldMap temperature
         * @property {Array.<number>|null} [evilness] WorldMap evilness
         * @property {Array.<number>|null} [drainage] WorldMap drainage
         * @property {Array.<number>|null} [volcanism] WorldMap volcanism
         * @property {Array.<number>|null} [savagery] WorldMap savagery
         * @property {Array.<RemoteFortressReader.ICloud>|null} [clouds] WorldMap clouds
         * @property {Array.<number>|null} [salinity] WorldMap salinity
         * @property {number|null} [mapX] WorldMap mapX
         * @property {number|null} [mapY] WorldMap mapY
         * @property {number|null} [centerX] WorldMap centerX
         * @property {number|null} [centerY] WorldMap centerY
         * @property {number|null} [centerZ] WorldMap centerZ
         * @property {number|null} [curYear] WorldMap curYear
         * @property {number|null} [curYearTick] WorldMap curYearTick
         * @property {RemoteFortressReader.WorldPoles|null} [worldPoles] WorldMap worldPoles
         * @property {Array.<RemoteFortressReader.IRiverTile>|null} [riverTiles] WorldMap riverTiles
         * @property {Array.<number>|null} [waterElevation] WorldMap waterElevation
         * @property {Array.<RemoteFortressReader.IRegionTile>|null} [regionTiles] WorldMap regionTiles
         */

        /**
         * Constructs a new WorldMap.
         * @memberof RemoteFortressReader
         * @classdesc Represents a WorldMap.
         * @implements IWorldMap
         * @constructor
         * @param {RemoteFortressReader.IWorldMap=} [properties] Properties to set
         */
        function WorldMap(properties) {
            this.elevation = [];
            this.rainfall = [];
            this.vegetation = [];
            this.temperature = [];
            this.evilness = [];
            this.drainage = [];
            this.volcanism = [];
            this.savagery = [];
            this.clouds = [];
            this.salinity = [];
            this.riverTiles = [];
            this.waterElevation = [];
            this.regionTiles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WorldMap worldWidth.
         * @member {number} worldWidth
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.worldWidth = 0;

        /**
         * WorldMap worldHeight.
         * @member {number} worldHeight
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.worldHeight = 0;

        /**
         * WorldMap name.
         * @member {string} name
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.name = "";

        /**
         * WorldMap nameEnglish.
         * @member {string} nameEnglish
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.nameEnglish = "";

        /**
         * WorldMap elevation.
         * @member {Array.<number>} elevation
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.elevation = $util.emptyArray;

        /**
         * WorldMap rainfall.
         * @member {Array.<number>} rainfall
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.rainfall = $util.emptyArray;

        /**
         * WorldMap vegetation.
         * @member {Array.<number>} vegetation
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.vegetation = $util.emptyArray;

        /**
         * WorldMap temperature.
         * @member {Array.<number>} temperature
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.temperature = $util.emptyArray;

        /**
         * WorldMap evilness.
         * @member {Array.<number>} evilness
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.evilness = $util.emptyArray;

        /**
         * WorldMap drainage.
         * @member {Array.<number>} drainage
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.drainage = $util.emptyArray;

        /**
         * WorldMap volcanism.
         * @member {Array.<number>} volcanism
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.volcanism = $util.emptyArray;

        /**
         * WorldMap savagery.
         * @member {Array.<number>} savagery
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.savagery = $util.emptyArray;

        /**
         * WorldMap clouds.
         * @member {Array.<RemoteFortressReader.ICloud>} clouds
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.clouds = $util.emptyArray;

        /**
         * WorldMap salinity.
         * @member {Array.<number>} salinity
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.salinity = $util.emptyArray;

        /**
         * WorldMap mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.mapX = 0;

        /**
         * WorldMap mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.mapY = 0;

        /**
         * WorldMap centerX.
         * @member {number} centerX
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.centerX = 0;

        /**
         * WorldMap centerY.
         * @member {number} centerY
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.centerY = 0;

        /**
         * WorldMap centerZ.
         * @member {number} centerZ
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.centerZ = 0;

        /**
         * WorldMap curYear.
         * @member {number} curYear
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.curYear = 0;

        /**
         * WorldMap curYearTick.
         * @member {number} curYearTick
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.curYearTick = 0;

        /**
         * WorldMap worldPoles.
         * @member {RemoteFortressReader.WorldPoles} worldPoles
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.worldPoles = 0;

        /**
         * WorldMap riverTiles.
         * @member {Array.<RemoteFortressReader.IRiverTile>} riverTiles
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.riverTiles = $util.emptyArray;

        /**
         * WorldMap waterElevation.
         * @member {Array.<number>} waterElevation
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.waterElevation = $util.emptyArray;

        /**
         * WorldMap regionTiles.
         * @member {Array.<RemoteFortressReader.IRegionTile>} regionTiles
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.regionTiles = $util.emptyArray;

        /**
         * Creates a new WorldMap instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.IWorldMap=} [properties] Properties to set
         * @returns {RemoteFortressReader.WorldMap} WorldMap instance
         */
        WorldMap.create = function create(properties) {
            return new WorldMap(properties);
        };

        /**
         * Encodes the specified WorldMap message. Does not implicitly {@link RemoteFortressReader.WorldMap.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.IWorldMap} message WorldMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.worldWidth);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.worldHeight);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nameEnglish);
            if (message.elevation != null && message.elevation.length)
                for (var i = 0; i < message.elevation.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.elevation[i]);
            if (message.rainfall != null && message.rainfall.length)
                for (var i = 0; i < message.rainfall.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rainfall[i]);
            if (message.vegetation != null && message.vegetation.length)
                for (var i = 0; i < message.vegetation.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.vegetation[i]);
            if (message.temperature != null && message.temperature.length)
                for (var i = 0; i < message.temperature.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.temperature[i]);
            if (message.evilness != null && message.evilness.length)
                for (var i = 0; i < message.evilness.length; ++i)
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.evilness[i]);
            if (message.drainage != null && message.drainage.length)
                for (var i = 0; i < message.drainage.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.drainage[i]);
            if (message.volcanism != null && message.volcanism.length)
                for (var i = 0; i < message.volcanism.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.volcanism[i]);
            if (message.savagery != null && message.savagery.length)
                for (var i = 0; i < message.savagery.length; ++i)
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.savagery[i]);
            if (message.clouds != null && message.clouds.length)
                for (var i = 0; i < message.clouds.length; ++i)
                    $root.RemoteFortressReader.Cloud.encode(message.clouds[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.salinity != null && message.salinity.length)
                for (var i = 0; i < message.salinity.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.salinity[i]);
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.mapX);
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.mapY);
            if (message.centerX != null && message.hasOwnProperty("centerX"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.centerX);
            if (message.centerY != null && message.hasOwnProperty("centerY"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.centerY);
            if (message.centerZ != null && message.hasOwnProperty("centerZ"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.centerZ);
            if (message.curYear != null && message.hasOwnProperty("curYear"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.curYear);
            if (message.curYearTick != null && message.hasOwnProperty("curYearTick"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.curYearTick);
            if (message.worldPoles != null && message.hasOwnProperty("worldPoles"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.worldPoles);
            if (message.riverTiles != null && message.riverTiles.length)
                for (var i = 0; i < message.riverTiles.length; ++i)
                    $root.RemoteFortressReader.RiverTile.encode(message.riverTiles[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.waterElevation != null && message.waterElevation.length)
                for (var i = 0; i < message.waterElevation.length; ++i)
                    writer.uint32(/* id 24, wireType 0 =*/192).int32(message.waterElevation[i]);
            if (message.regionTiles != null && message.regionTiles.length)
                for (var i = 0; i < message.regionTiles.length; ++i)
                    $root.RemoteFortressReader.RegionTile.encode(message.regionTiles[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WorldMap message, length delimited. Does not implicitly {@link RemoteFortressReader.WorldMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.IWorldMap} message WorldMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WorldMap message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.WorldMap} WorldMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.WorldMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldWidth = reader.int32();
                    break;
                case 2:
                    message.worldHeight = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.nameEnglish = reader.string();
                    break;
                case 5:
                    if (!(message.elevation && message.elevation.length))
                        message.elevation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.elevation.push(reader.int32());
                    } else
                        message.elevation.push(reader.int32());
                    break;
                case 6:
                    if (!(message.rainfall && message.rainfall.length))
                        message.rainfall = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rainfall.push(reader.int32());
                    } else
                        message.rainfall.push(reader.int32());
                    break;
                case 7:
                    if (!(message.vegetation && message.vegetation.length))
                        message.vegetation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.vegetation.push(reader.int32());
                    } else
                        message.vegetation.push(reader.int32());
                    break;
                case 8:
                    if (!(message.temperature && message.temperature.length))
                        message.temperature = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.temperature.push(reader.int32());
                    } else
                        message.temperature.push(reader.int32());
                    break;
                case 9:
                    if (!(message.evilness && message.evilness.length))
                        message.evilness = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.evilness.push(reader.int32());
                    } else
                        message.evilness.push(reader.int32());
                    break;
                case 10:
                    if (!(message.drainage && message.drainage.length))
                        message.drainage = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.drainage.push(reader.int32());
                    } else
                        message.drainage.push(reader.int32());
                    break;
                case 11:
                    if (!(message.volcanism && message.volcanism.length))
                        message.volcanism = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.volcanism.push(reader.int32());
                    } else
                        message.volcanism.push(reader.int32());
                    break;
                case 12:
                    if (!(message.savagery && message.savagery.length))
                        message.savagery = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.savagery.push(reader.int32());
                    } else
                        message.savagery.push(reader.int32());
                    break;
                case 13:
                    if (!(message.clouds && message.clouds.length))
                        message.clouds = [];
                    message.clouds.push($root.RemoteFortressReader.Cloud.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.salinity && message.salinity.length))
                        message.salinity = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.salinity.push(reader.int32());
                    } else
                        message.salinity.push(reader.int32());
                    break;
                case 15:
                    message.mapX = reader.int32();
                    break;
                case 16:
                    message.mapY = reader.int32();
                    break;
                case 17:
                    message.centerX = reader.int32();
                    break;
                case 18:
                    message.centerY = reader.int32();
                    break;
                case 19:
                    message.centerZ = reader.int32();
                    break;
                case 20:
                    message.curYear = reader.int32();
                    break;
                case 21:
                    message.curYearTick = reader.int32();
                    break;
                case 22:
                    message.worldPoles = reader.int32();
                    break;
                case 23:
                    if (!(message.riverTiles && message.riverTiles.length))
                        message.riverTiles = [];
                    message.riverTiles.push($root.RemoteFortressReader.RiverTile.decode(reader, reader.uint32()));
                    break;
                case 24:
                    if (!(message.waterElevation && message.waterElevation.length))
                        message.waterElevation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waterElevation.push(reader.int32());
                    } else
                        message.waterElevation.push(reader.int32());
                    break;
                case 25:
                    if (!(message.regionTiles && message.regionTiles.length))
                        message.regionTiles = [];
                    message.regionTiles.push($root.RemoteFortressReader.RegionTile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("worldWidth"))
                throw $util.ProtocolError("missing required 'worldWidth'", { instance: message });
            if (!message.hasOwnProperty("worldHeight"))
                throw $util.ProtocolError("missing required 'worldHeight'", { instance: message });
            return message;
        };

        /**
         * Decodes a WorldMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.WorldMap} WorldMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WorldMap message.
         * @function verify
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WorldMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.worldWidth))
                return "worldWidth: integer expected";
            if (!$util.isInteger(message.worldHeight))
                return "worldHeight: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                if (!$util.isString(message.nameEnglish))
                    return "nameEnglish: string expected";
            if (message.elevation != null && message.hasOwnProperty("elevation")) {
                if (!Array.isArray(message.elevation))
                    return "elevation: array expected";
                for (var i = 0; i < message.elevation.length; ++i)
                    if (!$util.isInteger(message.elevation[i]))
                        return "elevation: integer[] expected";
            }
            if (message.rainfall != null && message.hasOwnProperty("rainfall")) {
                if (!Array.isArray(message.rainfall))
                    return "rainfall: array expected";
                for (var i = 0; i < message.rainfall.length; ++i)
                    if (!$util.isInteger(message.rainfall[i]))
                        return "rainfall: integer[] expected";
            }
            if (message.vegetation != null && message.hasOwnProperty("vegetation")) {
                if (!Array.isArray(message.vegetation))
                    return "vegetation: array expected";
                for (var i = 0; i < message.vegetation.length; ++i)
                    if (!$util.isInteger(message.vegetation[i]))
                        return "vegetation: integer[] expected";
            }
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                if (!Array.isArray(message.temperature))
                    return "temperature: array expected";
                for (var i = 0; i < message.temperature.length; ++i)
                    if (!$util.isInteger(message.temperature[i]))
                        return "temperature: integer[] expected";
            }
            if (message.evilness != null && message.hasOwnProperty("evilness")) {
                if (!Array.isArray(message.evilness))
                    return "evilness: array expected";
                for (var i = 0; i < message.evilness.length; ++i)
                    if (!$util.isInteger(message.evilness[i]))
                        return "evilness: integer[] expected";
            }
            if (message.drainage != null && message.hasOwnProperty("drainage")) {
                if (!Array.isArray(message.drainage))
                    return "drainage: array expected";
                for (var i = 0; i < message.drainage.length; ++i)
                    if (!$util.isInteger(message.drainage[i]))
                        return "drainage: integer[] expected";
            }
            if (message.volcanism != null && message.hasOwnProperty("volcanism")) {
                if (!Array.isArray(message.volcanism))
                    return "volcanism: array expected";
                for (var i = 0; i < message.volcanism.length; ++i)
                    if (!$util.isInteger(message.volcanism[i]))
                        return "volcanism: integer[] expected";
            }
            if (message.savagery != null && message.hasOwnProperty("savagery")) {
                if (!Array.isArray(message.savagery))
                    return "savagery: array expected";
                for (var i = 0; i < message.savagery.length; ++i)
                    if (!$util.isInteger(message.savagery[i]))
                        return "savagery: integer[] expected";
            }
            if (message.clouds != null && message.hasOwnProperty("clouds")) {
                if (!Array.isArray(message.clouds))
                    return "clouds: array expected";
                for (var i = 0; i < message.clouds.length; ++i) {
                    var error = $root.RemoteFortressReader.Cloud.verify(message.clouds[i]);
                    if (error)
                        return "clouds." + error;
                }
            }
            if (message.salinity != null && message.hasOwnProperty("salinity")) {
                if (!Array.isArray(message.salinity))
                    return "salinity: array expected";
                for (var i = 0; i < message.salinity.length; ++i)
                    if (!$util.isInteger(message.salinity[i]))
                        return "salinity: integer[] expected";
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                if (!$util.isInteger(message.mapX))
                    return "mapX: integer expected";
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                if (!$util.isInteger(message.mapY))
                    return "mapY: integer expected";
            if (message.centerX != null && message.hasOwnProperty("centerX"))
                if (!$util.isInteger(message.centerX))
                    return "centerX: integer expected";
            if (message.centerY != null && message.hasOwnProperty("centerY"))
                if (!$util.isInteger(message.centerY))
                    return "centerY: integer expected";
            if (message.centerZ != null && message.hasOwnProperty("centerZ"))
                if (!$util.isInteger(message.centerZ))
                    return "centerZ: integer expected";
            if (message.curYear != null && message.hasOwnProperty("curYear"))
                if (!$util.isInteger(message.curYear))
                    return "curYear: integer expected";
            if (message.curYearTick != null && message.hasOwnProperty("curYearTick"))
                if (!$util.isInteger(message.curYearTick))
                    return "curYearTick: integer expected";
            if (message.worldPoles != null && message.hasOwnProperty("worldPoles"))
                switch (message.worldPoles) {
                default:
                    return "worldPoles: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.riverTiles != null && message.hasOwnProperty("riverTiles")) {
                if (!Array.isArray(message.riverTiles))
                    return "riverTiles: array expected";
                for (var i = 0; i < message.riverTiles.length; ++i) {
                    var error = $root.RemoteFortressReader.RiverTile.verify(message.riverTiles[i]);
                    if (error)
                        return "riverTiles." + error;
                }
            }
            if (message.waterElevation != null && message.hasOwnProperty("waterElevation")) {
                if (!Array.isArray(message.waterElevation))
                    return "waterElevation: array expected";
                for (var i = 0; i < message.waterElevation.length; ++i)
                    if (!$util.isInteger(message.waterElevation[i]))
                        return "waterElevation: integer[] expected";
            }
            if (message.regionTiles != null && message.hasOwnProperty("regionTiles")) {
                if (!Array.isArray(message.regionTiles))
                    return "regionTiles: array expected";
                for (var i = 0; i < message.regionTiles.length; ++i) {
                    var error = $root.RemoteFortressReader.RegionTile.verify(message.regionTiles[i]);
                    if (error)
                        return "regionTiles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WorldMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.WorldMap} WorldMap
         */
        WorldMap.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.WorldMap)
                return object;
            var message = new $root.RemoteFortressReader.WorldMap();
            if (object.worldWidth != null)
                message.worldWidth = object.worldWidth | 0;
            if (object.worldHeight != null)
                message.worldHeight = object.worldHeight | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.nameEnglish != null)
                message.nameEnglish = String(object.nameEnglish);
            if (object.elevation) {
                if (!Array.isArray(object.elevation))
                    throw TypeError(".RemoteFortressReader.WorldMap.elevation: array expected");
                message.elevation = [];
                for (var i = 0; i < object.elevation.length; ++i)
                    message.elevation[i] = object.elevation[i] | 0;
            }
            if (object.rainfall) {
                if (!Array.isArray(object.rainfall))
                    throw TypeError(".RemoteFortressReader.WorldMap.rainfall: array expected");
                message.rainfall = [];
                for (var i = 0; i < object.rainfall.length; ++i)
                    message.rainfall[i] = object.rainfall[i] | 0;
            }
            if (object.vegetation) {
                if (!Array.isArray(object.vegetation))
                    throw TypeError(".RemoteFortressReader.WorldMap.vegetation: array expected");
                message.vegetation = [];
                for (var i = 0; i < object.vegetation.length; ++i)
                    message.vegetation[i] = object.vegetation[i] | 0;
            }
            if (object.temperature) {
                if (!Array.isArray(object.temperature))
                    throw TypeError(".RemoteFortressReader.WorldMap.temperature: array expected");
                message.temperature = [];
                for (var i = 0; i < object.temperature.length; ++i)
                    message.temperature[i] = object.temperature[i] | 0;
            }
            if (object.evilness) {
                if (!Array.isArray(object.evilness))
                    throw TypeError(".RemoteFortressReader.WorldMap.evilness: array expected");
                message.evilness = [];
                for (var i = 0; i < object.evilness.length; ++i)
                    message.evilness[i] = object.evilness[i] | 0;
            }
            if (object.drainage) {
                if (!Array.isArray(object.drainage))
                    throw TypeError(".RemoteFortressReader.WorldMap.drainage: array expected");
                message.drainage = [];
                for (var i = 0; i < object.drainage.length; ++i)
                    message.drainage[i] = object.drainage[i] | 0;
            }
            if (object.volcanism) {
                if (!Array.isArray(object.volcanism))
                    throw TypeError(".RemoteFortressReader.WorldMap.volcanism: array expected");
                message.volcanism = [];
                for (var i = 0; i < object.volcanism.length; ++i)
                    message.volcanism[i] = object.volcanism[i] | 0;
            }
            if (object.savagery) {
                if (!Array.isArray(object.savagery))
                    throw TypeError(".RemoteFortressReader.WorldMap.savagery: array expected");
                message.savagery = [];
                for (var i = 0; i < object.savagery.length; ++i)
                    message.savagery[i] = object.savagery[i] | 0;
            }
            if (object.clouds) {
                if (!Array.isArray(object.clouds))
                    throw TypeError(".RemoteFortressReader.WorldMap.clouds: array expected");
                message.clouds = [];
                for (var i = 0; i < object.clouds.length; ++i) {
                    if (typeof object.clouds[i] !== "object")
                        throw TypeError(".RemoteFortressReader.WorldMap.clouds: object expected");
                    message.clouds[i] = $root.RemoteFortressReader.Cloud.fromObject(object.clouds[i]);
                }
            }
            if (object.salinity) {
                if (!Array.isArray(object.salinity))
                    throw TypeError(".RemoteFortressReader.WorldMap.salinity: array expected");
                message.salinity = [];
                for (var i = 0; i < object.salinity.length; ++i)
                    message.salinity[i] = object.salinity[i] | 0;
            }
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.centerX != null)
                message.centerX = object.centerX | 0;
            if (object.centerY != null)
                message.centerY = object.centerY | 0;
            if (object.centerZ != null)
                message.centerZ = object.centerZ | 0;
            if (object.curYear != null)
                message.curYear = object.curYear | 0;
            if (object.curYearTick != null)
                message.curYearTick = object.curYearTick | 0;
            switch (object.worldPoles) {
            case "NO_POLES":
            case 0:
                message.worldPoles = 0;
                break;
            case "NORTH_POLE":
            case 1:
                message.worldPoles = 1;
                break;
            case "SOUTH_POLE":
            case 2:
                message.worldPoles = 2;
                break;
            case "BOTH_POLES":
            case 3:
                message.worldPoles = 3;
                break;
            }
            if (object.riverTiles) {
                if (!Array.isArray(object.riverTiles))
                    throw TypeError(".RemoteFortressReader.WorldMap.riverTiles: array expected");
                message.riverTiles = [];
                for (var i = 0; i < object.riverTiles.length; ++i) {
                    if (typeof object.riverTiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.WorldMap.riverTiles: object expected");
                    message.riverTiles[i] = $root.RemoteFortressReader.RiverTile.fromObject(object.riverTiles[i]);
                }
            }
            if (object.waterElevation) {
                if (!Array.isArray(object.waterElevation))
                    throw TypeError(".RemoteFortressReader.WorldMap.waterElevation: array expected");
                message.waterElevation = [];
                for (var i = 0; i < object.waterElevation.length; ++i)
                    message.waterElevation[i] = object.waterElevation[i] | 0;
            }
            if (object.regionTiles) {
                if (!Array.isArray(object.regionTiles))
                    throw TypeError(".RemoteFortressReader.WorldMap.regionTiles: array expected");
                message.regionTiles = [];
                for (var i = 0; i < object.regionTiles.length; ++i) {
                    if (typeof object.regionTiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.WorldMap.regionTiles: object expected");
                    message.regionTiles[i] = $root.RemoteFortressReader.RegionTile.fromObject(object.regionTiles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WorldMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.WorldMap} message WorldMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WorldMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.elevation = [];
                object.rainfall = [];
                object.vegetation = [];
                object.temperature = [];
                object.evilness = [];
                object.drainage = [];
                object.volcanism = [];
                object.savagery = [];
                object.clouds = [];
                object.salinity = [];
                object.riverTiles = [];
                object.waterElevation = [];
                object.regionTiles = [];
            }
            if (options.defaults) {
                object.worldWidth = 0;
                object.worldHeight = 0;
                object.name = "";
                object.nameEnglish = "";
                object.mapX = 0;
                object.mapY = 0;
                object.centerX = 0;
                object.centerY = 0;
                object.centerZ = 0;
                object.curYear = 0;
                object.curYearTick = 0;
                object.worldPoles = options.enums === String ? "NO_POLES" : 0;
            }
            if (message.worldWidth != null && message.hasOwnProperty("worldWidth"))
                object.worldWidth = message.worldWidth;
            if (message.worldHeight != null && message.hasOwnProperty("worldHeight"))
                object.worldHeight = message.worldHeight;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                object.nameEnglish = message.nameEnglish;
            if (message.elevation && message.elevation.length) {
                object.elevation = [];
                for (var j = 0; j < message.elevation.length; ++j)
                    object.elevation[j] = message.elevation[j];
            }
            if (message.rainfall && message.rainfall.length) {
                object.rainfall = [];
                for (var j = 0; j < message.rainfall.length; ++j)
                    object.rainfall[j] = message.rainfall[j];
            }
            if (message.vegetation && message.vegetation.length) {
                object.vegetation = [];
                for (var j = 0; j < message.vegetation.length; ++j)
                    object.vegetation[j] = message.vegetation[j];
            }
            if (message.temperature && message.temperature.length) {
                object.temperature = [];
                for (var j = 0; j < message.temperature.length; ++j)
                    object.temperature[j] = message.temperature[j];
            }
            if (message.evilness && message.evilness.length) {
                object.evilness = [];
                for (var j = 0; j < message.evilness.length; ++j)
                    object.evilness[j] = message.evilness[j];
            }
            if (message.drainage && message.drainage.length) {
                object.drainage = [];
                for (var j = 0; j < message.drainage.length; ++j)
                    object.drainage[j] = message.drainage[j];
            }
            if (message.volcanism && message.volcanism.length) {
                object.volcanism = [];
                for (var j = 0; j < message.volcanism.length; ++j)
                    object.volcanism[j] = message.volcanism[j];
            }
            if (message.savagery && message.savagery.length) {
                object.savagery = [];
                for (var j = 0; j < message.savagery.length; ++j)
                    object.savagery[j] = message.savagery[j];
            }
            if (message.clouds && message.clouds.length) {
                object.clouds = [];
                for (var j = 0; j < message.clouds.length; ++j)
                    object.clouds[j] = $root.RemoteFortressReader.Cloud.toObject(message.clouds[j], options);
            }
            if (message.salinity && message.salinity.length) {
                object.salinity = [];
                for (var j = 0; j < message.salinity.length; ++j)
                    object.salinity[j] = message.salinity[j];
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.centerX != null && message.hasOwnProperty("centerX"))
                object.centerX = message.centerX;
            if (message.centerY != null && message.hasOwnProperty("centerY"))
                object.centerY = message.centerY;
            if (message.centerZ != null && message.hasOwnProperty("centerZ"))
                object.centerZ = message.centerZ;
            if (message.curYear != null && message.hasOwnProperty("curYear"))
                object.curYear = message.curYear;
            if (message.curYearTick != null && message.hasOwnProperty("curYearTick"))
                object.curYearTick = message.curYearTick;
            if (message.worldPoles != null && message.hasOwnProperty("worldPoles"))
                object.worldPoles = options.enums === String ? $root.RemoteFortressReader.WorldPoles[message.worldPoles] : message.worldPoles;
            if (message.riverTiles && message.riverTiles.length) {
                object.riverTiles = [];
                for (var j = 0; j < message.riverTiles.length; ++j)
                    object.riverTiles[j] = $root.RemoteFortressReader.RiverTile.toObject(message.riverTiles[j], options);
            }
            if (message.waterElevation && message.waterElevation.length) {
                object.waterElevation = [];
                for (var j = 0; j < message.waterElevation.length; ++j)
                    object.waterElevation[j] = message.waterElevation[j];
            }
            if (message.regionTiles && message.regionTiles.length) {
                object.regionTiles = [];
                for (var j = 0; j < message.regionTiles.length; ++j)
                    object.regionTiles[j] = $root.RemoteFortressReader.RegionTile.toObject(message.regionTiles[j], options);
            }
            return object;
        };

        /**
         * Converts this WorldMap to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WorldMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WorldMap;
    })();

    /**
     * SiteRealizationBuildingType enum.
     * @name RemoteFortressReader.SiteRealizationBuildingType
     * @enum {string}
     * @property {number} cottage_plot=0 cottage_plot value
     * @property {number} castle_wall=1 castle_wall value
     * @property {number} castle_tower=2 castle_tower value
     * @property {number} castle_courtyard=3 castle_courtyard value
     * @property {number} house=4 house value
     * @property {number} temple=5 temple value
     * @property {number} tomb=6 tomb value
     * @property {number} shop_house=7 shop_house value
     * @property {number} warehouse=8 warehouse value
     * @property {number} market_square=9 market_square value
     * @property {number} pasture=10 pasture value
     * @property {number} waste=11 waste value
     * @property {number} courtyard=12 courtyard value
     * @property {number} well=13 well value
     * @property {number} vault=14 vault value
     * @property {number} great_tower=15 great_tower value
     * @property {number} trenches=16 trenches value
     * @property {number} tree_house=17 tree_house value
     * @property {number} hillock_house=18 hillock_house value
     * @property {number} mead_hall=19 mead_hall value
     * @property {number} fortress_entrance=20 fortress_entrance value
     * @property {number} library=21 library value
     * @property {number} tavern=22 tavern value
     */
    RemoteFortressReader.SiteRealizationBuildingType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "cottage_plot"] = 0;
        values[valuesById[1] = "castle_wall"] = 1;
        values[valuesById[2] = "castle_tower"] = 2;
        values[valuesById[3] = "castle_courtyard"] = 3;
        values[valuesById[4] = "house"] = 4;
        values[valuesById[5] = "temple"] = 5;
        values[valuesById[6] = "tomb"] = 6;
        values[valuesById[7] = "shop_house"] = 7;
        values[valuesById[8] = "warehouse"] = 8;
        values[valuesById[9] = "market_square"] = 9;
        values[valuesById[10] = "pasture"] = 10;
        values[valuesById[11] = "waste"] = 11;
        values[valuesById[12] = "courtyard"] = 12;
        values[valuesById[13] = "well"] = 13;
        values[valuesById[14] = "vault"] = 14;
        values[valuesById[15] = "great_tower"] = 15;
        values[valuesById[16] = "trenches"] = 16;
        values[valuesById[17] = "tree_house"] = 17;
        values[valuesById[18] = "hillock_house"] = 18;
        values[valuesById[19] = "mead_hall"] = 19;
        values[valuesById[20] = "fortress_entrance"] = 20;
        values[valuesById[21] = "library"] = 21;
        values[valuesById[22] = "tavern"] = 22;
        return values;
    })();

    RemoteFortressReader.SiteRealizationBuildingWall = (function() {

        /**
         * Properties of a SiteRealizationBuildingWall.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuildingWall
         * @property {number|null} [startX] SiteRealizationBuildingWall startX
         * @property {number|null} [startY] SiteRealizationBuildingWall startY
         * @property {number|null} [startZ] SiteRealizationBuildingWall startZ
         * @property {number|null} [endX] SiteRealizationBuildingWall endX
         * @property {number|null} [endY] SiteRealizationBuildingWall endY
         * @property {number|null} [endZ] SiteRealizationBuildingWall endZ
         */

        /**
         * Constructs a new SiteRealizationBuildingWall.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuildingWall.
         * @implements ISiteRealizationBuildingWall
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall=} [properties] Properties to set
         */
        function SiteRealizationBuildingWall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuildingWall startX.
         * @member {number} startX
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.startX = 0;

        /**
         * SiteRealizationBuildingWall startY.
         * @member {number} startY
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.startY = 0;

        /**
         * SiteRealizationBuildingWall startZ.
         * @member {number} startZ
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.startZ = 0;

        /**
         * SiteRealizationBuildingWall endX.
         * @member {number} endX
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.endX = 0;

        /**
         * SiteRealizationBuildingWall endY.
         * @member {number} endY
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.endY = 0;

        /**
         * SiteRealizationBuildingWall endZ.
         * @member {number} endZ
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.endZ = 0;

        /**
         * Creates a new SiteRealizationBuildingWall instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall instance
         */
        SiteRealizationBuildingWall.create = function create(properties) {
            return new SiteRealizationBuildingWall(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuildingWall message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingWall.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall} message SiteRealizationBuildingWall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingWall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startX != null && message.hasOwnProperty("startX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.startX);
            if (message.startY != null && message.hasOwnProperty("startY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.startY);
            if (message.startZ != null && message.hasOwnProperty("startZ"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.startZ);
            if (message.endX != null && message.hasOwnProperty("endX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.endX);
            if (message.endY != null && message.hasOwnProperty("endY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.endY);
            if (message.endZ != null && message.hasOwnProperty("endZ"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.endZ);
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuildingWall message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingWall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall} message SiteRealizationBuildingWall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingWall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuildingWall message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingWall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuildingWall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startX = reader.int32();
                    break;
                case 2:
                    message.startY = reader.int32();
                    break;
                case 3:
                    message.startZ = reader.int32();
                    break;
                case 4:
                    message.endX = reader.int32();
                    break;
                case 5:
                    message.endY = reader.int32();
                    break;
                case 6:
                    message.endZ = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuildingWall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingWall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuildingWall message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuildingWall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startX != null && message.hasOwnProperty("startX"))
                if (!$util.isInteger(message.startX))
                    return "startX: integer expected";
            if (message.startY != null && message.hasOwnProperty("startY"))
                if (!$util.isInteger(message.startY))
                    return "startY: integer expected";
            if (message.startZ != null && message.hasOwnProperty("startZ"))
                if (!$util.isInteger(message.startZ))
                    return "startZ: integer expected";
            if (message.endX != null && message.hasOwnProperty("endX"))
                if (!$util.isInteger(message.endX))
                    return "endX: integer expected";
            if (message.endY != null && message.hasOwnProperty("endY"))
                if (!$util.isInteger(message.endY))
                    return "endY: integer expected";
            if (message.endZ != null && message.hasOwnProperty("endZ"))
                if (!$util.isInteger(message.endZ))
                    return "endZ: integer expected";
            return null;
        };

        /**
         * Creates a SiteRealizationBuildingWall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall
         */
        SiteRealizationBuildingWall.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuildingWall)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuildingWall();
            if (object.startX != null)
                message.startX = object.startX | 0;
            if (object.startY != null)
                message.startY = object.startY | 0;
            if (object.startZ != null)
                message.startZ = object.startZ | 0;
            if (object.endX != null)
                message.endX = object.endX | 0;
            if (object.endY != null)
                message.endY = object.endY | 0;
            if (object.endZ != null)
                message.endZ = object.endZ | 0;
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuildingWall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuildingWall} message SiteRealizationBuildingWall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuildingWall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.startX = 0;
                object.startY = 0;
                object.startZ = 0;
                object.endX = 0;
                object.endY = 0;
                object.endZ = 0;
            }
            if (message.startX != null && message.hasOwnProperty("startX"))
                object.startX = message.startX;
            if (message.startY != null && message.hasOwnProperty("startY"))
                object.startY = message.startY;
            if (message.startZ != null && message.hasOwnProperty("startZ"))
                object.startZ = message.startZ;
            if (message.endX != null && message.hasOwnProperty("endX"))
                object.endX = message.endX;
            if (message.endY != null && message.hasOwnProperty("endY"))
                object.endY = message.endY;
            if (message.endZ != null && message.hasOwnProperty("endZ"))
                object.endZ = message.endZ;
            return object;
        };

        /**
         * Converts this SiteRealizationBuildingWall to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuildingWall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuildingWall;
    })();

    RemoteFortressReader.SiteRealizationBuildingTower = (function() {

        /**
         * Properties of a SiteRealizationBuildingTower.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuildingTower
         * @property {number|null} [roofZ] SiteRealizationBuildingTower roofZ
         * @property {boolean|null} [round] SiteRealizationBuildingTower round
         * @property {boolean|null} [goblin] SiteRealizationBuildingTower goblin
         */

        /**
         * Constructs a new SiteRealizationBuildingTower.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuildingTower.
         * @implements ISiteRealizationBuildingTower
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower=} [properties] Properties to set
         */
        function SiteRealizationBuildingTower(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuildingTower roofZ.
         * @member {number} roofZ
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         */
        SiteRealizationBuildingTower.prototype.roofZ = 0;

        /**
         * SiteRealizationBuildingTower round.
         * @member {boolean} round
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         */
        SiteRealizationBuildingTower.prototype.round = false;

        /**
         * SiteRealizationBuildingTower goblin.
         * @member {boolean} goblin
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         */
        SiteRealizationBuildingTower.prototype.goblin = false;

        /**
         * Creates a new SiteRealizationBuildingTower instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower instance
         */
        SiteRealizationBuildingTower.create = function create(properties) {
            return new SiteRealizationBuildingTower(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuildingTower message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTower.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower} message SiteRealizationBuildingTower message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTower.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roofZ != null && message.hasOwnProperty("roofZ"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roofZ);
            if (message.round != null && message.hasOwnProperty("round"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.round);
            if (message.goblin != null && message.hasOwnProperty("goblin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.goblin);
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuildingTower message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTower.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower} message SiteRealizationBuildingTower message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTower.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuildingTower message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTower.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuildingTower();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roofZ = reader.int32();
                    break;
                case 2:
                    message.round = reader.bool();
                    break;
                case 3:
                    message.goblin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuildingTower message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTower.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuildingTower message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuildingTower.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roofZ != null && message.hasOwnProperty("roofZ"))
                if (!$util.isInteger(message.roofZ))
                    return "roofZ: integer expected";
            if (message.round != null && message.hasOwnProperty("round"))
                if (typeof message.round !== "boolean")
                    return "round: boolean expected";
            if (message.goblin != null && message.hasOwnProperty("goblin"))
                if (typeof message.goblin !== "boolean")
                    return "goblin: boolean expected";
            return null;
        };

        /**
         * Creates a SiteRealizationBuildingTower message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower
         */
        SiteRealizationBuildingTower.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuildingTower)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuildingTower();
            if (object.roofZ != null)
                message.roofZ = object.roofZ | 0;
            if (object.round != null)
                message.round = Boolean(object.round);
            if (object.goblin != null)
                message.goblin = Boolean(object.goblin);
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuildingTower message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuildingTower} message SiteRealizationBuildingTower
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuildingTower.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roofZ = 0;
                object.round = false;
                object.goblin = false;
            }
            if (message.roofZ != null && message.hasOwnProperty("roofZ"))
                object.roofZ = message.roofZ;
            if (message.round != null && message.hasOwnProperty("round"))
                object.round = message.round;
            if (message.goblin != null && message.hasOwnProperty("goblin"))
                object.goblin = message.goblin;
            return object;
        };

        /**
         * Converts this SiteRealizationBuildingTower to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuildingTower.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuildingTower;
    })();

    RemoteFortressReader.TrenchSpoke = (function() {

        /**
         * Properties of a TrenchSpoke.
         * @memberof RemoteFortressReader
         * @interface ITrenchSpoke
         * @property {number|null} [moundStart] TrenchSpoke moundStart
         * @property {number|null} [trenchStart] TrenchSpoke trenchStart
         * @property {number|null} [trenchEnd] TrenchSpoke trenchEnd
         * @property {number|null} [moundEnd] TrenchSpoke moundEnd
         */

        /**
         * Constructs a new TrenchSpoke.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TrenchSpoke.
         * @implements ITrenchSpoke
         * @constructor
         * @param {RemoteFortressReader.ITrenchSpoke=} [properties] Properties to set
         */
        function TrenchSpoke(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrenchSpoke moundStart.
         * @member {number} moundStart
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.moundStart = 0;

        /**
         * TrenchSpoke trenchStart.
         * @member {number} trenchStart
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.trenchStart = 0;

        /**
         * TrenchSpoke trenchEnd.
         * @member {number} trenchEnd
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.trenchEnd = 0;

        /**
         * TrenchSpoke moundEnd.
         * @member {number} moundEnd
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.moundEnd = 0;

        /**
         * Creates a new TrenchSpoke instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.ITrenchSpoke=} [properties] Properties to set
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke instance
         */
        TrenchSpoke.create = function create(properties) {
            return new TrenchSpoke(properties);
        };

        /**
         * Encodes the specified TrenchSpoke message. Does not implicitly {@link RemoteFortressReader.TrenchSpoke.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.ITrenchSpoke} message TrenchSpoke message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrenchSpoke.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.moundStart != null && message.hasOwnProperty("moundStart"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.moundStart);
            if (message.trenchStart != null && message.hasOwnProperty("trenchStart"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trenchStart);
            if (message.trenchEnd != null && message.hasOwnProperty("trenchEnd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trenchEnd);
            if (message.moundEnd != null && message.hasOwnProperty("moundEnd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.moundEnd);
            return writer;
        };

        /**
         * Encodes the specified TrenchSpoke message, length delimited. Does not implicitly {@link RemoteFortressReader.TrenchSpoke.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.ITrenchSpoke} message TrenchSpoke message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrenchSpoke.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrenchSpoke message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrenchSpoke.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TrenchSpoke();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.moundStart = reader.int32();
                    break;
                case 2:
                    message.trenchStart = reader.int32();
                    break;
                case 3:
                    message.trenchEnd = reader.int32();
                    break;
                case 4:
                    message.moundEnd = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrenchSpoke message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrenchSpoke.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrenchSpoke message.
         * @function verify
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrenchSpoke.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.moundStart != null && message.hasOwnProperty("moundStart"))
                if (!$util.isInteger(message.moundStart))
                    return "moundStart: integer expected";
            if (message.trenchStart != null && message.hasOwnProperty("trenchStart"))
                if (!$util.isInteger(message.trenchStart))
                    return "trenchStart: integer expected";
            if (message.trenchEnd != null && message.hasOwnProperty("trenchEnd"))
                if (!$util.isInteger(message.trenchEnd))
                    return "trenchEnd: integer expected";
            if (message.moundEnd != null && message.hasOwnProperty("moundEnd"))
                if (!$util.isInteger(message.moundEnd))
                    return "moundEnd: integer expected";
            return null;
        };

        /**
         * Creates a TrenchSpoke message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke
         */
        TrenchSpoke.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TrenchSpoke)
                return object;
            var message = new $root.RemoteFortressReader.TrenchSpoke();
            if (object.moundStart != null)
                message.moundStart = object.moundStart | 0;
            if (object.trenchStart != null)
                message.trenchStart = object.trenchStart | 0;
            if (object.trenchEnd != null)
                message.trenchEnd = object.trenchEnd | 0;
            if (object.moundEnd != null)
                message.moundEnd = object.moundEnd | 0;
            return message;
        };

        /**
         * Creates a plain object from a TrenchSpoke message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.TrenchSpoke} message TrenchSpoke
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrenchSpoke.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.moundStart = 0;
                object.trenchStart = 0;
                object.trenchEnd = 0;
                object.moundEnd = 0;
            }
            if (message.moundStart != null && message.hasOwnProperty("moundStart"))
                object.moundStart = message.moundStart;
            if (message.trenchStart != null && message.hasOwnProperty("trenchStart"))
                object.trenchStart = message.trenchStart;
            if (message.trenchEnd != null && message.hasOwnProperty("trenchEnd"))
                object.trenchEnd = message.trenchEnd;
            if (message.moundEnd != null && message.hasOwnProperty("moundEnd"))
                object.moundEnd = message.moundEnd;
            return object;
        };

        /**
         * Converts this TrenchSpoke to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrenchSpoke.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrenchSpoke;
    })();

    RemoteFortressReader.SiteRealizationBuildingTrenches = (function() {

        /**
         * Properties of a SiteRealizationBuildingTrenches.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuildingTrenches
         * @property {Array.<RemoteFortressReader.ITrenchSpoke>|null} [spokes] SiteRealizationBuildingTrenches spokes
         */

        /**
         * Constructs a new SiteRealizationBuildingTrenches.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuildingTrenches.
         * @implements ISiteRealizationBuildingTrenches
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches=} [properties] Properties to set
         */
        function SiteRealizationBuildingTrenches(properties) {
            this.spokes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuildingTrenches spokes.
         * @member {Array.<RemoteFortressReader.ITrenchSpoke>} spokes
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @instance
         */
        SiteRealizationBuildingTrenches.prototype.spokes = $util.emptyArray;

        /**
         * Creates a new SiteRealizationBuildingTrenches instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches instance
         */
        SiteRealizationBuildingTrenches.create = function create(properties) {
            return new SiteRealizationBuildingTrenches(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuildingTrenches message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTrenches.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches} message SiteRealizationBuildingTrenches message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTrenches.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spokes != null && message.spokes.length)
                for (var i = 0; i < message.spokes.length; ++i)
                    $root.RemoteFortressReader.TrenchSpoke.encode(message.spokes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuildingTrenches message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTrenches.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches} message SiteRealizationBuildingTrenches message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTrenches.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuildingTrenches message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTrenches.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuildingTrenches();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.spokes && message.spokes.length))
                        message.spokes = [];
                    message.spokes.push($root.RemoteFortressReader.TrenchSpoke.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuildingTrenches message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTrenches.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuildingTrenches message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuildingTrenches.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spokes != null && message.hasOwnProperty("spokes")) {
                if (!Array.isArray(message.spokes))
                    return "spokes: array expected";
                for (var i = 0; i < message.spokes.length; ++i) {
                    var error = $root.RemoteFortressReader.TrenchSpoke.verify(message.spokes[i]);
                    if (error)
                        return "spokes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SiteRealizationBuildingTrenches message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches
         */
        SiteRealizationBuildingTrenches.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuildingTrenches)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuildingTrenches();
            if (object.spokes) {
                if (!Array.isArray(object.spokes))
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuildingTrenches.spokes: array expected");
                message.spokes = [];
                for (var i = 0; i < object.spokes.length; ++i) {
                    if (typeof object.spokes[i] !== "object")
                        throw TypeError(".RemoteFortressReader.SiteRealizationBuildingTrenches.spokes: object expected");
                    message.spokes[i] = $root.RemoteFortressReader.TrenchSpoke.fromObject(object.spokes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuildingTrenches message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuildingTrenches} message SiteRealizationBuildingTrenches
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuildingTrenches.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.spokes = [];
            if (message.spokes && message.spokes.length) {
                object.spokes = [];
                for (var j = 0; j < message.spokes.length; ++j)
                    object.spokes[j] = $root.RemoteFortressReader.TrenchSpoke.toObject(message.spokes[j], options);
            }
            return object;
        };

        /**
         * Converts this SiteRealizationBuildingTrenches to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuildingTrenches.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuildingTrenches;
    })();

    RemoteFortressReader.SiteRealizationBuilding = (function() {

        /**
         * Properties of a SiteRealizationBuilding.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuilding
         * @property {number|null} [id] SiteRealizationBuilding id
         * @property {RemoteFortressReader.SiteRealizationBuildingType|null} [type] SiteRealizationBuilding type
         * @property {number|null} [minX] SiteRealizationBuilding minX
         * @property {number|null} [minY] SiteRealizationBuilding minY
         * @property {number|null} [maxX] SiteRealizationBuilding maxX
         * @property {number|null} [maxY] SiteRealizationBuilding maxY
         * @property {RemoteFortressReader.IMatPair|null} [material] SiteRealizationBuilding material
         * @property {RemoteFortressReader.ISiteRealizationBuildingWall|null} [wallInfo] SiteRealizationBuilding wallInfo
         * @property {RemoteFortressReader.ISiteRealizationBuildingTower|null} [towerInfo] SiteRealizationBuilding towerInfo
         * @property {RemoteFortressReader.ISiteRealizationBuildingTrenches|null} [trenchInfo] SiteRealizationBuilding trenchInfo
         */

        /**
         * Constructs a new SiteRealizationBuilding.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuilding.
         * @implements ISiteRealizationBuilding
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuilding=} [properties] Properties to set
         */
        function SiteRealizationBuilding(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuilding id.
         * @member {number} id
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.id = 0;

        /**
         * SiteRealizationBuilding type.
         * @member {RemoteFortressReader.SiteRealizationBuildingType} type
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.type = 0;

        /**
         * SiteRealizationBuilding minX.
         * @member {number} minX
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.minX = 0;

        /**
         * SiteRealizationBuilding minY.
         * @member {number} minY
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.minY = 0;

        /**
         * SiteRealizationBuilding maxX.
         * @member {number} maxX
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.maxX = 0;

        /**
         * SiteRealizationBuilding maxY.
         * @member {number} maxY
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.maxY = 0;

        /**
         * SiteRealizationBuilding material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.material = null;

        /**
         * SiteRealizationBuilding wallInfo.
         * @member {RemoteFortressReader.ISiteRealizationBuildingWall|null|undefined} wallInfo
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.wallInfo = null;

        /**
         * SiteRealizationBuilding towerInfo.
         * @member {RemoteFortressReader.ISiteRealizationBuildingTower|null|undefined} towerInfo
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.towerInfo = null;

        /**
         * SiteRealizationBuilding trenchInfo.
         * @member {RemoteFortressReader.ISiteRealizationBuildingTrenches|null|undefined} trenchInfo
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.trenchInfo = null;

        /**
         * Creates a new SiteRealizationBuilding instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuilding=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding instance
         */
        SiteRealizationBuilding.create = function create(properties) {
            return new SiteRealizationBuilding(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuilding message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuilding.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuilding} message SiteRealizationBuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuilding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.minX != null && message.hasOwnProperty("minX"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minX);
            if (message.minY != null && message.hasOwnProperty("minY"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minY);
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxX);
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxY);
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.wallInfo != null && message.hasOwnProperty("wallInfo"))
                $root.RemoteFortressReader.SiteRealizationBuildingWall.encode(message.wallInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.towerInfo != null && message.hasOwnProperty("towerInfo"))
                $root.RemoteFortressReader.SiteRealizationBuildingTower.encode(message.towerInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.trenchInfo != null && message.hasOwnProperty("trenchInfo"))
                $root.RemoteFortressReader.SiteRealizationBuildingTrenches.encode(message.trenchInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuilding message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuilding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuilding} message SiteRealizationBuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuilding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuilding message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuilding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuilding();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.minX = reader.int32();
                    break;
                case 4:
                    message.minY = reader.int32();
                    break;
                case 5:
                    message.maxX = reader.int32();
                    break;
                case 6:
                    message.maxY = reader.int32();
                    break;
                case 7:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.wallInfo = $root.RemoteFortressReader.SiteRealizationBuildingWall.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.towerInfo = $root.RemoteFortressReader.SiteRealizationBuildingTower.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.trenchInfo = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuilding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuilding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuilding message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuilding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                    break;
                }
            if (message.minX != null && message.hasOwnProperty("minX"))
                if (!$util.isInteger(message.minX))
                    return "minX: integer expected";
            if (message.minY != null && message.hasOwnProperty("minY"))
                if (!$util.isInteger(message.minY))
                    return "minY: integer expected";
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                if (!$util.isInteger(message.maxX))
                    return "maxX: integer expected";
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                if (!$util.isInteger(message.maxY))
                    return "maxY: integer expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.wallInfo != null && message.hasOwnProperty("wallInfo")) {
                var error = $root.RemoteFortressReader.SiteRealizationBuildingWall.verify(message.wallInfo);
                if (error)
                    return "wallInfo." + error;
            }
            if (message.towerInfo != null && message.hasOwnProperty("towerInfo")) {
                var error = $root.RemoteFortressReader.SiteRealizationBuildingTower.verify(message.towerInfo);
                if (error)
                    return "towerInfo." + error;
            }
            if (message.trenchInfo != null && message.hasOwnProperty("trenchInfo")) {
                var error = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.verify(message.trenchInfo);
                if (error)
                    return "trenchInfo." + error;
            }
            return null;
        };

        /**
         * Creates a SiteRealizationBuilding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding
         */
        SiteRealizationBuilding.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuilding)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuilding();
            if (object.id != null)
                message.id = object.id | 0;
            switch (object.type) {
            case "cottage_plot":
            case 0:
                message.type = 0;
                break;
            case "castle_wall":
            case 1:
                message.type = 1;
                break;
            case "castle_tower":
            case 2:
                message.type = 2;
                break;
            case "castle_courtyard":
            case 3:
                message.type = 3;
                break;
            case "house":
            case 4:
                message.type = 4;
                break;
            case "temple":
            case 5:
                message.type = 5;
                break;
            case "tomb":
            case 6:
                message.type = 6;
                break;
            case "shop_house":
            case 7:
                message.type = 7;
                break;
            case "warehouse":
            case 8:
                message.type = 8;
                break;
            case "market_square":
            case 9:
                message.type = 9;
                break;
            case "pasture":
            case 10:
                message.type = 10;
                break;
            case "waste":
            case 11:
                message.type = 11;
                break;
            case "courtyard":
            case 12:
                message.type = 12;
                break;
            case "well":
            case 13:
                message.type = 13;
                break;
            case "vault":
            case 14:
                message.type = 14;
                break;
            case "great_tower":
            case 15:
                message.type = 15;
                break;
            case "trenches":
            case 16:
                message.type = 16;
                break;
            case "tree_house":
            case 17:
                message.type = 17;
                break;
            case "hillock_house":
            case 18:
                message.type = 18;
                break;
            case "mead_hall":
            case 19:
                message.type = 19;
                break;
            case "fortress_entrance":
            case 20:
                message.type = 20;
                break;
            case "library":
            case 21:
                message.type = 21;
                break;
            case "tavern":
            case 22:
                message.type = 22;
                break;
            }
            if (object.minX != null)
                message.minX = object.minX | 0;
            if (object.minY != null)
                message.minY = object.minY | 0;
            if (object.maxX != null)
                message.maxX = object.maxX | 0;
            if (object.maxY != null)
                message.maxY = object.maxY | 0;
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.wallInfo != null) {
                if (typeof object.wallInfo !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.wallInfo: object expected");
                message.wallInfo = $root.RemoteFortressReader.SiteRealizationBuildingWall.fromObject(object.wallInfo);
            }
            if (object.towerInfo != null) {
                if (typeof object.towerInfo !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.towerInfo: object expected");
                message.towerInfo = $root.RemoteFortressReader.SiteRealizationBuildingTower.fromObject(object.towerInfo);
            }
            if (object.trenchInfo != null) {
                if (typeof object.trenchInfo !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.trenchInfo: object expected");
                message.trenchInfo = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.fromObject(object.trenchInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuilding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuilding} message SiteRealizationBuilding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuilding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.type = options.enums === String ? "cottage_plot" : 0;
                object.minX = 0;
                object.minY = 0;
                object.maxX = 0;
                object.maxY = 0;
                object.material = null;
                object.wallInfo = null;
                object.towerInfo = null;
                object.trenchInfo = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.SiteRealizationBuildingType[message.type] : message.type;
            if (message.minX != null && message.hasOwnProperty("minX"))
                object.minX = message.minX;
            if (message.minY != null && message.hasOwnProperty("minY"))
                object.minY = message.minY;
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                object.maxX = message.maxX;
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                object.maxY = message.maxY;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.wallInfo != null && message.hasOwnProperty("wallInfo"))
                object.wallInfo = $root.RemoteFortressReader.SiteRealizationBuildingWall.toObject(message.wallInfo, options);
            if (message.towerInfo != null && message.hasOwnProperty("towerInfo"))
                object.towerInfo = $root.RemoteFortressReader.SiteRealizationBuildingTower.toObject(message.towerInfo, options);
            if (message.trenchInfo != null && message.hasOwnProperty("trenchInfo"))
                object.trenchInfo = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.toObject(message.trenchInfo, options);
            return object;
        };

        /**
         * Converts this SiteRealizationBuilding to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuilding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuilding;
    })();

    RemoteFortressReader.RegionTile = (function() {

        /**
         * Properties of a RegionTile.
         * @memberof RemoteFortressReader
         * @interface IRegionTile
         * @property {number|null} [elevation] RegionTile elevation
         * @property {number|null} [rainfall] RegionTile rainfall
         * @property {number|null} [vegetation] RegionTile vegetation
         * @property {number|null} [temperature] RegionTile temperature
         * @property {number|null} [evilness] RegionTile evilness
         * @property {number|null} [drainage] RegionTile drainage
         * @property {number|null} [volcanism] RegionTile volcanism
         * @property {number|null} [savagery] RegionTile savagery
         * @property {number|null} [salinity] RegionTile salinity
         * @property {RemoteFortressReader.IRiverTile|null} [riverTiles] RegionTile riverTiles
         * @property {number|null} [waterElevation] RegionTile waterElevation
         * @property {RemoteFortressReader.IMatPair|null} [surfaceMaterial] RegionTile surfaceMaterial
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [plantMaterials] RegionTile plantMaterials
         * @property {Array.<RemoteFortressReader.ISiteRealizationBuilding>|null} [buildings] RegionTile buildings
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [stoneMaterials] RegionTile stoneMaterials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [treeMaterials] RegionTile treeMaterials
         * @property {number|null} [snow] RegionTile snow
         */

        /**
         * Constructs a new RegionTile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RegionTile.
         * @implements IRegionTile
         * @constructor
         * @param {RemoteFortressReader.IRegionTile=} [properties] Properties to set
         */
        function RegionTile(properties) {
            this.plantMaterials = [];
            this.buildings = [];
            this.stoneMaterials = [];
            this.treeMaterials = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegionTile elevation.
         * @member {number} elevation
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.elevation = 0;

        /**
         * RegionTile rainfall.
         * @member {number} rainfall
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.rainfall = 0;

        /**
         * RegionTile vegetation.
         * @member {number} vegetation
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.vegetation = 0;

        /**
         * RegionTile temperature.
         * @member {number} temperature
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.temperature = 0;

        /**
         * RegionTile evilness.
         * @member {number} evilness
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.evilness = 0;

        /**
         * RegionTile drainage.
         * @member {number} drainage
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.drainage = 0;

        /**
         * RegionTile volcanism.
         * @member {number} volcanism
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.volcanism = 0;

        /**
         * RegionTile savagery.
         * @member {number} savagery
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.savagery = 0;

        /**
         * RegionTile salinity.
         * @member {number} salinity
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.salinity = 0;

        /**
         * RegionTile riverTiles.
         * @member {RemoteFortressReader.IRiverTile|null|undefined} riverTiles
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.riverTiles = null;

        /**
         * RegionTile waterElevation.
         * @member {number} waterElevation
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.waterElevation = 0;

        /**
         * RegionTile surfaceMaterial.
         * @member {RemoteFortressReader.IMatPair|null|undefined} surfaceMaterial
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.surfaceMaterial = null;

        /**
         * RegionTile plantMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} plantMaterials
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.plantMaterials = $util.emptyArray;

        /**
         * RegionTile buildings.
         * @member {Array.<RemoteFortressReader.ISiteRealizationBuilding>} buildings
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.buildings = $util.emptyArray;

        /**
         * RegionTile stoneMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} stoneMaterials
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.stoneMaterials = $util.emptyArray;

        /**
         * RegionTile treeMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} treeMaterials
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.treeMaterials = $util.emptyArray;

        /**
         * RegionTile snow.
         * @member {number} snow
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.snow = 0;

        /**
         * Creates a new RegionTile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.IRegionTile=} [properties] Properties to set
         * @returns {RemoteFortressReader.RegionTile} RegionTile instance
         */
        RegionTile.create = function create(properties) {
            return new RegionTile(properties);
        };

        /**
         * Encodes the specified RegionTile message. Does not implicitly {@link RemoteFortressReader.RegionTile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.IRegionTile} message RegionTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elevation);
            if (message.rainfall != null && message.hasOwnProperty("rainfall"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rainfall);
            if (message.vegetation != null && message.hasOwnProperty("vegetation"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.vegetation);
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.temperature);
            if (message.evilness != null && message.hasOwnProperty("evilness"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.evilness);
            if (message.drainage != null && message.hasOwnProperty("drainage"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.drainage);
            if (message.volcanism != null && message.hasOwnProperty("volcanism"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.volcanism);
            if (message.savagery != null && message.hasOwnProperty("savagery"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.savagery);
            if (message.salinity != null && message.hasOwnProperty("salinity"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.salinity);
            if (message.riverTiles != null && message.hasOwnProperty("riverTiles"))
                $root.RemoteFortressReader.RiverTile.encode(message.riverTiles, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.waterElevation != null && message.hasOwnProperty("waterElevation"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.waterElevation);
            if (message.surfaceMaterial != null && message.hasOwnProperty("surfaceMaterial"))
                $root.RemoteFortressReader.MatPair.encode(message.surfaceMaterial, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.plantMaterials != null && message.plantMaterials.length)
                for (var i = 0; i < message.plantMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.plantMaterials[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.buildings != null && message.buildings.length)
                for (var i = 0; i < message.buildings.length; ++i)
                    $root.RemoteFortressReader.SiteRealizationBuilding.encode(message.buildings[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.stoneMaterials != null && message.stoneMaterials.length)
                for (var i = 0; i < message.stoneMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.stoneMaterials[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.treeMaterials != null && message.treeMaterials.length)
                for (var i = 0; i < message.treeMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.treeMaterials[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.snow != null && message.hasOwnProperty("snow"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.snow);
            return writer;
        };

        /**
         * Encodes the specified RegionTile message, length delimited. Does not implicitly {@link RemoteFortressReader.RegionTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.IRegionTile} message RegionTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegionTile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RegionTile} RegionTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RegionTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.elevation = reader.int32();
                    break;
                case 2:
                    message.rainfall = reader.int32();
                    break;
                case 3:
                    message.vegetation = reader.int32();
                    break;
                case 4:
                    message.temperature = reader.int32();
                    break;
                case 5:
                    message.evilness = reader.int32();
                    break;
                case 6:
                    message.drainage = reader.int32();
                    break;
                case 7:
                    message.volcanism = reader.int32();
                    break;
                case 8:
                    message.savagery = reader.int32();
                    break;
                case 9:
                    message.salinity = reader.int32();
                    break;
                case 10:
                    message.riverTiles = $root.RemoteFortressReader.RiverTile.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.waterElevation = reader.int32();
                    break;
                case 12:
                    message.surfaceMaterial = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 13:
                    if (!(message.plantMaterials && message.plantMaterials.length))
                        message.plantMaterials = [];
                    message.plantMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.buildings && message.buildings.length))
                        message.buildings = [];
                    message.buildings.push($root.RemoteFortressReader.SiteRealizationBuilding.decode(reader, reader.uint32()));
                    break;
                case 15:
                    if (!(message.stoneMaterials && message.stoneMaterials.length))
                        message.stoneMaterials = [];
                    message.stoneMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 16:
                    if (!(message.treeMaterials && message.treeMaterials.length))
                        message.treeMaterials = [];
                    message.treeMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.snow = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegionTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RegionTile} RegionTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegionTile message.
         * @function verify
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegionTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                if (!$util.isInteger(message.elevation))
                    return "elevation: integer expected";
            if (message.rainfall != null && message.hasOwnProperty("rainfall"))
                if (!$util.isInteger(message.rainfall))
                    return "rainfall: integer expected";
            if (message.vegetation != null && message.hasOwnProperty("vegetation"))
                if (!$util.isInteger(message.vegetation))
                    return "vegetation: integer expected";
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                if (!$util.isInteger(message.temperature))
                    return "temperature: integer expected";
            if (message.evilness != null && message.hasOwnProperty("evilness"))
                if (!$util.isInteger(message.evilness))
                    return "evilness: integer expected";
            if (message.drainage != null && message.hasOwnProperty("drainage"))
                if (!$util.isInteger(message.drainage))
                    return "drainage: integer expected";
            if (message.volcanism != null && message.hasOwnProperty("volcanism"))
                if (!$util.isInteger(message.volcanism))
                    return "volcanism: integer expected";
            if (message.savagery != null && message.hasOwnProperty("savagery"))
                if (!$util.isInteger(message.savagery))
                    return "savagery: integer expected";
            if (message.salinity != null && message.hasOwnProperty("salinity"))
                if (!$util.isInteger(message.salinity))
                    return "salinity: integer expected";
            if (message.riverTiles != null && message.hasOwnProperty("riverTiles")) {
                var error = $root.RemoteFortressReader.RiverTile.verify(message.riverTiles);
                if (error)
                    return "riverTiles." + error;
            }
            if (message.waterElevation != null && message.hasOwnProperty("waterElevation"))
                if (!$util.isInteger(message.waterElevation))
                    return "waterElevation: integer expected";
            if (message.surfaceMaterial != null && message.hasOwnProperty("surfaceMaterial")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.surfaceMaterial);
                if (error)
                    return "surfaceMaterial." + error;
            }
            if (message.plantMaterials != null && message.hasOwnProperty("plantMaterials")) {
                if (!Array.isArray(message.plantMaterials))
                    return "plantMaterials: array expected";
                for (var i = 0; i < message.plantMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.plantMaterials[i]);
                    if (error)
                        return "plantMaterials." + error;
                }
            }
            if (message.buildings != null && message.hasOwnProperty("buildings")) {
                if (!Array.isArray(message.buildings))
                    return "buildings: array expected";
                for (var i = 0; i < message.buildings.length; ++i) {
                    var error = $root.RemoteFortressReader.SiteRealizationBuilding.verify(message.buildings[i]);
                    if (error)
                        return "buildings." + error;
                }
            }
            if (message.stoneMaterials != null && message.hasOwnProperty("stoneMaterials")) {
                if (!Array.isArray(message.stoneMaterials))
                    return "stoneMaterials: array expected";
                for (var i = 0; i < message.stoneMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.stoneMaterials[i]);
                    if (error)
                        return "stoneMaterials." + error;
                }
            }
            if (message.treeMaterials != null && message.hasOwnProperty("treeMaterials")) {
                if (!Array.isArray(message.treeMaterials))
                    return "treeMaterials: array expected";
                for (var i = 0; i < message.treeMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.treeMaterials[i]);
                    if (error)
                        return "treeMaterials." + error;
                }
            }
            if (message.snow != null && message.hasOwnProperty("snow"))
                if (!$util.isInteger(message.snow))
                    return "snow: integer expected";
            return null;
        };

        /**
         * Creates a RegionTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RegionTile} RegionTile
         */
        RegionTile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RegionTile)
                return object;
            var message = new $root.RemoteFortressReader.RegionTile();
            if (object.elevation != null)
                message.elevation = object.elevation | 0;
            if (object.rainfall != null)
                message.rainfall = object.rainfall | 0;
            if (object.vegetation != null)
                message.vegetation = object.vegetation | 0;
            if (object.temperature != null)
                message.temperature = object.temperature | 0;
            if (object.evilness != null)
                message.evilness = object.evilness | 0;
            if (object.drainage != null)
                message.drainage = object.drainage | 0;
            if (object.volcanism != null)
                message.volcanism = object.volcanism | 0;
            if (object.savagery != null)
                message.savagery = object.savagery | 0;
            if (object.salinity != null)
                message.salinity = object.salinity | 0;
            if (object.riverTiles != null) {
                if (typeof object.riverTiles !== "object")
                    throw TypeError(".RemoteFortressReader.RegionTile.riverTiles: object expected");
                message.riverTiles = $root.RemoteFortressReader.RiverTile.fromObject(object.riverTiles);
            }
            if (object.waterElevation != null)
                message.waterElevation = object.waterElevation | 0;
            if (object.surfaceMaterial != null) {
                if (typeof object.surfaceMaterial !== "object")
                    throw TypeError(".RemoteFortressReader.RegionTile.surfaceMaterial: object expected");
                message.surfaceMaterial = $root.RemoteFortressReader.MatPair.fromObject(object.surfaceMaterial);
            }
            if (object.plantMaterials) {
                if (!Array.isArray(object.plantMaterials))
                    throw TypeError(".RemoteFortressReader.RegionTile.plantMaterials: array expected");
                message.plantMaterials = [];
                for (var i = 0; i < object.plantMaterials.length; ++i) {
                    if (typeof object.plantMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.plantMaterials: object expected");
                    message.plantMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.plantMaterials[i]);
                }
            }
            if (object.buildings) {
                if (!Array.isArray(object.buildings))
                    throw TypeError(".RemoteFortressReader.RegionTile.buildings: array expected");
                message.buildings = [];
                for (var i = 0; i < object.buildings.length; ++i) {
                    if (typeof object.buildings[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.buildings: object expected");
                    message.buildings[i] = $root.RemoteFortressReader.SiteRealizationBuilding.fromObject(object.buildings[i]);
                }
            }
            if (object.stoneMaterials) {
                if (!Array.isArray(object.stoneMaterials))
                    throw TypeError(".RemoteFortressReader.RegionTile.stoneMaterials: array expected");
                message.stoneMaterials = [];
                for (var i = 0; i < object.stoneMaterials.length; ++i) {
                    if (typeof object.stoneMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.stoneMaterials: object expected");
                    message.stoneMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.stoneMaterials[i]);
                }
            }
            if (object.treeMaterials) {
                if (!Array.isArray(object.treeMaterials))
                    throw TypeError(".RemoteFortressReader.RegionTile.treeMaterials: array expected");
                message.treeMaterials = [];
                for (var i = 0; i < object.treeMaterials.length; ++i) {
                    if (typeof object.treeMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.treeMaterials: object expected");
                    message.treeMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.treeMaterials[i]);
                }
            }
            if (object.snow != null)
                message.snow = object.snow | 0;
            return message;
        };

        /**
         * Creates a plain object from a RegionTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.RegionTile} message RegionTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegionTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.plantMaterials = [];
                object.buildings = [];
                object.stoneMaterials = [];
                object.treeMaterials = [];
            }
            if (options.defaults) {
                object.elevation = 0;
                object.rainfall = 0;
                object.vegetation = 0;
                object.temperature = 0;
                object.evilness = 0;
                object.drainage = 0;
                object.volcanism = 0;
                object.savagery = 0;
                object.salinity = 0;
                object.riverTiles = null;
                object.waterElevation = 0;
                object.surfaceMaterial = null;
                object.snow = 0;
            }
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                object.elevation = message.elevation;
            if (message.rainfall != null && message.hasOwnProperty("rainfall"))
                object.rainfall = message.rainfall;
            if (message.vegetation != null && message.hasOwnProperty("vegetation"))
                object.vegetation = message.vegetation;
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                object.temperature = message.temperature;
            if (message.evilness != null && message.hasOwnProperty("evilness"))
                object.evilness = message.evilness;
            if (message.drainage != null && message.hasOwnProperty("drainage"))
                object.drainage = message.drainage;
            if (message.volcanism != null && message.hasOwnProperty("volcanism"))
                object.volcanism = message.volcanism;
            if (message.savagery != null && message.hasOwnProperty("savagery"))
                object.savagery = message.savagery;
            if (message.salinity != null && message.hasOwnProperty("salinity"))
                object.salinity = message.salinity;
            if (message.riverTiles != null && message.hasOwnProperty("riverTiles"))
                object.riverTiles = $root.RemoteFortressReader.RiverTile.toObject(message.riverTiles, options);
            if (message.waterElevation != null && message.hasOwnProperty("waterElevation"))
                object.waterElevation = message.waterElevation;
            if (message.surfaceMaterial != null && message.hasOwnProperty("surfaceMaterial"))
                object.surfaceMaterial = $root.RemoteFortressReader.MatPair.toObject(message.surfaceMaterial, options);
            if (message.plantMaterials && message.plantMaterials.length) {
                object.plantMaterials = [];
                for (var j = 0; j < message.plantMaterials.length; ++j)
                    object.plantMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.plantMaterials[j], options);
            }
            if (message.buildings && message.buildings.length) {
                object.buildings = [];
                for (var j = 0; j < message.buildings.length; ++j)
                    object.buildings[j] = $root.RemoteFortressReader.SiteRealizationBuilding.toObject(message.buildings[j], options);
            }
            if (message.stoneMaterials && message.stoneMaterials.length) {
                object.stoneMaterials = [];
                for (var j = 0; j < message.stoneMaterials.length; ++j)
                    object.stoneMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.stoneMaterials[j], options);
            }
            if (message.treeMaterials && message.treeMaterials.length) {
                object.treeMaterials = [];
                for (var j = 0; j < message.treeMaterials.length; ++j)
                    object.treeMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.treeMaterials[j], options);
            }
            if (message.snow != null && message.hasOwnProperty("snow"))
                object.snow = message.snow;
            return object;
        };

        /**
         * Converts this RegionTile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegionTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegionTile;
    })();

    RemoteFortressReader.RegionMap = (function() {

        /**
         * Properties of a RegionMap.
         * @memberof RemoteFortressReader
         * @interface IRegionMap
         * @property {number|null} [mapX] RegionMap mapX
         * @property {number|null} [mapY] RegionMap mapY
         * @property {string|null} [name] RegionMap name
         * @property {string|null} [nameEnglish] RegionMap nameEnglish
         * @property {Array.<RemoteFortressReader.IRegionTile>|null} [tiles] RegionMap tiles
         */

        /**
         * Constructs a new RegionMap.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RegionMap.
         * @implements IRegionMap
         * @constructor
         * @param {RemoteFortressReader.IRegionMap=} [properties] Properties to set
         */
        function RegionMap(properties) {
            this.tiles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegionMap mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.mapX = 0;

        /**
         * RegionMap mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.mapY = 0;

        /**
         * RegionMap name.
         * @member {string} name
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.name = "";

        /**
         * RegionMap nameEnglish.
         * @member {string} nameEnglish
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.nameEnglish = "";

        /**
         * RegionMap tiles.
         * @member {Array.<RemoteFortressReader.IRegionTile>} tiles
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.tiles = $util.emptyArray;

        /**
         * Creates a new RegionMap instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.IRegionMap=} [properties] Properties to set
         * @returns {RemoteFortressReader.RegionMap} RegionMap instance
         */
        RegionMap.create = function create(properties) {
            return new RegionMap(properties);
        };

        /**
         * Encodes the specified RegionMap message. Does not implicitly {@link RemoteFortressReader.RegionMap.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.IRegionMap} message RegionMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mapX);
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapY);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nameEnglish);
            if (message.tiles != null && message.tiles.length)
                for (var i = 0; i < message.tiles.length; ++i)
                    $root.RemoteFortressReader.RegionTile.encode(message.tiles[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegionMap message, length delimited. Does not implicitly {@link RemoteFortressReader.RegionMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.IRegionMap} message RegionMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegionMap message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RegionMap} RegionMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RegionMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mapX = reader.int32();
                    break;
                case 2:
                    message.mapY = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.nameEnglish = reader.string();
                    break;
                case 5:
                    if (!(message.tiles && message.tiles.length))
                        message.tiles = [];
                    message.tiles.push($root.RemoteFortressReader.RegionTile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegionMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RegionMap} RegionMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegionMap message.
         * @function verify
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegionMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                if (!$util.isInteger(message.mapX))
                    return "mapX: integer expected";
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                if (!$util.isInteger(message.mapY))
                    return "mapY: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                if (!$util.isString(message.nameEnglish))
                    return "nameEnglish: string expected";
            if (message.tiles != null && message.hasOwnProperty("tiles")) {
                if (!Array.isArray(message.tiles))
                    return "tiles: array expected";
                for (var i = 0; i < message.tiles.length; ++i) {
                    var error = $root.RemoteFortressReader.RegionTile.verify(message.tiles[i]);
                    if (error)
                        return "tiles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegionMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RegionMap} RegionMap
         */
        RegionMap.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RegionMap)
                return object;
            var message = new $root.RemoteFortressReader.RegionMap();
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.nameEnglish != null)
                message.nameEnglish = String(object.nameEnglish);
            if (object.tiles) {
                if (!Array.isArray(object.tiles))
                    throw TypeError(".RemoteFortressReader.RegionMap.tiles: array expected");
                message.tiles = [];
                for (var i = 0; i < object.tiles.length; ++i) {
                    if (typeof object.tiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionMap.tiles: object expected");
                    message.tiles[i] = $root.RemoteFortressReader.RegionTile.fromObject(object.tiles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RegionMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.RegionMap} message RegionMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegionMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tiles = [];
            if (options.defaults) {
                object.mapX = 0;
                object.mapY = 0;
                object.name = "";
                object.nameEnglish = "";
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                object.nameEnglish = message.nameEnglish;
            if (message.tiles && message.tiles.length) {
                object.tiles = [];
                for (var j = 0; j < message.tiles.length; ++j)
                    object.tiles[j] = $root.RemoteFortressReader.RegionTile.toObject(message.tiles[j], options);
            }
            return object;
        };

        /**
         * Converts this RegionMap to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegionMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegionMap;
    })();

    RemoteFortressReader.RegionMaps = (function() {

        /**
         * Properties of a RegionMaps.
         * @memberof RemoteFortressReader
         * @interface IRegionMaps
         * @property {Array.<RemoteFortressReader.IWorldMap>|null} [worldMaps] RegionMaps worldMaps
         * @property {Array.<RemoteFortressReader.IRegionMap>|null} [regionMaps] RegionMaps regionMaps
         */

        /**
         * Constructs a new RegionMaps.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RegionMaps.
         * @implements IRegionMaps
         * @constructor
         * @param {RemoteFortressReader.IRegionMaps=} [properties] Properties to set
         */
        function RegionMaps(properties) {
            this.worldMaps = [];
            this.regionMaps = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegionMaps worldMaps.
         * @member {Array.<RemoteFortressReader.IWorldMap>} worldMaps
         * @memberof RemoteFortressReader.RegionMaps
         * @instance
         */
        RegionMaps.prototype.worldMaps = $util.emptyArray;

        /**
         * RegionMaps regionMaps.
         * @member {Array.<RemoteFortressReader.IRegionMap>} regionMaps
         * @memberof RemoteFortressReader.RegionMaps
         * @instance
         */
        RegionMaps.prototype.regionMaps = $util.emptyArray;

        /**
         * Creates a new RegionMaps instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.IRegionMaps=} [properties] Properties to set
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps instance
         */
        RegionMaps.create = function create(properties) {
            return new RegionMaps(properties);
        };

        /**
         * Encodes the specified RegionMaps message. Does not implicitly {@link RemoteFortressReader.RegionMaps.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.IRegionMaps} message RegionMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMaps.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldMaps != null && message.worldMaps.length)
                for (var i = 0; i < message.worldMaps.length; ++i)
                    $root.RemoteFortressReader.WorldMap.encode(message.worldMaps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.regionMaps != null && message.regionMaps.length)
                for (var i = 0; i < message.regionMaps.length; ++i)
                    $root.RemoteFortressReader.RegionMap.encode(message.regionMaps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegionMaps message, length delimited. Does not implicitly {@link RemoteFortressReader.RegionMaps.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.IRegionMaps} message RegionMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMaps.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegionMaps message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMaps.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RegionMaps();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.worldMaps && message.worldMaps.length))
                        message.worldMaps = [];
                    message.worldMaps.push($root.RemoteFortressReader.WorldMap.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.regionMaps && message.regionMaps.length))
                        message.regionMaps = [];
                    message.regionMaps.push($root.RemoteFortressReader.RegionMap.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegionMaps message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMaps.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegionMaps message.
         * @function verify
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegionMaps.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldMaps != null && message.hasOwnProperty("worldMaps")) {
                if (!Array.isArray(message.worldMaps))
                    return "worldMaps: array expected";
                for (var i = 0; i < message.worldMaps.length; ++i) {
                    var error = $root.RemoteFortressReader.WorldMap.verify(message.worldMaps[i]);
                    if (error)
                        return "worldMaps." + error;
                }
            }
            if (message.regionMaps != null && message.hasOwnProperty("regionMaps")) {
                if (!Array.isArray(message.regionMaps))
                    return "regionMaps: array expected";
                for (var i = 0; i < message.regionMaps.length; ++i) {
                    var error = $root.RemoteFortressReader.RegionMap.verify(message.regionMaps[i]);
                    if (error)
                        return "regionMaps." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegionMaps message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps
         */
        RegionMaps.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RegionMaps)
                return object;
            var message = new $root.RemoteFortressReader.RegionMaps();
            if (object.worldMaps) {
                if (!Array.isArray(object.worldMaps))
                    throw TypeError(".RemoteFortressReader.RegionMaps.worldMaps: array expected");
                message.worldMaps = [];
                for (var i = 0; i < object.worldMaps.length; ++i) {
                    if (typeof object.worldMaps[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionMaps.worldMaps: object expected");
                    message.worldMaps[i] = $root.RemoteFortressReader.WorldMap.fromObject(object.worldMaps[i]);
                }
            }
            if (object.regionMaps) {
                if (!Array.isArray(object.regionMaps))
                    throw TypeError(".RemoteFortressReader.RegionMaps.regionMaps: array expected");
                message.regionMaps = [];
                for (var i = 0; i < object.regionMaps.length; ++i) {
                    if (typeof object.regionMaps[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionMaps.regionMaps: object expected");
                    message.regionMaps[i] = $root.RemoteFortressReader.RegionMap.fromObject(object.regionMaps[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RegionMaps message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.RegionMaps} message RegionMaps
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegionMaps.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.worldMaps = [];
                object.regionMaps = [];
            }
            if (message.worldMaps && message.worldMaps.length) {
                object.worldMaps = [];
                for (var j = 0; j < message.worldMaps.length; ++j)
                    object.worldMaps[j] = $root.RemoteFortressReader.WorldMap.toObject(message.worldMaps[j], options);
            }
            if (message.regionMaps && message.regionMaps.length) {
                object.regionMaps = [];
                for (var j = 0; j < message.regionMaps.length; ++j)
                    object.regionMaps[j] = $root.RemoteFortressReader.RegionMap.toObject(message.regionMaps[j], options);
            }
            return object;
        };

        /**
         * Converts this RegionMaps to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RegionMaps
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegionMaps.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegionMaps;
    })();

    /**
     * PatternType enum.
     * @name RemoteFortressReader.PatternType
     * @enum {string}
     * @property {number} MONOTONE=0 MONOTONE value
     * @property {number} STRIPES=1 STRIPES value
     * @property {number} IRIS_EYE=2 IRIS_EYE value
     * @property {number} SPOTS=3 SPOTS value
     * @property {number} PUPIL_EYE=4 PUPIL_EYE value
     * @property {number} MOTTLED=5 MOTTLED value
     */
    RemoteFortressReader.PatternType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MONOTONE"] = 0;
        values[valuesById[1] = "STRIPES"] = 1;
        values[valuesById[2] = "IRIS_EYE"] = 2;
        values[valuesById[3] = "SPOTS"] = 3;
        values[valuesById[4] = "PUPIL_EYE"] = 4;
        values[valuesById[5] = "MOTTLED"] = 5;
        return values;
    })();

    RemoteFortressReader.PatternDescriptor = (function() {

        /**
         * Properties of a PatternDescriptor.
         * @memberof RemoteFortressReader
         * @interface IPatternDescriptor
         * @property {string|null} [id] PatternDescriptor id
         * @property {Array.<RemoteFortressReader.IColorDefinition>|null} [colors] PatternDescriptor colors
         * @property {RemoteFortressReader.PatternType|null} [pattern] PatternDescriptor pattern
         */

        /**
         * Constructs a new PatternDescriptor.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PatternDescriptor.
         * @implements IPatternDescriptor
         * @constructor
         * @param {RemoteFortressReader.IPatternDescriptor=} [properties] Properties to set
         */
        function PatternDescriptor(properties) {
            this.colors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PatternDescriptor id.
         * @member {string} id
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         */
        PatternDescriptor.prototype.id = "";

        /**
         * PatternDescriptor colors.
         * @member {Array.<RemoteFortressReader.IColorDefinition>} colors
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         */
        PatternDescriptor.prototype.colors = $util.emptyArray;

        /**
         * PatternDescriptor pattern.
         * @member {RemoteFortressReader.PatternType} pattern
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         */
        PatternDescriptor.prototype.pattern = 0;

        /**
         * Creates a new PatternDescriptor instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.IPatternDescriptor=} [properties] Properties to set
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor instance
         */
        PatternDescriptor.create = function create(properties) {
            return new PatternDescriptor(properties);
        };

        /**
         * Encodes the specified PatternDescriptor message. Does not implicitly {@link RemoteFortressReader.PatternDescriptor.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.IPatternDescriptor} message PatternDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatternDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.colors != null && message.colors.length)
                for (var i = 0; i < message.colors.length; ++i)
                    $root.RemoteFortressReader.ColorDefinition.encode(message.colors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pattern);
            return writer;
        };

        /**
         * Encodes the specified PatternDescriptor message, length delimited. Does not implicitly {@link RemoteFortressReader.PatternDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.IPatternDescriptor} message PatternDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatternDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PatternDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatternDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PatternDescriptor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    if (!(message.colors && message.colors.length))
                        message.colors = [];
                    message.colors.push($root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pattern = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PatternDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatternDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PatternDescriptor message.
         * @function verify
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PatternDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.colors != null && message.hasOwnProperty("colors")) {
                if (!Array.isArray(message.colors))
                    return "colors: array expected";
                for (var i = 0; i < message.colors.length; ++i) {
                    var error = $root.RemoteFortressReader.ColorDefinition.verify(message.colors[i]);
                    if (error)
                        return "colors." + error;
                }
            }
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                switch (message.pattern) {
                default:
                    return "pattern: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a PatternDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor
         */
        PatternDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PatternDescriptor)
                return object;
            var message = new $root.RemoteFortressReader.PatternDescriptor();
            if (object.id != null)
                message.id = String(object.id);
            if (object.colors) {
                if (!Array.isArray(object.colors))
                    throw TypeError(".RemoteFortressReader.PatternDescriptor.colors: array expected");
                message.colors = [];
                for (var i = 0; i < object.colors.length; ++i) {
                    if (typeof object.colors[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PatternDescriptor.colors: object expected");
                    message.colors[i] = $root.RemoteFortressReader.ColorDefinition.fromObject(object.colors[i]);
                }
            }
            switch (object.pattern) {
            case "MONOTONE":
            case 0:
                message.pattern = 0;
                break;
            case "STRIPES":
            case 1:
                message.pattern = 1;
                break;
            case "IRIS_EYE":
            case 2:
                message.pattern = 2;
                break;
            case "SPOTS":
            case 3:
                message.pattern = 3;
                break;
            case "PUPIL_EYE":
            case 4:
                message.pattern = 4;
                break;
            case "MOTTLED":
            case 5:
                message.pattern = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PatternDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.PatternDescriptor} message PatternDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PatternDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.colors = [];
            if (options.defaults) {
                object.id = "";
                object.pattern = options.enums === String ? "MONOTONE" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.colors && message.colors.length) {
                object.colors = [];
                for (var j = 0; j < message.colors.length; ++j)
                    object.colors[j] = $root.RemoteFortressReader.ColorDefinition.toObject(message.colors[j], options);
            }
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = options.enums === String ? $root.RemoteFortressReader.PatternType[message.pattern] : message.pattern;
            return object;
        };

        /**
         * Converts this PatternDescriptor to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PatternDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PatternDescriptor;
    })();

    RemoteFortressReader.ColorModifierRaw = (function() {

        /**
         * Properties of a ColorModifierRaw.
         * @memberof RemoteFortressReader
         * @interface IColorModifierRaw
         * @property {Array.<RemoteFortressReader.IPatternDescriptor>|null} [patterns] ColorModifierRaw patterns
         * @property {Array.<number>|null} [bodyPartId] ColorModifierRaw bodyPartId
         * @property {Array.<number>|null} [tissueLayerId] ColorModifierRaw tissueLayerId
         * @property {number|null} [startDate] ColorModifierRaw startDate
         * @property {number|null} [endDate] ColorModifierRaw endDate
         * @property {string|null} [part] ColorModifierRaw part
         */

        /**
         * Constructs a new ColorModifierRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ColorModifierRaw.
         * @implements IColorModifierRaw
         * @constructor
         * @param {RemoteFortressReader.IColorModifierRaw=} [properties] Properties to set
         */
        function ColorModifierRaw(properties) {
            this.patterns = [];
            this.bodyPartId = [];
            this.tissueLayerId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorModifierRaw patterns.
         * @member {Array.<RemoteFortressReader.IPatternDescriptor>} patterns
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.patterns = $util.emptyArray;

        /**
         * ColorModifierRaw bodyPartId.
         * @member {Array.<number>} bodyPartId
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.bodyPartId = $util.emptyArray;

        /**
         * ColorModifierRaw tissueLayerId.
         * @member {Array.<number>} tissueLayerId
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.tissueLayerId = $util.emptyArray;

        /**
         * ColorModifierRaw startDate.
         * @member {number} startDate
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.startDate = 0;

        /**
         * ColorModifierRaw endDate.
         * @member {number} endDate
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.endDate = 0;

        /**
         * ColorModifierRaw part.
         * @member {string} part
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.part = "";

        /**
         * Creates a new ColorModifierRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.IColorModifierRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw instance
         */
        ColorModifierRaw.create = function create(properties) {
            return new ColorModifierRaw(properties);
        };

        /**
         * Encodes the specified ColorModifierRaw message. Does not implicitly {@link RemoteFortressReader.ColorModifierRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.IColorModifierRaw} message ColorModifierRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorModifierRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.patterns != null && message.patterns.length)
                for (var i = 0; i < message.patterns.length; ++i)
                    $root.RemoteFortressReader.PatternDescriptor.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.bodyPartId != null && message.bodyPartId.length)
                for (var i = 0; i < message.bodyPartId.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bodyPartId[i]);
            if (message.tissueLayerId != null && message.tissueLayerId.length)
                for (var i = 0; i < message.tissueLayerId.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tissueLayerId[i]);
            if (message.startDate != null && message.hasOwnProperty("startDate"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.startDate);
            if (message.endDate != null && message.hasOwnProperty("endDate"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.endDate);
            if (message.part != null && message.hasOwnProperty("part"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.part);
            return writer;
        };

        /**
         * Encodes the specified ColorModifierRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.ColorModifierRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.IColorModifierRaw} message ColorModifierRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorModifierRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorModifierRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorModifierRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ColorModifierRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.patterns && message.patterns.length))
                        message.patterns = [];
                    message.patterns.push($root.RemoteFortressReader.PatternDescriptor.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.bodyPartId && message.bodyPartId.length))
                        message.bodyPartId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bodyPartId.push(reader.int32());
                    } else
                        message.bodyPartId.push(reader.int32());
                    break;
                case 3:
                    if (!(message.tissueLayerId && message.tissueLayerId.length))
                        message.tissueLayerId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tissueLayerId.push(reader.int32());
                    } else
                        message.tissueLayerId.push(reader.int32());
                    break;
                case 4:
                    message.startDate = reader.int32();
                    break;
                case 5:
                    message.endDate = reader.int32();
                    break;
                case 6:
                    message.part = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorModifierRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorModifierRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorModifierRaw message.
         * @function verify
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorModifierRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.patterns != null && message.hasOwnProperty("patterns")) {
                if (!Array.isArray(message.patterns))
                    return "patterns: array expected";
                for (var i = 0; i < message.patterns.length; ++i) {
                    var error = $root.RemoteFortressReader.PatternDescriptor.verify(message.patterns[i]);
                    if (error)
                        return "patterns." + error;
                }
            }
            if (message.bodyPartId != null && message.hasOwnProperty("bodyPartId")) {
                if (!Array.isArray(message.bodyPartId))
                    return "bodyPartId: array expected";
                for (var i = 0; i < message.bodyPartId.length; ++i)
                    if (!$util.isInteger(message.bodyPartId[i]))
                        return "bodyPartId: integer[] expected";
            }
            if (message.tissueLayerId != null && message.hasOwnProperty("tissueLayerId")) {
                if (!Array.isArray(message.tissueLayerId))
                    return "tissueLayerId: array expected";
                for (var i = 0; i < message.tissueLayerId.length; ++i)
                    if (!$util.isInteger(message.tissueLayerId[i]))
                        return "tissueLayerId: integer[] expected";
            }
            if (message.startDate != null && message.hasOwnProperty("startDate"))
                if (!$util.isInteger(message.startDate))
                    return "startDate: integer expected";
            if (message.endDate != null && message.hasOwnProperty("endDate"))
                if (!$util.isInteger(message.endDate))
                    return "endDate: integer expected";
            if (message.part != null && message.hasOwnProperty("part"))
                if (!$util.isString(message.part))
                    return "part: string expected";
            return null;
        };

        /**
         * Creates a ColorModifierRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw
         */
        ColorModifierRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ColorModifierRaw)
                return object;
            var message = new $root.RemoteFortressReader.ColorModifierRaw();
            if (object.patterns) {
                if (!Array.isArray(object.patterns))
                    throw TypeError(".RemoteFortressReader.ColorModifierRaw.patterns: array expected");
                message.patterns = [];
                for (var i = 0; i < object.patterns.length; ++i) {
                    if (typeof object.patterns[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ColorModifierRaw.patterns: object expected");
                    message.patterns[i] = $root.RemoteFortressReader.PatternDescriptor.fromObject(object.patterns[i]);
                }
            }
            if (object.bodyPartId) {
                if (!Array.isArray(object.bodyPartId))
                    throw TypeError(".RemoteFortressReader.ColorModifierRaw.bodyPartId: array expected");
                message.bodyPartId = [];
                for (var i = 0; i < object.bodyPartId.length; ++i)
                    message.bodyPartId[i] = object.bodyPartId[i] | 0;
            }
            if (object.tissueLayerId) {
                if (!Array.isArray(object.tissueLayerId))
                    throw TypeError(".RemoteFortressReader.ColorModifierRaw.tissueLayerId: array expected");
                message.tissueLayerId = [];
                for (var i = 0; i < object.tissueLayerId.length; ++i)
                    message.tissueLayerId[i] = object.tissueLayerId[i] | 0;
            }
            if (object.startDate != null)
                message.startDate = object.startDate | 0;
            if (object.endDate != null)
                message.endDate = object.endDate | 0;
            if (object.part != null)
                message.part = String(object.part);
            return message;
        };

        /**
         * Creates a plain object from a ColorModifierRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.ColorModifierRaw} message ColorModifierRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorModifierRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.patterns = [];
                object.bodyPartId = [];
                object.tissueLayerId = [];
            }
            if (options.defaults) {
                object.startDate = 0;
                object.endDate = 0;
                object.part = "";
            }
            if (message.patterns && message.patterns.length) {
                object.patterns = [];
                for (var j = 0; j < message.patterns.length; ++j)
                    object.patterns[j] = $root.RemoteFortressReader.PatternDescriptor.toObject(message.patterns[j], options);
            }
            if (message.bodyPartId && message.bodyPartId.length) {
                object.bodyPartId = [];
                for (var j = 0; j < message.bodyPartId.length; ++j)
                    object.bodyPartId[j] = message.bodyPartId[j];
            }
            if (message.tissueLayerId && message.tissueLayerId.length) {
                object.tissueLayerId = [];
                for (var j = 0; j < message.tissueLayerId.length; ++j)
                    object.tissueLayerId[j] = message.tissueLayerId[j];
            }
            if (message.startDate != null && message.hasOwnProperty("startDate"))
                object.startDate = message.startDate;
            if (message.endDate != null && message.hasOwnProperty("endDate"))
                object.endDate = message.endDate;
            if (message.part != null && message.hasOwnProperty("part"))
                object.part = message.part;
            return object;
        };

        /**
         * Converts this ColorModifierRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorModifierRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ColorModifierRaw;
    })();

    RemoteFortressReader.BodyPartLayerRaw = (function() {

        /**
         * Properties of a BodyPartLayerRaw.
         * @memberof RemoteFortressReader
         * @interface IBodyPartLayerRaw
         * @property {string|null} [layerName] BodyPartLayerRaw layerName
         * @property {number|null} [tissueId] BodyPartLayerRaw tissueId
         * @property {number|null} [layerDepth] BodyPartLayerRaw layerDepth
         * @property {Array.<number>|null} [bpModifiers] BodyPartLayerRaw bpModifiers
         */

        /**
         * Constructs a new BodyPartLayerRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BodyPartLayerRaw.
         * @implements IBodyPartLayerRaw
         * @constructor
         * @param {RemoteFortressReader.IBodyPartLayerRaw=} [properties] Properties to set
         */
        function BodyPartLayerRaw(properties) {
            this.bpModifiers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BodyPartLayerRaw layerName.
         * @member {string} layerName
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.layerName = "";

        /**
         * BodyPartLayerRaw tissueId.
         * @member {number} tissueId
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.tissueId = 0;

        /**
         * BodyPartLayerRaw layerDepth.
         * @member {number} layerDepth
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.layerDepth = 0;

        /**
         * BodyPartLayerRaw bpModifiers.
         * @member {Array.<number>} bpModifiers
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.bpModifiers = $util.emptyArray;

        /**
         * Creates a new BodyPartLayerRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartLayerRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw instance
         */
        BodyPartLayerRaw.create = function create(properties) {
            return new BodyPartLayerRaw(properties);
        };

        /**
         * Encodes the specified BodyPartLayerRaw message. Does not implicitly {@link RemoteFortressReader.BodyPartLayerRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartLayerRaw} message BodyPartLayerRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartLayerRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.layerName != null && message.hasOwnProperty("layerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.layerName);
            if (message.tissueId != null && message.hasOwnProperty("tissueId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tissueId);
            if (message.layerDepth != null && message.hasOwnProperty("layerDepth"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.layerDepth);
            if (message.bpModifiers != null && message.bpModifiers.length)
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bpModifiers[i]);
            return writer;
        };

        /**
         * Encodes the specified BodyPartLayerRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.BodyPartLayerRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartLayerRaw} message BodyPartLayerRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartLayerRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BodyPartLayerRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartLayerRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BodyPartLayerRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.layerName = reader.string();
                    break;
                case 2:
                    message.tissueId = reader.int32();
                    break;
                case 3:
                    message.layerDepth = reader.int32();
                    break;
                case 4:
                    if (!(message.bpModifiers && message.bpModifiers.length))
                        message.bpModifiers = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bpModifiers.push(reader.int32());
                    } else
                        message.bpModifiers.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BodyPartLayerRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartLayerRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BodyPartLayerRaw message.
         * @function verify
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BodyPartLayerRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.layerName != null && message.hasOwnProperty("layerName"))
                if (!$util.isString(message.layerName))
                    return "layerName: string expected";
            if (message.tissueId != null && message.hasOwnProperty("tissueId"))
                if (!$util.isInteger(message.tissueId))
                    return "tissueId: integer expected";
            if (message.layerDepth != null && message.hasOwnProperty("layerDepth"))
                if (!$util.isInteger(message.layerDepth))
                    return "layerDepth: integer expected";
            if (message.bpModifiers != null && message.hasOwnProperty("bpModifiers")) {
                if (!Array.isArray(message.bpModifiers))
                    return "bpModifiers: array expected";
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    if (!$util.isInteger(message.bpModifiers[i]))
                        return "bpModifiers: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BodyPartLayerRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw
         */
        BodyPartLayerRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BodyPartLayerRaw)
                return object;
            var message = new $root.RemoteFortressReader.BodyPartLayerRaw();
            if (object.layerName != null)
                message.layerName = String(object.layerName);
            if (object.tissueId != null)
                message.tissueId = object.tissueId | 0;
            if (object.layerDepth != null)
                message.layerDepth = object.layerDepth | 0;
            if (object.bpModifiers) {
                if (!Array.isArray(object.bpModifiers))
                    throw TypeError(".RemoteFortressReader.BodyPartLayerRaw.bpModifiers: array expected");
                message.bpModifiers = [];
                for (var i = 0; i < object.bpModifiers.length; ++i)
                    message.bpModifiers[i] = object.bpModifiers[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BodyPartLayerRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.BodyPartLayerRaw} message BodyPartLayerRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BodyPartLayerRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bpModifiers = [];
            if (options.defaults) {
                object.layerName = "";
                object.tissueId = 0;
                object.layerDepth = 0;
            }
            if (message.layerName != null && message.hasOwnProperty("layerName"))
                object.layerName = message.layerName;
            if (message.tissueId != null && message.hasOwnProperty("tissueId"))
                object.tissueId = message.tissueId;
            if (message.layerDepth != null && message.hasOwnProperty("layerDepth"))
                object.layerDepth = message.layerDepth;
            if (message.bpModifiers && message.bpModifiers.length) {
                object.bpModifiers = [];
                for (var j = 0; j < message.bpModifiers.length; ++j)
                    object.bpModifiers[j] = message.bpModifiers[j];
            }
            return object;
        };

        /**
         * Converts this BodyPartLayerRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BodyPartLayerRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BodyPartLayerRaw;
    })();

    RemoteFortressReader.BodyPartRaw = (function() {

        /**
         * Properties of a BodyPartRaw.
         * @memberof RemoteFortressReader
         * @interface IBodyPartRaw
         * @property {string|null} [token] BodyPartRaw token
         * @property {string|null} [category] BodyPartRaw category
         * @property {number|null} [parent] BodyPartRaw parent
         * @property {Array.<boolean>|null} [flags] BodyPartRaw flags
         * @property {Array.<RemoteFortressReader.IBodyPartLayerRaw>|null} [layers] BodyPartRaw layers
         * @property {number|null} [relsize] BodyPartRaw relsize
         */

        /**
         * Constructs a new BodyPartRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BodyPartRaw.
         * @implements IBodyPartRaw
         * @constructor
         * @param {RemoteFortressReader.IBodyPartRaw=} [properties] Properties to set
         */
        function BodyPartRaw(properties) {
            this.flags = [];
            this.layers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BodyPartRaw token.
         * @member {string} token
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.token = "";

        /**
         * BodyPartRaw category.
         * @member {string} category
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.category = "";

        /**
         * BodyPartRaw parent.
         * @member {number} parent
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.parent = 0;

        /**
         * BodyPartRaw flags.
         * @member {Array.<boolean>} flags
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.flags = $util.emptyArray;

        /**
         * BodyPartRaw layers.
         * @member {Array.<RemoteFortressReader.IBodyPartLayerRaw>} layers
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.layers = $util.emptyArray;

        /**
         * BodyPartRaw relsize.
         * @member {number} relsize
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.relsize = 0;

        /**
         * Creates a new BodyPartRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw instance
         */
        BodyPartRaw.create = function create(properties) {
            return new BodyPartRaw(properties);
        };

        /**
         * Encodes the specified BodyPartRaw message. Does not implicitly {@link RemoteFortressReader.BodyPartRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartRaw} message BodyPartRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            if (message.category != null && message.hasOwnProperty("category"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.category);
            if (message.parent != null && message.hasOwnProperty("parent"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.parent);
            if (message.flags != null && message.flags.length)
                for (var i = 0; i < message.flags.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.flags[i]);
            if (message.layers != null && message.layers.length)
                for (var i = 0; i < message.layers.length; ++i)
                    $root.RemoteFortressReader.BodyPartLayerRaw.encode(message.layers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.relsize != null && message.hasOwnProperty("relsize"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.relsize);
            return writer;
        };

        /**
         * Encodes the specified BodyPartRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.BodyPartRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartRaw} message BodyPartRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BodyPartRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BodyPartRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.category = reader.string();
                    break;
                case 3:
                    message.parent = reader.int32();
                    break;
                case 4:
                    if (!(message.flags && message.flags.length))
                        message.flags = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.flags.push(reader.bool());
                    } else
                        message.flags.push(reader.bool());
                    break;
                case 5:
                    if (!(message.layers && message.layers.length))
                        message.layers = [];
                    message.layers.push($root.RemoteFortressReader.BodyPartLayerRaw.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.relsize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BodyPartRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BodyPartRaw message.
         * @function verify
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BodyPartRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.category != null && message.hasOwnProperty("category"))
                if (!$util.isString(message.category))
                    return "category: string expected";
            if (message.parent != null && message.hasOwnProperty("parent"))
                if (!$util.isInteger(message.parent))
                    return "parent: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (var i = 0; i < message.flags.length; ++i)
                    if (typeof message.flags[i] !== "boolean")
                        return "flags: boolean[] expected";
            }
            if (message.layers != null && message.hasOwnProperty("layers")) {
                if (!Array.isArray(message.layers))
                    return "layers: array expected";
                for (var i = 0; i < message.layers.length; ++i) {
                    var error = $root.RemoteFortressReader.BodyPartLayerRaw.verify(message.layers[i]);
                    if (error)
                        return "layers." + error;
                }
            }
            if (message.relsize != null && message.hasOwnProperty("relsize"))
                if (!$util.isInteger(message.relsize))
                    return "relsize: integer expected";
            return null;
        };

        /**
         * Creates a BodyPartRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw
         */
        BodyPartRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BodyPartRaw)
                return object;
            var message = new $root.RemoteFortressReader.BodyPartRaw();
            if (object.token != null)
                message.token = String(object.token);
            if (object.category != null)
                message.category = String(object.category);
            if (object.parent != null)
                message.parent = object.parent | 0;
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".RemoteFortressReader.BodyPartRaw.flags: array expected");
                message.flags = [];
                for (var i = 0; i < object.flags.length; ++i)
                    message.flags[i] = Boolean(object.flags[i]);
            }
            if (object.layers) {
                if (!Array.isArray(object.layers))
                    throw TypeError(".RemoteFortressReader.BodyPartRaw.layers: array expected");
                message.layers = [];
                for (var i = 0; i < object.layers.length; ++i) {
                    if (typeof object.layers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BodyPartRaw.layers: object expected");
                    message.layers[i] = $root.RemoteFortressReader.BodyPartLayerRaw.fromObject(object.layers[i]);
                }
            }
            if (object.relsize != null)
                message.relsize = object.relsize | 0;
            return message;
        };

        /**
         * Creates a plain object from a BodyPartRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.BodyPartRaw} message BodyPartRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BodyPartRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.flags = [];
                object.layers = [];
            }
            if (options.defaults) {
                object.token = "";
                object.category = "";
                object.parent = 0;
                object.relsize = 0;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.category != null && message.hasOwnProperty("category"))
                object.category = message.category;
            if (message.parent != null && message.hasOwnProperty("parent"))
                object.parent = message.parent;
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (var j = 0; j < message.flags.length; ++j)
                    object.flags[j] = message.flags[j];
            }
            if (message.layers && message.layers.length) {
                object.layers = [];
                for (var j = 0; j < message.layers.length; ++j)
                    object.layers[j] = $root.RemoteFortressReader.BodyPartLayerRaw.toObject(message.layers[j], options);
            }
            if (message.relsize != null && message.hasOwnProperty("relsize"))
                object.relsize = message.relsize;
            return object;
        };

        /**
         * Converts this BodyPartRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BodyPartRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BodyPartRaw;
    })();

    RemoteFortressReader.BpAppearanceModifier = (function() {

        /**
         * Properties of a BpAppearanceModifier.
         * @memberof RemoteFortressReader
         * @interface IBpAppearanceModifier
         * @property {string|null} [type] BpAppearanceModifier type
         * @property {number|null} [modMin] BpAppearanceModifier modMin
         * @property {number|null} [modMax] BpAppearanceModifier modMax
         */

        /**
         * Constructs a new BpAppearanceModifier.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BpAppearanceModifier.
         * @implements IBpAppearanceModifier
         * @constructor
         * @param {RemoteFortressReader.IBpAppearanceModifier=} [properties] Properties to set
         */
        function BpAppearanceModifier(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BpAppearanceModifier type.
         * @member {string} type
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         */
        BpAppearanceModifier.prototype.type = "";

        /**
         * BpAppearanceModifier modMin.
         * @member {number} modMin
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         */
        BpAppearanceModifier.prototype.modMin = 0;

        /**
         * BpAppearanceModifier modMax.
         * @member {number} modMax
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         */
        BpAppearanceModifier.prototype.modMax = 0;

        /**
         * Creates a new BpAppearanceModifier instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.IBpAppearanceModifier=} [properties] Properties to set
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier instance
         */
        BpAppearanceModifier.create = function create(properties) {
            return new BpAppearanceModifier(properties);
        };

        /**
         * Encodes the specified BpAppearanceModifier message. Does not implicitly {@link RemoteFortressReader.BpAppearanceModifier.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.IBpAppearanceModifier} message BpAppearanceModifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BpAppearanceModifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.modMin != null && message.hasOwnProperty("modMin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.modMin);
            if (message.modMax != null && message.hasOwnProperty("modMax"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.modMax);
            return writer;
        };

        /**
         * Encodes the specified BpAppearanceModifier message, length delimited. Does not implicitly {@link RemoteFortressReader.BpAppearanceModifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.IBpAppearanceModifier} message BpAppearanceModifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BpAppearanceModifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BpAppearanceModifier message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BpAppearanceModifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BpAppearanceModifier();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.modMin = reader.int32();
                    break;
                case 3:
                    message.modMax = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BpAppearanceModifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BpAppearanceModifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BpAppearanceModifier message.
         * @function verify
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BpAppearanceModifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.modMin != null && message.hasOwnProperty("modMin"))
                if (!$util.isInteger(message.modMin))
                    return "modMin: integer expected";
            if (message.modMax != null && message.hasOwnProperty("modMax"))
                if (!$util.isInteger(message.modMax))
                    return "modMax: integer expected";
            return null;
        };

        /**
         * Creates a BpAppearanceModifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier
         */
        BpAppearanceModifier.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BpAppearanceModifier)
                return object;
            var message = new $root.RemoteFortressReader.BpAppearanceModifier();
            if (object.type != null)
                message.type = String(object.type);
            if (object.modMin != null)
                message.modMin = object.modMin | 0;
            if (object.modMax != null)
                message.modMax = object.modMax | 0;
            return message;
        };

        /**
         * Creates a plain object from a BpAppearanceModifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.BpAppearanceModifier} message BpAppearanceModifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BpAppearanceModifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                object.modMin = 0;
                object.modMax = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.modMin != null && message.hasOwnProperty("modMin"))
                object.modMin = message.modMin;
            if (message.modMax != null && message.hasOwnProperty("modMax"))
                object.modMax = message.modMax;
            return object;
        };

        /**
         * Converts this BpAppearanceModifier to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BpAppearanceModifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BpAppearanceModifier;
    })();

    RemoteFortressReader.TissueRaw = (function() {

        /**
         * Properties of a TissueRaw.
         * @memberof RemoteFortressReader
         * @interface ITissueRaw
         * @property {string|null} [id] TissueRaw id
         * @property {string|null} [name] TissueRaw name
         * @property {RemoteFortressReader.IMatPair|null} [material] TissueRaw material
         * @property {string|null} [subordinateToTissue] TissueRaw subordinateToTissue
         */

        /**
         * Constructs a new TissueRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TissueRaw.
         * @implements ITissueRaw
         * @constructor
         * @param {RemoteFortressReader.ITissueRaw=} [properties] Properties to set
         */
        function TissueRaw(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TissueRaw id.
         * @member {string} id
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.id = "";

        /**
         * TissueRaw name.
         * @member {string} name
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.name = "";

        /**
         * TissueRaw material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.material = null;

        /**
         * TissueRaw subordinateToTissue.
         * @member {string} subordinateToTissue
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.subordinateToTissue = "";

        /**
         * Creates a new TissueRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.ITissueRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw instance
         */
        TissueRaw.create = function create(properties) {
            return new TissueRaw(properties);
        };

        /**
         * Encodes the specified TissueRaw message. Does not implicitly {@link RemoteFortressReader.TissueRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.ITissueRaw} message TissueRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TissueRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.subordinateToTissue != null && message.hasOwnProperty("subordinateToTissue"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.subordinateToTissue);
            return writer;
        };

        /**
         * Encodes the specified TissueRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.TissueRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.ITissueRaw} message TissueRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TissueRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TissueRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TissueRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TissueRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.subordinateToTissue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TissueRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TissueRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TissueRaw message.
         * @function verify
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TissueRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.subordinateToTissue != null && message.hasOwnProperty("subordinateToTissue"))
                if (!$util.isString(message.subordinateToTissue))
                    return "subordinateToTissue: string expected";
            return null;
        };

        /**
         * Creates a TissueRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw
         */
        TissueRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TissueRaw)
                return object;
            var message = new $root.RemoteFortressReader.TissueRaw();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.TissueRaw.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.subordinateToTissue != null)
                message.subordinateToTissue = String(object.subordinateToTissue);
            return message;
        };

        /**
         * Creates a plain object from a TissueRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.TissueRaw} message TissueRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TissueRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.material = null;
                object.subordinateToTissue = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.subordinateToTissue != null && message.hasOwnProperty("subordinateToTissue"))
                object.subordinateToTissue = message.subordinateToTissue;
            return object;
        };

        /**
         * Converts this TissueRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TissueRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TissueRaw;
    })();

    RemoteFortressReader.CasteRaw = (function() {

        /**
         * Properties of a CasteRaw.
         * @memberof RemoteFortressReader
         * @interface ICasteRaw
         * @property {number|null} [index] CasteRaw index
         * @property {string|null} [casteId] CasteRaw casteId
         * @property {Array.<string>|null} [casteName] CasteRaw casteName
         * @property {Array.<string>|null} [babyName] CasteRaw babyName
         * @property {Array.<string>|null} [childName] CasteRaw childName
         * @property {number|null} [gender] CasteRaw gender
         * @property {Array.<RemoteFortressReader.IBodyPartRaw>|null} [bodyParts] CasteRaw bodyParts
         * @property {number|null} [totalRelsize] CasteRaw totalRelsize
         * @property {Array.<RemoteFortressReader.IBpAppearanceModifier>|null} [modifiers] CasteRaw modifiers
         * @property {Array.<number>|null} [modifierIdx] CasteRaw modifierIdx
         * @property {Array.<number>|null} [partIdx] CasteRaw partIdx
         * @property {Array.<number>|null} [layerIdx] CasteRaw layerIdx
         * @property {Array.<RemoteFortressReader.IBpAppearanceModifier>|null} [bodyAppearanceModifiers] CasteRaw bodyAppearanceModifiers
         * @property {Array.<RemoteFortressReader.IColorModifierRaw>|null} [colorModifiers] CasteRaw colorModifiers
         * @property {string|null} [description] CasteRaw description
         * @property {number|null} [adultSize] CasteRaw adultSize
         */

        /**
         * Constructs a new CasteRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a CasteRaw.
         * @implements ICasteRaw
         * @constructor
         * @param {RemoteFortressReader.ICasteRaw=} [properties] Properties to set
         */
        function CasteRaw(properties) {
            this.casteName = [];
            this.babyName = [];
            this.childName = [];
            this.bodyParts = [];
            this.modifiers = [];
            this.modifierIdx = [];
            this.partIdx = [];
            this.layerIdx = [];
            this.bodyAppearanceModifiers = [];
            this.colorModifiers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CasteRaw index.
         * @member {number} index
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.index = 0;

        /**
         * CasteRaw casteId.
         * @member {string} casteId
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.casteId = "";

        /**
         * CasteRaw casteName.
         * @member {Array.<string>} casteName
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.casteName = $util.emptyArray;

        /**
         * CasteRaw babyName.
         * @member {Array.<string>} babyName
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.babyName = $util.emptyArray;

        /**
         * CasteRaw childName.
         * @member {Array.<string>} childName
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.childName = $util.emptyArray;

        /**
         * CasteRaw gender.
         * @member {number} gender
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.gender = 0;

        /**
         * CasteRaw bodyParts.
         * @member {Array.<RemoteFortressReader.IBodyPartRaw>} bodyParts
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.bodyParts = $util.emptyArray;

        /**
         * CasteRaw totalRelsize.
         * @member {number} totalRelsize
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.totalRelsize = 0;

        /**
         * CasteRaw modifiers.
         * @member {Array.<RemoteFortressReader.IBpAppearanceModifier>} modifiers
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.modifiers = $util.emptyArray;

        /**
         * CasteRaw modifierIdx.
         * @member {Array.<number>} modifierIdx
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.modifierIdx = $util.emptyArray;

        /**
         * CasteRaw partIdx.
         * @member {Array.<number>} partIdx
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.partIdx = $util.emptyArray;

        /**
         * CasteRaw layerIdx.
         * @member {Array.<number>} layerIdx
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.layerIdx = $util.emptyArray;

        /**
         * CasteRaw bodyAppearanceModifiers.
         * @member {Array.<RemoteFortressReader.IBpAppearanceModifier>} bodyAppearanceModifiers
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.bodyAppearanceModifiers = $util.emptyArray;

        /**
         * CasteRaw colorModifiers.
         * @member {Array.<RemoteFortressReader.IColorModifierRaw>} colorModifiers
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.colorModifiers = $util.emptyArray;

        /**
         * CasteRaw description.
         * @member {string} description
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.description = "";

        /**
         * CasteRaw adultSize.
         * @member {number} adultSize
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.adultSize = 0;

        /**
         * Creates a new CasteRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.ICasteRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw instance
         */
        CasteRaw.create = function create(properties) {
            return new CasteRaw(properties);
        };

        /**
         * Encodes the specified CasteRaw message. Does not implicitly {@link RemoteFortressReader.CasteRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.ICasteRaw} message CasteRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CasteRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.casteId != null && message.hasOwnProperty("casteId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.casteId);
            if (message.casteName != null && message.casteName.length)
                for (var i = 0; i < message.casteName.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.casteName[i]);
            if (message.babyName != null && message.babyName.length)
                for (var i = 0; i < message.babyName.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.babyName[i]);
            if (message.childName != null && message.childName.length)
                for (var i = 0; i < message.childName.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.childName[i]);
            if (message.gender != null && message.hasOwnProperty("gender"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.gender);
            if (message.bodyParts != null && message.bodyParts.length)
                for (var i = 0; i < message.bodyParts.length; ++i)
                    $root.RemoteFortressReader.BodyPartRaw.encode(message.bodyParts[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.totalRelsize != null && message.hasOwnProperty("totalRelsize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.totalRelsize);
            if (message.modifiers != null && message.modifiers.length)
                for (var i = 0; i < message.modifiers.length; ++i)
                    $root.RemoteFortressReader.BpAppearanceModifier.encode(message.modifiers[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.modifierIdx != null && message.modifierIdx.length)
                for (var i = 0; i < message.modifierIdx.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.modifierIdx[i]);
            if (message.partIdx != null && message.partIdx.length)
                for (var i = 0; i < message.partIdx.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.partIdx[i]);
            if (message.layerIdx != null && message.layerIdx.length)
                for (var i = 0; i < message.layerIdx.length; ++i)
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.layerIdx[i]);
            if (message.bodyAppearanceModifiers != null && message.bodyAppearanceModifiers.length)
                for (var i = 0; i < message.bodyAppearanceModifiers.length; ++i)
                    $root.RemoteFortressReader.BpAppearanceModifier.encode(message.bodyAppearanceModifiers[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.colorModifiers != null && message.colorModifiers.length)
                for (var i = 0; i < message.colorModifiers.length; ++i)
                    $root.RemoteFortressReader.ColorModifierRaw.encode(message.colorModifiers[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.description);
            if (message.adultSize != null && message.hasOwnProperty("adultSize"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.adultSize);
            return writer;
        };

        /**
         * Encodes the specified CasteRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.CasteRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.ICasteRaw} message CasteRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CasteRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CasteRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CasteRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.CasteRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.casteId = reader.string();
                    break;
                case 3:
                    if (!(message.casteName && message.casteName.length))
                        message.casteName = [];
                    message.casteName.push(reader.string());
                    break;
                case 4:
                    if (!(message.babyName && message.babyName.length))
                        message.babyName = [];
                    message.babyName.push(reader.string());
                    break;
                case 5:
                    if (!(message.childName && message.childName.length))
                        message.childName = [];
                    message.childName.push(reader.string());
                    break;
                case 6:
                    message.gender = reader.int32();
                    break;
                case 7:
                    if (!(message.bodyParts && message.bodyParts.length))
                        message.bodyParts = [];
                    message.bodyParts.push($root.RemoteFortressReader.BodyPartRaw.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.totalRelsize = reader.int32();
                    break;
                case 9:
                    if (!(message.modifiers && message.modifiers.length))
                        message.modifiers = [];
                    message.modifiers.push($root.RemoteFortressReader.BpAppearanceModifier.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.modifierIdx && message.modifierIdx.length))
                        message.modifierIdx = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.modifierIdx.push(reader.int32());
                    } else
                        message.modifierIdx.push(reader.int32());
                    break;
                case 11:
                    if (!(message.partIdx && message.partIdx.length))
                        message.partIdx = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.partIdx.push(reader.int32());
                    } else
                        message.partIdx.push(reader.int32());
                    break;
                case 12:
                    if (!(message.layerIdx && message.layerIdx.length))
                        message.layerIdx = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.layerIdx.push(reader.int32());
                    } else
                        message.layerIdx.push(reader.int32());
                    break;
                case 13:
                    if (!(message.bodyAppearanceModifiers && message.bodyAppearanceModifiers.length))
                        message.bodyAppearanceModifiers = [];
                    message.bodyAppearanceModifiers.push($root.RemoteFortressReader.BpAppearanceModifier.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.colorModifiers && message.colorModifiers.length))
                        message.colorModifiers = [];
                    message.colorModifiers.push($root.RemoteFortressReader.ColorModifierRaw.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.description = reader.string();
                    break;
                case 16:
                    message.adultSize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CasteRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CasteRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CasteRaw message.
         * @function verify
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CasteRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.casteId != null && message.hasOwnProperty("casteId"))
                if (!$util.isString(message.casteId))
                    return "casteId: string expected";
            if (message.casteName != null && message.hasOwnProperty("casteName")) {
                if (!Array.isArray(message.casteName))
                    return "casteName: array expected";
                for (var i = 0; i < message.casteName.length; ++i)
                    if (!$util.isString(message.casteName[i]))
                        return "casteName: string[] expected";
            }
            if (message.babyName != null && message.hasOwnProperty("babyName")) {
                if (!Array.isArray(message.babyName))
                    return "babyName: array expected";
                for (var i = 0; i < message.babyName.length; ++i)
                    if (!$util.isString(message.babyName[i]))
                        return "babyName: string[] expected";
            }
            if (message.childName != null && message.hasOwnProperty("childName")) {
                if (!Array.isArray(message.childName))
                    return "childName: array expected";
                for (var i = 0; i < message.childName.length; ++i)
                    if (!$util.isString(message.childName[i]))
                        return "childName: string[] expected";
            }
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            if (message.bodyParts != null && message.hasOwnProperty("bodyParts")) {
                if (!Array.isArray(message.bodyParts))
                    return "bodyParts: array expected";
                for (var i = 0; i < message.bodyParts.length; ++i) {
                    var error = $root.RemoteFortressReader.BodyPartRaw.verify(message.bodyParts[i]);
                    if (error)
                        return "bodyParts." + error;
                }
            }
            if (message.totalRelsize != null && message.hasOwnProperty("totalRelsize"))
                if (!$util.isInteger(message.totalRelsize))
                    return "totalRelsize: integer expected";
            if (message.modifiers != null && message.hasOwnProperty("modifiers")) {
                if (!Array.isArray(message.modifiers))
                    return "modifiers: array expected";
                for (var i = 0; i < message.modifiers.length; ++i) {
                    var error = $root.RemoteFortressReader.BpAppearanceModifier.verify(message.modifiers[i]);
                    if (error)
                        return "modifiers." + error;
                }
            }
            if (message.modifierIdx != null && message.hasOwnProperty("modifierIdx")) {
                if (!Array.isArray(message.modifierIdx))
                    return "modifierIdx: array expected";
                for (var i = 0; i < message.modifierIdx.length; ++i)
                    if (!$util.isInteger(message.modifierIdx[i]))
                        return "modifierIdx: integer[] expected";
            }
            if (message.partIdx != null && message.hasOwnProperty("partIdx")) {
                if (!Array.isArray(message.partIdx))
                    return "partIdx: array expected";
                for (var i = 0; i < message.partIdx.length; ++i)
                    if (!$util.isInteger(message.partIdx[i]))
                        return "partIdx: integer[] expected";
            }
            if (message.layerIdx != null && message.hasOwnProperty("layerIdx")) {
                if (!Array.isArray(message.layerIdx))
                    return "layerIdx: array expected";
                for (var i = 0; i < message.layerIdx.length; ++i)
                    if (!$util.isInteger(message.layerIdx[i]))
                        return "layerIdx: integer[] expected";
            }
            if (message.bodyAppearanceModifiers != null && message.hasOwnProperty("bodyAppearanceModifiers")) {
                if (!Array.isArray(message.bodyAppearanceModifiers))
                    return "bodyAppearanceModifiers: array expected";
                for (var i = 0; i < message.bodyAppearanceModifiers.length; ++i) {
                    var error = $root.RemoteFortressReader.BpAppearanceModifier.verify(message.bodyAppearanceModifiers[i]);
                    if (error)
                        return "bodyAppearanceModifiers." + error;
                }
            }
            if (message.colorModifiers != null && message.hasOwnProperty("colorModifiers")) {
                if (!Array.isArray(message.colorModifiers))
                    return "colorModifiers: array expected";
                for (var i = 0; i < message.colorModifiers.length; ++i) {
                    var error = $root.RemoteFortressReader.ColorModifierRaw.verify(message.colorModifiers[i]);
                    if (error)
                        return "colorModifiers." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.adultSize != null && message.hasOwnProperty("adultSize"))
                if (!$util.isInteger(message.adultSize))
                    return "adultSize: integer expected";
            return null;
        };

        /**
         * Creates a CasteRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw
         */
        CasteRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.CasteRaw)
                return object;
            var message = new $root.RemoteFortressReader.CasteRaw();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.casteId != null)
                message.casteId = String(object.casteId);
            if (object.casteName) {
                if (!Array.isArray(object.casteName))
                    throw TypeError(".RemoteFortressReader.CasteRaw.casteName: array expected");
                message.casteName = [];
                for (var i = 0; i < object.casteName.length; ++i)
                    message.casteName[i] = String(object.casteName[i]);
            }
            if (object.babyName) {
                if (!Array.isArray(object.babyName))
                    throw TypeError(".RemoteFortressReader.CasteRaw.babyName: array expected");
                message.babyName = [];
                for (var i = 0; i < object.babyName.length; ++i)
                    message.babyName[i] = String(object.babyName[i]);
            }
            if (object.childName) {
                if (!Array.isArray(object.childName))
                    throw TypeError(".RemoteFortressReader.CasteRaw.childName: array expected");
                message.childName = [];
                for (var i = 0; i < object.childName.length; ++i)
                    message.childName[i] = String(object.childName[i]);
            }
            if (object.gender != null)
                message.gender = object.gender | 0;
            if (object.bodyParts) {
                if (!Array.isArray(object.bodyParts))
                    throw TypeError(".RemoteFortressReader.CasteRaw.bodyParts: array expected");
                message.bodyParts = [];
                for (var i = 0; i < object.bodyParts.length; ++i) {
                    if (typeof object.bodyParts[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.bodyParts: object expected");
                    message.bodyParts[i] = $root.RemoteFortressReader.BodyPartRaw.fromObject(object.bodyParts[i]);
                }
            }
            if (object.totalRelsize != null)
                message.totalRelsize = object.totalRelsize | 0;
            if (object.modifiers) {
                if (!Array.isArray(object.modifiers))
                    throw TypeError(".RemoteFortressReader.CasteRaw.modifiers: array expected");
                message.modifiers = [];
                for (var i = 0; i < object.modifiers.length; ++i) {
                    if (typeof object.modifiers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.modifiers: object expected");
                    message.modifiers[i] = $root.RemoteFortressReader.BpAppearanceModifier.fromObject(object.modifiers[i]);
                }
            }
            if (object.modifierIdx) {
                if (!Array.isArray(object.modifierIdx))
                    throw TypeError(".RemoteFortressReader.CasteRaw.modifierIdx: array expected");
                message.modifierIdx = [];
                for (var i = 0; i < object.modifierIdx.length; ++i)
                    message.modifierIdx[i] = object.modifierIdx[i] | 0;
            }
            if (object.partIdx) {
                if (!Array.isArray(object.partIdx))
                    throw TypeError(".RemoteFortressReader.CasteRaw.partIdx: array expected");
                message.partIdx = [];
                for (var i = 0; i < object.partIdx.length; ++i)
                    message.partIdx[i] = object.partIdx[i] | 0;
            }
            if (object.layerIdx) {
                if (!Array.isArray(object.layerIdx))
                    throw TypeError(".RemoteFortressReader.CasteRaw.layerIdx: array expected");
                message.layerIdx = [];
                for (var i = 0; i < object.layerIdx.length; ++i)
                    message.layerIdx[i] = object.layerIdx[i] | 0;
            }
            if (object.bodyAppearanceModifiers) {
                if (!Array.isArray(object.bodyAppearanceModifiers))
                    throw TypeError(".RemoteFortressReader.CasteRaw.bodyAppearanceModifiers: array expected");
                message.bodyAppearanceModifiers = [];
                for (var i = 0; i < object.bodyAppearanceModifiers.length; ++i) {
                    if (typeof object.bodyAppearanceModifiers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.bodyAppearanceModifiers: object expected");
                    message.bodyAppearanceModifiers[i] = $root.RemoteFortressReader.BpAppearanceModifier.fromObject(object.bodyAppearanceModifiers[i]);
                }
            }
            if (object.colorModifiers) {
                if (!Array.isArray(object.colorModifiers))
                    throw TypeError(".RemoteFortressReader.CasteRaw.colorModifiers: array expected");
                message.colorModifiers = [];
                for (var i = 0; i < object.colorModifiers.length; ++i) {
                    if (typeof object.colorModifiers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.colorModifiers: object expected");
                    message.colorModifiers[i] = $root.RemoteFortressReader.ColorModifierRaw.fromObject(object.colorModifiers[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.adultSize != null)
                message.adultSize = object.adultSize | 0;
            return message;
        };

        /**
         * Creates a plain object from a CasteRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.CasteRaw} message CasteRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CasteRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.casteName = [];
                object.babyName = [];
                object.childName = [];
                object.bodyParts = [];
                object.modifiers = [];
                object.modifierIdx = [];
                object.partIdx = [];
                object.layerIdx = [];
                object.bodyAppearanceModifiers = [];
                object.colorModifiers = [];
            }
            if (options.defaults) {
                object.index = 0;
                object.casteId = "";
                object.gender = 0;
                object.totalRelsize = 0;
                object.description = "";
                object.adultSize = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.casteId != null && message.hasOwnProperty("casteId"))
                object.casteId = message.casteId;
            if (message.casteName && message.casteName.length) {
                object.casteName = [];
                for (var j = 0; j < message.casteName.length; ++j)
                    object.casteName[j] = message.casteName[j];
            }
            if (message.babyName && message.babyName.length) {
                object.babyName = [];
                for (var j = 0; j < message.babyName.length; ++j)
                    object.babyName[j] = message.babyName[j];
            }
            if (message.childName && message.childName.length) {
                object.childName = [];
                for (var j = 0; j < message.childName.length; ++j)
                    object.childName[j] = message.childName[j];
            }
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.bodyParts && message.bodyParts.length) {
                object.bodyParts = [];
                for (var j = 0; j < message.bodyParts.length; ++j)
                    object.bodyParts[j] = $root.RemoteFortressReader.BodyPartRaw.toObject(message.bodyParts[j], options);
            }
            if (message.totalRelsize != null && message.hasOwnProperty("totalRelsize"))
                object.totalRelsize = message.totalRelsize;
            if (message.modifiers && message.modifiers.length) {
                object.modifiers = [];
                for (var j = 0; j < message.modifiers.length; ++j)
                    object.modifiers[j] = $root.RemoteFortressReader.BpAppearanceModifier.toObject(message.modifiers[j], options);
            }
            if (message.modifierIdx && message.modifierIdx.length) {
                object.modifierIdx = [];
                for (var j = 0; j < message.modifierIdx.length; ++j)
                    object.modifierIdx[j] = message.modifierIdx[j];
            }
            if (message.partIdx && message.partIdx.length) {
                object.partIdx = [];
                for (var j = 0; j < message.partIdx.length; ++j)
                    object.partIdx[j] = message.partIdx[j];
            }
            if (message.layerIdx && message.layerIdx.length) {
                object.layerIdx = [];
                for (var j = 0; j < message.layerIdx.length; ++j)
                    object.layerIdx[j] = message.layerIdx[j];
            }
            if (message.bodyAppearanceModifiers && message.bodyAppearanceModifiers.length) {
                object.bodyAppearanceModifiers = [];
                for (var j = 0; j < message.bodyAppearanceModifiers.length; ++j)
                    object.bodyAppearanceModifiers[j] = $root.RemoteFortressReader.BpAppearanceModifier.toObject(message.bodyAppearanceModifiers[j], options);
            }
            if (message.colorModifiers && message.colorModifiers.length) {
                object.colorModifiers = [];
                for (var j = 0; j < message.colorModifiers.length; ++j)
                    object.colorModifiers[j] = $root.RemoteFortressReader.ColorModifierRaw.toObject(message.colorModifiers[j], options);
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.adultSize != null && message.hasOwnProperty("adultSize"))
                object.adultSize = message.adultSize;
            return object;
        };

        /**
         * Converts this CasteRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CasteRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CasteRaw;
    })();

    RemoteFortressReader.CreatureRaw = (function() {

        /**
         * Properties of a CreatureRaw.
         * @memberof RemoteFortressReader
         * @interface ICreatureRaw
         * @property {number|null} [index] CreatureRaw index
         * @property {string|null} [creatureId] CreatureRaw creatureId
         * @property {Array.<string>|null} [name] CreatureRaw name
         * @property {Array.<string>|null} [generalBabyName] CreatureRaw generalBabyName
         * @property {Array.<string>|null} [generalChildName] CreatureRaw generalChildName
         * @property {number|null} [creatureTile] CreatureRaw creatureTile
         * @property {number|null} [creatureSoldierTile] CreatureRaw creatureSoldierTile
         * @property {RemoteFortressReader.IColorDefinition|null} [color] CreatureRaw color
         * @property {number|null} [adultsize] CreatureRaw adultsize
         * @property {Array.<RemoteFortressReader.ICasteRaw>|null} [caste] CreatureRaw caste
         * @property {Array.<RemoteFortressReader.ITissueRaw>|null} [tissues] CreatureRaw tissues
         */

        /**
         * Constructs a new CreatureRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a CreatureRaw.
         * @implements ICreatureRaw
         * @constructor
         * @param {RemoteFortressReader.ICreatureRaw=} [properties] Properties to set
         */
        function CreatureRaw(properties) {
            this.name = [];
            this.generalBabyName = [];
            this.generalChildName = [];
            this.caste = [];
            this.tissues = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatureRaw index.
         * @member {number} index
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.index = 0;

        /**
         * CreatureRaw creatureId.
         * @member {string} creatureId
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.creatureId = "";

        /**
         * CreatureRaw name.
         * @member {Array.<string>} name
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.name = $util.emptyArray;

        /**
         * CreatureRaw generalBabyName.
         * @member {Array.<string>} generalBabyName
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.generalBabyName = $util.emptyArray;

        /**
         * CreatureRaw generalChildName.
         * @member {Array.<string>} generalChildName
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.generalChildName = $util.emptyArray;

        /**
         * CreatureRaw creatureTile.
         * @member {number} creatureTile
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.creatureTile = 0;

        /**
         * CreatureRaw creatureSoldierTile.
         * @member {number} creatureSoldierTile
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.creatureSoldierTile = 0;

        /**
         * CreatureRaw color.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} color
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.color = null;

        /**
         * CreatureRaw adultsize.
         * @member {number} adultsize
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.adultsize = 0;

        /**
         * CreatureRaw caste.
         * @member {Array.<RemoteFortressReader.ICasteRaw>} caste
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.caste = $util.emptyArray;

        /**
         * CreatureRaw tissues.
         * @member {Array.<RemoteFortressReader.ITissueRaw>} tissues
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.tissues = $util.emptyArray;

        /**
         * Creates a new CreatureRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.ICreatureRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw instance
         */
        CreatureRaw.create = function create(properties) {
            return new CreatureRaw(properties);
        };

        /**
         * Encodes the specified CreatureRaw message. Does not implicitly {@link RemoteFortressReader.CreatureRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.ICreatureRaw} message CreatureRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.creatureId != null && message.hasOwnProperty("creatureId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.creatureId);
            if (message.name != null && message.name.length)
                for (var i = 0; i < message.name.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name[i]);
            if (message.generalBabyName != null && message.generalBabyName.length)
                for (var i = 0; i < message.generalBabyName.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.generalBabyName[i]);
            if (message.generalChildName != null && message.generalChildName.length)
                for (var i = 0; i < message.generalChildName.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.generalChildName[i]);
            if (message.creatureTile != null && message.hasOwnProperty("creatureTile"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.creatureTile);
            if (message.creatureSoldierTile != null && message.hasOwnProperty("creatureSoldierTile"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.creatureSoldierTile);
            if (message.color != null && message.hasOwnProperty("color"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.color, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.adultsize != null && message.hasOwnProperty("adultsize"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.adultsize);
            if (message.caste != null && message.caste.length)
                for (var i = 0; i < message.caste.length; ++i)
                    $root.RemoteFortressReader.CasteRaw.encode(message.caste[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.tissues != null && message.tissues.length)
                for (var i = 0; i < message.tissues.length; ++i)
                    $root.RemoteFortressReader.TissueRaw.encode(message.tissues[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreatureRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.CreatureRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.ICreatureRaw} message CreatureRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatureRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.CreatureRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.creatureId = reader.string();
                    break;
                case 3:
                    if (!(message.name && message.name.length))
                        message.name = [];
                    message.name.push(reader.string());
                    break;
                case 4:
                    if (!(message.generalBabyName && message.generalBabyName.length))
                        message.generalBabyName = [];
                    message.generalBabyName.push(reader.string());
                    break;
                case 5:
                    if (!(message.generalChildName && message.generalChildName.length))
                        message.generalChildName = [];
                    message.generalChildName.push(reader.string());
                    break;
                case 6:
                    message.creatureTile = reader.int32();
                    break;
                case 7:
                    message.creatureSoldierTile = reader.int32();
                    break;
                case 8:
                    message.color = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.adultsize = reader.int32();
                    break;
                case 10:
                    if (!(message.caste && message.caste.length))
                        message.caste = [];
                    message.caste.push($root.RemoteFortressReader.CasteRaw.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.tissues && message.tissues.length))
                        message.tissues = [];
                    message.tissues.push($root.RemoteFortressReader.TissueRaw.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatureRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatureRaw message.
         * @function verify
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatureRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.creatureId != null && message.hasOwnProperty("creatureId"))
                if (!$util.isString(message.creatureId))
                    return "creatureId: string expected";
            if (message.name != null && message.hasOwnProperty("name")) {
                if (!Array.isArray(message.name))
                    return "name: array expected";
                for (var i = 0; i < message.name.length; ++i)
                    if (!$util.isString(message.name[i]))
                        return "name: string[] expected";
            }
            if (message.generalBabyName != null && message.hasOwnProperty("generalBabyName")) {
                if (!Array.isArray(message.generalBabyName))
                    return "generalBabyName: array expected";
                for (var i = 0; i < message.generalBabyName.length; ++i)
                    if (!$util.isString(message.generalBabyName[i]))
                        return "generalBabyName: string[] expected";
            }
            if (message.generalChildName != null && message.hasOwnProperty("generalChildName")) {
                if (!Array.isArray(message.generalChildName))
                    return "generalChildName: array expected";
                for (var i = 0; i < message.generalChildName.length; ++i)
                    if (!$util.isString(message.generalChildName[i]))
                        return "generalChildName: string[] expected";
            }
            if (message.creatureTile != null && message.hasOwnProperty("creatureTile"))
                if (!$util.isInteger(message.creatureTile))
                    return "creatureTile: integer expected";
            if (message.creatureSoldierTile != null && message.hasOwnProperty("creatureSoldierTile"))
                if (!$util.isInteger(message.creatureSoldierTile))
                    return "creatureSoldierTile: integer expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.adultsize != null && message.hasOwnProperty("adultsize"))
                if (!$util.isInteger(message.adultsize))
                    return "adultsize: integer expected";
            if (message.caste != null && message.hasOwnProperty("caste")) {
                if (!Array.isArray(message.caste))
                    return "caste: array expected";
                for (var i = 0; i < message.caste.length; ++i) {
                    var error = $root.RemoteFortressReader.CasteRaw.verify(message.caste[i]);
                    if (error)
                        return "caste." + error;
                }
            }
            if (message.tissues != null && message.hasOwnProperty("tissues")) {
                if (!Array.isArray(message.tissues))
                    return "tissues: array expected";
                for (var i = 0; i < message.tissues.length; ++i) {
                    var error = $root.RemoteFortressReader.TissueRaw.verify(message.tissues[i]);
                    if (error)
                        return "tissues." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreatureRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw
         */
        CreatureRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.CreatureRaw)
                return object;
            var message = new $root.RemoteFortressReader.CreatureRaw();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.creatureId != null)
                message.creatureId = String(object.creatureId);
            if (object.name) {
                if (!Array.isArray(object.name))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.name: array expected");
                message.name = [];
                for (var i = 0; i < object.name.length; ++i)
                    message.name[i] = String(object.name[i]);
            }
            if (object.generalBabyName) {
                if (!Array.isArray(object.generalBabyName))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.generalBabyName: array expected");
                message.generalBabyName = [];
                for (var i = 0; i < object.generalBabyName.length; ++i)
                    message.generalBabyName[i] = String(object.generalBabyName[i]);
            }
            if (object.generalChildName) {
                if (!Array.isArray(object.generalChildName))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.generalChildName: array expected");
                message.generalChildName = [];
                for (var i = 0; i < object.generalChildName.length; ++i)
                    message.generalChildName[i] = String(object.generalChildName[i]);
            }
            if (object.creatureTile != null)
                message.creatureTile = object.creatureTile | 0;
            if (object.creatureSoldierTile != null)
                message.creatureSoldierTile = object.creatureSoldierTile | 0;
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".RemoteFortressReader.CreatureRaw.color: object expected");
                message.color = $root.RemoteFortressReader.ColorDefinition.fromObject(object.color);
            }
            if (object.adultsize != null)
                message.adultsize = object.adultsize | 0;
            if (object.caste) {
                if (!Array.isArray(object.caste))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.caste: array expected");
                message.caste = [];
                for (var i = 0; i < object.caste.length; ++i) {
                    if (typeof object.caste[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CreatureRaw.caste: object expected");
                    message.caste[i] = $root.RemoteFortressReader.CasteRaw.fromObject(object.caste[i]);
                }
            }
            if (object.tissues) {
                if (!Array.isArray(object.tissues))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.tissues: array expected");
                message.tissues = [];
                for (var i = 0; i < object.tissues.length; ++i) {
                    if (typeof object.tissues[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CreatureRaw.tissues: object expected");
                    message.tissues[i] = $root.RemoteFortressReader.TissueRaw.fromObject(object.tissues[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreatureRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.CreatureRaw} message CreatureRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatureRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.name = [];
                object.generalBabyName = [];
                object.generalChildName = [];
                object.caste = [];
                object.tissues = [];
            }
            if (options.defaults) {
                object.index = 0;
                object.creatureId = "";
                object.creatureTile = 0;
                object.creatureSoldierTile = 0;
                object.color = null;
                object.adultsize = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.creatureId != null && message.hasOwnProperty("creatureId"))
                object.creatureId = message.creatureId;
            if (message.name && message.name.length) {
                object.name = [];
                for (var j = 0; j < message.name.length; ++j)
                    object.name[j] = message.name[j];
            }
            if (message.generalBabyName && message.generalBabyName.length) {
                object.generalBabyName = [];
                for (var j = 0; j < message.generalBabyName.length; ++j)
                    object.generalBabyName[j] = message.generalBabyName[j];
            }
            if (message.generalChildName && message.generalChildName.length) {
                object.generalChildName = [];
                for (var j = 0; j < message.generalChildName.length; ++j)
                    object.generalChildName[j] = message.generalChildName[j];
            }
            if (message.creatureTile != null && message.hasOwnProperty("creatureTile"))
                object.creatureTile = message.creatureTile;
            if (message.creatureSoldierTile != null && message.hasOwnProperty("creatureSoldierTile"))
                object.creatureSoldierTile = message.creatureSoldierTile;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.RemoteFortressReader.ColorDefinition.toObject(message.color, options);
            if (message.adultsize != null && message.hasOwnProperty("adultsize"))
                object.adultsize = message.adultsize;
            if (message.caste && message.caste.length) {
                object.caste = [];
                for (var j = 0; j < message.caste.length; ++j)
                    object.caste[j] = $root.RemoteFortressReader.CasteRaw.toObject(message.caste[j], options);
            }
            if (message.tissues && message.tissues.length) {
                object.tissues = [];
                for (var j = 0; j < message.tissues.length; ++j)
                    object.tissues[j] = $root.RemoteFortressReader.TissueRaw.toObject(message.tissues[j], options);
            }
            return object;
        };

        /**
         * Converts this CreatureRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatureRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatureRaw;
    })();

    RemoteFortressReader.CreatureRawList = (function() {

        /**
         * Properties of a CreatureRawList.
         * @memberof RemoteFortressReader
         * @interface ICreatureRawList
         * @property {Array.<RemoteFortressReader.ICreatureRaw>|null} [creatureRaws] CreatureRawList creatureRaws
         */

        /**
         * Constructs a new CreatureRawList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a CreatureRawList.
         * @implements ICreatureRawList
         * @constructor
         * @param {RemoteFortressReader.ICreatureRawList=} [properties] Properties to set
         */
        function CreatureRawList(properties) {
            this.creatureRaws = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatureRawList creatureRaws.
         * @member {Array.<RemoteFortressReader.ICreatureRaw>} creatureRaws
         * @memberof RemoteFortressReader.CreatureRawList
         * @instance
         */
        CreatureRawList.prototype.creatureRaws = $util.emptyArray;

        /**
         * Creates a new CreatureRawList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.ICreatureRawList=} [properties] Properties to set
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList instance
         */
        CreatureRawList.create = function create(properties) {
            return new CreatureRawList(properties);
        };

        /**
         * Encodes the specified CreatureRawList message. Does not implicitly {@link RemoteFortressReader.CreatureRawList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.ICreatureRawList} message CreatureRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRawList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creatureRaws != null && message.creatureRaws.length)
                for (var i = 0; i < message.creatureRaws.length; ++i)
                    $root.RemoteFortressReader.CreatureRaw.encode(message.creatureRaws[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreatureRawList message, length delimited. Does not implicitly {@link RemoteFortressReader.CreatureRawList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.ICreatureRawList} message CreatureRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRawList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatureRawList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRawList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.CreatureRawList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.creatureRaws && message.creatureRaws.length))
                        message.creatureRaws = [];
                    message.creatureRaws.push($root.RemoteFortressReader.CreatureRaw.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatureRawList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRawList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatureRawList message.
         * @function verify
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatureRawList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creatureRaws != null && message.hasOwnProperty("creatureRaws")) {
                if (!Array.isArray(message.creatureRaws))
                    return "creatureRaws: array expected";
                for (var i = 0; i < message.creatureRaws.length; ++i) {
                    var error = $root.RemoteFortressReader.CreatureRaw.verify(message.creatureRaws[i]);
                    if (error)
                        return "creatureRaws." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreatureRawList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList
         */
        CreatureRawList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.CreatureRawList)
                return object;
            var message = new $root.RemoteFortressReader.CreatureRawList();
            if (object.creatureRaws) {
                if (!Array.isArray(object.creatureRaws))
                    throw TypeError(".RemoteFortressReader.CreatureRawList.creatureRaws: array expected");
                message.creatureRaws = [];
                for (var i = 0; i < object.creatureRaws.length; ++i) {
                    if (typeof object.creatureRaws[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CreatureRawList.creatureRaws: object expected");
                    message.creatureRaws[i] = $root.RemoteFortressReader.CreatureRaw.fromObject(object.creatureRaws[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreatureRawList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.CreatureRawList} message CreatureRawList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatureRawList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.creatureRaws = [];
            if (message.creatureRaws && message.creatureRaws.length) {
                object.creatureRaws = [];
                for (var j = 0; j < message.creatureRaws.length; ++j)
                    object.creatureRaws[j] = $root.RemoteFortressReader.CreatureRaw.toObject(message.creatureRaws[j], options);
            }
            return object;
        };

        /**
         * Converts this CreatureRawList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.CreatureRawList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatureRawList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatureRawList;
    })();

    RemoteFortressReader.Army = (function() {

        /**
         * Properties of an Army.
         * @memberof RemoteFortressReader
         * @interface IArmy
         * @property {number|null} [id] Army id
         * @property {number|null} [posX] Army posX
         * @property {number|null} [posY] Army posY
         * @property {number|null} [posZ] Army posZ
         * @property {RemoteFortressReader.IUnitDefinition|null} [leader] Army leader
         * @property {Array.<RemoteFortressReader.IUnitDefinition>|null} [members] Army members
         * @property {number|null} [flags] Army flags
         */

        /**
         * Constructs a new Army.
         * @memberof RemoteFortressReader
         * @classdesc Represents an Army.
         * @implements IArmy
         * @constructor
         * @param {RemoteFortressReader.IArmy=} [properties] Properties to set
         */
        function Army(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Army id.
         * @member {number} id
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.id = 0;

        /**
         * Army posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.posX = 0;

        /**
         * Army posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.posY = 0;

        /**
         * Army posZ.
         * @member {number} posZ
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.posZ = 0;

        /**
         * Army leader.
         * @member {RemoteFortressReader.IUnitDefinition|null|undefined} leader
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.leader = null;

        /**
         * Army members.
         * @member {Array.<RemoteFortressReader.IUnitDefinition>} members
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.members = $util.emptyArray;

        /**
         * Army flags.
         * @member {number} flags
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.flags = 0;

        /**
         * Creates a new Army instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.IArmy=} [properties] Properties to set
         * @returns {RemoteFortressReader.Army} Army instance
         */
        Army.create = function create(properties) {
            return new Army(properties);
        };

        /**
         * Encodes the specified Army message. Does not implicitly {@link RemoteFortressReader.Army.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.IArmy} message Army message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Army.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.posX != null && message.hasOwnProperty("posX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posX);
            if (message.posY != null && message.hasOwnProperty("posY"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posY);
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.posZ);
            if (message.leader != null && message.hasOwnProperty("leader"))
                $root.RemoteFortressReader.UnitDefinition.encode(message.leader, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.RemoteFortressReader.UnitDefinition.encode(message.members[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.flags != null && message.hasOwnProperty("flags"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.flags);
            return writer;
        };

        /**
         * Encodes the specified Army message, length delimited. Does not implicitly {@link RemoteFortressReader.Army.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.IArmy} message Army message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Army.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Army message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Army} Army
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Army.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Army();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.posX = reader.int32();
                    break;
                case 3:
                    message.posY = reader.int32();
                    break;
                case 4:
                    message.posZ = reader.int32();
                    break;
                case 5:
                    message.leader = $root.RemoteFortressReader.UnitDefinition.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.RemoteFortressReader.UnitDefinition.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Army message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Army} Army
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Army.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Army message.
         * @function verify
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Army.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.posX != null && message.hasOwnProperty("posX"))
                if (!$util.isInteger(message.posX))
                    return "posX: integer expected";
            if (message.posY != null && message.hasOwnProperty("posY"))
                if (!$util.isInteger(message.posY))
                    return "posY: integer expected";
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                if (!$util.isInteger(message.posZ))
                    return "posZ: integer expected";
            if (message.leader != null && message.hasOwnProperty("leader")) {
                var error = $root.RemoteFortressReader.UnitDefinition.verify(message.leader);
                if (error)
                    return "leader." + error;
            }
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.RemoteFortressReader.UnitDefinition.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };

        /**
         * Creates an Army message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Army} Army
         */
        Army.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Army)
                return object;
            var message = new $root.RemoteFortressReader.Army();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.posZ != null)
                message.posZ = object.posZ | 0;
            if (object.leader != null) {
                if (typeof object.leader !== "object")
                    throw TypeError(".RemoteFortressReader.Army.leader: object expected");
                message.leader = $root.RemoteFortressReader.UnitDefinition.fromObject(object.leader);
            }
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".RemoteFortressReader.Army.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Army.members: object expected");
                    message.members[i] = $root.RemoteFortressReader.UnitDefinition.fromObject(object.members[i]);
                }
            }
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Army message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.Army} message Army
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Army.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (options.defaults) {
                object.id = 0;
                object.posX = 0;
                object.posY = 0;
                object.posZ = 0;
                object.leader = null;
                object.flags = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                object.posZ = message.posZ;
            if (message.leader != null && message.hasOwnProperty("leader"))
                object.leader = $root.RemoteFortressReader.UnitDefinition.toObject(message.leader, options);
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.RemoteFortressReader.UnitDefinition.toObject(message.members[j], options);
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };

        /**
         * Converts this Army to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Army
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Army.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Army;
    })();

    RemoteFortressReader.ArmyList = (function() {

        /**
         * Properties of an ArmyList.
         * @memberof RemoteFortressReader
         * @interface IArmyList
         * @property {Array.<RemoteFortressReader.IArmy>|null} [armies] ArmyList armies
         */

        /**
         * Constructs a new ArmyList.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArmyList.
         * @implements IArmyList
         * @constructor
         * @param {RemoteFortressReader.IArmyList=} [properties] Properties to set
         */
        function ArmyList(properties) {
            this.armies = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArmyList armies.
         * @member {Array.<RemoteFortressReader.IArmy>} armies
         * @memberof RemoteFortressReader.ArmyList
         * @instance
         */
        ArmyList.prototype.armies = $util.emptyArray;

        /**
         * Creates a new ArmyList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.IArmyList=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArmyList} ArmyList instance
         */
        ArmyList.create = function create(properties) {
            return new ArmyList(properties);
        };

        /**
         * Encodes the specified ArmyList message. Does not implicitly {@link RemoteFortressReader.ArmyList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.IArmyList} message ArmyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArmyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.armies != null && message.armies.length)
                for (var i = 0; i < message.armies.length; ++i)
                    $root.RemoteFortressReader.Army.encode(message.armies[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArmyList message, length delimited. Does not implicitly {@link RemoteFortressReader.ArmyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.IArmyList} message ArmyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArmyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArmyList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArmyList} ArmyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArmyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArmyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.armies && message.armies.length))
                        message.armies = [];
                    message.armies.push($root.RemoteFortressReader.Army.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArmyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArmyList} ArmyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArmyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArmyList message.
         * @function verify
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArmyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.armies != null && message.hasOwnProperty("armies")) {
                if (!Array.isArray(message.armies))
                    return "armies: array expected";
                for (var i = 0; i < message.armies.length; ++i) {
                    var error = $root.RemoteFortressReader.Army.verify(message.armies[i]);
                    if (error)
                        return "armies." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArmyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArmyList} ArmyList
         */
        ArmyList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArmyList)
                return object;
            var message = new $root.RemoteFortressReader.ArmyList();
            if (object.armies) {
                if (!Array.isArray(object.armies))
                    throw TypeError(".RemoteFortressReader.ArmyList.armies: array expected");
                message.armies = [];
                for (var i = 0; i < object.armies.length; ++i) {
                    if (typeof object.armies[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ArmyList.armies: object expected");
                    message.armies[i] = $root.RemoteFortressReader.Army.fromObject(object.armies[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArmyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.ArmyList} message ArmyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArmyList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.armies = [];
            if (message.armies && message.armies.length) {
                object.armies = [];
                for (var j = 0; j < message.armies.length; ++j)
                    object.armies[j] = $root.RemoteFortressReader.Army.toObject(message.armies[j], options);
            }
            return object;
        };

        /**
         * Converts this ArmyList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArmyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArmyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArmyList;
    })();

    RemoteFortressReader.GrowthPrint = (function() {

        /**
         * Properties of a GrowthPrint.
         * @memberof RemoteFortressReader
         * @interface IGrowthPrint
         * @property {number|null} [priority] GrowthPrint priority
         * @property {number|null} [color] GrowthPrint color
         * @property {number|null} [timingStart] GrowthPrint timingStart
         * @property {number|null} [timingEnd] GrowthPrint timingEnd
         * @property {number|null} [tile] GrowthPrint tile
         */

        /**
         * Constructs a new GrowthPrint.
         * @memberof RemoteFortressReader
         * @classdesc Represents a GrowthPrint.
         * @implements IGrowthPrint
         * @constructor
         * @param {RemoteFortressReader.IGrowthPrint=} [properties] Properties to set
         */
        function GrowthPrint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GrowthPrint priority.
         * @member {number} priority
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.priority = 0;

        /**
         * GrowthPrint color.
         * @member {number} color
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.color = 0;

        /**
         * GrowthPrint timingStart.
         * @member {number} timingStart
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.timingStart = 0;

        /**
         * GrowthPrint timingEnd.
         * @member {number} timingEnd
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.timingEnd = 0;

        /**
         * GrowthPrint tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.tile = 0;

        /**
         * Creates a new GrowthPrint instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.IGrowthPrint=} [properties] Properties to set
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint instance
         */
        GrowthPrint.create = function create(properties) {
            return new GrowthPrint(properties);
        };

        /**
         * Encodes the specified GrowthPrint message. Does not implicitly {@link RemoteFortressReader.GrowthPrint.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.IGrowthPrint} message GrowthPrint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowthPrint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.priority != null && message.hasOwnProperty("priority"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.priority);
            if (message.color != null && message.hasOwnProperty("color"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.timingStart);
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timingEnd);
            if (message.tile != null && message.hasOwnProperty("tile"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.tile);
            return writer;
        };

        /**
         * Encodes the specified GrowthPrint message, length delimited. Does not implicitly {@link RemoteFortressReader.GrowthPrint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.IGrowthPrint} message GrowthPrint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowthPrint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GrowthPrint message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowthPrint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.GrowthPrint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.priority = reader.int32();
                    break;
                case 2:
                    message.color = reader.int32();
                    break;
                case 3:
                    message.timingStart = reader.int32();
                    break;
                case 4:
                    message.timingEnd = reader.int32();
                    break;
                case 5:
                    message.tile = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GrowthPrint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowthPrint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GrowthPrint message.
         * @function verify
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GrowthPrint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                if (!$util.isInteger(message.timingStart))
                    return "timingStart: integer expected";
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                if (!$util.isInteger(message.timingEnd))
                    return "timingEnd: integer expected";
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            return null;
        };

        /**
         * Creates a GrowthPrint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint
         */
        GrowthPrint.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.GrowthPrint)
                return object;
            var message = new $root.RemoteFortressReader.GrowthPrint();
            if (object.priority != null)
                message.priority = object.priority | 0;
            if (object.color != null)
                message.color = object.color | 0;
            if (object.timingStart != null)
                message.timingStart = object.timingStart | 0;
            if (object.timingEnd != null)
                message.timingEnd = object.timingEnd | 0;
            if (object.tile != null)
                message.tile = object.tile | 0;
            return message;
        };

        /**
         * Creates a plain object from a GrowthPrint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.GrowthPrint} message GrowthPrint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GrowthPrint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.priority = 0;
                object.color = 0;
                object.timingStart = 0;
                object.timingEnd = 0;
                object.tile = 0;
            }
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                object.timingStart = message.timingStart;
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                object.timingEnd = message.timingEnd;
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            return object;
        };

        /**
         * Converts this GrowthPrint to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GrowthPrint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GrowthPrint;
    })();

    RemoteFortressReader.TreeGrowth = (function() {

        /**
         * Properties of a TreeGrowth.
         * @memberof RemoteFortressReader
         * @interface ITreeGrowth
         * @property {number|null} [index] TreeGrowth index
         * @property {string|null} [id] TreeGrowth id
         * @property {string|null} [name] TreeGrowth name
         * @property {RemoteFortressReader.IMatPair|null} [mat] TreeGrowth mat
         * @property {Array.<RemoteFortressReader.IGrowthPrint>|null} [prints] TreeGrowth prints
         * @property {number|null} [timingStart] TreeGrowth timingStart
         * @property {number|null} [timingEnd] TreeGrowth timingEnd
         * @property {boolean|null} [twigs] TreeGrowth twigs
         * @property {boolean|null} [lightBranches] TreeGrowth lightBranches
         * @property {boolean|null} [heavyBranches] TreeGrowth heavyBranches
         * @property {boolean|null} [trunk] TreeGrowth trunk
         * @property {boolean|null} [roots] TreeGrowth roots
         * @property {boolean|null} [cap] TreeGrowth cap
         * @property {boolean|null} [sapling] TreeGrowth sapling
         * @property {number|null} [trunkHeightStart] TreeGrowth trunkHeightStart
         * @property {number|null} [trunkHeightEnd] TreeGrowth trunkHeightEnd
         */

        /**
         * Constructs a new TreeGrowth.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TreeGrowth.
         * @implements ITreeGrowth
         * @constructor
         * @param {RemoteFortressReader.ITreeGrowth=} [properties] Properties to set
         */
        function TreeGrowth(properties) {
            this.prints = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreeGrowth index.
         * @member {number} index
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.index = 0;

        /**
         * TreeGrowth id.
         * @member {string} id
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.id = "";

        /**
         * TreeGrowth name.
         * @member {string} name
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.name = "";

        /**
         * TreeGrowth mat.
         * @member {RemoteFortressReader.IMatPair|null|undefined} mat
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.mat = null;

        /**
         * TreeGrowth prints.
         * @member {Array.<RemoteFortressReader.IGrowthPrint>} prints
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.prints = $util.emptyArray;

        /**
         * TreeGrowth timingStart.
         * @member {number} timingStart
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.timingStart = 0;

        /**
         * TreeGrowth timingEnd.
         * @member {number} timingEnd
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.timingEnd = 0;

        /**
         * TreeGrowth twigs.
         * @member {boolean} twigs
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.twigs = false;

        /**
         * TreeGrowth lightBranches.
         * @member {boolean} lightBranches
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.lightBranches = false;

        /**
         * TreeGrowth heavyBranches.
         * @member {boolean} heavyBranches
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.heavyBranches = false;

        /**
         * TreeGrowth trunk.
         * @member {boolean} trunk
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.trunk = false;

        /**
         * TreeGrowth roots.
         * @member {boolean} roots
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.roots = false;

        /**
         * TreeGrowth cap.
         * @member {boolean} cap
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.cap = false;

        /**
         * TreeGrowth sapling.
         * @member {boolean} sapling
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.sapling = false;

        /**
         * TreeGrowth trunkHeightStart.
         * @member {number} trunkHeightStart
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.trunkHeightStart = 0;

        /**
         * TreeGrowth trunkHeightEnd.
         * @member {number} trunkHeightEnd
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.trunkHeightEnd = 0;

        /**
         * Creates a new TreeGrowth instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.ITreeGrowth=} [properties] Properties to set
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth instance
         */
        TreeGrowth.create = function create(properties) {
            return new TreeGrowth(properties);
        };

        /**
         * Encodes the specified TreeGrowth message. Does not implicitly {@link RemoteFortressReader.TreeGrowth.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.ITreeGrowth} message TreeGrowth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreeGrowth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.mat != null && message.hasOwnProperty("mat"))
                $root.RemoteFortressReader.MatPair.encode(message.mat, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.prints != null && message.prints.length)
                for (var i = 0; i < message.prints.length; ++i)
                    $root.RemoteFortressReader.GrowthPrint.encode(message.prints[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timingStart);
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timingEnd);
            if (message.twigs != null && message.hasOwnProperty("twigs"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.twigs);
            if (message.lightBranches != null && message.hasOwnProperty("lightBranches"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.lightBranches);
            if (message.heavyBranches != null && message.hasOwnProperty("heavyBranches"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.heavyBranches);
            if (message.trunk != null && message.hasOwnProperty("trunk"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.trunk);
            if (message.roots != null && message.hasOwnProperty("roots"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.roots);
            if (message.cap != null && message.hasOwnProperty("cap"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.cap);
            if (message.sapling != null && message.hasOwnProperty("sapling"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.sapling);
            if (message.trunkHeightStart != null && message.hasOwnProperty("trunkHeightStart"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.trunkHeightStart);
            if (message.trunkHeightEnd != null && message.hasOwnProperty("trunkHeightEnd"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.trunkHeightEnd);
            return writer;
        };

        /**
         * Encodes the specified TreeGrowth message, length delimited. Does not implicitly {@link RemoteFortressReader.TreeGrowth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.ITreeGrowth} message TreeGrowth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreeGrowth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreeGrowth message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreeGrowth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TreeGrowth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.mat = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.prints && message.prints.length))
                        message.prints = [];
                    message.prints.push($root.RemoteFortressReader.GrowthPrint.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timingStart = reader.int32();
                    break;
                case 7:
                    message.timingEnd = reader.int32();
                    break;
                case 8:
                    message.twigs = reader.bool();
                    break;
                case 9:
                    message.lightBranches = reader.bool();
                    break;
                case 10:
                    message.heavyBranches = reader.bool();
                    break;
                case 11:
                    message.trunk = reader.bool();
                    break;
                case 12:
                    message.roots = reader.bool();
                    break;
                case 13:
                    message.cap = reader.bool();
                    break;
                case 14:
                    message.sapling = reader.bool();
                    break;
                case 15:
                    message.trunkHeightStart = reader.int32();
                    break;
                case 16:
                    message.trunkHeightEnd = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreeGrowth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreeGrowth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreeGrowth message.
         * @function verify
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreeGrowth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.mat != null && message.hasOwnProperty("mat")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.mat);
                if (error)
                    return "mat." + error;
            }
            if (message.prints != null && message.hasOwnProperty("prints")) {
                if (!Array.isArray(message.prints))
                    return "prints: array expected";
                for (var i = 0; i < message.prints.length; ++i) {
                    var error = $root.RemoteFortressReader.GrowthPrint.verify(message.prints[i]);
                    if (error)
                        return "prints." + error;
                }
            }
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                if (!$util.isInteger(message.timingStart))
                    return "timingStart: integer expected";
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                if (!$util.isInteger(message.timingEnd))
                    return "timingEnd: integer expected";
            if (message.twigs != null && message.hasOwnProperty("twigs"))
                if (typeof message.twigs !== "boolean")
                    return "twigs: boolean expected";
            if (message.lightBranches != null && message.hasOwnProperty("lightBranches"))
                if (typeof message.lightBranches !== "boolean")
                    return "lightBranches: boolean expected";
            if (message.heavyBranches != null && message.hasOwnProperty("heavyBranches"))
                if (typeof message.heavyBranches !== "boolean")
                    return "heavyBranches: boolean expected";
            if (message.trunk != null && message.hasOwnProperty("trunk"))
                if (typeof message.trunk !== "boolean")
                    return "trunk: boolean expected";
            if (message.roots != null && message.hasOwnProperty("roots"))
                if (typeof message.roots !== "boolean")
                    return "roots: boolean expected";
            if (message.cap != null && message.hasOwnProperty("cap"))
                if (typeof message.cap !== "boolean")
                    return "cap: boolean expected";
            if (message.sapling != null && message.hasOwnProperty("sapling"))
                if (typeof message.sapling !== "boolean")
                    return "sapling: boolean expected";
            if (message.trunkHeightStart != null && message.hasOwnProperty("trunkHeightStart"))
                if (!$util.isInteger(message.trunkHeightStart))
                    return "trunkHeightStart: integer expected";
            if (message.trunkHeightEnd != null && message.hasOwnProperty("trunkHeightEnd"))
                if (!$util.isInteger(message.trunkHeightEnd))
                    return "trunkHeightEnd: integer expected";
            return null;
        };

        /**
         * Creates a TreeGrowth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth
         */
        TreeGrowth.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TreeGrowth)
                return object;
            var message = new $root.RemoteFortressReader.TreeGrowth();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.mat != null) {
                if (typeof object.mat !== "object")
                    throw TypeError(".RemoteFortressReader.TreeGrowth.mat: object expected");
                message.mat = $root.RemoteFortressReader.MatPair.fromObject(object.mat);
            }
            if (object.prints) {
                if (!Array.isArray(object.prints))
                    throw TypeError(".RemoteFortressReader.TreeGrowth.prints: array expected");
                message.prints = [];
                for (var i = 0; i < object.prints.length; ++i) {
                    if (typeof object.prints[i] !== "object")
                        throw TypeError(".RemoteFortressReader.TreeGrowth.prints: object expected");
                    message.prints[i] = $root.RemoteFortressReader.GrowthPrint.fromObject(object.prints[i]);
                }
            }
            if (object.timingStart != null)
                message.timingStart = object.timingStart | 0;
            if (object.timingEnd != null)
                message.timingEnd = object.timingEnd | 0;
            if (object.twigs != null)
                message.twigs = Boolean(object.twigs);
            if (object.lightBranches != null)
                message.lightBranches = Boolean(object.lightBranches);
            if (object.heavyBranches != null)
                message.heavyBranches = Boolean(object.heavyBranches);
            if (object.trunk != null)
                message.trunk = Boolean(object.trunk);
            if (object.roots != null)
                message.roots = Boolean(object.roots);
            if (object.cap != null)
                message.cap = Boolean(object.cap);
            if (object.sapling != null)
                message.sapling = Boolean(object.sapling);
            if (object.trunkHeightStart != null)
                message.trunkHeightStart = object.trunkHeightStart | 0;
            if (object.trunkHeightEnd != null)
                message.trunkHeightEnd = object.trunkHeightEnd | 0;
            return message;
        };

        /**
         * Creates a plain object from a TreeGrowth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.TreeGrowth} message TreeGrowth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TreeGrowth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.prints = [];
            if (options.defaults) {
                object.index = 0;
                object.id = "";
                object.name = "";
                object.mat = null;
                object.timingStart = 0;
                object.timingEnd = 0;
                object.twigs = false;
                object.lightBranches = false;
                object.heavyBranches = false;
                object.trunk = false;
                object.roots = false;
                object.cap = false;
                object.sapling = false;
                object.trunkHeightStart = 0;
                object.trunkHeightEnd = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.mat != null && message.hasOwnProperty("mat"))
                object.mat = $root.RemoteFortressReader.MatPair.toObject(message.mat, options);
            if (message.prints && message.prints.length) {
                object.prints = [];
                for (var j = 0; j < message.prints.length; ++j)
                    object.prints[j] = $root.RemoteFortressReader.GrowthPrint.toObject(message.prints[j], options);
            }
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                object.timingStart = message.timingStart;
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                object.timingEnd = message.timingEnd;
            if (message.twigs != null && message.hasOwnProperty("twigs"))
                object.twigs = message.twigs;
            if (message.lightBranches != null && message.hasOwnProperty("lightBranches"))
                object.lightBranches = message.lightBranches;
            if (message.heavyBranches != null && message.hasOwnProperty("heavyBranches"))
                object.heavyBranches = message.heavyBranches;
            if (message.trunk != null && message.hasOwnProperty("trunk"))
                object.trunk = message.trunk;
            if (message.roots != null && message.hasOwnProperty("roots"))
                object.roots = message.roots;
            if (message.cap != null && message.hasOwnProperty("cap"))
                object.cap = message.cap;
            if (message.sapling != null && message.hasOwnProperty("sapling"))
                object.sapling = message.sapling;
            if (message.trunkHeightStart != null && message.hasOwnProperty("trunkHeightStart"))
                object.trunkHeightStart = message.trunkHeightStart;
            if (message.trunkHeightEnd != null && message.hasOwnProperty("trunkHeightEnd"))
                object.trunkHeightEnd = message.trunkHeightEnd;
            return object;
        };

        /**
         * Converts this TreeGrowth to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TreeGrowth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TreeGrowth;
    })();

    RemoteFortressReader.PlantRaw = (function() {

        /**
         * Properties of a PlantRaw.
         * @memberof RemoteFortressReader
         * @interface IPlantRaw
         * @property {number|null} [index] PlantRaw index
         * @property {string|null} [id] PlantRaw id
         * @property {string|null} [name] PlantRaw name
         * @property {Array.<RemoteFortressReader.ITreeGrowth>|null} [growths] PlantRaw growths
         * @property {number|null} [tile] PlantRaw tile
         */

        /**
         * Constructs a new PlantRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantRaw.
         * @implements IPlantRaw
         * @constructor
         * @param {RemoteFortressReader.IPlantRaw=} [properties] Properties to set
         */
        function PlantRaw(properties) {
            this.growths = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantRaw index.
         * @member {number} index
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.index = 0;

        /**
         * PlantRaw id.
         * @member {string} id
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.id = "";

        /**
         * PlantRaw name.
         * @member {string} name
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.name = "";

        /**
         * PlantRaw growths.
         * @member {Array.<RemoteFortressReader.ITreeGrowth>} growths
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.growths = $util.emptyArray;

        /**
         * PlantRaw tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.tile = 0;

        /**
         * Creates a new PlantRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.IPlantRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw instance
         */
        PlantRaw.create = function create(properties) {
            return new PlantRaw(properties);
        };

        /**
         * Encodes the specified PlantRaw message. Does not implicitly {@link RemoteFortressReader.PlantRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.IPlantRaw} message PlantRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.growths != null && message.growths.length)
                for (var i = 0; i < message.growths.length; ++i)
                    $root.RemoteFortressReader.TreeGrowth.encode(message.growths[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.tile != null && message.hasOwnProperty("tile"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.tile);
            return writer;
        };

        /**
         * Encodes the specified PlantRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.IPlantRaw} message PlantRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    if (!(message.growths && message.growths.length))
                        message.growths = [];
                    message.growths.push($root.RemoteFortressReader.TreeGrowth.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.tile = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlantRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantRaw message.
         * @function verify
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.growths != null && message.hasOwnProperty("growths")) {
                if (!Array.isArray(message.growths))
                    return "growths: array expected";
                for (var i = 0; i < message.growths.length; ++i) {
                    var error = $root.RemoteFortressReader.TreeGrowth.verify(message.growths[i]);
                    if (error)
                        return "growths." + error;
                }
            }
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            return null;
        };

        /**
         * Creates a PlantRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw
         */
        PlantRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantRaw)
                return object;
            var message = new $root.RemoteFortressReader.PlantRaw();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.growths) {
                if (!Array.isArray(object.growths))
                    throw TypeError(".RemoteFortressReader.PlantRaw.growths: array expected");
                message.growths = [];
                for (var i = 0; i < object.growths.length; ++i) {
                    if (typeof object.growths[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PlantRaw.growths: object expected");
                    message.growths[i] = $root.RemoteFortressReader.TreeGrowth.fromObject(object.growths[i]);
                }
            }
            if (object.tile != null)
                message.tile = object.tile | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlantRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.PlantRaw} message PlantRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.growths = [];
            if (options.defaults) {
                object.index = 0;
                object.id = "";
                object.name = "";
                object.tile = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.growths && message.growths.length) {
                object.growths = [];
                for (var j = 0; j < message.growths.length; ++j)
                    object.growths[j] = $root.RemoteFortressReader.TreeGrowth.toObject(message.growths[j], options);
            }
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            return object;
        };

        /**
         * Converts this PlantRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantRaw;
    })();

    RemoteFortressReader.PlantRawList = (function() {

        /**
         * Properties of a PlantRawList.
         * @memberof RemoteFortressReader
         * @interface IPlantRawList
         * @property {Array.<RemoteFortressReader.IPlantRaw>|null} [plantRaws] PlantRawList plantRaws
         */

        /**
         * Constructs a new PlantRawList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantRawList.
         * @implements IPlantRawList
         * @constructor
         * @param {RemoteFortressReader.IPlantRawList=} [properties] Properties to set
         */
        function PlantRawList(properties) {
            this.plantRaws = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantRawList plantRaws.
         * @member {Array.<RemoteFortressReader.IPlantRaw>} plantRaws
         * @memberof RemoteFortressReader.PlantRawList
         * @instance
         */
        PlantRawList.prototype.plantRaws = $util.emptyArray;

        /**
         * Creates a new PlantRawList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.IPlantRawList=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList instance
         */
        PlantRawList.create = function create(properties) {
            return new PlantRawList(properties);
        };

        /**
         * Encodes the specified PlantRawList message. Does not implicitly {@link RemoteFortressReader.PlantRawList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.IPlantRawList} message PlantRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRawList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.plantRaws != null && message.plantRaws.length)
                for (var i = 0; i < message.plantRaws.length; ++i)
                    $root.RemoteFortressReader.PlantRaw.encode(message.plantRaws[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlantRawList message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantRawList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.IPlantRawList} message PlantRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRawList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantRawList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRawList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantRawList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.plantRaws && message.plantRaws.length))
                        message.plantRaws = [];
                    message.plantRaws.push($root.RemoteFortressReader.PlantRaw.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlantRawList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRawList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantRawList message.
         * @function verify
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantRawList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.plantRaws != null && message.hasOwnProperty("plantRaws")) {
                if (!Array.isArray(message.plantRaws))
                    return "plantRaws: array expected";
                for (var i = 0; i < message.plantRaws.length; ++i) {
                    var error = $root.RemoteFortressReader.PlantRaw.verify(message.plantRaws[i]);
                    if (error)
                        return "plantRaws." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PlantRawList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList
         */
        PlantRawList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantRawList)
                return object;
            var message = new $root.RemoteFortressReader.PlantRawList();
            if (object.plantRaws) {
                if (!Array.isArray(object.plantRaws))
                    throw TypeError(".RemoteFortressReader.PlantRawList.plantRaws: array expected");
                message.plantRaws = [];
                for (var i = 0; i < object.plantRaws.length; ++i) {
                    if (typeof object.plantRaws[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PlantRawList.plantRaws: object expected");
                    message.plantRaws[i] = $root.RemoteFortressReader.PlantRaw.fromObject(object.plantRaws[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PlantRawList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.PlantRawList} message PlantRawList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantRawList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plantRaws = [];
            if (message.plantRaws && message.plantRaws.length) {
                object.plantRaws = [];
                for (var j = 0; j < message.plantRaws.length; ++j)
                    object.plantRaws[j] = $root.RemoteFortressReader.PlantRaw.toObject(message.plantRaws[j], options);
            }
            return object;
        };

        /**
         * Converts this PlantRawList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantRawList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantRawList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantRawList;
    })();

    RemoteFortressReader.ScreenTile = (function() {

        /**
         * Properties of a ScreenTile.
         * @memberof RemoteFortressReader
         * @interface IScreenTile
         * @property {number|null} [character] ScreenTile character
         * @property {number|null} [foreground] ScreenTile foreground
         * @property {number|null} [background] ScreenTile background
         */

        /**
         * Constructs a new ScreenTile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ScreenTile.
         * @implements IScreenTile
         * @constructor
         * @param {RemoteFortressReader.IScreenTile=} [properties] Properties to set
         */
        function ScreenTile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScreenTile character.
         * @member {number} character
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         */
        ScreenTile.prototype.character = 0;

        /**
         * ScreenTile foreground.
         * @member {number} foreground
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         */
        ScreenTile.prototype.foreground = 0;

        /**
         * ScreenTile background.
         * @member {number} background
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         */
        ScreenTile.prototype.background = 0;

        /**
         * Creates a new ScreenTile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.IScreenTile=} [properties] Properties to set
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile instance
         */
        ScreenTile.create = function create(properties) {
            return new ScreenTile(properties);
        };

        /**
         * Encodes the specified ScreenTile message. Does not implicitly {@link RemoteFortressReader.ScreenTile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.IScreenTile} message ScreenTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.character != null && message.hasOwnProperty("character"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.character);
            if (message.foreground != null && message.hasOwnProperty("foreground"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.foreground);
            if (message.background != null && message.hasOwnProperty("background"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.background);
            return writer;
        };

        /**
         * Encodes the specified ScreenTile message, length delimited. Does not implicitly {@link RemoteFortressReader.ScreenTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.IScreenTile} message ScreenTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ScreenTile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ScreenTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.character = reader.uint32();
                    break;
                case 2:
                    message.foreground = reader.uint32();
                    break;
                case 3:
                    message.background = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScreenTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ScreenTile message.
         * @function verify
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScreenTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.character != null && message.hasOwnProperty("character"))
                if (!$util.isInteger(message.character))
                    return "character: integer expected";
            if (message.foreground != null && message.hasOwnProperty("foreground"))
                if (!$util.isInteger(message.foreground))
                    return "foreground: integer expected";
            if (message.background != null && message.hasOwnProperty("background"))
                if (!$util.isInteger(message.background))
                    return "background: integer expected";
            return null;
        };

        /**
         * Creates a ScreenTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile
         */
        ScreenTile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ScreenTile)
                return object;
            var message = new $root.RemoteFortressReader.ScreenTile();
            if (object.character != null)
                message.character = object.character >>> 0;
            if (object.foreground != null)
                message.foreground = object.foreground >>> 0;
            if (object.background != null)
                message.background = object.background >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ScreenTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.ScreenTile} message ScreenTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScreenTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.character = 0;
                object.foreground = 0;
                object.background = 0;
            }
            if (message.character != null && message.hasOwnProperty("character"))
                object.character = message.character;
            if (message.foreground != null && message.hasOwnProperty("foreground"))
                object.foreground = message.foreground;
            if (message.background != null && message.hasOwnProperty("background"))
                object.background = message.background;
            return object;
        };

        /**
         * Converts this ScreenTile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScreenTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ScreenTile;
    })();

    RemoteFortressReader.ScreenCapture = (function() {

        /**
         * Properties of a ScreenCapture.
         * @memberof RemoteFortressReader
         * @interface IScreenCapture
         * @property {number|null} [width] ScreenCapture width
         * @property {number|null} [height] ScreenCapture height
         * @property {Array.<RemoteFortressReader.IScreenTile>|null} [tiles] ScreenCapture tiles
         */

        /**
         * Constructs a new ScreenCapture.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ScreenCapture.
         * @implements IScreenCapture
         * @constructor
         * @param {RemoteFortressReader.IScreenCapture=} [properties] Properties to set
         */
        function ScreenCapture(properties) {
            this.tiles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScreenCapture width.
         * @member {number} width
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         */
        ScreenCapture.prototype.width = 0;

        /**
         * ScreenCapture height.
         * @member {number} height
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         */
        ScreenCapture.prototype.height = 0;

        /**
         * ScreenCapture tiles.
         * @member {Array.<RemoteFortressReader.IScreenTile>} tiles
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         */
        ScreenCapture.prototype.tiles = $util.emptyArray;

        /**
         * Creates a new ScreenCapture instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.IScreenCapture=} [properties] Properties to set
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture instance
         */
        ScreenCapture.create = function create(properties) {
            return new ScreenCapture(properties);
        };

        /**
         * Encodes the specified ScreenCapture message. Does not implicitly {@link RemoteFortressReader.ScreenCapture.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.IScreenCapture} message ScreenCapture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenCapture.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.width != null && message.hasOwnProperty("width"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.width);
            if (message.height != null && message.hasOwnProperty("height"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.height);
            if (message.tiles != null && message.tiles.length)
                for (var i = 0; i < message.tiles.length; ++i)
                    $root.RemoteFortressReader.ScreenTile.encode(message.tiles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ScreenCapture message, length delimited. Does not implicitly {@link RemoteFortressReader.ScreenCapture.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.IScreenCapture} message ScreenCapture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenCapture.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ScreenCapture message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenCapture.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ScreenCapture();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.width = reader.uint32();
                    break;
                case 2:
                    message.height = reader.uint32();
                    break;
                case 3:
                    if (!(message.tiles && message.tiles.length))
                        message.tiles = [];
                    message.tiles.push($root.RemoteFortressReader.ScreenTile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScreenCapture message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenCapture.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ScreenCapture message.
         * @function verify
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScreenCapture.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.tiles != null && message.hasOwnProperty("tiles")) {
                if (!Array.isArray(message.tiles))
                    return "tiles: array expected";
                for (var i = 0; i < message.tiles.length; ++i) {
                    var error = $root.RemoteFortressReader.ScreenTile.verify(message.tiles[i]);
                    if (error)
                        return "tiles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ScreenCapture message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture
         */
        ScreenCapture.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ScreenCapture)
                return object;
            var message = new $root.RemoteFortressReader.ScreenCapture();
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.tiles) {
                if (!Array.isArray(object.tiles))
                    throw TypeError(".RemoteFortressReader.ScreenCapture.tiles: array expected");
                message.tiles = [];
                for (var i = 0; i < object.tiles.length; ++i) {
                    if (typeof object.tiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ScreenCapture.tiles: object expected");
                    message.tiles[i] = $root.RemoteFortressReader.ScreenTile.fromObject(object.tiles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ScreenCapture message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.ScreenCapture} message ScreenCapture
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScreenCapture.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tiles = [];
            if (options.defaults) {
                object.width = 0;
                object.height = 0;
            }
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.tiles && message.tiles.length) {
                object.tiles = [];
                for (var j = 0; j < message.tiles.length; ++j)
                    object.tiles[j] = $root.RemoteFortressReader.ScreenTile.toObject(message.tiles[j], options);
            }
            return object;
        };

        /**
         * Converts this ScreenCapture to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScreenCapture.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ScreenCapture;
    })();

    RemoteFortressReader.KeyboardEvent = (function() {

        /**
         * Properties of a KeyboardEvent.
         * @memberof RemoteFortressReader
         * @interface IKeyboardEvent
         * @property {number|null} [type] KeyboardEvent type
         * @property {number|null} [which] KeyboardEvent which
         * @property {number|null} [state] KeyboardEvent state
         * @property {number|null} [scancode] KeyboardEvent scancode
         * @property {number|null} [sym] KeyboardEvent sym
         * @property {number|null} [mod] KeyboardEvent mod
         * @property {number|null} [unicode] KeyboardEvent unicode
         */

        /**
         * Constructs a new KeyboardEvent.
         * @memberof RemoteFortressReader
         * @classdesc Represents a KeyboardEvent.
         * @implements IKeyboardEvent
         * @constructor
         * @param {RemoteFortressReader.IKeyboardEvent=} [properties] Properties to set
         */
        function KeyboardEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyboardEvent type.
         * @member {number} type
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.type = 0;

        /**
         * KeyboardEvent which.
         * @member {number} which
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.which = 0;

        /**
         * KeyboardEvent state.
         * @member {number} state
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.state = 0;

        /**
         * KeyboardEvent scancode.
         * @member {number} scancode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.scancode = 0;

        /**
         * KeyboardEvent sym.
         * @member {number} sym
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.sym = 0;

        /**
         * KeyboardEvent mod.
         * @member {number} mod
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.mod = 0;

        /**
         * KeyboardEvent unicode.
         * @member {number} unicode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.unicode = 0;

        /**
         * Creates a new KeyboardEvent instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.IKeyboardEvent=} [properties] Properties to set
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent instance
         */
        KeyboardEvent.create = function create(properties) {
            return new KeyboardEvent(properties);
        };

        /**
         * Encodes the specified KeyboardEvent message. Does not implicitly {@link RemoteFortressReader.KeyboardEvent.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.IKeyboardEvent} message KeyboardEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyboardEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.which != null && message.hasOwnProperty("which"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.which);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.state);
            if (message.scancode != null && message.hasOwnProperty("scancode"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.scancode);
            if (message.sym != null && message.hasOwnProperty("sym"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.sym);
            if (message.mod != null && message.hasOwnProperty("mod"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.mod);
            if (message.unicode != null && message.hasOwnProperty("unicode"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.unicode);
            return writer;
        };

        /**
         * Encodes the specified KeyboardEvent message, length delimited. Does not implicitly {@link RemoteFortressReader.KeyboardEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.IKeyboardEvent} message KeyboardEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyboardEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyboardEvent message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyboardEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.KeyboardEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.uint32();
                    break;
                case 2:
                    message.which = reader.uint32();
                    break;
                case 3:
                    message.state = reader.uint32();
                    break;
                case 4:
                    message.scancode = reader.uint32();
                    break;
                case 5:
                    message.sym = reader.uint32();
                    break;
                case 6:
                    message.mod = reader.uint32();
                    break;
                case 7:
                    message.unicode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyboardEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyboardEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyboardEvent message.
         * @function verify
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyboardEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.which != null && message.hasOwnProperty("which"))
                if (!$util.isInteger(message.which))
                    return "which: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.scancode != null && message.hasOwnProperty("scancode"))
                if (!$util.isInteger(message.scancode))
                    return "scancode: integer expected";
            if (message.sym != null && message.hasOwnProperty("sym"))
                if (!$util.isInteger(message.sym))
                    return "sym: integer expected";
            if (message.mod != null && message.hasOwnProperty("mod"))
                if (!$util.isInteger(message.mod))
                    return "mod: integer expected";
            if (message.unicode != null && message.hasOwnProperty("unicode"))
                if (!$util.isInteger(message.unicode))
                    return "unicode: integer expected";
            return null;
        };

        /**
         * Creates a KeyboardEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent
         */
        KeyboardEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.KeyboardEvent)
                return object;
            var message = new $root.RemoteFortressReader.KeyboardEvent();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.which != null)
                message.which = object.which >>> 0;
            if (object.state != null)
                message.state = object.state >>> 0;
            if (object.scancode != null)
                message.scancode = object.scancode >>> 0;
            if (object.sym != null)
                message.sym = object.sym >>> 0;
            if (object.mod != null)
                message.mod = object.mod >>> 0;
            if (object.unicode != null)
                message.unicode = object.unicode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a KeyboardEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.KeyboardEvent} message KeyboardEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyboardEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.which = 0;
                object.state = 0;
                object.scancode = 0;
                object.sym = 0;
                object.mod = 0;
                object.unicode = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.which != null && message.hasOwnProperty("which"))
                object.which = message.which;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.scancode != null && message.hasOwnProperty("scancode"))
                object.scancode = message.scancode;
            if (message.sym != null && message.hasOwnProperty("sym"))
                object.sym = message.sym;
            if (message.mod != null && message.hasOwnProperty("mod"))
                object.mod = message.mod;
            if (message.unicode != null && message.hasOwnProperty("unicode"))
                object.unicode = message.unicode;
            return object;
        };

        /**
         * Converts this KeyboardEvent to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyboardEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyboardEvent;
    })();

    RemoteFortressReader.DigCommand = (function() {

        /**
         * Properties of a DigCommand.
         * @memberof RemoteFortressReader
         * @interface IDigCommand
         * @property {RemoteFortressReader.TileDigDesignation|null} [designation] DigCommand designation
         * @property {Array.<RemoteFortressReader.ICoord>|null} [locations] DigCommand locations
         */

        /**
         * Constructs a new DigCommand.
         * @memberof RemoteFortressReader
         * @classdesc Represents a DigCommand.
         * @implements IDigCommand
         * @constructor
         * @param {RemoteFortressReader.IDigCommand=} [properties] Properties to set
         */
        function DigCommand(properties) {
            this.locations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DigCommand designation.
         * @member {RemoteFortressReader.TileDigDesignation} designation
         * @memberof RemoteFortressReader.DigCommand
         * @instance
         */
        DigCommand.prototype.designation = 0;

        /**
         * DigCommand locations.
         * @member {Array.<RemoteFortressReader.ICoord>} locations
         * @memberof RemoteFortressReader.DigCommand
         * @instance
         */
        DigCommand.prototype.locations = $util.emptyArray;

        /**
         * Creates a new DigCommand instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.IDigCommand=} [properties] Properties to set
         * @returns {RemoteFortressReader.DigCommand} DigCommand instance
         */
        DigCommand.create = function create(properties) {
            return new DigCommand(properties);
        };

        /**
         * Encodes the specified DigCommand message. Does not implicitly {@link RemoteFortressReader.DigCommand.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.IDigCommand} message DigCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DigCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.designation != null && message.hasOwnProperty("designation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.designation);
            if (message.locations != null && message.locations.length)
                for (var i = 0; i < message.locations.length; ++i)
                    $root.RemoteFortressReader.Coord.encode(message.locations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DigCommand message, length delimited. Does not implicitly {@link RemoteFortressReader.DigCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.IDigCommand} message DigCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DigCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DigCommand message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.DigCommand} DigCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DigCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.DigCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.designation = reader.int32();
                    break;
                case 2:
                    if (!(message.locations && message.locations.length))
                        message.locations = [];
                    message.locations.push($root.RemoteFortressReader.Coord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DigCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.DigCommand} DigCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DigCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DigCommand message.
         * @function verify
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DigCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.designation != null && message.hasOwnProperty("designation"))
                switch (message.designation) {
                default:
                    return "designation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.locations != null && message.hasOwnProperty("locations")) {
                if (!Array.isArray(message.locations))
                    return "locations: array expected";
                for (var i = 0; i < message.locations.length; ++i) {
                    var error = $root.RemoteFortressReader.Coord.verify(message.locations[i]);
                    if (error)
                        return "locations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a DigCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.DigCommand} DigCommand
         */
        DigCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.DigCommand)
                return object;
            var message = new $root.RemoteFortressReader.DigCommand();
            switch (object.designation) {
            case "NO_DIG":
            case 0:
                message.designation = 0;
                break;
            case "DEFAULT_DIG":
            case 1:
                message.designation = 1;
                break;
            case "UP_DOWN_STAIR_DIG":
            case 2:
                message.designation = 2;
                break;
            case "CHANNEL_DIG":
            case 3:
                message.designation = 3;
                break;
            case "RAMP_DIG":
            case 4:
                message.designation = 4;
                break;
            case "DOWN_STAIR_DIG":
            case 5:
                message.designation = 5;
                break;
            case "UP_STAIR_DIG":
            case 6:
                message.designation = 6;
                break;
            }
            if (object.locations) {
                if (!Array.isArray(object.locations))
                    throw TypeError(".RemoteFortressReader.DigCommand.locations: array expected");
                message.locations = [];
                for (var i = 0; i < object.locations.length; ++i) {
                    if (typeof object.locations[i] !== "object")
                        throw TypeError(".RemoteFortressReader.DigCommand.locations: object expected");
                    message.locations[i] = $root.RemoteFortressReader.Coord.fromObject(object.locations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a DigCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.DigCommand} message DigCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DigCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.locations = [];
            if (options.defaults)
                object.designation = options.enums === String ? "NO_DIG" : 0;
            if (message.designation != null && message.hasOwnProperty("designation"))
                object.designation = options.enums === String ? $root.RemoteFortressReader.TileDigDesignation[message.designation] : message.designation;
            if (message.locations && message.locations.length) {
                object.locations = [];
                for (var j = 0; j < message.locations.length; ++j)
                    object.locations[j] = $root.RemoteFortressReader.Coord.toObject(message.locations[j], options);
            }
            return object;
        };

        /**
         * Converts this DigCommand to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.DigCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DigCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DigCommand;
    })();

    RemoteFortressReader.SingleBool = (function() {

        /**
         * Properties of a SingleBool.
         * @memberof RemoteFortressReader
         * @interface ISingleBool
         * @property {boolean|null} [Value] SingleBool Value
         */

        /**
         * Constructs a new SingleBool.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SingleBool.
         * @implements ISingleBool
         * @constructor
         * @param {RemoteFortressReader.ISingleBool=} [properties] Properties to set
         */
        function SingleBool(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SingleBool Value.
         * @member {boolean} Value
         * @memberof RemoteFortressReader.SingleBool
         * @instance
         */
        SingleBool.prototype.Value = false;

        /**
         * Creates a new SingleBool instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.ISingleBool=} [properties] Properties to set
         * @returns {RemoteFortressReader.SingleBool} SingleBool instance
         */
        SingleBool.create = function create(properties) {
            return new SingleBool(properties);
        };

        /**
         * Encodes the specified SingleBool message. Does not implicitly {@link RemoteFortressReader.SingleBool.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.ISingleBool} message SingleBool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleBool.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Value != null && message.hasOwnProperty("Value"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.Value);
            return writer;
        };

        /**
         * Encodes the specified SingleBool message, length delimited. Does not implicitly {@link RemoteFortressReader.SingleBool.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.ISingleBool} message SingleBool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleBool.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SingleBool message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SingleBool} SingleBool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleBool.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SingleBool();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SingleBool message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SingleBool} SingleBool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleBool.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SingleBool message.
         * @function verify
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SingleBool.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Value != null && message.hasOwnProperty("Value"))
                if (typeof message.Value !== "boolean")
                    return "Value: boolean expected";
            return null;
        };

        /**
         * Creates a SingleBool message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SingleBool} SingleBool
         */
        SingleBool.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SingleBool)
                return object;
            var message = new $root.RemoteFortressReader.SingleBool();
            if (object.Value != null)
                message.Value = Boolean(object.Value);
            return message;
        };

        /**
         * Creates a plain object from a SingleBool message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.SingleBool} message SingleBool
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SingleBool.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.Value = false;
            if (message.Value != null && message.hasOwnProperty("Value"))
                object.Value = message.Value;
            return object;
        };

        /**
         * Converts this SingleBool to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SingleBool
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SingleBool.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SingleBool;
    })();

    RemoteFortressReader.VersionInfo = (function() {

        /**
         * Properties of a VersionInfo.
         * @memberof RemoteFortressReader
         * @interface IVersionInfo
         * @property {string|null} [dwarfFortressVersion] VersionInfo dwarfFortressVersion
         * @property {string|null} [dfhackVersion] VersionInfo dfhackVersion
         * @property {string|null} [remoteFortressReaderVersion] VersionInfo remoteFortressReaderVersion
         */

        /**
         * Constructs a new VersionInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a VersionInfo.
         * @implements IVersionInfo
         * @constructor
         * @param {RemoteFortressReader.IVersionInfo=} [properties] Properties to set
         */
        function VersionInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VersionInfo dwarfFortressVersion.
         * @member {string} dwarfFortressVersion
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         */
        VersionInfo.prototype.dwarfFortressVersion = "";

        /**
         * VersionInfo dfhackVersion.
         * @member {string} dfhackVersion
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         */
        VersionInfo.prototype.dfhackVersion = "";

        /**
         * VersionInfo remoteFortressReaderVersion.
         * @member {string} remoteFortressReaderVersion
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         */
        VersionInfo.prototype.remoteFortressReaderVersion = "";

        /**
         * Creates a new VersionInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.IVersionInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo instance
         */
        VersionInfo.create = function create(properties) {
            return new VersionInfo(properties);
        };

        /**
         * Encodes the specified VersionInfo message. Does not implicitly {@link RemoteFortressReader.VersionInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.IVersionInfo} message VersionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dwarfFortressVersion != null && message.hasOwnProperty("dwarfFortressVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dwarfFortressVersion);
            if (message.dfhackVersion != null && message.hasOwnProperty("dfhackVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.dfhackVersion);
            if (message.remoteFortressReaderVersion != null && message.hasOwnProperty("remoteFortressReaderVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.remoteFortressReaderVersion);
            return writer;
        };

        /**
         * Encodes the specified VersionInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.VersionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.IVersionInfo} message VersionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.VersionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dwarfFortressVersion = reader.string();
                    break;
                case 2:
                    message.dfhackVersion = reader.string();
                    break;
                case 3:
                    message.remoteFortressReaderVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VersionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionInfo message.
         * @function verify
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dwarfFortressVersion != null && message.hasOwnProperty("dwarfFortressVersion"))
                if (!$util.isString(message.dwarfFortressVersion))
                    return "dwarfFortressVersion: string expected";
            if (message.dfhackVersion != null && message.hasOwnProperty("dfhackVersion"))
                if (!$util.isString(message.dfhackVersion))
                    return "dfhackVersion: string expected";
            if (message.remoteFortressReaderVersion != null && message.hasOwnProperty("remoteFortressReaderVersion"))
                if (!$util.isString(message.remoteFortressReaderVersion))
                    return "remoteFortressReaderVersion: string expected";
            return null;
        };

        /**
         * Creates a VersionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo
         */
        VersionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.VersionInfo)
                return object;
            var message = new $root.RemoteFortressReader.VersionInfo();
            if (object.dwarfFortressVersion != null)
                message.dwarfFortressVersion = String(object.dwarfFortressVersion);
            if (object.dfhackVersion != null)
                message.dfhackVersion = String(object.dfhackVersion);
            if (object.remoteFortressReaderVersion != null)
                message.remoteFortressReaderVersion = String(object.remoteFortressReaderVersion);
            return message;
        };

        /**
         * Creates a plain object from a VersionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.VersionInfo} message VersionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dwarfFortressVersion = "";
                object.dfhackVersion = "";
                object.remoteFortressReaderVersion = "";
            }
            if (message.dwarfFortressVersion != null && message.hasOwnProperty("dwarfFortressVersion"))
                object.dwarfFortressVersion = message.dwarfFortressVersion;
            if (message.dfhackVersion != null && message.hasOwnProperty("dfhackVersion"))
                object.dfhackVersion = message.dfhackVersion;
            if (message.remoteFortressReaderVersion != null && message.hasOwnProperty("remoteFortressReaderVersion"))
                object.remoteFortressReaderVersion = message.remoteFortressReaderVersion;
            return object;
        };

        /**
         * Converts this VersionInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VersionInfo;
    })();

    RemoteFortressReader.ListRequest = (function() {

        /**
         * Properties of a ListRequest.
         * @memberof RemoteFortressReader
         * @interface IListRequest
         * @property {number|null} [listStart] ListRequest listStart
         * @property {number|null} [listEnd] ListRequest listEnd
         */

        /**
         * Constructs a new ListRequest.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ListRequest.
         * @implements IListRequest
         * @constructor
         * @param {RemoteFortressReader.IListRequest=} [properties] Properties to set
         */
        function ListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListRequest listStart.
         * @member {number} listStart
         * @memberof RemoteFortressReader.ListRequest
         * @instance
         */
        ListRequest.prototype.listStart = 0;

        /**
         * ListRequest listEnd.
         * @member {number} listEnd
         * @memberof RemoteFortressReader.ListRequest
         * @instance
         */
        ListRequest.prototype.listEnd = 0;

        /**
         * Creates a new ListRequest instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.IListRequest=} [properties] Properties to set
         * @returns {RemoteFortressReader.ListRequest} ListRequest instance
         */
        ListRequest.create = function create(properties) {
            return new ListRequest(properties);
        };

        /**
         * Encodes the specified ListRequest message. Does not implicitly {@link RemoteFortressReader.ListRequest.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.IListRequest} message ListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.listStart != null && message.hasOwnProperty("listStart"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.listStart);
            if (message.listEnd != null && message.hasOwnProperty("listEnd"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.listEnd);
            return writer;
        };

        /**
         * Encodes the specified ListRequest message, length delimited. Does not implicitly {@link RemoteFortressReader.ListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.IListRequest} message ListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ListRequest} ListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.listStart = reader.int32();
                    break;
                case 2:
                    message.listEnd = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ListRequest} ListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListRequest message.
         * @function verify
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.listStart != null && message.hasOwnProperty("listStart"))
                if (!$util.isInteger(message.listStart))
                    return "listStart: integer expected";
            if (message.listEnd != null && message.hasOwnProperty("listEnd"))
                if (!$util.isInteger(message.listEnd))
                    return "listEnd: integer expected";
            return null;
        };

        /**
         * Creates a ListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ListRequest} ListRequest
         */
        ListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ListRequest)
                return object;
            var message = new $root.RemoteFortressReader.ListRequest();
            if (object.listStart != null)
                message.listStart = object.listStart | 0;
            if (object.listEnd != null)
                message.listEnd = object.listEnd | 0;
            return message;
        };

        /**
         * Creates a plain object from a ListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.ListRequest} message ListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.listStart = 0;
                object.listEnd = 0;
            }
            if (message.listStart != null && message.hasOwnProperty("listStart"))
                object.listStart = message.listStart;
            if (message.listEnd != null && message.hasOwnProperty("listEnd"))
                object.listEnd = message.listEnd;
            return object;
        };

        /**
         * Converts this ListRequest to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListRequest;
    })();

    RemoteFortressReader.Report = (function() {

        /**
         * Properties of a Report.
         * @memberof RemoteFortressReader
         * @interface IReport
         * @property {number|null} [type] Report type
         * @property {string|null} [text] Report text
         * @property {RemoteFortressReader.IColorDefinition|null} [color] Report color
         * @property {number|null} [duration] Report duration
         * @property {boolean|null} [continuation] Report continuation
         * @property {boolean|null} [unconscious] Report unconscious
         * @property {boolean|null} [announcement] Report announcement
         * @property {number|null} [repeatCount] Report repeatCount
         * @property {RemoteFortressReader.ICoord|null} [pos] Report pos
         * @property {number|null} [id] Report id
         * @property {number|null} [year] Report year
         * @property {number|null} [time] Report time
         */

        /**
         * Constructs a new Report.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Report.
         * @implements IReport
         * @constructor
         * @param {RemoteFortressReader.IReport=} [properties] Properties to set
         */
        function Report(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Report type.
         * @member {number} type
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.type = 0;

        /**
         * Report text.
         * @member {string} text
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.text = "";

        /**
         * Report color.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} color
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.color = null;

        /**
         * Report duration.
         * @member {number} duration
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.duration = 0;

        /**
         * Report continuation.
         * @member {boolean} continuation
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.continuation = false;

        /**
         * Report unconscious.
         * @member {boolean} unconscious
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.unconscious = false;

        /**
         * Report announcement.
         * @member {boolean} announcement
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.announcement = false;

        /**
         * Report repeatCount.
         * @member {number} repeatCount
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.repeatCount = 0;

        /**
         * Report pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.pos = null;

        /**
         * Report id.
         * @member {number} id
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.id = 0;

        /**
         * Report year.
         * @member {number} year
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.year = 0;

        /**
         * Report time.
         * @member {number} time
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.time = 0;

        /**
         * Creates a new Report instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.IReport=} [properties] Properties to set
         * @returns {RemoteFortressReader.Report} Report instance
         */
        Report.create = function create(properties) {
            return new Report(properties);
        };

        /**
         * Encodes the specified Report message. Does not implicitly {@link RemoteFortressReader.Report.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.IReport} message Report message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Report.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.text != null && message.hasOwnProperty("text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.color != null && message.hasOwnProperty("color"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.duration != null && message.hasOwnProperty("duration"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.duration);
            if (message.continuation != null && message.hasOwnProperty("continuation"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.continuation);
            if (message.unconscious != null && message.hasOwnProperty("unconscious"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.unconscious);
            if (message.announcement != null && message.hasOwnProperty("announcement"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.announcement);
            if (message.repeatCount != null && message.hasOwnProperty("repeatCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.repeatCount);
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.id);
            if (message.year != null && message.hasOwnProperty("year"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.year);
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.time);
            return writer;
        };

        /**
         * Encodes the specified Report message, length delimited. Does not implicitly {@link RemoteFortressReader.Report.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.IReport} message Report message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Report.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Report message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Report} Report
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Report.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Report();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.color = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.duration = reader.int32();
                    break;
                case 5:
                    message.continuation = reader.bool();
                    break;
                case 6:
                    message.unconscious = reader.bool();
                    break;
                case 7:
                    message.announcement = reader.bool();
                    break;
                case 8:
                    message.repeatCount = reader.int32();
                    break;
                case 9:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.id = reader.int32();
                    break;
                case 11:
                    message.year = reader.int32();
                    break;
                case 12:
                    message.time = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Report message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Report} Report
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Report.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Report message.
         * @function verify
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Report.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.continuation != null && message.hasOwnProperty("continuation"))
                if (typeof message.continuation !== "boolean")
                    return "continuation: boolean expected";
            if (message.unconscious != null && message.hasOwnProperty("unconscious"))
                if (typeof message.unconscious !== "boolean")
                    return "unconscious: boolean expected";
            if (message.announcement != null && message.hasOwnProperty("announcement"))
                if (typeof message.announcement !== "boolean")
                    return "announcement: boolean expected";
            if (message.repeatCount != null && message.hasOwnProperty("repeatCount"))
                if (!$util.isInteger(message.repeatCount))
                    return "repeatCount: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.year != null && message.hasOwnProperty("year"))
                if (!$util.isInteger(message.year))
                    return "year: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            return null;
        };

        /**
         * Creates a Report message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Report} Report
         */
        Report.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Report)
                return object;
            var message = new $root.RemoteFortressReader.Report();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".RemoteFortressReader.Report.color: object expected");
                message.color = $root.RemoteFortressReader.ColorDefinition.fromObject(object.color);
            }
            if (object.duration != null)
                message.duration = object.duration | 0;
            if (object.continuation != null)
                message.continuation = Boolean(object.continuation);
            if (object.unconscious != null)
                message.unconscious = Boolean(object.unconscious);
            if (object.announcement != null)
                message.announcement = Boolean(object.announcement);
            if (object.repeatCount != null)
                message.repeatCount = object.repeatCount | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Report.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.id != null)
                message.id = object.id | 0;
            if (object.year != null)
                message.year = object.year | 0;
            if (object.time != null)
                message.time = object.time | 0;
            return message;
        };

        /**
         * Creates a plain object from a Report message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.Report} message Report
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Report.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.text = "";
                object.color = null;
                object.duration = 0;
                object.continuation = false;
                object.unconscious = false;
                object.announcement = false;
                object.repeatCount = 0;
                object.pos = null;
                object.id = 0;
                object.year = 0;
                object.time = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.RemoteFortressReader.ColorDefinition.toObject(message.color, options);
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.continuation != null && message.hasOwnProperty("continuation"))
                object.continuation = message.continuation;
            if (message.unconscious != null && message.hasOwnProperty("unconscious"))
                object.unconscious = message.unconscious;
            if (message.announcement != null && message.hasOwnProperty("announcement"))
                object.announcement = message.announcement;
            if (message.repeatCount != null && message.hasOwnProperty("repeatCount"))
                object.repeatCount = message.repeatCount;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.year != null && message.hasOwnProperty("year"))
                object.year = message.year;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            return object;
        };

        /**
         * Converts this Report to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Report
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Report.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Report;
    })();

    RemoteFortressReader.Status = (function() {

        /**
         * Properties of a Status.
         * @memberof RemoteFortressReader
         * @interface IStatus
         * @property {Array.<RemoteFortressReader.IReport>|null} [reports] Status reports
         */

        /**
         * Constructs a new Status.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Status.
         * @implements IStatus
         * @constructor
         * @param {RemoteFortressReader.IStatus=} [properties] Properties to set
         */
        function Status(properties) {
            this.reports = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Status reports.
         * @member {Array.<RemoteFortressReader.IReport>} reports
         * @memberof RemoteFortressReader.Status
         * @instance
         */
        Status.prototype.reports = $util.emptyArray;

        /**
         * Creates a new Status instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.IStatus=} [properties] Properties to set
         * @returns {RemoteFortressReader.Status} Status instance
         */
        Status.create = function create(properties) {
            return new Status(properties);
        };

        /**
         * Encodes the specified Status message. Does not implicitly {@link RemoteFortressReader.Status.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reports != null && message.reports.length)
                for (var i = 0; i < message.reports.length; ++i)
                    $root.RemoteFortressReader.Report.encode(message.reports[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Status message, length delimited. Does not implicitly {@link RemoteFortressReader.Status.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Status message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Status();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.reports && message.reports.length))
                        message.reports = [];
                    message.reports.push($root.RemoteFortressReader.Report.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Status message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Status message.
         * @function verify
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Status.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reports != null && message.hasOwnProperty("reports")) {
                if (!Array.isArray(message.reports))
                    return "reports: array expected";
                for (var i = 0; i < message.reports.length; ++i) {
                    var error = $root.RemoteFortressReader.Report.verify(message.reports[i]);
                    if (error)
                        return "reports." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Status message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Status} Status
         */
        Status.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Status)
                return object;
            var message = new $root.RemoteFortressReader.Status();
            if (object.reports) {
                if (!Array.isArray(object.reports))
                    throw TypeError(".RemoteFortressReader.Status.reports: array expected");
                message.reports = [];
                for (var i = 0; i < object.reports.length; ++i) {
                    if (typeof object.reports[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Status.reports: object expected");
                    message.reports[i] = $root.RemoteFortressReader.Report.fromObject(object.reports[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Status message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.Status} message Status
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Status.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reports = [];
            if (message.reports && message.reports.length) {
                object.reports = [];
                for (var j = 0; j < message.reports.length; ++j)
                    object.reports[j] = $root.RemoteFortressReader.Report.toObject(message.reports[j], options);
            }
            return object;
        };

        /**
         * Converts this Status to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Status
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Status.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Status;
    })();

    RemoteFortressReader.ShapeDescriptior = (function() {

        /**
         * Properties of a ShapeDescriptior.
         * @memberof RemoteFortressReader
         * @interface IShapeDescriptior
         * @property {string|null} [id] ShapeDescriptior id
         * @property {number|null} [tile] ShapeDescriptior tile
         */

        /**
         * Constructs a new ShapeDescriptior.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ShapeDescriptior.
         * @implements IShapeDescriptior
         * @constructor
         * @param {RemoteFortressReader.IShapeDescriptior=} [properties] Properties to set
         */
        function ShapeDescriptior(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShapeDescriptior id.
         * @member {string} id
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @instance
         */
        ShapeDescriptior.prototype.id = "";

        /**
         * ShapeDescriptior tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @instance
         */
        ShapeDescriptior.prototype.tile = 0;

        /**
         * Creates a new ShapeDescriptior instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.IShapeDescriptior=} [properties] Properties to set
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior instance
         */
        ShapeDescriptior.create = function create(properties) {
            return new ShapeDescriptior(properties);
        };

        /**
         * Encodes the specified ShapeDescriptior message. Does not implicitly {@link RemoteFortressReader.ShapeDescriptior.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.IShapeDescriptior} message ShapeDescriptior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShapeDescriptior.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.tile != null && message.hasOwnProperty("tile"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tile);
            return writer;
        };

        /**
         * Encodes the specified ShapeDescriptior message, length delimited. Does not implicitly {@link RemoteFortressReader.ShapeDescriptior.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.IShapeDescriptior} message ShapeDescriptior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShapeDescriptior.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShapeDescriptior message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShapeDescriptior.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ShapeDescriptior();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.tile = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShapeDescriptior message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShapeDescriptior.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShapeDescriptior message.
         * @function verify
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShapeDescriptior.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            return null;
        };

        /**
         * Creates a ShapeDescriptior message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior
         */
        ShapeDescriptior.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ShapeDescriptior)
                return object;
            var message = new $root.RemoteFortressReader.ShapeDescriptior();
            if (object.id != null)
                message.id = String(object.id);
            if (object.tile != null)
                message.tile = object.tile | 0;
            return message;
        };

        /**
         * Creates a plain object from a ShapeDescriptior message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.ShapeDescriptior} message ShapeDescriptior
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShapeDescriptior.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.tile = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            return object;
        };

        /**
         * Converts this ShapeDescriptior to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShapeDescriptior.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShapeDescriptior;
    })();

    RemoteFortressReader.Language = (function() {

        /**
         * Properties of a Language.
         * @memberof RemoteFortressReader
         * @interface ILanguage
         * @property {Array.<RemoteFortressReader.IShapeDescriptior>|null} [shapes] Language shapes
         */

        /**
         * Constructs a new Language.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Language.
         * @implements ILanguage
         * @constructor
         * @param {RemoteFortressReader.ILanguage=} [properties] Properties to set
         */
        function Language(properties) {
            this.shapes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Language shapes.
         * @member {Array.<RemoteFortressReader.IShapeDescriptior>} shapes
         * @memberof RemoteFortressReader.Language
         * @instance
         */
        Language.prototype.shapes = $util.emptyArray;

        /**
         * Creates a new Language instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.ILanguage=} [properties] Properties to set
         * @returns {RemoteFortressReader.Language} Language instance
         */
        Language.create = function create(properties) {
            return new Language(properties);
        };

        /**
         * Encodes the specified Language message. Does not implicitly {@link RemoteFortressReader.Language.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.ILanguage} message Language message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Language.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shapes != null && message.shapes.length)
                for (var i = 0; i < message.shapes.length; ++i)
                    $root.RemoteFortressReader.ShapeDescriptior.encode(message.shapes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Language message, length delimited. Does not implicitly {@link RemoteFortressReader.Language.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.ILanguage} message Language message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Language.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Language message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Language} Language
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Language.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Language();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.shapes && message.shapes.length))
                        message.shapes = [];
                    message.shapes.push($root.RemoteFortressReader.ShapeDescriptior.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Language message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Language} Language
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Language.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Language message.
         * @function verify
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Language.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shapes != null && message.hasOwnProperty("shapes")) {
                if (!Array.isArray(message.shapes))
                    return "shapes: array expected";
                for (var i = 0; i < message.shapes.length; ++i) {
                    var error = $root.RemoteFortressReader.ShapeDescriptior.verify(message.shapes[i]);
                    if (error)
                        return "shapes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Language message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Language} Language
         */
        Language.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Language)
                return object;
            var message = new $root.RemoteFortressReader.Language();
            if (object.shapes) {
                if (!Array.isArray(object.shapes))
                    throw TypeError(".RemoteFortressReader.Language.shapes: array expected");
                message.shapes = [];
                for (var i = 0; i < object.shapes.length; ++i) {
                    if (typeof object.shapes[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Language.shapes: object expected");
                    message.shapes[i] = $root.RemoteFortressReader.ShapeDescriptior.fromObject(object.shapes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Language message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.Language} message Language
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Language.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shapes = [];
            if (message.shapes && message.shapes.length) {
                object.shapes = [];
                for (var j = 0; j < message.shapes.length; ++j)
                    object.shapes[j] = $root.RemoteFortressReader.ShapeDescriptior.toObject(message.shapes[j], options);
            }
            return object;
        };

        /**
         * Converts this Language to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Language
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Language.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Language;
    })();

    /**
     * ImprovementType enum.
     * @name RemoteFortressReader.ImprovementType
     * @enum {string}
     * @property {number} ART_IMAGE=0 ART_IMAGE value
     * @property {number} COVERED=1 COVERED value
     * @property {number} RINGS_HANGING=2 RINGS_HANGING value
     * @property {number} BANDS=3 BANDS value
     * @property {number} SPIKES=4 SPIKES value
     * @property {number} ITEMSPECIFIC=5 ITEMSPECIFIC value
     * @property {number} THREAD=6 THREAD value
     * @property {number} CLOTH=7 CLOTH value
     * @property {number} SEWN_IMAGE=8 SEWN_IMAGE value
     * @property {number} PAGES=9 PAGES value
     * @property {number} ILLUSTRATION=10 ILLUSTRATION value
     * @property {number} INSTRUMENT_PIECE=11 INSTRUMENT_PIECE value
     * @property {number} WRITING=12 WRITING value
     */
    RemoteFortressReader.ImprovementType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ART_IMAGE"] = 0;
        values[valuesById[1] = "COVERED"] = 1;
        values[valuesById[2] = "RINGS_HANGING"] = 2;
        values[valuesById[3] = "BANDS"] = 3;
        values[valuesById[4] = "SPIKES"] = 4;
        values[valuesById[5] = "ITEMSPECIFIC"] = 5;
        values[valuesById[6] = "THREAD"] = 6;
        values[valuesById[7] = "CLOTH"] = 7;
        values[valuesById[8] = "SEWN_IMAGE"] = 8;
        values[valuesById[9] = "PAGES"] = 9;
        values[valuesById[10] = "ILLUSTRATION"] = 10;
        values[valuesById[11] = "INSTRUMENT_PIECE"] = 11;
        values[valuesById[12] = "WRITING"] = 12;
        return values;
    })();

    RemoteFortressReader.ItemImprovement = (function() {

        /**
         * Properties of an ItemImprovement.
         * @memberof RemoteFortressReader
         * @interface IItemImprovement
         * @property {RemoteFortressReader.IMatPair|null} [material] ItemImprovement material
         * @property {RemoteFortressReader.ImprovementType|null} [type] ItemImprovement type
         * @property {number|null} [shape] ItemImprovement shape
         * @property {number|null} [specificType] ItemImprovement specificType
         * @property {RemoteFortressReader.IArtImage|null} [image] ItemImprovement image
         */

        /**
         * Constructs a new ItemImprovement.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ItemImprovement.
         * @implements IItemImprovement
         * @constructor
         * @param {RemoteFortressReader.IItemImprovement=} [properties] Properties to set
         */
        function ItemImprovement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemImprovement material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.material = null;

        /**
         * ItemImprovement type.
         * @member {RemoteFortressReader.ImprovementType} type
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.type = 0;

        /**
         * ItemImprovement shape.
         * @member {number} shape
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.shape = 0;

        /**
         * ItemImprovement specificType.
         * @member {number} specificType
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.specificType = 0;

        /**
         * ItemImprovement image.
         * @member {RemoteFortressReader.IArtImage|null|undefined} image
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.image = null;

        /**
         * Creates a new ItemImprovement instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.IItemImprovement=} [properties] Properties to set
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement instance
         */
        ItemImprovement.create = function create(properties) {
            return new ItemImprovement(properties);
        };

        /**
         * Encodes the specified ItemImprovement message. Does not implicitly {@link RemoteFortressReader.ItemImprovement.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.IItemImprovement} message ItemImprovement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemImprovement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.shape != null && message.hasOwnProperty("shape"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.shape);
            if (message.specificType != null && message.hasOwnProperty("specificType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.specificType);
            if (message.image != null && message.hasOwnProperty("image"))
                $root.RemoteFortressReader.ArtImage.encode(message.image, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ItemImprovement message, length delimited. Does not implicitly {@link RemoteFortressReader.ItemImprovement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.IItemImprovement} message ItemImprovement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemImprovement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemImprovement message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemImprovement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ItemImprovement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.shape = reader.int32();
                    break;
                case 4:
                    message.specificType = reader.int32();
                    break;
                case 5:
                    message.image = $root.RemoteFortressReader.ArtImage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemImprovement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemImprovement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemImprovement message.
         * @function verify
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemImprovement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.shape != null && message.hasOwnProperty("shape"))
                if (!$util.isInteger(message.shape))
                    return "shape: integer expected";
            if (message.specificType != null && message.hasOwnProperty("specificType"))
                if (!$util.isInteger(message.specificType))
                    return "specificType: integer expected";
            if (message.image != null && message.hasOwnProperty("image")) {
                var error = $root.RemoteFortressReader.ArtImage.verify(message.image);
                if (error)
                    return "image." + error;
            }
            return null;
        };

        /**
         * Creates an ItemImprovement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement
         */
        ItemImprovement.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ItemImprovement)
                return object;
            var message = new $root.RemoteFortressReader.ItemImprovement();
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.ItemImprovement.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            switch (object.type) {
            case "ART_IMAGE":
            case 0:
                message.type = 0;
                break;
            case "COVERED":
            case 1:
                message.type = 1;
                break;
            case "RINGS_HANGING":
            case 2:
                message.type = 2;
                break;
            case "BANDS":
            case 3:
                message.type = 3;
                break;
            case "SPIKES":
            case 4:
                message.type = 4;
                break;
            case "ITEMSPECIFIC":
            case 5:
                message.type = 5;
                break;
            case "THREAD":
            case 6:
                message.type = 6;
                break;
            case "CLOTH":
            case 7:
                message.type = 7;
                break;
            case "SEWN_IMAGE":
            case 8:
                message.type = 8;
                break;
            case "PAGES":
            case 9:
                message.type = 9;
                break;
            case "ILLUSTRATION":
            case 10:
                message.type = 10;
                break;
            case "INSTRUMENT_PIECE":
            case 11:
                message.type = 11;
                break;
            case "WRITING":
            case 12:
                message.type = 12;
                break;
            }
            if (object.shape != null)
                message.shape = object.shape | 0;
            if (object.specificType != null)
                message.specificType = object.specificType | 0;
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".RemoteFortressReader.ItemImprovement.image: object expected");
                message.image = $root.RemoteFortressReader.ArtImage.fromObject(object.image);
            }
            return message;
        };

        /**
         * Creates a plain object from an ItemImprovement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.ItemImprovement} message ItemImprovement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemImprovement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.material = null;
                object.type = options.enums === String ? "ART_IMAGE" : 0;
                object.shape = 0;
                object.specificType = 0;
                object.image = null;
            }
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.ImprovementType[message.type] : message.type;
            if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = message.shape;
            if (message.specificType != null && message.hasOwnProperty("specificType"))
                object.specificType = message.specificType;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.RemoteFortressReader.ArtImage.toObject(message.image, options);
            return object;
        };

        /**
         * Converts this ItemImprovement to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemImprovement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemImprovement;
    })();

    /**
     * ArtImageElementType enum.
     * @name RemoteFortressReader.ArtImageElementType
     * @enum {string}
     * @property {number} IMAGE_CREATURE=0 IMAGE_CREATURE value
     * @property {number} IMAGE_PLANT=1 IMAGE_PLANT value
     * @property {number} IMAGE_TREE=2 IMAGE_TREE value
     * @property {number} IMAGE_SHAPE=3 IMAGE_SHAPE value
     * @property {number} IMAGE_ITEM=4 IMAGE_ITEM value
     */
    RemoteFortressReader.ArtImageElementType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IMAGE_CREATURE"] = 0;
        values[valuesById[1] = "IMAGE_PLANT"] = 1;
        values[valuesById[2] = "IMAGE_TREE"] = 2;
        values[valuesById[3] = "IMAGE_SHAPE"] = 3;
        values[valuesById[4] = "IMAGE_ITEM"] = 4;
        return values;
    })();

    RemoteFortressReader.ArtImageElement = (function() {

        /**
         * Properties of an ArtImageElement.
         * @memberof RemoteFortressReader
         * @interface IArtImageElement
         * @property {number|null} [count] ArtImageElement count
         * @property {RemoteFortressReader.ArtImageElementType|null} [type] ArtImageElement type
         * @property {RemoteFortressReader.IMatPair|null} [creatureItem] ArtImageElement creatureItem
         * @property {RemoteFortressReader.IMatPair|null} [material] ArtImageElement material
         * @property {number|null} [id] ArtImageElement id
         */

        /**
         * Constructs a new ArtImageElement.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArtImageElement.
         * @implements IArtImageElement
         * @constructor
         * @param {RemoteFortressReader.IArtImageElement=} [properties] Properties to set
         */
        function ArtImageElement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtImageElement count.
         * @member {number} count
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.count = 0;

        /**
         * ArtImageElement type.
         * @member {RemoteFortressReader.ArtImageElementType} type
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.type = 0;

        /**
         * ArtImageElement creatureItem.
         * @member {RemoteFortressReader.IMatPair|null|undefined} creatureItem
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.creatureItem = null;

        /**
         * ArtImageElement material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.material = null;

        /**
         * ArtImageElement id.
         * @member {number} id
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.id = 0;

        /**
         * Creates a new ArtImageElement instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.IArtImageElement=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement instance
         */
        ArtImageElement.create = function create(properties) {
            return new ArtImageElement(properties);
        };

        /**
         * Encodes the specified ArtImageElement message. Does not implicitly {@link RemoteFortressReader.ArtImageElement.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.IArtImageElement} message ArtImageElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.creatureItem != null && message.hasOwnProperty("creatureItem"))
                $root.RemoteFortressReader.MatPair.encode(message.creatureItem, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified ArtImageElement message, length delimited. Does not implicitly {@link RemoteFortressReader.ArtImageElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.IArtImageElement} message ArtImageElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtImageElement message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArtImageElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.creatureItem = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtImageElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtImageElement message.
         * @function verify
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtImageElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.creatureItem != null && message.hasOwnProperty("creatureItem")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.creatureItem);
                if (error)
                    return "creatureItem." + error;
            }
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates an ArtImageElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement
         */
        ArtImageElement.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArtImageElement)
                return object;
            var message = new $root.RemoteFortressReader.ArtImageElement();
            if (object.count != null)
                message.count = object.count | 0;
            switch (object.type) {
            case "IMAGE_CREATURE":
            case 0:
                message.type = 0;
                break;
            case "IMAGE_PLANT":
            case 1:
                message.type = 1;
                break;
            case "IMAGE_TREE":
            case 2:
                message.type = 2;
                break;
            case "IMAGE_SHAPE":
            case 3:
                message.type = 3;
                break;
            case "IMAGE_ITEM":
            case 4:
                message.type = 4;
                break;
            }
            if (object.creatureItem != null) {
                if (typeof object.creatureItem !== "object")
                    throw TypeError(".RemoteFortressReader.ArtImageElement.creatureItem: object expected");
                message.creatureItem = $root.RemoteFortressReader.MatPair.fromObject(object.creatureItem);
            }
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.ArtImageElement.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from an ArtImageElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.ArtImageElement} message ArtImageElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtImageElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.count = 0;
                object.type = options.enums === String ? "IMAGE_CREATURE" : 0;
                object.creatureItem = null;
                object.material = null;
                object.id = 0;
            }
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.ArtImageElementType[message.type] : message.type;
            if (message.creatureItem != null && message.hasOwnProperty("creatureItem"))
                object.creatureItem = $root.RemoteFortressReader.MatPair.toObject(message.creatureItem, options);
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ArtImageElement to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtImageElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtImageElement;
    })();

    /**
     * ArtImagePropertyType enum.
     * @name RemoteFortressReader.ArtImagePropertyType
     * @enum {string}
     * @property {number} TRANSITIVE_VERB=0 TRANSITIVE_VERB value
     * @property {number} INTRANSITIVE_VERB=1 INTRANSITIVE_VERB value
     */
    RemoteFortressReader.ArtImagePropertyType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TRANSITIVE_VERB"] = 0;
        values[valuesById[1] = "INTRANSITIVE_VERB"] = 1;
        return values;
    })();

    RemoteFortressReader.ArtImageProperty = (function() {

        /**
         * Properties of an ArtImageProperty.
         * @memberof RemoteFortressReader
         * @interface IArtImageProperty
         * @property {number|null} [subject] ArtImageProperty subject
         * @property {number|null} [object] ArtImageProperty object
         * @property {RemoteFortressReader.ArtImageVerb|null} [verb] ArtImageProperty verb
         * @property {RemoteFortressReader.ArtImagePropertyType|null} [type] ArtImageProperty type
         */

        /**
         * Constructs a new ArtImageProperty.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArtImageProperty.
         * @implements IArtImageProperty
         * @constructor
         * @param {RemoteFortressReader.IArtImageProperty=} [properties] Properties to set
         */
        function ArtImageProperty(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtImageProperty subject.
         * @member {number} subject
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.subject = 0;

        /**
         * ArtImageProperty object.
         * @member {number} object
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.object = 0;

        /**
         * ArtImageProperty verb.
         * @member {RemoteFortressReader.ArtImageVerb} verb
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.verb = 0;

        /**
         * ArtImageProperty type.
         * @member {RemoteFortressReader.ArtImagePropertyType} type
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.type = 0;

        /**
         * Creates a new ArtImageProperty instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.IArtImageProperty=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty instance
         */
        ArtImageProperty.create = function create(properties) {
            return new ArtImageProperty(properties);
        };

        /**
         * Encodes the specified ArtImageProperty message. Does not implicitly {@link RemoteFortressReader.ArtImageProperty.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.IArtImageProperty} message ArtImageProperty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageProperty.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subject != null && message.hasOwnProperty("subject"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subject);
            if (message.object != null && message.hasOwnProperty("object"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.object);
            if (message.verb != null && message.hasOwnProperty("verb"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.verb);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ArtImageProperty message, length delimited. Does not implicitly {@link RemoteFortressReader.ArtImageProperty.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.IArtImageProperty} message ArtImageProperty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageProperty.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtImageProperty message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageProperty.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArtImageProperty();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subject = reader.int32();
                    break;
                case 2:
                    message.object = reader.int32();
                    break;
                case 3:
                    message.verb = reader.int32();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtImageProperty message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageProperty.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtImageProperty message.
         * @function verify
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtImageProperty.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subject != null && message.hasOwnProperty("subject"))
                if (!$util.isInteger(message.subject))
                    return "subject: integer expected";
            if (message.object != null && message.hasOwnProperty("object"))
                if (!$util.isInteger(message.object))
                    return "object: integer expected";
            if (message.verb != null && message.hasOwnProperty("verb"))
                switch (message.verb) {
                default:
                    return "verb: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                    break;
                }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an ArtImageProperty message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty
         */
        ArtImageProperty.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArtImageProperty)
                return object;
            var message = new $root.RemoteFortressReader.ArtImageProperty();
            if (object.subject != null)
                message.subject = object.subject | 0;
            if (object.object != null)
                message.object = object.object | 0;
            switch (object.verb) {
            case "VERB_WITHERING":
            case 0:
                message.verb = 0;
                break;
            case "VERB_SURROUNDEDBY":
            case 1:
                message.verb = 1;
                break;
            case "VERB_MASSACRING":
            case 2:
                message.verb = 2;
                break;
            case "VERB_FIGHTING":
            case 3:
                message.verb = 3;
                break;
            case "VERB_LABORING":
            case 4:
                message.verb = 4;
                break;
            case "VERB_GREETING":
            case 5:
                message.verb = 5;
                break;
            case "VERB_REFUSING":
            case 6:
                message.verb = 6;
                break;
            case "VERB_SPEAKING":
            case 7:
                message.verb = 7;
                break;
            case "VERB_EMBRACING":
            case 8:
                message.verb = 8;
                break;
            case "VERB_STRIKINGDOWN":
            case 9:
                message.verb = 9;
                break;
            case "VERB_MENACINGPOSE":
            case 10:
                message.verb = 10;
                break;
            case "VERB_TRAVELING":
            case 11:
                message.verb = 11;
                break;
            case "VERB_RAISING":
            case 12:
                message.verb = 12;
                break;
            case "VERB_HIDING":
            case 13:
                message.verb = 13;
                break;
            case "VERB_LOOKINGCONFUSED":
            case 14:
                message.verb = 14;
                break;
            case "VERB_LOOKINGTERRIFIED":
            case 15:
                message.verb = 15;
                break;
            case "VERB_DEVOURING":
            case 16:
                message.verb = 16;
                break;
            case "VERB_ADMIRING":
            case 17:
                message.verb = 17;
                break;
            case "VERB_BURNING":
            case 18:
                message.verb = 18;
                break;
            case "VERB_WEEPING":
            case 19:
                message.verb = 19;
                break;
            case "VERB_LOOKINGDEJECTED":
            case 20:
                message.verb = 20;
                break;
            case "VERB_CRINGING":
            case 21:
                message.verb = 21;
                break;
            case "VERB_SCREAMING":
            case 22:
                message.verb = 22;
                break;
            case "VERB_SUBMISSIVEGESTURE":
            case 23:
                message.verb = 23;
                break;
            case "VERB_FETALPOSITION":
            case 24:
                message.verb = 24;
                break;
            case "VERB_SMEAREDINTOSPIRAL":
            case 25:
                message.verb = 25;
                break;
            case "VERB_FALLING":
            case 26:
                message.verb = 26;
                break;
            case "VERB_DEAD":
            case 27:
                message.verb = 27;
                break;
            case "VERB_LAUGHING":
            case 28:
                message.verb = 28;
                break;
            case "VERB_LOOKINGOFFENDED":
            case 29:
                message.verb = 29;
                break;
            case "VERB_BEINGSHOT":
            case 30:
                message.verb = 30;
                break;
            case "VERB_PLAINTIVEGESTURE":
            case 31:
                message.verb = 31;
                break;
            case "VERB_MELTING":
            case 32:
                message.verb = 32;
                break;
            case "VERB_SHOOTING":
            case 33:
                message.verb = 33;
                break;
            case "VERB_TORTURING":
            case 34:
                message.verb = 34;
                break;
            case "VERB_COMMITTINGDEPRAVEDACT":
            case 35:
                message.verb = 35;
                break;
            case "VERB_PRAYING":
            case 36:
                message.verb = 36;
                break;
            case "VERB_CONTEMPLATING":
            case 37:
                message.verb = 37;
                break;
            case "VERB_COOKING":
            case 38:
                message.verb = 38;
                break;
            case "VERB_ENGRAVING":
            case 39:
                message.verb = 39;
                break;
            case "VERB_PROSTRATING":
            case 40:
                message.verb = 40;
                break;
            case "VERB_SUFFERING":
            case 41:
                message.verb = 41;
                break;
            case "VERB_BEINGIMPALED":
            case 42:
                message.verb = 42;
                break;
            case "VERB_BEINGCONTORTED":
            case 43:
                message.verb = 43;
                break;
            case "VERB_BEINGFLAYED":
            case 44:
                message.verb = 44;
                break;
            case "VERB_HANGINGFROM":
            case 45:
                message.verb = 45;
                break;
            case "VERB_BEINGMUTILATED":
            case 46:
                message.verb = 46;
                break;
            case "VERB_TRIUMPHANTPOSE":
            case 47:
                message.verb = 47;
                break;
            }
            switch (object.type) {
            case "TRANSITIVE_VERB":
            case 0:
                message.type = 0;
                break;
            case "INTRANSITIVE_VERB":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtImageProperty message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.ArtImageProperty} message ArtImageProperty
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtImageProperty.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.subject = 0;
                object.object = 0;
                object.verb = options.enums === String ? "VERB_WITHERING" : 0;
                object.type = options.enums === String ? "TRANSITIVE_VERB" : 0;
            }
            if (message.subject != null && message.hasOwnProperty("subject"))
                object.subject = message.subject;
            if (message.object != null && message.hasOwnProperty("object"))
                object.object = message.object;
            if (message.verb != null && message.hasOwnProperty("verb"))
                object.verb = options.enums === String ? $root.RemoteFortressReader.ArtImageVerb[message.verb] : message.verb;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.ArtImagePropertyType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ArtImageProperty to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtImageProperty.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtImageProperty;
    })();

    RemoteFortressReader.ArtImage = (function() {

        /**
         * Properties of an ArtImage.
         * @memberof RemoteFortressReader
         * @interface IArtImage
         * @property {Array.<RemoteFortressReader.IArtImageElement>|null} [elements] ArtImage elements
         * @property {RemoteFortressReader.IMatPair|null} [id] ArtImage id
         * @property {Array.<RemoteFortressReader.IArtImageProperty>|null} [properties] ArtImage properties
         */

        /**
         * Constructs a new ArtImage.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArtImage.
         * @implements IArtImage
         * @constructor
         * @param {RemoteFortressReader.IArtImage=} [properties] Properties to set
         */
        function ArtImage(properties) {
            this.elements = [];
            this.properties = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtImage elements.
         * @member {Array.<RemoteFortressReader.IArtImageElement>} elements
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         */
        ArtImage.prototype.elements = $util.emptyArray;

        /**
         * ArtImage id.
         * @member {RemoteFortressReader.IMatPair|null|undefined} id
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         */
        ArtImage.prototype.id = null;

        /**
         * ArtImage properties.
         * @member {Array.<RemoteFortressReader.IArtImageProperty>} properties
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         */
        ArtImage.prototype.properties = $util.emptyArray;

        /**
         * Creates a new ArtImage instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.IArtImage=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArtImage} ArtImage instance
         */
        ArtImage.create = function create(properties) {
            return new ArtImage(properties);
        };

        /**
         * Encodes the specified ArtImage message. Does not implicitly {@link RemoteFortressReader.ArtImage.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.IArtImage} message ArtImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    $root.RemoteFortressReader.ArtImageElement.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                $root.RemoteFortressReader.MatPair.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.properties != null && message.properties.length)
                for (var i = 0; i < message.properties.length; ++i)
                    $root.RemoteFortressReader.ArtImageProperty.encode(message.properties[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArtImage message, length delimited. Does not implicitly {@link RemoteFortressReader.ArtImage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.IArtImage} message ArtImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtImage message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArtImage} ArtImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArtImage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push($root.RemoteFortressReader.ArtImageElement.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.id = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.properties && message.properties.length))
                        message.properties = [];
                    message.properties.push($root.RemoteFortressReader.ArtImageProperty.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtImage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArtImage} ArtImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtImage message.
         * @function verify
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtImage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i) {
                    var error = $root.RemoteFortressReader.ArtImageElement.verify(message.elements[i]);
                    if (error)
                        return "elements." + error;
                }
            }
            if (message.id != null && message.hasOwnProperty("id")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!Array.isArray(message.properties))
                    return "properties: array expected";
                for (var i = 0; i < message.properties.length; ++i) {
                    var error = $root.RemoteFortressReader.ArtImageProperty.verify(message.properties[i]);
                    if (error)
                        return "properties." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArtImage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArtImage} ArtImage
         */
        ArtImage.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArtImage)
                return object;
            var message = new $root.RemoteFortressReader.ArtImage();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".RemoteFortressReader.ArtImage.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i) {
                    if (typeof object.elements[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ArtImage.elements: object expected");
                    message.elements[i] = $root.RemoteFortressReader.ArtImageElement.fromObject(object.elements[i]);
                }
            }
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".RemoteFortressReader.ArtImage.id: object expected");
                message.id = $root.RemoteFortressReader.MatPair.fromObject(object.id);
            }
            if (object.properties) {
                if (!Array.isArray(object.properties))
                    throw TypeError(".RemoteFortressReader.ArtImage.properties: array expected");
                message.properties = [];
                for (var i = 0; i < object.properties.length; ++i) {
                    if (typeof object.properties[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ArtImage.properties: object expected");
                    message.properties[i] = $root.RemoteFortressReader.ArtImageProperty.fromObject(object.properties[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtImage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.ArtImage} message ArtImage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtImage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.elements = [];
                object.properties = [];
            }
            if (options.defaults)
                object.id = null;
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = $root.RemoteFortressReader.ArtImageElement.toObject(message.elements[j], options);
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.RemoteFortressReader.MatPair.toObject(message.id, options);
            if (message.properties && message.properties.length) {
                object.properties = [];
                for (var j = 0; j < message.properties.length; ++j)
                    object.properties[j] = $root.RemoteFortressReader.ArtImageProperty.toObject(message.properties[j], options);
            }
            return object;
        };

        /**
         * Converts this ArtImage to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtImage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtImage;
    })();

    RemoteFortressReader.Engraving = (function() {

        /**
         * Properties of an Engraving.
         * @memberof RemoteFortressReader
         * @interface IEngraving
         * @property {RemoteFortressReader.ICoord|null} [pos] Engraving pos
         * @property {number|null} [quality] Engraving quality
         * @property {number|null} [tile] Engraving tile
         * @property {RemoteFortressReader.IArtImage|null} [image] Engraving image
         * @property {boolean|null} [floor] Engraving floor
         * @property {boolean|null} [west] Engraving west
         * @property {boolean|null} [east] Engraving east
         * @property {boolean|null} [north] Engraving north
         * @property {boolean|null} [south] Engraving south
         * @property {boolean|null} [hidden] Engraving hidden
         * @property {boolean|null} [northwest] Engraving northwest
         * @property {boolean|null} [northeast] Engraving northeast
         * @property {boolean|null} [southwest] Engraving southwest
         * @property {boolean|null} [southeast] Engraving southeast
         */

        /**
         * Constructs a new Engraving.
         * @memberof RemoteFortressReader
         * @classdesc Represents an Engraving.
         * @implements IEngraving
         * @constructor
         * @param {RemoteFortressReader.IEngraving=} [properties] Properties to set
         */
        function Engraving(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Engraving pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.pos = null;

        /**
         * Engraving quality.
         * @member {number} quality
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.quality = 0;

        /**
         * Engraving tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.tile = 0;

        /**
         * Engraving image.
         * @member {RemoteFortressReader.IArtImage|null|undefined} image
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.image = null;

        /**
         * Engraving floor.
         * @member {boolean} floor
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.floor = false;

        /**
         * Engraving west.
         * @member {boolean} west
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.west = false;

        /**
         * Engraving east.
         * @member {boolean} east
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.east = false;

        /**
         * Engraving north.
         * @member {boolean} north
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.north = false;

        /**
         * Engraving south.
         * @member {boolean} south
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.south = false;

        /**
         * Engraving hidden.
         * @member {boolean} hidden
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.hidden = false;

        /**
         * Engraving northwest.
         * @member {boolean} northwest
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.northwest = false;

        /**
         * Engraving northeast.
         * @member {boolean} northeast
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.northeast = false;

        /**
         * Engraving southwest.
         * @member {boolean} southwest
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.southwest = false;

        /**
         * Engraving southeast.
         * @member {boolean} southeast
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.southeast = false;

        /**
         * Creates a new Engraving instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.IEngraving=} [properties] Properties to set
         * @returns {RemoteFortressReader.Engraving} Engraving instance
         */
        Engraving.create = function create(properties) {
            return new Engraving(properties);
        };

        /**
         * Encodes the specified Engraving message. Does not implicitly {@link RemoteFortressReader.Engraving.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.IEngraving} message Engraving message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Engraving.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.quality != null && message.hasOwnProperty("quality"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.quality);
            if (message.tile != null && message.hasOwnProperty("tile"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tile);
            if (message.image != null && message.hasOwnProperty("image"))
                $root.RemoteFortressReader.ArtImage.encode(message.image, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.floor != null && message.hasOwnProperty("floor"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.floor);
            if (message.west != null && message.hasOwnProperty("west"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.west);
            if (message.east != null && message.hasOwnProperty("east"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.east);
            if (message.north != null && message.hasOwnProperty("north"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.north);
            if (message.south != null && message.hasOwnProperty("south"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.south);
            if (message.hidden != null && message.hasOwnProperty("hidden"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hidden);
            if (message.northwest != null && message.hasOwnProperty("northwest"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.northwest);
            if (message.northeast != null && message.hasOwnProperty("northeast"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.northeast);
            if (message.southwest != null && message.hasOwnProperty("southwest"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.southwest);
            if (message.southeast != null && message.hasOwnProperty("southeast"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.southeast);
            return writer;
        };

        /**
         * Encodes the specified Engraving message, length delimited. Does not implicitly {@link RemoteFortressReader.Engraving.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.IEngraving} message Engraving message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Engraving.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Engraving message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Engraving} Engraving
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Engraving.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Engraving();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.quality = reader.int32();
                    break;
                case 3:
                    message.tile = reader.int32();
                    break;
                case 4:
                    message.image = $root.RemoteFortressReader.ArtImage.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.floor = reader.bool();
                    break;
                case 6:
                    message.west = reader.bool();
                    break;
                case 7:
                    message.east = reader.bool();
                    break;
                case 8:
                    message.north = reader.bool();
                    break;
                case 9:
                    message.south = reader.bool();
                    break;
                case 10:
                    message.hidden = reader.bool();
                    break;
                case 11:
                    message.northwest = reader.bool();
                    break;
                case 12:
                    message.northeast = reader.bool();
                    break;
                case 13:
                    message.southwest = reader.bool();
                    break;
                case 14:
                    message.southeast = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Engraving message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Engraving} Engraving
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Engraving.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Engraving message.
         * @function verify
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Engraving.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.quality != null && message.hasOwnProperty("quality"))
                if (!$util.isInteger(message.quality))
                    return "quality: integer expected";
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            if (message.image != null && message.hasOwnProperty("image")) {
                var error = $root.RemoteFortressReader.ArtImage.verify(message.image);
                if (error)
                    return "image." + error;
            }
            if (message.floor != null && message.hasOwnProperty("floor"))
                if (typeof message.floor !== "boolean")
                    return "floor: boolean expected";
            if (message.west != null && message.hasOwnProperty("west"))
                if (typeof message.west !== "boolean")
                    return "west: boolean expected";
            if (message.east != null && message.hasOwnProperty("east"))
                if (typeof message.east !== "boolean")
                    return "east: boolean expected";
            if (message.north != null && message.hasOwnProperty("north"))
                if (typeof message.north !== "boolean")
                    return "north: boolean expected";
            if (message.south != null && message.hasOwnProperty("south"))
                if (typeof message.south !== "boolean")
                    return "south: boolean expected";
            if (message.hidden != null && message.hasOwnProperty("hidden"))
                if (typeof message.hidden !== "boolean")
                    return "hidden: boolean expected";
            if (message.northwest != null && message.hasOwnProperty("northwest"))
                if (typeof message.northwest !== "boolean")
                    return "northwest: boolean expected";
            if (message.northeast != null && message.hasOwnProperty("northeast"))
                if (typeof message.northeast !== "boolean")
                    return "northeast: boolean expected";
            if (message.southwest != null && message.hasOwnProperty("southwest"))
                if (typeof message.southwest !== "boolean")
                    return "southwest: boolean expected";
            if (message.southeast != null && message.hasOwnProperty("southeast"))
                if (typeof message.southeast !== "boolean")
                    return "southeast: boolean expected";
            return null;
        };

        /**
         * Creates an Engraving message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Engraving} Engraving
         */
        Engraving.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Engraving)
                return object;
            var message = new $root.RemoteFortressReader.Engraving();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Engraving.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.quality != null)
                message.quality = object.quality | 0;
            if (object.tile != null)
                message.tile = object.tile | 0;
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".RemoteFortressReader.Engraving.image: object expected");
                message.image = $root.RemoteFortressReader.ArtImage.fromObject(object.image);
            }
            if (object.floor != null)
                message.floor = Boolean(object.floor);
            if (object.west != null)
                message.west = Boolean(object.west);
            if (object.east != null)
                message.east = Boolean(object.east);
            if (object.north != null)
                message.north = Boolean(object.north);
            if (object.south != null)
                message.south = Boolean(object.south);
            if (object.hidden != null)
                message.hidden = Boolean(object.hidden);
            if (object.northwest != null)
                message.northwest = Boolean(object.northwest);
            if (object.northeast != null)
                message.northeast = Boolean(object.northeast);
            if (object.southwest != null)
                message.southwest = Boolean(object.southwest);
            if (object.southeast != null)
                message.southeast = Boolean(object.southeast);
            return message;
        };

        /**
         * Creates a plain object from an Engraving message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.Engraving} message Engraving
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Engraving.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.quality = 0;
                object.tile = 0;
                object.image = null;
                object.floor = false;
                object.west = false;
                object.east = false;
                object.north = false;
                object.south = false;
                object.hidden = false;
                object.northwest = false;
                object.northeast = false;
                object.southwest = false;
                object.southeast = false;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = message.quality;
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.RemoteFortressReader.ArtImage.toObject(message.image, options);
            if (message.floor != null && message.hasOwnProperty("floor"))
                object.floor = message.floor;
            if (message.west != null && message.hasOwnProperty("west"))
                object.west = message.west;
            if (message.east != null && message.hasOwnProperty("east"))
                object.east = message.east;
            if (message.north != null && message.hasOwnProperty("north"))
                object.north = message.north;
            if (message.south != null && message.hasOwnProperty("south"))
                object.south = message.south;
            if (message.hidden != null && message.hasOwnProperty("hidden"))
                object.hidden = message.hidden;
            if (message.northwest != null && message.hasOwnProperty("northwest"))
                object.northwest = message.northwest;
            if (message.northeast != null && message.hasOwnProperty("northeast"))
                object.northeast = message.northeast;
            if (message.southwest != null && message.hasOwnProperty("southwest"))
                object.southwest = message.southwest;
            if (message.southeast != null && message.hasOwnProperty("southeast"))
                object.southeast = message.southeast;
            return object;
        };

        /**
         * Converts this Engraving to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Engraving
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Engraving.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Engraving;
    })();

    /**
     * ArtImageVerb enum.
     * @name RemoteFortressReader.ArtImageVerb
     * @enum {string}
     * @property {number} VERB_WITHERING=0 VERB_WITHERING value
     * @property {number} VERB_SURROUNDEDBY=1 VERB_SURROUNDEDBY value
     * @property {number} VERB_MASSACRING=2 VERB_MASSACRING value
     * @property {number} VERB_FIGHTING=3 VERB_FIGHTING value
     * @property {number} VERB_LABORING=4 VERB_LABORING value
     * @property {number} VERB_GREETING=5 VERB_GREETING value
     * @property {number} VERB_REFUSING=6 VERB_REFUSING value
     * @property {number} VERB_SPEAKING=7 VERB_SPEAKING value
     * @property {number} VERB_EMBRACING=8 VERB_EMBRACING value
     * @property {number} VERB_STRIKINGDOWN=9 VERB_STRIKINGDOWN value
     * @property {number} VERB_MENACINGPOSE=10 VERB_MENACINGPOSE value
     * @property {number} VERB_TRAVELING=11 VERB_TRAVELING value
     * @property {number} VERB_RAISING=12 VERB_RAISING value
     * @property {number} VERB_HIDING=13 VERB_HIDING value
     * @property {number} VERB_LOOKINGCONFUSED=14 VERB_LOOKINGCONFUSED value
     * @property {number} VERB_LOOKINGTERRIFIED=15 VERB_LOOKINGTERRIFIED value
     * @property {number} VERB_DEVOURING=16 VERB_DEVOURING value
     * @property {number} VERB_ADMIRING=17 VERB_ADMIRING value
     * @property {number} VERB_BURNING=18 VERB_BURNING value
     * @property {number} VERB_WEEPING=19 VERB_WEEPING value
     * @property {number} VERB_LOOKINGDEJECTED=20 VERB_LOOKINGDEJECTED value
     * @property {number} VERB_CRINGING=21 VERB_CRINGING value
     * @property {number} VERB_SCREAMING=22 VERB_SCREAMING value
     * @property {number} VERB_SUBMISSIVEGESTURE=23 VERB_SUBMISSIVEGESTURE value
     * @property {number} VERB_FETALPOSITION=24 VERB_FETALPOSITION value
     * @property {number} VERB_SMEAREDINTOSPIRAL=25 VERB_SMEAREDINTOSPIRAL value
     * @property {number} VERB_FALLING=26 VERB_FALLING value
     * @property {number} VERB_DEAD=27 VERB_DEAD value
     * @property {number} VERB_LAUGHING=28 VERB_LAUGHING value
     * @property {number} VERB_LOOKINGOFFENDED=29 VERB_LOOKINGOFFENDED value
     * @property {number} VERB_BEINGSHOT=30 VERB_BEINGSHOT value
     * @property {number} VERB_PLAINTIVEGESTURE=31 VERB_PLAINTIVEGESTURE value
     * @property {number} VERB_MELTING=32 VERB_MELTING value
     * @property {number} VERB_SHOOTING=33 VERB_SHOOTING value
     * @property {number} VERB_TORTURING=34 VERB_TORTURING value
     * @property {number} VERB_COMMITTINGDEPRAVEDACT=35 VERB_COMMITTINGDEPRAVEDACT value
     * @property {number} VERB_PRAYING=36 VERB_PRAYING value
     * @property {number} VERB_CONTEMPLATING=37 VERB_CONTEMPLATING value
     * @property {number} VERB_COOKING=38 VERB_COOKING value
     * @property {number} VERB_ENGRAVING=39 VERB_ENGRAVING value
     * @property {number} VERB_PROSTRATING=40 VERB_PROSTRATING value
     * @property {number} VERB_SUFFERING=41 VERB_SUFFERING value
     * @property {number} VERB_BEINGIMPALED=42 VERB_BEINGIMPALED value
     * @property {number} VERB_BEINGCONTORTED=43 VERB_BEINGCONTORTED value
     * @property {number} VERB_BEINGFLAYED=44 VERB_BEINGFLAYED value
     * @property {number} VERB_HANGINGFROM=45 VERB_HANGINGFROM value
     * @property {number} VERB_BEINGMUTILATED=46 VERB_BEINGMUTILATED value
     * @property {number} VERB_TRIUMPHANTPOSE=47 VERB_TRIUMPHANTPOSE value
     */
    RemoteFortressReader.ArtImageVerb = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VERB_WITHERING"] = 0;
        values[valuesById[1] = "VERB_SURROUNDEDBY"] = 1;
        values[valuesById[2] = "VERB_MASSACRING"] = 2;
        values[valuesById[3] = "VERB_FIGHTING"] = 3;
        values[valuesById[4] = "VERB_LABORING"] = 4;
        values[valuesById[5] = "VERB_GREETING"] = 5;
        values[valuesById[6] = "VERB_REFUSING"] = 6;
        values[valuesById[7] = "VERB_SPEAKING"] = 7;
        values[valuesById[8] = "VERB_EMBRACING"] = 8;
        values[valuesById[9] = "VERB_STRIKINGDOWN"] = 9;
        values[valuesById[10] = "VERB_MENACINGPOSE"] = 10;
        values[valuesById[11] = "VERB_TRAVELING"] = 11;
        values[valuesById[12] = "VERB_RAISING"] = 12;
        values[valuesById[13] = "VERB_HIDING"] = 13;
        values[valuesById[14] = "VERB_LOOKINGCONFUSED"] = 14;
        values[valuesById[15] = "VERB_LOOKINGTERRIFIED"] = 15;
        values[valuesById[16] = "VERB_DEVOURING"] = 16;
        values[valuesById[17] = "VERB_ADMIRING"] = 17;
        values[valuesById[18] = "VERB_BURNING"] = 18;
        values[valuesById[19] = "VERB_WEEPING"] = 19;
        values[valuesById[20] = "VERB_LOOKINGDEJECTED"] = 20;
        values[valuesById[21] = "VERB_CRINGING"] = 21;
        values[valuesById[22] = "VERB_SCREAMING"] = 22;
        values[valuesById[23] = "VERB_SUBMISSIVEGESTURE"] = 23;
        values[valuesById[24] = "VERB_FETALPOSITION"] = 24;
        values[valuesById[25] = "VERB_SMEAREDINTOSPIRAL"] = 25;
        values[valuesById[26] = "VERB_FALLING"] = 26;
        values[valuesById[27] = "VERB_DEAD"] = 27;
        values[valuesById[28] = "VERB_LAUGHING"] = 28;
        values[valuesById[29] = "VERB_LOOKINGOFFENDED"] = 29;
        values[valuesById[30] = "VERB_BEINGSHOT"] = 30;
        values[valuesById[31] = "VERB_PLAINTIVEGESTURE"] = 31;
        values[valuesById[32] = "VERB_MELTING"] = 32;
        values[valuesById[33] = "VERB_SHOOTING"] = 33;
        values[valuesById[34] = "VERB_TORTURING"] = 34;
        values[valuesById[35] = "VERB_COMMITTINGDEPRAVEDACT"] = 35;
        values[valuesById[36] = "VERB_PRAYING"] = 36;
        values[valuesById[37] = "VERB_CONTEMPLATING"] = 37;
        values[valuesById[38] = "VERB_COOKING"] = 38;
        values[valuesById[39] = "VERB_ENGRAVING"] = 39;
        values[valuesById[40] = "VERB_PROSTRATING"] = 40;
        values[valuesById[41] = "VERB_SUFFERING"] = 41;
        values[valuesById[42] = "VERB_BEINGIMPALED"] = 42;
        values[valuesById[43] = "VERB_BEINGCONTORTED"] = 43;
        values[valuesById[44] = "VERB_BEINGFLAYED"] = 44;
        values[valuesById[45] = "VERB_HANGINGFROM"] = 45;
        values[valuesById[46] = "VERB_BEINGMUTILATED"] = 46;
        values[valuesById[47] = "VERB_TRIUMPHANTPOSE"] = 47;
        return values;
    })();

    /**
     * FlowType enum.
     * @name RemoteFortressReader.FlowType
     * @enum {string}
     * @property {number} Miasma=0 Miasma value
     * @property {number} Steam=1 Steam value
     * @property {number} Mist=2 Mist value
     * @property {number} MaterialDust=3 MaterialDust value
     * @property {number} MagmaMist=4 MagmaMist value
     * @property {number} Smoke=5 Smoke value
     * @property {number} Dragonfire=6 Dragonfire value
     * @property {number} Fire=7 Fire value
     * @property {number} Web=8 Web value
     * @property {number} MaterialGas=9 MaterialGas value
     * @property {number} MaterialVapor=10 MaterialVapor value
     * @property {number} OceanWave=11 OceanWave value
     * @property {number} SeaFoam=12 SeaFoam value
     * @property {number} ItemCloud=13 ItemCloud value
     * @property {number} CampFire=-1 CampFire value
     */
    RemoteFortressReader.FlowType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Miasma"] = 0;
        values[valuesById[1] = "Steam"] = 1;
        values[valuesById[2] = "Mist"] = 2;
        values[valuesById[3] = "MaterialDust"] = 3;
        values[valuesById[4] = "MagmaMist"] = 4;
        values[valuesById[5] = "Smoke"] = 5;
        values[valuesById[6] = "Dragonfire"] = 6;
        values[valuesById[7] = "Fire"] = 7;
        values[valuesById[8] = "Web"] = 8;
        values[valuesById[9] = "MaterialGas"] = 9;
        values[valuesById[10] = "MaterialVapor"] = 10;
        values[valuesById[11] = "OceanWave"] = 11;
        values[valuesById[12] = "SeaFoam"] = 12;
        values[valuesById[13] = "ItemCloud"] = 13;
        values[valuesById[-1] = "CampFire"] = -1;
        return values;
    })();

    RemoteFortressReader.FlowInfo = (function() {

        /**
         * Properties of a FlowInfo.
         * @memberof RemoteFortressReader
         * @interface IFlowInfo
         * @property {number|null} [index] FlowInfo index
         * @property {RemoteFortressReader.FlowType|null} [type] FlowInfo type
         * @property {number|null} [density] FlowInfo density
         * @property {RemoteFortressReader.ICoord|null} [pos] FlowInfo pos
         * @property {RemoteFortressReader.ICoord|null} [dest] FlowInfo dest
         * @property {boolean|null} [expanding] FlowInfo expanding
         * @property {boolean|null} [reuse] FlowInfo reuse
         * @property {number|null} [guideId] FlowInfo guideId
         * @property {RemoteFortressReader.IMatPair|null} [material] FlowInfo material
         * @property {RemoteFortressReader.IMatPair|null} [item] FlowInfo item
         */

        /**
         * Constructs a new FlowInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a FlowInfo.
         * @implements IFlowInfo
         * @constructor
         * @param {RemoteFortressReader.IFlowInfo=} [properties] Properties to set
         */
        function FlowInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FlowInfo index.
         * @member {number} index
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.index = 0;

        /**
         * FlowInfo type.
         * @member {RemoteFortressReader.FlowType} type
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.type = 0;

        /**
         * FlowInfo density.
         * @member {number} density
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.density = 0;

        /**
         * FlowInfo pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.pos = null;

        /**
         * FlowInfo dest.
         * @member {RemoteFortressReader.ICoord|null|undefined} dest
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.dest = null;

        /**
         * FlowInfo expanding.
         * @member {boolean} expanding
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.expanding = false;

        /**
         * FlowInfo reuse.
         * @member {boolean} reuse
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.reuse = false;

        /**
         * FlowInfo guideId.
         * @member {number} guideId
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.guideId = 0;

        /**
         * FlowInfo material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.material = null;

        /**
         * FlowInfo item.
         * @member {RemoteFortressReader.IMatPair|null|undefined} item
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.item = null;

        /**
         * Creates a new FlowInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.IFlowInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo instance
         */
        FlowInfo.create = function create(properties) {
            return new FlowInfo(properties);
        };

        /**
         * Encodes the specified FlowInfo message. Does not implicitly {@link RemoteFortressReader.FlowInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.IFlowInfo} message FlowInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.density != null && message.hasOwnProperty("density"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.density);
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.dest != null && message.hasOwnProperty("dest"))
                $root.RemoteFortressReader.Coord.encode(message.dest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.expanding != null && message.hasOwnProperty("expanding"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.expanding);
            if (message.reuse != null && message.hasOwnProperty("reuse"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.reuse);
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.guideId);
            if (message.material != null && message.hasOwnProperty("material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.item != null && message.hasOwnProperty("item"))
                $root.RemoteFortressReader.MatPair.encode(message.item, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FlowInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.FlowInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.IFlowInfo} message FlowInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FlowInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.FlowInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.density = reader.int32();
                    break;
                case 4:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.dest = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.expanding = reader.bool();
                    break;
                case 7:
                    message.reuse = reader.bool();
                    break;
                case 8:
                    message.guideId = reader.int32();
                    break;
                case 9:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.item = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FlowInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FlowInfo message.
         * @function verify
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FlowInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case -1:
                    break;
                }
            if (message.density != null && message.hasOwnProperty("density"))
                if (!$util.isInteger(message.density))
                    return "density: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.dest != null && message.hasOwnProperty("dest")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.dest);
                if (error)
                    return "dest." + error;
            }
            if (message.expanding != null && message.hasOwnProperty("expanding"))
                if (typeof message.expanding !== "boolean")
                    return "expanding: boolean expected";
            if (message.reuse != null && message.hasOwnProperty("reuse"))
                if (typeof message.reuse !== "boolean")
                    return "reuse: boolean expected";
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                if (!$util.isInteger(message.guideId))
                    return "guideId: integer expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a FlowInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo
         */
        FlowInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.FlowInfo)
                return object;
            var message = new $root.RemoteFortressReader.FlowInfo();
            if (object.index != null)
                message.index = object.index | 0;
            switch (object.type) {
            case "Miasma":
            case 0:
                message.type = 0;
                break;
            case "Steam":
            case 1:
                message.type = 1;
                break;
            case "Mist":
            case 2:
                message.type = 2;
                break;
            case "MaterialDust":
            case 3:
                message.type = 3;
                break;
            case "MagmaMist":
            case 4:
                message.type = 4;
                break;
            case "Smoke":
            case 5:
                message.type = 5;
                break;
            case "Dragonfire":
            case 6:
                message.type = 6;
                break;
            case "Fire":
            case 7:
                message.type = 7;
                break;
            case "Web":
            case 8:
                message.type = 8;
                break;
            case "MaterialGas":
            case 9:
                message.type = 9;
                break;
            case "MaterialVapor":
            case 10:
                message.type = 10;
                break;
            case "OceanWave":
            case 11:
                message.type = 11;
                break;
            case "SeaFoam":
            case 12:
                message.type = 12;
                break;
            case "ItemCloud":
            case 13:
                message.type = 13;
                break;
            case "CampFire":
            case -1:
                message.type = -1;
                break;
            }
            if (object.density != null)
                message.density = object.density | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.dest != null) {
                if (typeof object.dest !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.dest: object expected");
                message.dest = $root.RemoteFortressReader.Coord.fromObject(object.dest);
            }
            if (object.expanding != null)
                message.expanding = Boolean(object.expanding);
            if (object.reuse != null)
                message.reuse = Boolean(object.reuse);
            if (object.guideId != null)
                message.guideId = object.guideId | 0;
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.item: object expected");
                message.item = $root.RemoteFortressReader.MatPair.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a FlowInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.FlowInfo} message FlowInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FlowInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.type = options.enums === String ? "Miasma" : 0;
                object.density = 0;
                object.pos = null;
                object.dest = null;
                object.expanding = false;
                object.reuse = false;
                object.guideId = 0;
                object.material = null;
                object.item = null;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.FlowType[message.type] : message.type;
            if (message.density != null && message.hasOwnProperty("density"))
                object.density = message.density;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = $root.RemoteFortressReader.Coord.toObject(message.dest, options);
            if (message.expanding != null && message.hasOwnProperty("expanding"))
                object.expanding = message.expanding;
            if (message.reuse != null && message.hasOwnProperty("reuse"))
                object.reuse = message.reuse;
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                object.guideId = message.guideId;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.MatPair.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this FlowInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FlowInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FlowInfo;
    })();

    RemoteFortressReader.Wave = (function() {

        /**
         * Properties of a Wave.
         * @memberof RemoteFortressReader
         * @interface IWave
         * @property {RemoteFortressReader.ICoord|null} [dest] Wave dest
         * @property {RemoteFortressReader.ICoord|null} [pos] Wave pos
         */

        /**
         * Constructs a new Wave.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Wave.
         * @implements IWave
         * @constructor
         * @param {RemoteFortressReader.IWave=} [properties] Properties to set
         */
        function Wave(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Wave dest.
         * @member {RemoteFortressReader.ICoord|null|undefined} dest
         * @memberof RemoteFortressReader.Wave
         * @instance
         */
        Wave.prototype.dest = null;

        /**
         * Wave pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Wave
         * @instance
         */
        Wave.prototype.pos = null;

        /**
         * Creates a new Wave instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.IWave=} [properties] Properties to set
         * @returns {RemoteFortressReader.Wave} Wave instance
         */
        Wave.create = function create(properties) {
            return new Wave(properties);
        };

        /**
         * Encodes the specified Wave message. Does not implicitly {@link RemoteFortressReader.Wave.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.IWave} message Wave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wave.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && message.hasOwnProperty("dest"))
                $root.RemoteFortressReader.Coord.encode(message.dest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Wave message, length delimited. Does not implicitly {@link RemoteFortressReader.Wave.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.IWave} message Wave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wave.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Wave message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Wave} Wave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wave.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Wave();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dest = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Wave message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Wave} Wave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wave.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Wave message.
         * @function verify
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Wave.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.dest);
                if (error)
                    return "dest." + error;
            }
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a Wave message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Wave} Wave
         */
        Wave.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Wave)
                return object;
            var message = new $root.RemoteFortressReader.Wave();
            if (object.dest != null) {
                if (typeof object.dest !== "object")
                    throw TypeError(".RemoteFortressReader.Wave.dest: object expected");
                message.dest = $root.RemoteFortressReader.Coord.fromObject(object.dest);
            }
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Wave.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a Wave message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.Wave} message Wave
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Wave.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dest = null;
                object.pos = null;
            }
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = $root.RemoteFortressReader.Coord.toObject(message.dest, options);
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this Wave to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Wave
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Wave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Wave;
    })();

    return RemoteFortressReader;
})();

$root.ItemdefInstrument = (function() {

    /**
     * Namespace ItemdefInstrument.
     * @exports ItemdefInstrument
     * @namespace
     */
    var ItemdefInstrument = {};

    ItemdefInstrument.InstrumentFlags = (function() {

        /**
         * Properties of an InstrumentFlags.
         * @memberof ItemdefInstrument
         * @interface IInstrumentFlags
         * @property {boolean|null} [indefinitePitch] InstrumentFlags indefinitePitch
         * @property {boolean|null} [placedAsBuilding] InstrumentFlags placedAsBuilding
         * @property {boolean|null} [metalMat] InstrumentFlags metalMat
         * @property {boolean|null} [stoneMat] InstrumentFlags stoneMat
         * @property {boolean|null} [woodMat] InstrumentFlags woodMat
         * @property {boolean|null} [glassMat] InstrumentFlags glassMat
         * @property {boolean|null} [ceramicMat] InstrumentFlags ceramicMat
         * @property {boolean|null} [shellMat] InstrumentFlags shellMat
         * @property {boolean|null} [boneMat] InstrumentFlags boneMat
         */

        /**
         * Constructs a new InstrumentFlags.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentFlags.
         * @implements IInstrumentFlags
         * @constructor
         * @param {ItemdefInstrument.IInstrumentFlags=} [properties] Properties to set
         */
        function InstrumentFlags(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentFlags indefinitePitch.
         * @member {boolean} indefinitePitch
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.indefinitePitch = false;

        /**
         * InstrumentFlags placedAsBuilding.
         * @member {boolean} placedAsBuilding
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.placedAsBuilding = false;

        /**
         * InstrumentFlags metalMat.
         * @member {boolean} metalMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.metalMat = false;

        /**
         * InstrumentFlags stoneMat.
         * @member {boolean} stoneMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.stoneMat = false;

        /**
         * InstrumentFlags woodMat.
         * @member {boolean} woodMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.woodMat = false;

        /**
         * InstrumentFlags glassMat.
         * @member {boolean} glassMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.glassMat = false;

        /**
         * InstrumentFlags ceramicMat.
         * @member {boolean} ceramicMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.ceramicMat = false;

        /**
         * InstrumentFlags shellMat.
         * @member {boolean} shellMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.shellMat = false;

        /**
         * InstrumentFlags boneMat.
         * @member {boolean} boneMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.boneMat = false;

        /**
         * Creates a new InstrumentFlags instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.IInstrumentFlags=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags instance
         */
        InstrumentFlags.create = function create(properties) {
            return new InstrumentFlags(properties);
        };

        /**
         * Encodes the specified InstrumentFlags message. Does not implicitly {@link ItemdefInstrument.InstrumentFlags.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.IInstrumentFlags} message InstrumentFlags message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentFlags.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.indefinitePitch != null && message.hasOwnProperty("indefinitePitch"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.indefinitePitch);
            if (message.placedAsBuilding != null && message.hasOwnProperty("placedAsBuilding"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.placedAsBuilding);
            if (message.metalMat != null && message.hasOwnProperty("metalMat"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.metalMat);
            if (message.stoneMat != null && message.hasOwnProperty("stoneMat"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.stoneMat);
            if (message.woodMat != null && message.hasOwnProperty("woodMat"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.woodMat);
            if (message.glassMat != null && message.hasOwnProperty("glassMat"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.glassMat);
            if (message.ceramicMat != null && message.hasOwnProperty("ceramicMat"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.ceramicMat);
            if (message.shellMat != null && message.hasOwnProperty("shellMat"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.shellMat);
            if (message.boneMat != null && message.hasOwnProperty("boneMat"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.boneMat);
            return writer;
        };

        /**
         * Encodes the specified InstrumentFlags message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentFlags.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.IInstrumentFlags} message InstrumentFlags message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentFlags.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentFlags message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentFlags.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentFlags();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.indefinitePitch = reader.bool();
                    break;
                case 2:
                    message.placedAsBuilding = reader.bool();
                    break;
                case 3:
                    message.metalMat = reader.bool();
                    break;
                case 4:
                    message.stoneMat = reader.bool();
                    break;
                case 5:
                    message.woodMat = reader.bool();
                    break;
                case 6:
                    message.glassMat = reader.bool();
                    break;
                case 7:
                    message.ceramicMat = reader.bool();
                    break;
                case 8:
                    message.shellMat = reader.bool();
                    break;
                case 9:
                    message.boneMat = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentFlags message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentFlags.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentFlags message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentFlags.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.indefinitePitch != null && message.hasOwnProperty("indefinitePitch"))
                if (typeof message.indefinitePitch !== "boolean")
                    return "indefinitePitch: boolean expected";
            if (message.placedAsBuilding != null && message.hasOwnProperty("placedAsBuilding"))
                if (typeof message.placedAsBuilding !== "boolean")
                    return "placedAsBuilding: boolean expected";
            if (message.metalMat != null && message.hasOwnProperty("metalMat"))
                if (typeof message.metalMat !== "boolean")
                    return "metalMat: boolean expected";
            if (message.stoneMat != null && message.hasOwnProperty("stoneMat"))
                if (typeof message.stoneMat !== "boolean")
                    return "stoneMat: boolean expected";
            if (message.woodMat != null && message.hasOwnProperty("woodMat"))
                if (typeof message.woodMat !== "boolean")
                    return "woodMat: boolean expected";
            if (message.glassMat != null && message.hasOwnProperty("glassMat"))
                if (typeof message.glassMat !== "boolean")
                    return "glassMat: boolean expected";
            if (message.ceramicMat != null && message.hasOwnProperty("ceramicMat"))
                if (typeof message.ceramicMat !== "boolean")
                    return "ceramicMat: boolean expected";
            if (message.shellMat != null && message.hasOwnProperty("shellMat"))
                if (typeof message.shellMat !== "boolean")
                    return "shellMat: boolean expected";
            if (message.boneMat != null && message.hasOwnProperty("boneMat"))
                if (typeof message.boneMat !== "boolean")
                    return "boneMat: boolean expected";
            return null;
        };

        /**
         * Creates an InstrumentFlags message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags
         */
        InstrumentFlags.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentFlags)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentFlags();
            if (object.indefinitePitch != null)
                message.indefinitePitch = Boolean(object.indefinitePitch);
            if (object.placedAsBuilding != null)
                message.placedAsBuilding = Boolean(object.placedAsBuilding);
            if (object.metalMat != null)
                message.metalMat = Boolean(object.metalMat);
            if (object.stoneMat != null)
                message.stoneMat = Boolean(object.stoneMat);
            if (object.woodMat != null)
                message.woodMat = Boolean(object.woodMat);
            if (object.glassMat != null)
                message.glassMat = Boolean(object.glassMat);
            if (object.ceramicMat != null)
                message.ceramicMat = Boolean(object.ceramicMat);
            if (object.shellMat != null)
                message.shellMat = Boolean(object.shellMat);
            if (object.boneMat != null)
                message.boneMat = Boolean(object.boneMat);
            return message;
        };

        /**
         * Creates a plain object from an InstrumentFlags message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.InstrumentFlags} message InstrumentFlags
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentFlags.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.indefinitePitch = false;
                object.placedAsBuilding = false;
                object.metalMat = false;
                object.stoneMat = false;
                object.woodMat = false;
                object.glassMat = false;
                object.ceramicMat = false;
                object.shellMat = false;
                object.boneMat = false;
            }
            if (message.indefinitePitch != null && message.hasOwnProperty("indefinitePitch"))
                object.indefinitePitch = message.indefinitePitch;
            if (message.placedAsBuilding != null && message.hasOwnProperty("placedAsBuilding"))
                object.placedAsBuilding = message.placedAsBuilding;
            if (message.metalMat != null && message.hasOwnProperty("metalMat"))
                object.metalMat = message.metalMat;
            if (message.stoneMat != null && message.hasOwnProperty("stoneMat"))
                object.stoneMat = message.stoneMat;
            if (message.woodMat != null && message.hasOwnProperty("woodMat"))
                object.woodMat = message.woodMat;
            if (message.glassMat != null && message.hasOwnProperty("glassMat"))
                object.glassMat = message.glassMat;
            if (message.ceramicMat != null && message.hasOwnProperty("ceramicMat"))
                object.ceramicMat = message.ceramicMat;
            if (message.shellMat != null && message.hasOwnProperty("shellMat"))
                object.shellMat = message.shellMat;
            if (message.boneMat != null && message.hasOwnProperty("boneMat"))
                object.boneMat = message.boneMat;
            return object;
        };

        /**
         * Converts this InstrumentFlags to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentFlags.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentFlags;
    })();

    /**
     * PitchChoiceType enum.
     * @name ItemdefInstrument.PitchChoiceType
     * @enum {string}
     * @property {number} MEMBRANE_POSITION=0 MEMBRANE_POSITION value
     * @property {number} SUBPART_CHOICE=1 SUBPART_CHOICE value
     * @property {number} KEYBOARD=2 KEYBOARD value
     * @property {number} STOPPING_FRET=3 STOPPING_FRET value
     * @property {number} STOPPING_AGAINST_BODY=4 STOPPING_AGAINST_BODY value
     * @property {number} STOPPING_HOLE=5 STOPPING_HOLE value
     * @property {number} STOPPING_HOLE_KEY=6 STOPPING_HOLE_KEY value
     * @property {number} SLIDE=7 SLIDE value
     * @property {number} HARMONIC_SERIES=8 HARMONIC_SERIES value
     * @property {number} VALVE_ROUTES_AIR=9 VALVE_ROUTES_AIR value
     * @property {number} BP_IN_BELL=10 BP_IN_BELL value
     * @property {number} FOOT_PEDALS=11 FOOT_PEDALS value
     */
    ItemdefInstrument.PitchChoiceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MEMBRANE_POSITION"] = 0;
        values[valuesById[1] = "SUBPART_CHOICE"] = 1;
        values[valuesById[2] = "KEYBOARD"] = 2;
        values[valuesById[3] = "STOPPING_FRET"] = 3;
        values[valuesById[4] = "STOPPING_AGAINST_BODY"] = 4;
        values[valuesById[5] = "STOPPING_HOLE"] = 5;
        values[valuesById[6] = "STOPPING_HOLE_KEY"] = 6;
        values[valuesById[7] = "SLIDE"] = 7;
        values[valuesById[8] = "HARMONIC_SERIES"] = 8;
        values[valuesById[9] = "VALVE_ROUTES_AIR"] = 9;
        values[valuesById[10] = "BP_IN_BELL"] = 10;
        values[valuesById[11] = "FOOT_PEDALS"] = 11;
        return values;
    })();

    /**
     * SoundProductionType enum.
     * @name ItemdefInstrument.SoundProductionType
     * @enum {string}
     * @property {number} PLUCKED_BY_BP=0 PLUCKED_BY_BP value
     * @property {number} PLUCKED=1 PLUCKED value
     * @property {number} BOWED=2 BOWED value
     * @property {number} STRUCK_BY_BP=3 STRUCK_BY_BP value
     * @property {number} STRUCK=4 STRUCK value
     * @property {number} VIBRATE_BP_AGAINST_OPENING=5 VIBRATE_BP_AGAINST_OPENING value
     * @property {number} BLOW_AGAINST_FIPPLE=6 BLOW_AGAINST_FIPPLE value
     * @property {number} BLOW_OVER_OPENING_SIDE=7 BLOW_OVER_OPENING_SIDE value
     * @property {number} BLOW_OVER_OPENING_END=8 BLOW_OVER_OPENING_END value
     * @property {number} BLOW_OVER_SINGLE_REED=9 BLOW_OVER_SINGLE_REED value
     * @property {number} BLOW_OVER_DOUBLE_REED=10 BLOW_OVER_DOUBLE_REED value
     * @property {number} BLOW_OVER_FREE_REED=11 BLOW_OVER_FREE_REED value
     * @property {number} STRUCK_TOGETHER=12 STRUCK_TOGETHER value
     * @property {number} SHAKEN=13 SHAKEN value
     * @property {number} SCRAPED=14 SCRAPED value
     * @property {number} FRICTION=15 FRICTION value
     * @property {number} RESONATOR=16 RESONATOR value
     * @property {number} BAG_OVER_REED=17 BAG_OVER_REED value
     * @property {number} AIR_OVER_REED=18 AIR_OVER_REED value
     * @property {number} AIR_OVER_FREE_REED=19 AIR_OVER_FREE_REED value
     * @property {number} AIR_AGAINST_FIPPLE=20 AIR_AGAINST_FIPPLE value
     */
    ItemdefInstrument.SoundProductionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PLUCKED_BY_BP"] = 0;
        values[valuesById[1] = "PLUCKED"] = 1;
        values[valuesById[2] = "BOWED"] = 2;
        values[valuesById[3] = "STRUCK_BY_BP"] = 3;
        values[valuesById[4] = "STRUCK"] = 4;
        values[valuesById[5] = "VIBRATE_BP_AGAINST_OPENING"] = 5;
        values[valuesById[6] = "BLOW_AGAINST_FIPPLE"] = 6;
        values[valuesById[7] = "BLOW_OVER_OPENING_SIDE"] = 7;
        values[valuesById[8] = "BLOW_OVER_OPENING_END"] = 8;
        values[valuesById[9] = "BLOW_OVER_SINGLE_REED"] = 9;
        values[valuesById[10] = "BLOW_OVER_DOUBLE_REED"] = 10;
        values[valuesById[11] = "BLOW_OVER_FREE_REED"] = 11;
        values[valuesById[12] = "STRUCK_TOGETHER"] = 12;
        values[valuesById[13] = "SHAKEN"] = 13;
        values[valuesById[14] = "SCRAPED"] = 14;
        values[valuesById[15] = "FRICTION"] = 15;
        values[valuesById[16] = "RESONATOR"] = 16;
        values[valuesById[17] = "BAG_OVER_REED"] = 17;
        values[valuesById[18] = "AIR_OVER_REED"] = 18;
        values[valuesById[19] = "AIR_OVER_FREE_REED"] = 19;
        values[valuesById[20] = "AIR_AGAINST_FIPPLE"] = 20;
        return values;
    })();

    /**
     * TuningType enum.
     * @name ItemdefInstrument.TuningType
     * @enum {string}
     * @property {number} PEGS=0 PEGS value
     * @property {number} ADJUSTABLE_BRIDGES=1 ADJUSTABLE_BRIDGES value
     * @property {number} CROOKS=2 CROOKS value
     * @property {number} TIGHTENING=3 TIGHTENING value
     * @property {number} LEVERS=4 LEVERS value
     */
    ItemdefInstrument.TuningType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PEGS"] = 0;
        values[valuesById[1] = "ADJUSTABLE_BRIDGES"] = 1;
        values[valuesById[2] = "CROOKS"] = 2;
        values[valuesById[3] = "TIGHTENING"] = 3;
        values[valuesById[4] = "LEVERS"] = 4;
        return values;
    })();

    ItemdefInstrument.InstrumentPiece = (function() {

        /**
         * Properties of an InstrumentPiece.
         * @memberof ItemdefInstrument
         * @interface IInstrumentPiece
         * @property {string|null} [type] InstrumentPiece type
         * @property {string|null} [id] InstrumentPiece id
         * @property {string|null} [name] InstrumentPiece name
         * @property {string|null} [namePlural] InstrumentPiece namePlural
         */

        /**
         * Constructs a new InstrumentPiece.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentPiece.
         * @implements IInstrumentPiece
         * @constructor
         * @param {ItemdefInstrument.IInstrumentPiece=} [properties] Properties to set
         */
        function InstrumentPiece(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentPiece type.
         * @member {string} type
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.type = "";

        /**
         * InstrumentPiece id.
         * @member {string} id
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.id = "";

        /**
         * InstrumentPiece name.
         * @member {string} name
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.name = "";

        /**
         * InstrumentPiece namePlural.
         * @member {string} namePlural
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.namePlural = "";

        /**
         * Creates a new InstrumentPiece instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.IInstrumentPiece=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece instance
         */
        InstrumentPiece.create = function create(properties) {
            return new InstrumentPiece(properties);
        };

        /**
         * Encodes the specified InstrumentPiece message. Does not implicitly {@link ItemdefInstrument.InstrumentPiece.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.IInstrumentPiece} message InstrumentPiece message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentPiece.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.namePlural != null && message.hasOwnProperty("namePlural"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.namePlural);
            return writer;
        };

        /**
         * Encodes the specified InstrumentPiece message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentPiece.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.IInstrumentPiece} message InstrumentPiece message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentPiece.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentPiece message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentPiece.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentPiece();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.namePlural = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentPiece message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentPiece.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentPiece message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentPiece.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.namePlural != null && message.hasOwnProperty("namePlural"))
                if (!$util.isString(message.namePlural))
                    return "namePlural: string expected";
            return null;
        };

        /**
         * Creates an InstrumentPiece message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece
         */
        InstrumentPiece.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentPiece)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentPiece();
            if (object.type != null)
                message.type = String(object.type);
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.namePlural != null)
                message.namePlural = String(object.namePlural);
            return message;
        };

        /**
         * Creates a plain object from an InstrumentPiece message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.InstrumentPiece} message InstrumentPiece
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentPiece.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                object.id = "";
                object.name = "";
                object.namePlural = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.namePlural != null && message.hasOwnProperty("namePlural"))
                object.namePlural = message.namePlural;
            return object;
        };

        /**
         * Converts this InstrumentPiece to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentPiece.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentPiece;
    })();

    ItemdefInstrument.InstrumentRegister = (function() {

        /**
         * Properties of an InstrumentRegister.
         * @memberof ItemdefInstrument
         * @interface IInstrumentRegister
         * @property {number|null} [pitchRangeMin] InstrumentRegister pitchRangeMin
         * @property {number|null} [pitchRangeMax] InstrumentRegister pitchRangeMax
         */

        /**
         * Constructs a new InstrumentRegister.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentRegister.
         * @implements IInstrumentRegister
         * @constructor
         * @param {ItemdefInstrument.IInstrumentRegister=} [properties] Properties to set
         */
        function InstrumentRegister(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentRegister pitchRangeMin.
         * @member {number} pitchRangeMin
         * @memberof ItemdefInstrument.InstrumentRegister
         * @instance
         */
        InstrumentRegister.prototype.pitchRangeMin = 0;

        /**
         * InstrumentRegister pitchRangeMax.
         * @member {number} pitchRangeMax
         * @memberof ItemdefInstrument.InstrumentRegister
         * @instance
         */
        InstrumentRegister.prototype.pitchRangeMax = 0;

        /**
         * Creates a new InstrumentRegister instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.IInstrumentRegister=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister instance
         */
        InstrumentRegister.create = function create(properties) {
            return new InstrumentRegister(properties);
        };

        /**
         * Encodes the specified InstrumentRegister message. Does not implicitly {@link ItemdefInstrument.InstrumentRegister.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.IInstrumentRegister} message InstrumentRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentRegister.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pitchRangeMin);
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pitchRangeMax);
            return writer;
        };

        /**
         * Encodes the specified InstrumentRegister message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentRegister.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.IInstrumentRegister} message InstrumentRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentRegister.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentRegister message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentRegister.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentRegister();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pitchRangeMin = reader.int32();
                    break;
                case 2:
                    message.pitchRangeMax = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentRegister message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentRegister.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentRegister message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentRegister.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                if (!$util.isInteger(message.pitchRangeMin))
                    return "pitchRangeMin: integer expected";
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                if (!$util.isInteger(message.pitchRangeMax))
                    return "pitchRangeMax: integer expected";
            return null;
        };

        /**
         * Creates an InstrumentRegister message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister
         */
        InstrumentRegister.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentRegister)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentRegister();
            if (object.pitchRangeMin != null)
                message.pitchRangeMin = object.pitchRangeMin | 0;
            if (object.pitchRangeMax != null)
                message.pitchRangeMax = object.pitchRangeMax | 0;
            return message;
        };

        /**
         * Creates a plain object from an InstrumentRegister message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.InstrumentRegister} message InstrumentRegister
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentRegister.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pitchRangeMin = 0;
                object.pitchRangeMax = 0;
            }
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                object.pitchRangeMin = message.pitchRangeMin;
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                object.pitchRangeMax = message.pitchRangeMax;
            return object;
        };

        /**
         * Converts this InstrumentRegister to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentRegister
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentRegister.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentRegister;
    })();

    ItemdefInstrument.InstrumentDef = (function() {

        /**
         * Properties of an InstrumentDef.
         * @memberof ItemdefInstrument
         * @interface IInstrumentDef
         * @property {ItemdefInstrument.IInstrumentFlags|null} [flags] InstrumentDef flags
         * @property {number|null} [size] InstrumentDef size
         * @property {number|null} [value] InstrumentDef value
         * @property {number|null} [materialSize] InstrumentDef materialSize
         * @property {Array.<ItemdefInstrument.IInstrumentPiece>|null} [pieces] InstrumentDef pieces
         * @property {number|null} [pitchRangeMin] InstrumentDef pitchRangeMin
         * @property {number|null} [pitchRangeMax] InstrumentDef pitchRangeMax
         * @property {number|null} [volumeMbMin] InstrumentDef volumeMbMin
         * @property {number|null} [volumeMbMax] InstrumentDef volumeMbMax
         * @property {Array.<ItemdefInstrument.SoundProductionType>|null} [soundProduction] InstrumentDef soundProduction
         * @property {Array.<string>|null} [soundProductionParm1] InstrumentDef soundProductionParm1
         * @property {Array.<string>|null} [soundProductionParm2] InstrumentDef soundProductionParm2
         * @property {Array.<ItemdefInstrument.PitchChoiceType>|null} [pitchChoice] InstrumentDef pitchChoice
         * @property {Array.<string>|null} [pitchChoiceParm1] InstrumentDef pitchChoiceParm1
         * @property {Array.<string>|null} [pitchChoiceParm2] InstrumentDef pitchChoiceParm2
         * @property {Array.<ItemdefInstrument.TuningType>|null} [tuning] InstrumentDef tuning
         * @property {Array.<string>|null} [tuningParm] InstrumentDef tuningParm
         * @property {Array.<ItemdefInstrument.IInstrumentRegister>|null} [registers] InstrumentDef registers
         * @property {string|null} [description] InstrumentDef description
         */

        /**
         * Constructs a new InstrumentDef.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentDef.
         * @implements IInstrumentDef
         * @constructor
         * @param {ItemdefInstrument.IInstrumentDef=} [properties] Properties to set
         */
        function InstrumentDef(properties) {
            this.pieces = [];
            this.soundProduction = [];
            this.soundProductionParm1 = [];
            this.soundProductionParm2 = [];
            this.pitchChoice = [];
            this.pitchChoiceParm1 = [];
            this.pitchChoiceParm2 = [];
            this.tuning = [];
            this.tuningParm = [];
            this.registers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentDef flags.
         * @member {ItemdefInstrument.IInstrumentFlags|null|undefined} flags
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.flags = null;

        /**
         * InstrumentDef size.
         * @member {number} size
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.size = 0;

        /**
         * InstrumentDef value.
         * @member {number} value
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.value = 0;

        /**
         * InstrumentDef materialSize.
         * @member {number} materialSize
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.materialSize = 0;

        /**
         * InstrumentDef pieces.
         * @member {Array.<ItemdefInstrument.IInstrumentPiece>} pieces
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pieces = $util.emptyArray;

        /**
         * InstrumentDef pitchRangeMin.
         * @member {number} pitchRangeMin
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchRangeMin = 0;

        /**
         * InstrumentDef pitchRangeMax.
         * @member {number} pitchRangeMax
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchRangeMax = 0;

        /**
         * InstrumentDef volumeMbMin.
         * @member {number} volumeMbMin
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.volumeMbMin = 0;

        /**
         * InstrumentDef volumeMbMax.
         * @member {number} volumeMbMax
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.volumeMbMax = 0;

        /**
         * InstrumentDef soundProduction.
         * @member {Array.<ItemdefInstrument.SoundProductionType>} soundProduction
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.soundProduction = $util.emptyArray;

        /**
         * InstrumentDef soundProductionParm1.
         * @member {Array.<string>} soundProductionParm1
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.soundProductionParm1 = $util.emptyArray;

        /**
         * InstrumentDef soundProductionParm2.
         * @member {Array.<string>} soundProductionParm2
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.soundProductionParm2 = $util.emptyArray;

        /**
         * InstrumentDef pitchChoice.
         * @member {Array.<ItemdefInstrument.PitchChoiceType>} pitchChoice
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchChoice = $util.emptyArray;

        /**
         * InstrumentDef pitchChoiceParm1.
         * @member {Array.<string>} pitchChoiceParm1
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchChoiceParm1 = $util.emptyArray;

        /**
         * InstrumentDef pitchChoiceParm2.
         * @member {Array.<string>} pitchChoiceParm2
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchChoiceParm2 = $util.emptyArray;

        /**
         * InstrumentDef tuning.
         * @member {Array.<ItemdefInstrument.TuningType>} tuning
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.tuning = $util.emptyArray;

        /**
         * InstrumentDef tuningParm.
         * @member {Array.<string>} tuningParm
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.tuningParm = $util.emptyArray;

        /**
         * InstrumentDef registers.
         * @member {Array.<ItemdefInstrument.IInstrumentRegister>} registers
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.registers = $util.emptyArray;

        /**
         * InstrumentDef description.
         * @member {string} description
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.description = "";

        /**
         * Creates a new InstrumentDef instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.IInstrumentDef=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef instance
         */
        InstrumentDef.create = function create(properties) {
            return new InstrumentDef(properties);
        };

        /**
         * Encodes the specified InstrumentDef message. Does not implicitly {@link ItemdefInstrument.InstrumentDef.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.IInstrumentDef} message InstrumentDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flags != null && message.hasOwnProperty("flags"))
                $root.ItemdefInstrument.InstrumentFlags.encode(message.flags, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.size != null && message.hasOwnProperty("size"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.value);
            if (message.materialSize != null && message.hasOwnProperty("materialSize"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.materialSize);
            if (message.pieces != null && message.pieces.length)
                for (var i = 0; i < message.pieces.length; ++i)
                    $root.ItemdefInstrument.InstrumentPiece.encode(message.pieces[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.pitchRangeMin);
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.pitchRangeMax);
            if (message.volumeMbMin != null && message.hasOwnProperty("volumeMbMin"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.volumeMbMin);
            if (message.volumeMbMax != null && message.hasOwnProperty("volumeMbMax"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.volumeMbMax);
            if (message.soundProduction != null && message.soundProduction.length)
                for (var i = 0; i < message.soundProduction.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.soundProduction[i]);
            if (message.soundProductionParm1 != null && message.soundProductionParm1.length)
                for (var i = 0; i < message.soundProductionParm1.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.soundProductionParm1[i]);
            if (message.soundProductionParm2 != null && message.soundProductionParm2.length)
                for (var i = 0; i < message.soundProductionParm2.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.soundProductionParm2[i]);
            if (message.pitchChoice != null && message.pitchChoice.length)
                for (var i = 0; i < message.pitchChoice.length; ++i)
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.pitchChoice[i]);
            if (message.pitchChoiceParm1 != null && message.pitchChoiceParm1.length)
                for (var i = 0; i < message.pitchChoiceParm1.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.pitchChoiceParm1[i]);
            if (message.pitchChoiceParm2 != null && message.pitchChoiceParm2.length)
                for (var i = 0; i < message.pitchChoiceParm2.length; ++i)
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.pitchChoiceParm2[i]);
            if (message.tuning != null && message.tuning.length)
                for (var i = 0; i < message.tuning.length; ++i)
                    writer.uint32(/* id 16, wireType 0 =*/128).int32(message.tuning[i]);
            if (message.tuningParm != null && message.tuningParm.length)
                for (var i = 0; i < message.tuningParm.length; ++i)
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.tuningParm[i]);
            if (message.registers != null && message.registers.length)
                for (var i = 0; i < message.registers.length; ++i)
                    $root.ItemdefInstrument.InstrumentRegister.encode(message.registers[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified InstrumentDef message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.IInstrumentDef} message InstrumentDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentDef message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.flags = $root.ItemdefInstrument.InstrumentFlags.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.size = reader.int32();
                    break;
                case 3:
                    message.value = reader.int32();
                    break;
                case 4:
                    message.materialSize = reader.int32();
                    break;
                case 5:
                    if (!(message.pieces && message.pieces.length))
                        message.pieces = [];
                    message.pieces.push($root.ItemdefInstrument.InstrumentPiece.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.pitchRangeMin = reader.int32();
                    break;
                case 7:
                    message.pitchRangeMax = reader.int32();
                    break;
                case 8:
                    message.volumeMbMin = reader.int32();
                    break;
                case 9:
                    message.volumeMbMax = reader.int32();
                    break;
                case 10:
                    if (!(message.soundProduction && message.soundProduction.length))
                        message.soundProduction = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.soundProduction.push(reader.int32());
                    } else
                        message.soundProduction.push(reader.int32());
                    break;
                case 11:
                    if (!(message.soundProductionParm1 && message.soundProductionParm1.length))
                        message.soundProductionParm1 = [];
                    message.soundProductionParm1.push(reader.string());
                    break;
                case 12:
                    if (!(message.soundProductionParm2 && message.soundProductionParm2.length))
                        message.soundProductionParm2 = [];
                    message.soundProductionParm2.push(reader.string());
                    break;
                case 13:
                    if (!(message.pitchChoice && message.pitchChoice.length))
                        message.pitchChoice = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.pitchChoice.push(reader.int32());
                    } else
                        message.pitchChoice.push(reader.int32());
                    break;
                case 14:
                    if (!(message.pitchChoiceParm1 && message.pitchChoiceParm1.length))
                        message.pitchChoiceParm1 = [];
                    message.pitchChoiceParm1.push(reader.string());
                    break;
                case 15:
                    if (!(message.pitchChoiceParm2 && message.pitchChoiceParm2.length))
                        message.pitchChoiceParm2 = [];
                    message.pitchChoiceParm2.push(reader.string());
                    break;
                case 16:
                    if (!(message.tuning && message.tuning.length))
                        message.tuning = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tuning.push(reader.int32());
                    } else
                        message.tuning.push(reader.int32());
                    break;
                case 17:
                    if (!(message.tuningParm && message.tuningParm.length))
                        message.tuningParm = [];
                    message.tuningParm.push(reader.string());
                    break;
                case 18:
                    if (!(message.registers && message.registers.length))
                        message.registers = [];
                    message.registers.push($root.ItemdefInstrument.InstrumentRegister.decode(reader, reader.uint32()));
                    break;
                case 19:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentDef message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                var error = $root.ItemdefInstrument.InstrumentFlags.verify(message.flags);
                if (error)
                    return "flags." + error;
            }
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.materialSize != null && message.hasOwnProperty("materialSize"))
                if (!$util.isInteger(message.materialSize))
                    return "materialSize: integer expected";
            if (message.pieces != null && message.hasOwnProperty("pieces")) {
                if (!Array.isArray(message.pieces))
                    return "pieces: array expected";
                for (var i = 0; i < message.pieces.length; ++i) {
                    var error = $root.ItemdefInstrument.InstrumentPiece.verify(message.pieces[i]);
                    if (error)
                        return "pieces." + error;
                }
            }
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                if (!$util.isInteger(message.pitchRangeMin))
                    return "pitchRangeMin: integer expected";
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                if (!$util.isInteger(message.pitchRangeMax))
                    return "pitchRangeMax: integer expected";
            if (message.volumeMbMin != null && message.hasOwnProperty("volumeMbMin"))
                if (!$util.isInteger(message.volumeMbMin))
                    return "volumeMbMin: integer expected";
            if (message.volumeMbMax != null && message.hasOwnProperty("volumeMbMax"))
                if (!$util.isInteger(message.volumeMbMax))
                    return "volumeMbMax: integer expected";
            if (message.soundProduction != null && message.hasOwnProperty("soundProduction")) {
                if (!Array.isArray(message.soundProduction))
                    return "soundProduction: array expected";
                for (var i = 0; i < message.soundProduction.length; ++i)
                    switch (message.soundProduction[i]) {
                    default:
                        return "soundProduction: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                        break;
                    }
            }
            if (message.soundProductionParm1 != null && message.hasOwnProperty("soundProductionParm1")) {
                if (!Array.isArray(message.soundProductionParm1))
                    return "soundProductionParm1: array expected";
                for (var i = 0; i < message.soundProductionParm1.length; ++i)
                    if (!$util.isString(message.soundProductionParm1[i]))
                        return "soundProductionParm1: string[] expected";
            }
            if (message.soundProductionParm2 != null && message.hasOwnProperty("soundProductionParm2")) {
                if (!Array.isArray(message.soundProductionParm2))
                    return "soundProductionParm2: array expected";
                for (var i = 0; i < message.soundProductionParm2.length; ++i)
                    if (!$util.isString(message.soundProductionParm2[i]))
                        return "soundProductionParm2: string[] expected";
            }
            if (message.pitchChoice != null && message.hasOwnProperty("pitchChoice")) {
                if (!Array.isArray(message.pitchChoice))
                    return "pitchChoice: array expected";
                for (var i = 0; i < message.pitchChoice.length; ++i)
                    switch (message.pitchChoice[i]) {
                    default:
                        return "pitchChoice: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    }
            }
            if (message.pitchChoiceParm1 != null && message.hasOwnProperty("pitchChoiceParm1")) {
                if (!Array.isArray(message.pitchChoiceParm1))
                    return "pitchChoiceParm1: array expected";
                for (var i = 0; i < message.pitchChoiceParm1.length; ++i)
                    if (!$util.isString(message.pitchChoiceParm1[i]))
                        return "pitchChoiceParm1: string[] expected";
            }
            if (message.pitchChoiceParm2 != null && message.hasOwnProperty("pitchChoiceParm2")) {
                if (!Array.isArray(message.pitchChoiceParm2))
                    return "pitchChoiceParm2: array expected";
                for (var i = 0; i < message.pitchChoiceParm2.length; ++i)
                    if (!$util.isString(message.pitchChoiceParm2[i]))
                        return "pitchChoiceParm2: string[] expected";
            }
            if (message.tuning != null && message.hasOwnProperty("tuning")) {
                if (!Array.isArray(message.tuning))
                    return "tuning: array expected";
                for (var i = 0; i < message.tuning.length; ++i)
                    switch (message.tuning[i]) {
                    default:
                        return "tuning: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
            }
            if (message.tuningParm != null && message.hasOwnProperty("tuningParm")) {
                if (!Array.isArray(message.tuningParm))
                    return "tuningParm: array expected";
                for (var i = 0; i < message.tuningParm.length; ++i)
                    if (!$util.isString(message.tuningParm[i]))
                        return "tuningParm: string[] expected";
            }
            if (message.registers != null && message.hasOwnProperty("registers")) {
                if (!Array.isArray(message.registers))
                    return "registers: array expected";
                for (var i = 0; i < message.registers.length; ++i) {
                    var error = $root.ItemdefInstrument.InstrumentRegister.verify(message.registers[i]);
                    if (error)
                        return "registers." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates an InstrumentDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef
         */
        InstrumentDef.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentDef)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentDef();
            if (object.flags != null) {
                if (typeof object.flags !== "object")
                    throw TypeError(".ItemdefInstrument.InstrumentDef.flags: object expected");
                message.flags = $root.ItemdefInstrument.InstrumentFlags.fromObject(object.flags);
            }
            if (object.size != null)
                message.size = object.size | 0;
            if (object.value != null)
                message.value = object.value | 0;
            if (object.materialSize != null)
                message.materialSize = object.materialSize | 0;
            if (object.pieces) {
                if (!Array.isArray(object.pieces))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pieces: array expected");
                message.pieces = [];
                for (var i = 0; i < object.pieces.length; ++i) {
                    if (typeof object.pieces[i] !== "object")
                        throw TypeError(".ItemdefInstrument.InstrumentDef.pieces: object expected");
                    message.pieces[i] = $root.ItemdefInstrument.InstrumentPiece.fromObject(object.pieces[i]);
                }
            }
            if (object.pitchRangeMin != null)
                message.pitchRangeMin = object.pitchRangeMin | 0;
            if (object.pitchRangeMax != null)
                message.pitchRangeMax = object.pitchRangeMax | 0;
            if (object.volumeMbMin != null)
                message.volumeMbMin = object.volumeMbMin | 0;
            if (object.volumeMbMax != null)
                message.volumeMbMax = object.volumeMbMax | 0;
            if (object.soundProduction) {
                if (!Array.isArray(object.soundProduction))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.soundProduction: array expected");
                message.soundProduction = [];
                for (var i = 0; i < object.soundProduction.length; ++i)
                    switch (object.soundProduction[i]) {
                    default:
                    case "PLUCKED_BY_BP":
                    case 0:
                        message.soundProduction[i] = 0;
                        break;
                    case "PLUCKED":
                    case 1:
                        message.soundProduction[i] = 1;
                        break;
                    case "BOWED":
                    case 2:
                        message.soundProduction[i] = 2;
                        break;
                    case "STRUCK_BY_BP":
                    case 3:
                        message.soundProduction[i] = 3;
                        break;
                    case "STRUCK":
                    case 4:
                        message.soundProduction[i] = 4;
                        break;
                    case "VIBRATE_BP_AGAINST_OPENING":
                    case 5:
                        message.soundProduction[i] = 5;
                        break;
                    case "BLOW_AGAINST_FIPPLE":
                    case 6:
                        message.soundProduction[i] = 6;
                        break;
                    case "BLOW_OVER_OPENING_SIDE":
                    case 7:
                        message.soundProduction[i] = 7;
                        break;
                    case "BLOW_OVER_OPENING_END":
                    case 8:
                        message.soundProduction[i] = 8;
                        break;
                    case "BLOW_OVER_SINGLE_REED":
                    case 9:
                        message.soundProduction[i] = 9;
                        break;
                    case "BLOW_OVER_DOUBLE_REED":
                    case 10:
                        message.soundProduction[i] = 10;
                        break;
                    case "BLOW_OVER_FREE_REED":
                    case 11:
                        message.soundProduction[i] = 11;
                        break;
                    case "STRUCK_TOGETHER":
                    case 12:
                        message.soundProduction[i] = 12;
                        break;
                    case "SHAKEN":
                    case 13:
                        message.soundProduction[i] = 13;
                        break;
                    case "SCRAPED":
                    case 14:
                        message.soundProduction[i] = 14;
                        break;
                    case "FRICTION":
                    case 15:
                        message.soundProduction[i] = 15;
                        break;
                    case "RESONATOR":
                    case 16:
                        message.soundProduction[i] = 16;
                        break;
                    case "BAG_OVER_REED":
                    case 17:
                        message.soundProduction[i] = 17;
                        break;
                    case "AIR_OVER_REED":
                    case 18:
                        message.soundProduction[i] = 18;
                        break;
                    case "AIR_OVER_FREE_REED":
                    case 19:
                        message.soundProduction[i] = 19;
                        break;
                    case "AIR_AGAINST_FIPPLE":
                    case 20:
                        message.soundProduction[i] = 20;
                        break;
                    }
            }
            if (object.soundProductionParm1) {
                if (!Array.isArray(object.soundProductionParm1))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.soundProductionParm1: array expected");
                message.soundProductionParm1 = [];
                for (var i = 0; i < object.soundProductionParm1.length; ++i)
                    message.soundProductionParm1[i] = String(object.soundProductionParm1[i]);
            }
            if (object.soundProductionParm2) {
                if (!Array.isArray(object.soundProductionParm2))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.soundProductionParm2: array expected");
                message.soundProductionParm2 = [];
                for (var i = 0; i < object.soundProductionParm2.length; ++i)
                    message.soundProductionParm2[i] = String(object.soundProductionParm2[i]);
            }
            if (object.pitchChoice) {
                if (!Array.isArray(object.pitchChoice))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pitchChoice: array expected");
                message.pitchChoice = [];
                for (var i = 0; i < object.pitchChoice.length; ++i)
                    switch (object.pitchChoice[i]) {
                    default:
                    case "MEMBRANE_POSITION":
                    case 0:
                        message.pitchChoice[i] = 0;
                        break;
                    case "SUBPART_CHOICE":
                    case 1:
                        message.pitchChoice[i] = 1;
                        break;
                    case "KEYBOARD":
                    case 2:
                        message.pitchChoice[i] = 2;
                        break;
                    case "STOPPING_FRET":
                    case 3:
                        message.pitchChoice[i] = 3;
                        break;
                    case "STOPPING_AGAINST_BODY":
                    case 4:
                        message.pitchChoice[i] = 4;
                        break;
                    case "STOPPING_HOLE":
                    case 5:
                        message.pitchChoice[i] = 5;
                        break;
                    case "STOPPING_HOLE_KEY":
                    case 6:
                        message.pitchChoice[i] = 6;
                        break;
                    case "SLIDE":
                    case 7:
                        message.pitchChoice[i] = 7;
                        break;
                    case "HARMONIC_SERIES":
                    case 8:
                        message.pitchChoice[i] = 8;
                        break;
                    case "VALVE_ROUTES_AIR":
                    case 9:
                        message.pitchChoice[i] = 9;
                        break;
                    case "BP_IN_BELL":
                    case 10:
                        message.pitchChoice[i] = 10;
                        break;
                    case "FOOT_PEDALS":
                    case 11:
                        message.pitchChoice[i] = 11;
                        break;
                    }
            }
            if (object.pitchChoiceParm1) {
                if (!Array.isArray(object.pitchChoiceParm1))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pitchChoiceParm1: array expected");
                message.pitchChoiceParm1 = [];
                for (var i = 0; i < object.pitchChoiceParm1.length; ++i)
                    message.pitchChoiceParm1[i] = String(object.pitchChoiceParm1[i]);
            }
            if (object.pitchChoiceParm2) {
                if (!Array.isArray(object.pitchChoiceParm2))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pitchChoiceParm2: array expected");
                message.pitchChoiceParm2 = [];
                for (var i = 0; i < object.pitchChoiceParm2.length; ++i)
                    message.pitchChoiceParm2[i] = String(object.pitchChoiceParm2[i]);
            }
            if (object.tuning) {
                if (!Array.isArray(object.tuning))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.tuning: array expected");
                message.tuning = [];
                for (var i = 0; i < object.tuning.length; ++i)
                    switch (object.tuning[i]) {
                    default:
                    case "PEGS":
                    case 0:
                        message.tuning[i] = 0;
                        break;
                    case "ADJUSTABLE_BRIDGES":
                    case 1:
                        message.tuning[i] = 1;
                        break;
                    case "CROOKS":
                    case 2:
                        message.tuning[i] = 2;
                        break;
                    case "TIGHTENING":
                    case 3:
                        message.tuning[i] = 3;
                        break;
                    case "LEVERS":
                    case 4:
                        message.tuning[i] = 4;
                        break;
                    }
            }
            if (object.tuningParm) {
                if (!Array.isArray(object.tuningParm))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.tuningParm: array expected");
                message.tuningParm = [];
                for (var i = 0; i < object.tuningParm.length; ++i)
                    message.tuningParm[i] = String(object.tuningParm[i]);
            }
            if (object.registers) {
                if (!Array.isArray(object.registers))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.registers: array expected");
                message.registers = [];
                for (var i = 0; i < object.registers.length; ++i) {
                    if (typeof object.registers[i] !== "object")
                        throw TypeError(".ItemdefInstrument.InstrumentDef.registers: object expected");
                    message.registers[i] = $root.ItemdefInstrument.InstrumentRegister.fromObject(object.registers[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from an InstrumentDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.InstrumentDef} message InstrumentDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pieces = [];
                object.soundProduction = [];
                object.soundProductionParm1 = [];
                object.soundProductionParm2 = [];
                object.pitchChoice = [];
                object.pitchChoiceParm1 = [];
                object.pitchChoiceParm2 = [];
                object.tuning = [];
                object.tuningParm = [];
                object.registers = [];
            }
            if (options.defaults) {
                object.flags = null;
                object.size = 0;
                object.value = 0;
                object.materialSize = 0;
                object.pitchRangeMin = 0;
                object.pitchRangeMax = 0;
                object.volumeMbMin = 0;
                object.volumeMbMax = 0;
                object.description = "";
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = $root.ItemdefInstrument.InstrumentFlags.toObject(message.flags, options);
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.materialSize != null && message.hasOwnProperty("materialSize"))
                object.materialSize = message.materialSize;
            if (message.pieces && message.pieces.length) {
                object.pieces = [];
                for (var j = 0; j < message.pieces.length; ++j)
                    object.pieces[j] = $root.ItemdefInstrument.InstrumentPiece.toObject(message.pieces[j], options);
            }
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                object.pitchRangeMin = message.pitchRangeMin;
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                object.pitchRangeMax = message.pitchRangeMax;
            if (message.volumeMbMin != null && message.hasOwnProperty("volumeMbMin"))
                object.volumeMbMin = message.volumeMbMin;
            if (message.volumeMbMax != null && message.hasOwnProperty("volumeMbMax"))
                object.volumeMbMax = message.volumeMbMax;
            if (message.soundProduction && message.soundProduction.length) {
                object.soundProduction = [];
                for (var j = 0; j < message.soundProduction.length; ++j)
                    object.soundProduction[j] = options.enums === String ? $root.ItemdefInstrument.SoundProductionType[message.soundProduction[j]] : message.soundProduction[j];
            }
            if (message.soundProductionParm1 && message.soundProductionParm1.length) {
                object.soundProductionParm1 = [];
                for (var j = 0; j < message.soundProductionParm1.length; ++j)
                    object.soundProductionParm1[j] = message.soundProductionParm1[j];
            }
            if (message.soundProductionParm2 && message.soundProductionParm2.length) {
                object.soundProductionParm2 = [];
                for (var j = 0; j < message.soundProductionParm2.length; ++j)
                    object.soundProductionParm2[j] = message.soundProductionParm2[j];
            }
            if (message.pitchChoice && message.pitchChoice.length) {
                object.pitchChoice = [];
                for (var j = 0; j < message.pitchChoice.length; ++j)
                    object.pitchChoice[j] = options.enums === String ? $root.ItemdefInstrument.PitchChoiceType[message.pitchChoice[j]] : message.pitchChoice[j];
            }
            if (message.pitchChoiceParm1 && message.pitchChoiceParm1.length) {
                object.pitchChoiceParm1 = [];
                for (var j = 0; j < message.pitchChoiceParm1.length; ++j)
                    object.pitchChoiceParm1[j] = message.pitchChoiceParm1[j];
            }
            if (message.pitchChoiceParm2 && message.pitchChoiceParm2.length) {
                object.pitchChoiceParm2 = [];
                for (var j = 0; j < message.pitchChoiceParm2.length; ++j)
                    object.pitchChoiceParm2[j] = message.pitchChoiceParm2[j];
            }
            if (message.tuning && message.tuning.length) {
                object.tuning = [];
                for (var j = 0; j < message.tuning.length; ++j)
                    object.tuning[j] = options.enums === String ? $root.ItemdefInstrument.TuningType[message.tuning[j]] : message.tuning[j];
            }
            if (message.tuningParm && message.tuningParm.length) {
                object.tuningParm = [];
                for (var j = 0; j < message.tuningParm.length; ++j)
                    object.tuningParm[j] = message.tuningParm[j];
            }
            if (message.registers && message.registers.length) {
                object.registers = [];
                for (var j = 0; j < message.registers.length; ++j)
                    object.registers[j] = $root.ItemdefInstrument.InstrumentRegister.toObject(message.registers[j], options);
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this InstrumentDef to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentDef;
    })();

    return ItemdefInstrument;
})();

$root.dfproto = (function() {

    /**
     * Namespace dfproto.
     * @exports dfproto
     * @namespace
     */
    var dfproto = {};

    dfproto.RenameSquadIn = (function() {

        /**
         * Properties of a RenameSquadIn.
         * @memberof dfproto
         * @interface IRenameSquadIn
         * @property {number} squadId RenameSquadIn squadId
         * @property {string|null} [nickname] RenameSquadIn nickname
         * @property {string|null} [alias] RenameSquadIn alias
         */

        /**
         * Constructs a new RenameSquadIn.
         * @memberof dfproto
         * @classdesc Represents a RenameSquadIn.
         * @implements IRenameSquadIn
         * @constructor
         * @param {dfproto.IRenameSquadIn=} [properties] Properties to set
         */
        function RenameSquadIn(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameSquadIn squadId.
         * @member {number} squadId
         * @memberof dfproto.RenameSquadIn
         * @instance
         */
        RenameSquadIn.prototype.squadId = 0;

        /**
         * RenameSquadIn nickname.
         * @member {string} nickname
         * @memberof dfproto.RenameSquadIn
         * @instance
         */
        RenameSquadIn.prototype.nickname = "";

        /**
         * RenameSquadIn alias.
         * @member {string} alias
         * @memberof dfproto.RenameSquadIn
         * @instance
         */
        RenameSquadIn.prototype.alias = "";

        /**
         * Creates a new RenameSquadIn instance using the specified properties.
         * @function create
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.IRenameSquadIn=} [properties] Properties to set
         * @returns {dfproto.RenameSquadIn} RenameSquadIn instance
         */
        RenameSquadIn.create = function create(properties) {
            return new RenameSquadIn(properties);
        };

        /**
         * Encodes the specified RenameSquadIn message. Does not implicitly {@link dfproto.RenameSquadIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.IRenameSquadIn} message RenameSquadIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameSquadIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.squadId);
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.alias);
            return writer;
        };

        /**
         * Encodes the specified RenameSquadIn message, length delimited. Does not implicitly {@link dfproto.RenameSquadIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.IRenameSquadIn} message RenameSquadIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameSquadIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameSquadIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.RenameSquadIn} RenameSquadIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameSquadIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.RenameSquadIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.squadId = reader.int32();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    message.alias = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("squadId"))
                throw $util.ProtocolError("missing required 'squadId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RenameSquadIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.RenameSquadIn} RenameSquadIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameSquadIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameSquadIn message.
         * @function verify
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameSquadIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.squadId))
                return "squadId: integer expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            return null;
        };

        /**
         * Creates a RenameSquadIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.RenameSquadIn} RenameSquadIn
         */
        RenameSquadIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.RenameSquadIn)
                return object;
            var message = new $root.dfproto.RenameSquadIn();
            if (object.squadId != null)
                message.squadId = object.squadId | 0;
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.alias != null)
                message.alias = String(object.alias);
            return message;
        };

        /**
         * Creates a plain object from a RenameSquadIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.RenameSquadIn} message RenameSquadIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameSquadIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.squadId = 0;
                object.nickname = "";
                object.alias = "";
            }
            if (message.squadId != null && message.hasOwnProperty("squadId"))
                object.squadId = message.squadId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            return object;
        };

        /**
         * Converts this RenameSquadIn to JSON.
         * @function toJSON
         * @memberof dfproto.RenameSquadIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameSquadIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RenameSquadIn;
    })();

    dfproto.RenameUnitIn = (function() {

        /**
         * Properties of a RenameUnitIn.
         * @memberof dfproto
         * @interface IRenameUnitIn
         * @property {number} unitId RenameUnitIn unitId
         * @property {string|null} [nickname] RenameUnitIn nickname
         * @property {string|null} [profession] RenameUnitIn profession
         */

        /**
         * Constructs a new RenameUnitIn.
         * @memberof dfproto
         * @classdesc Represents a RenameUnitIn.
         * @implements IRenameUnitIn
         * @constructor
         * @param {dfproto.IRenameUnitIn=} [properties] Properties to set
         */
        function RenameUnitIn(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameUnitIn unitId.
         * @member {number} unitId
         * @memberof dfproto.RenameUnitIn
         * @instance
         */
        RenameUnitIn.prototype.unitId = 0;

        /**
         * RenameUnitIn nickname.
         * @member {string} nickname
         * @memberof dfproto.RenameUnitIn
         * @instance
         */
        RenameUnitIn.prototype.nickname = "";

        /**
         * RenameUnitIn profession.
         * @member {string} profession
         * @memberof dfproto.RenameUnitIn
         * @instance
         */
        RenameUnitIn.prototype.profession = "";

        /**
         * Creates a new RenameUnitIn instance using the specified properties.
         * @function create
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.IRenameUnitIn=} [properties] Properties to set
         * @returns {dfproto.RenameUnitIn} RenameUnitIn instance
         */
        RenameUnitIn.create = function create(properties) {
            return new RenameUnitIn(properties);
        };

        /**
         * Encodes the specified RenameUnitIn message. Does not implicitly {@link dfproto.RenameUnitIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.IRenameUnitIn} message RenameUnitIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameUnitIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.unitId);
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.profession != null && message.hasOwnProperty("profession"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.profession);
            return writer;
        };

        /**
         * Encodes the specified RenameUnitIn message, length delimited. Does not implicitly {@link dfproto.RenameUnitIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.IRenameUnitIn} message RenameUnitIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameUnitIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameUnitIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.RenameUnitIn} RenameUnitIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameUnitIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.RenameUnitIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.unitId = reader.int32();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    message.profession = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("unitId"))
                throw $util.ProtocolError("missing required 'unitId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RenameUnitIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.RenameUnitIn} RenameUnitIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameUnitIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameUnitIn message.
         * @function verify
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameUnitIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.unitId))
                return "unitId: integer expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.profession != null && message.hasOwnProperty("profession"))
                if (!$util.isString(message.profession))
                    return "profession: string expected";
            return null;
        };

        /**
         * Creates a RenameUnitIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.RenameUnitIn} RenameUnitIn
         */
        RenameUnitIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.RenameUnitIn)
                return object;
            var message = new $root.dfproto.RenameUnitIn();
            if (object.unitId != null)
                message.unitId = object.unitId | 0;
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.profession != null)
                message.profession = String(object.profession);
            return message;
        };

        /**
         * Creates a plain object from a RenameUnitIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.RenameUnitIn} message RenameUnitIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameUnitIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unitId = 0;
                object.nickname = "";
                object.profession = "";
            }
            if (message.unitId != null && message.hasOwnProperty("unitId"))
                object.unitId = message.unitId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.profession != null && message.hasOwnProperty("profession"))
                object.profession = message.profession;
            return object;
        };

        /**
         * Converts this RenameUnitIn to JSON.
         * @function toJSON
         * @memberof dfproto.RenameUnitIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameUnitIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RenameUnitIn;
    })();

    dfproto.RenameBuildingIn = (function() {

        /**
         * Properties of a RenameBuildingIn.
         * @memberof dfproto
         * @interface IRenameBuildingIn
         * @property {number} buildingId RenameBuildingIn buildingId
         * @property {string|null} [name] RenameBuildingIn name
         */

        /**
         * Constructs a new RenameBuildingIn.
         * @memberof dfproto
         * @classdesc Represents a RenameBuildingIn.
         * @implements IRenameBuildingIn
         * @constructor
         * @param {dfproto.IRenameBuildingIn=} [properties] Properties to set
         */
        function RenameBuildingIn(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameBuildingIn buildingId.
         * @member {number} buildingId
         * @memberof dfproto.RenameBuildingIn
         * @instance
         */
        RenameBuildingIn.prototype.buildingId = 0;

        /**
         * RenameBuildingIn name.
         * @member {string} name
         * @memberof dfproto.RenameBuildingIn
         * @instance
         */
        RenameBuildingIn.prototype.name = "";

        /**
         * Creates a new RenameBuildingIn instance using the specified properties.
         * @function create
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.IRenameBuildingIn=} [properties] Properties to set
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn instance
         */
        RenameBuildingIn.create = function create(properties) {
            return new RenameBuildingIn(properties);
        };

        /**
         * Encodes the specified RenameBuildingIn message. Does not implicitly {@link dfproto.RenameBuildingIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.IRenameBuildingIn} message RenameBuildingIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameBuildingIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buildingId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified RenameBuildingIn message, length delimited. Does not implicitly {@link dfproto.RenameBuildingIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.IRenameBuildingIn} message RenameBuildingIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameBuildingIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameBuildingIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameBuildingIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.RenameBuildingIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buildingId = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("buildingId"))
                throw $util.ProtocolError("missing required 'buildingId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RenameBuildingIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameBuildingIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameBuildingIn message.
         * @function verify
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameBuildingIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.buildingId))
                return "buildingId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a RenameBuildingIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn
         */
        RenameBuildingIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.RenameBuildingIn)
                return object;
            var message = new $root.dfproto.RenameBuildingIn();
            if (object.buildingId != null)
                message.buildingId = object.buildingId | 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a RenameBuildingIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.RenameBuildingIn} message RenameBuildingIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameBuildingIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buildingId = 0;
                object.name = "";
            }
            if (message.buildingId != null && message.hasOwnProperty("buildingId"))
                object.buildingId = message.buildingId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this RenameBuildingIn to JSON.
         * @function toJSON
         * @memberof dfproto.RenameBuildingIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameBuildingIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RenameBuildingIn;
    })();

    return dfproto;
})();

module.exports = $root;
