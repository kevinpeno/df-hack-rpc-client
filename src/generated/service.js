/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.DFHackRPCService = (function() {

    /**
     * Constructs a new DFHackRPCService service.
     * @exports DFHackRPCService
     * @classdesc Represents a DFHackRPCService
     * @extends $protobuf.rpc.Service
     * @constructor
     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
     */
    function DFHackRPCService(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
    }

    (DFHackRPCService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DFHackRPCService;

    /**
     * Creates new DFHackRPCService service using the specified rpc implementation.
     * @function create
     * @memberof DFHackRPCService
     * @static
     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
     * @returns {DFHackRPCService} RPC service. Useful where requests and/or responses are streamed.
     */
    DFHackRPCService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
        return new this(rpcImpl, requestDelimited, responseDelimited);
    };

    /**
     * Callback as used by {@link DFHackRPCService#bindMethod}.
     * @memberof DFHackRPCService
     * @typedef BindMethodCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.CoreBindReply} [response] CoreBindReply
     */

    /**
     * Calls BindMethod.
     * @function bindMethod
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ICoreBindRequest} request CoreBindRequest message or plain object
     * @param {DFHackRPCService.BindMethodCallback} callback Node-style callback called with the error, if any, and CoreBindReply
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.bindMethod = function bindMethod(request, callback) {
        return this.rpcCall(bindMethod, $root.dfproto.CoreBindRequest, $root.dfproto.CoreBindReply, request, callback);
    }, {"name": { value: "BindMethod" }, "FQDN": { value: "DFHackRPCService.BindMethod" }, "requestFQDN": { value: "dfproto.CoreBindRequest" }, "responseFQDN": { value: "dfproto.CoreBindReply" }});

    /**
     * Calls BindMethod.
     * @function bindMethod
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ICoreBindRequest} request CoreBindRequest message or plain object
     * @returns {Promise<dfproto.CoreBindReply>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#runCommand}.
     * @memberof DFHackRPCService
     * @typedef RunCommandCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls RunCommand.
     * @function runCommand
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ICoreRunCommandRequest} request CoreRunCommandRequest message or plain object
     * @param {DFHackRPCService.RunCommandCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.runCommand = function runCommand(request, callback) {
        return this.rpcCall(runCommand, $root.dfproto.CoreRunCommandRequest, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "RunCommand" }, "FQDN": { value: "DFHackRPCService.RunCommand" }, "requestFQDN": { value: "dfproto.CoreRunCommandRequest" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls RunCommand.
     * @function runCommand
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ICoreRunCommandRequest} request CoreRunCommandRequest message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#coreSuspend}.
     * @memberof DFHackRPCService
     * @typedef CoreSuspendCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.IntMessage} [response] IntMessage
     */

    /**
     * Calls CoreSuspend.
     * @function coreSuspend
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.CoreSuspendCallback} callback Node-style callback called with the error, if any, and IntMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.coreSuspend = function coreSuspend(request, callback) {
        return this.rpcCall(coreSuspend, $root.dfproto.EmptyMessage, $root.dfproto.IntMessage, request, callback);
    }, {"name": { value: "CoreSuspend" }, "FQDN": { value: "DFHackRPCService.CoreSuspend" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.IntMessage" }});

    /**
     * Calls CoreSuspend.
     * @function coreSuspend
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.IntMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#coreResume}.
     * @memberof DFHackRPCService
     * @typedef CoreResumeCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.IntMessage} [response] IntMessage
     */

    /**
     * Calls CoreResume.
     * @function coreResume
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.CoreResumeCallback} callback Node-style callback called with the error, if any, and IntMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.coreResume = function coreResume(request, callback) {
        return this.rpcCall(coreResume, $root.dfproto.EmptyMessage, $root.dfproto.IntMessage, request, callback);
    }, {"name": { value: "CoreResume" }, "FQDN": { value: "DFHackRPCService.CoreResume" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.IntMessage" }});

    /**
     * Calls CoreResume.
     * @function coreResume
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.IntMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#runLua}.
     * @memberof DFHackRPCService
     * @typedef RunLuaCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.StringListMessage} [response] StringListMessage
     */

    /**
     * Calls RunLua.
     * @function runLua
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ICoreRunLuaRequest} request CoreRunLuaRequest message or plain object
     * @param {DFHackRPCService.RunLuaCallback} callback Node-style callback called with the error, if any, and StringListMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.runLua = function runLua(request, callback) {
        return this.rpcCall(runLua, $root.dfproto.CoreRunLuaRequest, $root.dfproto.StringListMessage, request, callback);
    }, {"name": { value: "RunLua" }, "FQDN": { value: "DFHackRPCService.RunLua" }, "requestFQDN": { value: "dfproto.CoreRunLuaRequest" }, "responseFQDN": { value: "dfproto.StringListMessage" }});

    /**
     * Calls RunLua.
     * @function runLua
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ICoreRunLuaRequest} request CoreRunLuaRequest message or plain object
     * @returns {Promise<dfproto.StringListMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getVersion}.
     * @memberof DFHackRPCService
     * @typedef GetVersionCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.StringMessage} [response] StringMessage
     */

    /**
     * Calls GetVersion.
     * @function getVersion
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetVersionCallback} callback Node-style callback called with the error, if any, and StringMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getVersion = function getVersion(request, callback) {
        return this.rpcCall(getVersion, $root.dfproto.EmptyMessage, $root.dfproto.StringMessage, request, callback);
    }, {"name": { value: "GetVersion" }, "FQDN": { value: "DFHackRPCService.GetVersion" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.StringMessage" }});

    /**
     * Calls GetVersion.
     * @function getVersion
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.StringMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getDFVersion}.
     * @memberof DFHackRPCService
     * @typedef GetDFVersionCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.StringMessage} [response] StringMessage
     */

    /**
     * Calls GetDFVersion.
     * @function getDFVersion
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetDFVersionCallback} callback Node-style callback called with the error, if any, and StringMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getDFVersion = function getDFVersion(request, callback) {
        return this.rpcCall(getDFVersion, $root.dfproto.EmptyMessage, $root.dfproto.StringMessage, request, callback);
    }, {"name": { value: "GetDFVersion" }, "FQDN": { value: "DFHackRPCService.GetDFVersion" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.StringMessage" }});

    /**
     * Calls GetDFVersion.
     * @function getDFVersion
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.StringMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getWorldInfo}.
     * @memberof DFHackRPCService
     * @typedef GetWorldInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.GetWorldInfoOut} [response] GetWorldInfoOut
     */

    /**
     * Calls GetWorldInfo.
     * @function getWorldInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetWorldInfoCallback} callback Node-style callback called with the error, if any, and GetWorldInfoOut
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getWorldInfo = function getWorldInfo(request, callback) {
        return this.rpcCall(getWorldInfo, $root.dfproto.EmptyMessage, $root.dfproto.GetWorldInfoOut, request, callback);
    }, {"name": { value: "GetWorldInfo" }, "FQDN": { value: "DFHackRPCService.GetWorldInfo" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.GetWorldInfoOut" }});

    /**
     * Calls GetWorldInfo.
     * @function getWorldInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.GetWorldInfoOut>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#listEnums}.
     * @memberof DFHackRPCService
     * @typedef ListEnumsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.ListEnumsOut} [response] ListEnumsOut
     */

    /**
     * Calls ListEnums.
     * @function listEnums
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.ListEnumsCallback} callback Node-style callback called with the error, if any, and ListEnumsOut
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.listEnums = function listEnums(request, callback) {
        return this.rpcCall(listEnums, $root.dfproto.EmptyMessage, $root.dfproto.ListEnumsOut, request, callback);
    }, {"name": { value: "ListEnums" }, "FQDN": { value: "DFHackRPCService.ListEnums" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.ListEnumsOut" }});

    /**
     * Calls ListEnums.
     * @function listEnums
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.ListEnumsOut>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#listJobSkills}.
     * @memberof DFHackRPCService
     * @typedef ListJobSkillsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.ListJobSkillsOut} [response] ListJobSkillsOut
     */

    /**
     * Calls ListJobSkills.
     * @function listJobSkills
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.ListJobSkillsCallback} callback Node-style callback called with the error, if any, and ListJobSkillsOut
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.listJobSkills = function listJobSkills(request, callback) {
        return this.rpcCall(listJobSkills, $root.dfproto.EmptyMessage, $root.dfproto.ListJobSkillsOut, request, callback);
    }, {"name": { value: "ListJobSkills" }, "FQDN": { value: "DFHackRPCService.ListJobSkills" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.ListJobSkillsOut" }});

    /**
     * Calls ListJobSkills.
     * @function listJobSkills
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.ListJobSkillsOut>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#listMaterials}.
     * @memberof DFHackRPCService
     * @typedef ListMaterialsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.ListMaterialsOut} [response] ListMaterialsOut
     */

    /**
     * Calls ListMaterials.
     * @function listMaterials
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IListMaterialsIn} request ListMaterialsIn message or plain object
     * @param {DFHackRPCService.ListMaterialsCallback} callback Node-style callback called with the error, if any, and ListMaterialsOut
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.listMaterials = function listMaterials(request, callback) {
        return this.rpcCall(listMaterials, $root.dfproto.ListMaterialsIn, $root.dfproto.ListMaterialsOut, request, callback);
    }, {"name": { value: "ListMaterials" }, "FQDN": { value: "DFHackRPCService.ListMaterials" }, "requestFQDN": { value: "dfproto.ListMaterialsIn" }, "responseFQDN": { value: "dfproto.ListMaterialsOut" }});

    /**
     * Calls ListMaterials.
     * @function listMaterials
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IListMaterialsIn} request ListMaterialsIn message or plain object
     * @returns {Promise<dfproto.ListMaterialsOut>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#listUnits}.
     * @memberof DFHackRPCService
     * @typedef ListUnitsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.ListUnitsOut} [response] ListUnitsOut
     */

    /**
     * Calls ListUnits.
     * @function listUnits
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IListUnitsIn} request ListUnitsIn message or plain object
     * @param {DFHackRPCService.ListUnitsCallback} callback Node-style callback called with the error, if any, and ListUnitsOut
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.listUnits = function listUnits(request, callback) {
        return this.rpcCall(listUnits, $root.dfproto.ListUnitsIn, $root.dfproto.ListUnitsOut, request, callback);
    }, {"name": { value: "ListUnits" }, "FQDN": { value: "DFHackRPCService.ListUnits" }, "requestFQDN": { value: "dfproto.ListUnitsIn" }, "responseFQDN": { value: "dfproto.ListUnitsOut" }});

    /**
     * Calls ListUnits.
     * @function listUnits
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IListUnitsIn} request ListUnitsIn message or plain object
     * @returns {Promise<dfproto.ListUnitsOut>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#listSquads}.
     * @memberof DFHackRPCService
     * @typedef ListSquadsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.ListSquadsOut} [response] ListSquadsOut
     */

    /**
     * Calls ListSquads.
     * @function listSquads
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IListSquadsIn} request ListSquadsIn message or plain object
     * @param {DFHackRPCService.ListSquadsCallback} callback Node-style callback called with the error, if any, and ListSquadsOut
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.listSquads = function listSquads(request, callback) {
        return this.rpcCall(listSquads, $root.dfproto.ListSquadsIn, $root.dfproto.ListSquadsOut, request, callback);
    }, {"name": { value: "ListSquads" }, "FQDN": { value: "DFHackRPCService.ListSquads" }, "requestFQDN": { value: "dfproto.ListSquadsIn" }, "responseFQDN": { value: "dfproto.ListSquadsOut" }});

    /**
     * Calls ListSquads.
     * @function listSquads
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IListSquadsIn} request ListSquadsIn message or plain object
     * @returns {Promise<dfproto.ListSquadsOut>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#setUnitLabors}.
     * @memberof DFHackRPCService
     * @typedef SetUnitLaborsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls SetUnitLabors.
     * @function setUnitLabors
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ISetUnitLaborsIn} request SetUnitLaborsIn message or plain object
     * @param {DFHackRPCService.SetUnitLaborsCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.setUnitLabors = function setUnitLabors(request, callback) {
        return this.rpcCall(setUnitLabors, $root.dfproto.SetUnitLaborsIn, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "SetUnitLabors" }, "FQDN": { value: "DFHackRPCService.SetUnitLabors" }, "requestFQDN": { value: "dfproto.SetUnitLaborsIn" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls SetUnitLabors.
     * @function setUnitLabors
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.ISetUnitLaborsIn} request SetUnitLaborsIn message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getEmbarkTile}.
     * @memberof DFHackRPCService
     * @typedef GetEmbarkTileCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {isoworldremote.EmbarkTile} [response] EmbarkTile
     */

    /**
     * Calls GetEmbarkTile.
     * @function getEmbarkTile
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.ITileRequest} request TileRequest message or plain object
     * @param {DFHackRPCService.GetEmbarkTileCallback} callback Node-style callback called with the error, if any, and EmbarkTile
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getEmbarkTile = function getEmbarkTile(request, callback) {
        return this.rpcCall(getEmbarkTile, $root.isoworldremote.TileRequest, $root.isoworldremote.EmbarkTile, request, callback);
    }, {"name": { value: "GetEmbarkTile" }, "FQDN": { value: "DFHackRPCService.GetEmbarkTile" }, "requestFQDN": { value: "isoworldremote.TileRequest" }, "responseFQDN": { value: "isoworldremote.EmbarkTile" }});

    /**
     * Calls GetEmbarkTile.
     * @function getEmbarkTile
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.ITileRequest} request TileRequest message or plain object
     * @returns {Promise<isoworldremote.EmbarkTile>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getEmbarkInfo}.
     * @memberof DFHackRPCService
     * @typedef GetEmbarkInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {isoworldremote.MapReply} [response] MapReply
     */

    /**
     * Calls GetEmbarkInfo.
     * @function getEmbarkInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @param {DFHackRPCService.GetEmbarkInfoCallback} callback Node-style callback called with the error, if any, and MapReply
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getEmbarkInfo = function getEmbarkInfo(request, callback) {
        return this.rpcCall(getEmbarkInfo, $root.isoworldremote.MapRequest, $root.isoworldremote.MapReply, request, callback);
    }, {"name": { value: "GetEmbarkInfo" }, "FQDN": { value: "DFHackRPCService.GetEmbarkInfo" }, "requestFQDN": { value: "isoworldremote.MapRequest" }, "responseFQDN": { value: "isoworldremote.MapReply" }});

    /**
     * Calls GetEmbarkInfo.
     * @function getEmbarkInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @returns {Promise<isoworldremote.MapReply>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getRawNames}.
     * @memberof DFHackRPCService
     * @typedef GetRawNamesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {isoworldremote.RawNames} [response] RawNames
     */

    /**
     * Calls GetRawNames.
     * @function getRawNames
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @param {DFHackRPCService.GetRawNamesCallback} callback Node-style callback called with the error, if any, and RawNames
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getRawNames = function getRawNames(request, callback) {
        return this.rpcCall(getRawNames, $root.isoworldremote.MapRequest, $root.isoworldremote.RawNames, request, callback);
    }, {"name": { value: "GetRawNames" }, "FQDN": { value: "DFHackRPCService.GetRawNames" }, "requestFQDN": { value: "isoworldremote.MapRequest" }, "responseFQDN": { value: "isoworldremote.RawNames" }});

    /**
     * Calls GetRawNames.
     * @function getRawNames
     * @memberof DFHackRPCService
     * @instance
     * @param {isoworldremote.IMapRequest} request MapRequest message or plain object
     * @returns {Promise<isoworldremote.RawNames>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getMaterialList}.
     * @memberof DFHackRPCService
     * @typedef GetMaterialListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MaterialList} [response] MaterialList
     */

    /**
     * Calls GetMaterialList.
     * @function getMaterialList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetMaterialListCallback} callback Node-style callback called with the error, if any, and MaterialList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getMaterialList = function getMaterialList(request, callback) {
        return this.rpcCall(getMaterialList, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.MaterialList, request, callback);
    }, {"name": { value: "GetMaterialList" }, "FQDN": { value: "DFHackRPCService.GetMaterialList" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.MaterialList" }});

    /**
     * Calls GetMaterialList.
     * @function getMaterialList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MaterialList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getGrowthList}.
     * @memberof DFHackRPCService
     * @typedef GetGrowthListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MaterialList} [response] MaterialList
     */

    /**
     * Calls GetGrowthList.
     * @function getGrowthList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetGrowthListCallback} callback Node-style callback called with the error, if any, and MaterialList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getGrowthList = function getGrowthList(request, callback) {
        return this.rpcCall(getGrowthList, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.MaterialList, request, callback);
    }, {"name": { value: "GetGrowthList" }, "FQDN": { value: "DFHackRPCService.GetGrowthList" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.MaterialList" }});

    /**
     * Calls GetGrowthList.
     * @function getGrowthList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MaterialList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getBlockList}.
     * @memberof DFHackRPCService
     * @typedef GetBlockListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.BlockList} [response] BlockList
     */

    /**
     * Calls GetBlockList.
     * @function getBlockList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @param {DFHackRPCService.GetBlockListCallback} callback Node-style callback called with the error, if any, and BlockList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getBlockList = function getBlockList(request, callback) {
        return this.rpcCall(getBlockList, $root.RemoteFortressReader.BlockRequest, $root.RemoteFortressReader.BlockList, request, callback);
    }, {"name": { value: "GetBlockList" }, "FQDN": { value: "DFHackRPCService.GetBlockList" }, "requestFQDN": { value: "RemoteFortressReader.BlockRequest" }, "responseFQDN": { value: "RemoteFortressReader.BlockList" }});

    /**
     * Calls GetBlockList.
     * @function getBlockList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @returns {Promise<RemoteFortressReader.BlockList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#checkHashes}.
     * @memberof DFHackRPCService
     * @typedef CheckHashesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls CheckHashes.
     * @function checkHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.CheckHashesCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.checkHashes = function checkHashes(request, callback) {
        return this.rpcCall(checkHashes, $root.dfproto.EmptyMessage, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "CheckHashes" }, "FQDN": { value: "DFHackRPCService.CheckHashes" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls CheckHashes.
     * @function checkHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getTiletypeList}.
     * @memberof DFHackRPCService
     * @typedef GetTiletypeListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.TiletypeList} [response] TiletypeList
     */

    /**
     * Calls GetTiletypeList.
     * @function getTiletypeList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetTiletypeListCallback} callback Node-style callback called with the error, if any, and TiletypeList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getTiletypeList = function getTiletypeList(request, callback) {
        return this.rpcCall(getTiletypeList, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.TiletypeList, request, callback);
    }, {"name": { value: "GetTiletypeList" }, "FQDN": { value: "DFHackRPCService.GetTiletypeList" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.TiletypeList" }});

    /**
     * Calls GetTiletypeList.
     * @function getTiletypeList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.TiletypeList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPlantList}.
     * @memberof DFHackRPCService
     * @typedef GetPlantListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.PlantList} [response] PlantList
     */

    /**
     * Calls GetPlantList.
     * @function getPlantList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @param {DFHackRPCService.GetPlantListCallback} callback Node-style callback called with the error, if any, and PlantList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getPlantList = function getPlantList(request, callback) {
        return this.rpcCall(getPlantList, $root.RemoteFortressReader.BlockRequest, $root.RemoteFortressReader.PlantList, request, callback);
    }, {"name": { value: "GetPlantList" }, "FQDN": { value: "DFHackRPCService.GetPlantList" }, "requestFQDN": { value: "RemoteFortressReader.BlockRequest" }, "responseFQDN": { value: "RemoteFortressReader.PlantList" }});

    /**
     * Calls GetPlantList.
     * @function getPlantList
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @returns {Promise<RemoteFortressReader.PlantList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getUnitList}.
     * @memberof DFHackRPCService
     * @typedef GetUnitListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.UnitList} [response] UnitList
     */

    /**
     * Calls GetUnitList.
     * @function getUnitList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetUnitListCallback} callback Node-style callback called with the error, if any, and UnitList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getUnitList = function getUnitList(request, callback) {
        return this.rpcCall(getUnitList, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.UnitList, request, callback);
    }, {"name": { value: "GetUnitList" }, "FQDN": { value: "DFHackRPCService.GetUnitList" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.UnitList" }});

    /**
     * Calls GetUnitList.
     * @function getUnitList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.UnitList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getUnitListInside}.
     * @memberof DFHackRPCService
     * @typedef GetUnitListInsideCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.UnitList} [response] UnitList
     */

    /**
     * Calls GetUnitListInside.
     * @function getUnitListInside
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @param {DFHackRPCService.GetUnitListInsideCallback} callback Node-style callback called with the error, if any, and UnitList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getUnitListInside = function getUnitListInside(request, callback) {
        return this.rpcCall(getUnitListInside, $root.RemoteFortressReader.BlockRequest, $root.RemoteFortressReader.UnitList, request, callback);
    }, {"name": { value: "GetUnitListInside" }, "FQDN": { value: "DFHackRPCService.GetUnitListInside" }, "requestFQDN": { value: "RemoteFortressReader.BlockRequest" }, "responseFQDN": { value: "RemoteFortressReader.UnitList" }});

    /**
     * Calls GetUnitListInside.
     * @function getUnitListInside
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IBlockRequest} request BlockRequest message or plain object
     * @returns {Promise<RemoteFortressReader.UnitList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getViewInfo}.
     * @memberof DFHackRPCService
     * @typedef GetViewInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.ViewInfo} [response] ViewInfo
     */

    /**
     * Calls GetViewInfo.
     * @function getViewInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetViewInfoCallback} callback Node-style callback called with the error, if any, and ViewInfo
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getViewInfo = function getViewInfo(request, callback) {
        return this.rpcCall(getViewInfo, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.ViewInfo, request, callback);
    }, {"name": { value: "GetViewInfo" }, "FQDN": { value: "DFHackRPCService.GetViewInfo" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.ViewInfo" }});

    /**
     * Calls GetViewInfo.
     * @function getViewInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.ViewInfo>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getMapInfo}.
     * @memberof DFHackRPCService
     * @typedef GetMapInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MapInfo} [response] MapInfo
     */

    /**
     * Calls GetMapInfo.
     * @function getMapInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetMapInfoCallback} callback Node-style callback called with the error, if any, and MapInfo
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getMapInfo = function getMapInfo(request, callback) {
        return this.rpcCall(getMapInfo, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.MapInfo, request, callback);
    }, {"name": { value: "GetMapInfo" }, "FQDN": { value: "DFHackRPCService.GetMapInfo" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.MapInfo" }});

    /**
     * Calls GetMapInfo.
     * @function getMapInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MapInfo>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#resetMapHashes}.
     * @memberof DFHackRPCService
     * @typedef ResetMapHashesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls ResetMapHashes.
     * @function resetMapHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.ResetMapHashesCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.resetMapHashes = function resetMapHashes(request, callback) {
        return this.rpcCall(resetMapHashes, $root.dfproto.EmptyMessage, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "ResetMapHashes" }, "FQDN": { value: "DFHackRPCService.ResetMapHashes" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls ResetMapHashes.
     * @function resetMapHashes
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getItemList}.
     * @memberof DFHackRPCService
     * @typedef GetItemListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.MaterialList} [response] MaterialList
     */

    /**
     * Calls GetItemList.
     * @function getItemList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetItemListCallback} callback Node-style callback called with the error, if any, and MaterialList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getItemList = function getItemList(request, callback) {
        return this.rpcCall(getItemList, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.MaterialList, request, callback);
    }, {"name": { value: "GetItemList" }, "FQDN": { value: "DFHackRPCService.GetItemList" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.MaterialList" }});

    /**
     * Calls GetItemList.
     * @function getItemList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.MaterialList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getBuildingDefList}.
     * @memberof DFHackRPCService
     * @typedef GetBuildingDefListCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.BuildingList} [response] BuildingList
     */

    /**
     * Calls GetBuildingDefList.
     * @function getBuildingDefList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetBuildingDefListCallback} callback Node-style callback called with the error, if any, and BuildingList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getBuildingDefList = function getBuildingDefList(request, callback) {
        return this.rpcCall(getBuildingDefList, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.BuildingList, request, callback);
    }, {"name": { value: "GetBuildingDefList" }, "FQDN": { value: "DFHackRPCService.GetBuildingDefList" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.BuildingList" }});

    /**
     * Calls GetBuildingDefList.
     * @function getBuildingDefList
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.BuildingList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getWorldMap}.
     * @memberof DFHackRPCService
     * @typedef GetWorldMapCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.WorldMap} [response] WorldMap
     */

    /**
     * Calls GetWorldMap.
     * @function getWorldMap
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetWorldMapCallback} callback Node-style callback called with the error, if any, and WorldMap
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getWorldMap = function getWorldMap(request, callback) {
        return this.rpcCall(getWorldMap, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.WorldMap, request, callback);
    }, {"name": { value: "GetWorldMap" }, "FQDN": { value: "DFHackRPCService.GetWorldMap" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.WorldMap" }});

    /**
     * Calls GetWorldMap.
     * @function getWorldMap
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.WorldMap>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getWorldMapNew}.
     * @memberof DFHackRPCService
     * @typedef GetWorldMapNewCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.WorldMap} [response] WorldMap
     */

    /**
     * Calls GetWorldMapNew.
     * @function getWorldMapNew
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetWorldMapNewCallback} callback Node-style callback called with the error, if any, and WorldMap
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getWorldMapNew = function getWorldMapNew(request, callback) {
        return this.rpcCall(getWorldMapNew, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.WorldMap, request, callback);
    }, {"name": { value: "GetWorldMapNew" }, "FQDN": { value: "DFHackRPCService.GetWorldMapNew" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.WorldMap" }});

    /**
     * Calls GetWorldMapNew.
     * @function getWorldMapNew
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.WorldMap>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getRegionMaps}.
     * @memberof DFHackRPCService
     * @typedef GetRegionMapsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.RegionMaps} [response] RegionMaps
     */

    /**
     * Calls GetRegionMaps.
     * @function getRegionMaps
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetRegionMapsCallback} callback Node-style callback called with the error, if any, and RegionMaps
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getRegionMaps = function getRegionMaps(request, callback) {
        return this.rpcCall(getRegionMaps, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.RegionMaps, request, callback);
    }, {"name": { value: "GetRegionMaps" }, "FQDN": { value: "DFHackRPCService.GetRegionMaps" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.RegionMaps" }});

    /**
     * Calls GetRegionMaps.
     * @function getRegionMaps
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.RegionMaps>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getRegionMapsNew}.
     * @memberof DFHackRPCService
     * @typedef GetRegionMapsNewCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.RegionMaps} [response] RegionMaps
     */

    /**
     * Calls GetRegionMapsNew.
     * @function getRegionMapsNew
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetRegionMapsNewCallback} callback Node-style callback called with the error, if any, and RegionMaps
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getRegionMapsNew = function getRegionMapsNew(request, callback) {
        return this.rpcCall(getRegionMapsNew, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.RegionMaps, request, callback);
    }, {"name": { value: "GetRegionMapsNew" }, "FQDN": { value: "DFHackRPCService.GetRegionMapsNew" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.RegionMaps" }});

    /**
     * Calls GetRegionMapsNew.
     * @function getRegionMapsNew
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.RegionMaps>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getCreatureRaws}.
     * @memberof DFHackRPCService
     * @typedef GetCreatureRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.CreatureRawList} [response] CreatureRawList
     */

    /**
     * Calls GetCreatureRaws.
     * @function getCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetCreatureRawsCallback} callback Node-style callback called with the error, if any, and CreatureRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getCreatureRaws = function getCreatureRaws(request, callback) {
        return this.rpcCall(getCreatureRaws, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.CreatureRawList, request, callback);
    }, {"name": { value: "GetCreatureRaws" }, "FQDN": { value: "DFHackRPCService.GetCreatureRaws" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.CreatureRawList" }});

    /**
     * Calls GetCreatureRaws.
     * @function getCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.CreatureRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPartialCreatureRaws}.
     * @memberof DFHackRPCService
     * @typedef GetPartialCreatureRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.CreatureRawList} [response] CreatureRawList
     */

    /**
     * Calls GetPartialCreatureRaws.
     * @function getPartialCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @param {DFHackRPCService.GetPartialCreatureRawsCallback} callback Node-style callback called with the error, if any, and CreatureRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getPartialCreatureRaws = function getPartialCreatureRaws(request, callback) {
        return this.rpcCall(getPartialCreatureRaws, $root.RemoteFortressReader.ListRequest, $root.RemoteFortressReader.CreatureRawList, request, callback);
    }, {"name": { value: "GetPartialCreatureRaws" }, "FQDN": { value: "DFHackRPCService.GetPartialCreatureRaws" }, "requestFQDN": { value: "RemoteFortressReader.ListRequest" }, "responseFQDN": { value: "RemoteFortressReader.CreatureRawList" }});

    /**
     * Calls GetPartialCreatureRaws.
     * @function getPartialCreatureRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @returns {Promise<RemoteFortressReader.CreatureRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getWorldMapCenter}.
     * @memberof DFHackRPCService
     * @typedef GetWorldMapCenterCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.WorldMap} [response] WorldMap
     */

    /**
     * Calls GetWorldMapCenter.
     * @function getWorldMapCenter
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetWorldMapCenterCallback} callback Node-style callback called with the error, if any, and WorldMap
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getWorldMapCenter = function getWorldMapCenter(request, callback) {
        return this.rpcCall(getWorldMapCenter, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.WorldMap, request, callback);
    }, {"name": { value: "GetWorldMapCenter" }, "FQDN": { value: "DFHackRPCService.GetWorldMapCenter" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.WorldMap" }});

    /**
     * Calls GetWorldMapCenter.
     * @function getWorldMapCenter
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.WorldMap>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPlantRaws}.
     * @memberof DFHackRPCService
     * @typedef GetPlantRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.PlantRawList} [response] PlantRawList
     */

    /**
     * Calls GetPlantRaws.
     * @function getPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetPlantRawsCallback} callback Node-style callback called with the error, if any, and PlantRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getPlantRaws = function getPlantRaws(request, callback) {
        return this.rpcCall(getPlantRaws, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.PlantRawList, request, callback);
    }, {"name": { value: "GetPlantRaws" }, "FQDN": { value: "DFHackRPCService.GetPlantRaws" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.PlantRawList" }});

    /**
     * Calls GetPlantRaws.
     * @function getPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.PlantRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPartialPlantRaws}.
     * @memberof DFHackRPCService
     * @typedef GetPartialPlantRawsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.PlantRawList} [response] PlantRawList
     */

    /**
     * Calls GetPartialPlantRaws.
     * @function getPartialPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @param {DFHackRPCService.GetPartialPlantRawsCallback} callback Node-style callback called with the error, if any, and PlantRawList
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getPartialPlantRaws = function getPartialPlantRaws(request, callback) {
        return this.rpcCall(getPartialPlantRaws, $root.RemoteFortressReader.ListRequest, $root.RemoteFortressReader.PlantRawList, request, callback);
    }, {"name": { value: "GetPartialPlantRaws" }, "FQDN": { value: "DFHackRPCService.GetPartialPlantRaws" }, "requestFQDN": { value: "RemoteFortressReader.ListRequest" }, "responseFQDN": { value: "RemoteFortressReader.PlantRawList" }});

    /**
     * Calls GetPartialPlantRaws.
     * @function getPartialPlantRaws
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IListRequest} request ListRequest message or plain object
     * @returns {Promise<RemoteFortressReader.PlantRawList>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#copyScreen}.
     * @memberof DFHackRPCService
     * @typedef CopyScreenCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.ScreenCapture} [response] ScreenCapture
     */

    /**
     * Calls CopyScreen.
     * @function copyScreen
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.CopyScreenCallback} callback Node-style callback called with the error, if any, and ScreenCapture
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.copyScreen = function copyScreen(request, callback) {
        return this.rpcCall(copyScreen, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.ScreenCapture, request, callback);
    }, {"name": { value: "CopyScreen" }, "FQDN": { value: "DFHackRPCService.CopyScreen" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.ScreenCapture" }});

    /**
     * Calls CopyScreen.
     * @function copyScreen
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.ScreenCapture>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#passKeyboardEvent}.
     * @memberof DFHackRPCService
     * @typedef PassKeyboardEventCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls PassKeyboardEvent.
     * @function passKeyboardEvent
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IKeyboardEvent} request KeyboardEvent message or plain object
     * @param {DFHackRPCService.PassKeyboardEventCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.passKeyboardEvent = function passKeyboardEvent(request, callback) {
        return this.rpcCall(passKeyboardEvent, $root.RemoteFortressReader.KeyboardEvent, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "PassKeyboardEvent" }, "FQDN": { value: "DFHackRPCService.PassKeyboardEvent" }, "requestFQDN": { value: "RemoteFortressReader.KeyboardEvent" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls PassKeyboardEvent.
     * @function passKeyboardEvent
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IKeyboardEvent} request KeyboardEvent message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#sendDigCommand}.
     * @memberof DFHackRPCService
     * @typedef SendDigCommandCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls SendDigCommand.
     * @function sendDigCommand
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IDigCommand} request DigCommand message or plain object
     * @param {DFHackRPCService.SendDigCommandCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.sendDigCommand = function sendDigCommand(request, callback) {
        return this.rpcCall(sendDigCommand, $root.RemoteFortressReader.DigCommand, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "SendDigCommand" }, "FQDN": { value: "DFHackRPCService.SendDigCommand" }, "requestFQDN": { value: "RemoteFortressReader.DigCommand" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls SendDigCommand.
     * @function sendDigCommand
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.IDigCommand} request DigCommand message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#setPauseState}.
     * @memberof DFHackRPCService
     * @typedef SetPauseStateCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls SetPauseState.
     * @function setPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.ISingleBool} request SingleBool message or plain object
     * @param {DFHackRPCService.SetPauseStateCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.setPauseState = function setPauseState(request, callback) {
        return this.rpcCall(setPauseState, $root.RemoteFortressReader.SingleBool, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "SetPauseState" }, "FQDN": { value: "DFHackRPCService.SetPauseState" }, "requestFQDN": { value: "RemoteFortressReader.SingleBool" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls SetPauseState.
     * @function setPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {RemoteFortressReader.ISingleBool} request SingleBool message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getPauseState}.
     * @memberof DFHackRPCService
     * @typedef GetPauseStateCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.SingleBool} [response] SingleBool
     */

    /**
     * Calls GetPauseState.
     * @function getPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetPauseStateCallback} callback Node-style callback called with the error, if any, and SingleBool
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getPauseState = function getPauseState(request, callback) {
        return this.rpcCall(getPauseState, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.SingleBool, request, callback);
    }, {"name": { value: "GetPauseState" }, "FQDN": { value: "DFHackRPCService.GetPauseState" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.SingleBool" }});

    /**
     * Calls GetPauseState.
     * @function getPauseState
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.SingleBool>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getVersionInfo}.
     * @memberof DFHackRPCService
     * @typedef GetVersionInfoCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.VersionInfo} [response] VersionInfo
     */

    /**
     * Calls GetVersionInfo.
     * @function getVersionInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetVersionInfoCallback} callback Node-style callback called with the error, if any, and VersionInfo
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getVersionInfo = function getVersionInfo(request, callback) {
        return this.rpcCall(getVersionInfo, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.VersionInfo, request, callback);
    }, {"name": { value: "GetVersionInfo" }, "FQDN": { value: "DFHackRPCService.GetVersionInfo" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.VersionInfo" }});

    /**
     * Calls GetVersionInfo.
     * @function getVersionInfo
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.VersionInfo>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getReports}.
     * @memberof DFHackRPCService
     * @typedef GetReportsCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.Status} [response] Status
     */

    /**
     * Calls GetReports.
     * @function getReports
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetReportsCallback} callback Node-style callback called with the error, if any, and Status
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getReports = function getReports(request, callback) {
        return this.rpcCall(getReports, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.Status, request, callback);
    }, {"name": { value: "GetReports" }, "FQDN": { value: "DFHackRPCService.GetReports" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.Status" }});

    /**
     * Calls GetReports.
     * @function getReports
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.Status>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#getLanguage}.
     * @memberof DFHackRPCService
     * @typedef GetLanguageCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {RemoteFortressReader.Language} [response] Language
     */

    /**
     * Calls GetLanguage.
     * @function getLanguage
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @param {DFHackRPCService.GetLanguageCallback} callback Node-style callback called with the error, if any, and Language
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.getLanguage = function getLanguage(request, callback) {
        return this.rpcCall(getLanguage, $root.dfproto.EmptyMessage, $root.RemoteFortressReader.Language, request, callback);
    }, {"name": { value: "GetLanguage" }, "FQDN": { value: "DFHackRPCService.GetLanguage" }, "requestFQDN": { value: "dfproto.EmptyMessage" }, "responseFQDN": { value: "RemoteFortressReader.Language" }});

    /**
     * Calls GetLanguage.
     * @function getLanguage
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IEmptyMessage} request EmptyMessage message or plain object
     * @returns {Promise<RemoteFortressReader.Language>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#renameSquad}.
     * @memberof DFHackRPCService
     * @typedef RenameSquadCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls RenameSquad.
     * @function renameSquad
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameSquadIn} request RenameSquadIn message or plain object
     * @param {DFHackRPCService.RenameSquadCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.renameSquad = function renameSquad(request, callback) {
        return this.rpcCall(renameSquad, $root.dfproto.RenameSquadIn, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "RenameSquad" }, "FQDN": { value: "DFHackRPCService.RenameSquad" }, "requestFQDN": { value: "dfproto.RenameSquadIn" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls RenameSquad.
     * @function renameSquad
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameSquadIn} request RenameSquadIn message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#renameUnit}.
     * @memberof DFHackRPCService
     * @typedef RenameUnitCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls RenameUnit.
     * @function renameUnit
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameUnitIn} request RenameUnitIn message or plain object
     * @param {DFHackRPCService.RenameUnitCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.renameUnit = function renameUnit(request, callback) {
        return this.rpcCall(renameUnit, $root.dfproto.RenameUnitIn, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "RenameUnit" }, "FQDN": { value: "DFHackRPCService.RenameUnit" }, "requestFQDN": { value: "dfproto.RenameUnitIn" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls RenameUnit.
     * @function renameUnit
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameUnitIn} request RenameUnitIn message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link DFHackRPCService#renameBuilding}.
     * @memberof DFHackRPCService
     * @typedef RenameBuildingCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {dfproto.EmptyMessage} [response] EmptyMessage
     */

    /**
     * Calls RenameBuilding.
     * @function renameBuilding
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameBuildingIn} request RenameBuildingIn message or plain object
     * @param {DFHackRPCService.RenameBuildingCallback} callback Node-style callback called with the error, if any, and EmptyMessage
     * @returns {undefined}
     * @variation 1
     */
    Object.defineProperties(DFHackRPCService.prototype.renameBuilding = function renameBuilding(request, callback) {
        return this.rpcCall(renameBuilding, $root.dfproto.RenameBuildingIn, $root.dfproto.EmptyMessage, request, callback);
    }, {"name": { value: "RenameBuilding" }, "FQDN": { value: "DFHackRPCService.RenameBuilding" }, "requestFQDN": { value: "dfproto.RenameBuildingIn" }, "responseFQDN": { value: "dfproto.EmptyMessage" }});

    /**
     * Calls RenameBuilding.
     * @function renameBuilding
     * @memberof DFHackRPCService
     * @instance
     * @param {dfproto.IRenameBuildingIn} request RenameBuildingIn message or plain object
     * @returns {Promise<dfproto.EmptyMessage>} Promise
     * @variation 2
     */

    return DFHackRPCService;
})();

$root.dfproto = (function() {

    /**
     * Namespace dfproto.
     * @exports dfproto
     * @namespace
     */
    var dfproto = {};

    dfproto.GetWorldInfoOut = (function() {

        /**
         * Properties of a GetWorldInfoOut.
         * @memberof dfproto
         * @interface IGetWorldInfoOut
         * @property {dfproto.GetWorldInfoOut.Mode} mode GetWorldInfoOut mode
         * @property {string} saveDir GetWorldInfoOut saveDir
         * @property {dfproto.INameInfo|null} [worldName] GetWorldInfoOut worldName
         * @property {number|null} [civId] GetWorldInfoOut civId
         * @property {number|null} [siteId] GetWorldInfoOut siteId
         * @property {number|null} [groupId] GetWorldInfoOut groupId
         * @property {number|null} [raceId] GetWorldInfoOut raceId
         * @property {number|null} [playerUnitId] GetWorldInfoOut playerUnitId
         * @property {number|null} [playerHistfigId] GetWorldInfoOut playerHistfigId
         * @property {Array.<number>|null} [companionHistfigIds] GetWorldInfoOut companionHistfigIds
         */

        /**
         * Constructs a new GetWorldInfoOut.
         * @memberof dfproto
         * @classdesc Represents a GetWorldInfoOut.
         * @implements IGetWorldInfoOut
         * @constructor
         * @param {dfproto.IGetWorldInfoOut=} [properties] Properties to set
         */
        function GetWorldInfoOut(properties) {
            this.companionHistfigIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWorldInfoOut mode.
         * @member {dfproto.GetWorldInfoOut.Mode} mode
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.mode = 1;

        /**
         * GetWorldInfoOut saveDir.
         * @member {string} saveDir
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.saveDir = "";

        /**
         * GetWorldInfoOut worldName.
         * @member {dfproto.INameInfo|null|undefined} worldName
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.worldName = null;

        /**
         * GetWorldInfoOut civId.
         * @member {number} civId
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.civId = 0;

        /**
         * GetWorldInfoOut siteId.
         * @member {number} siteId
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.siteId = 0;

        /**
         * GetWorldInfoOut groupId.
         * @member {number} groupId
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.groupId = 0;

        /**
         * GetWorldInfoOut raceId.
         * @member {number} raceId
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.raceId = 0;

        /**
         * GetWorldInfoOut playerUnitId.
         * @member {number} playerUnitId
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.playerUnitId = 0;

        /**
         * GetWorldInfoOut playerHistfigId.
         * @member {number} playerHistfigId
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.playerHistfigId = 0;

        /**
         * GetWorldInfoOut companionHistfigIds.
         * @member {Array.<number>} companionHistfigIds
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         */
        GetWorldInfoOut.prototype.companionHistfigIds = $util.emptyArray;

        /**
         * Creates a new GetWorldInfoOut instance using the specified properties.
         * @function create
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {dfproto.IGetWorldInfoOut=} [properties] Properties to set
         * @returns {dfproto.GetWorldInfoOut} GetWorldInfoOut instance
         */
        GetWorldInfoOut.create = function create(properties) {
            return new GetWorldInfoOut(properties);
        };

        /**
         * Encodes the specified GetWorldInfoOut message. Does not implicitly {@link dfproto.GetWorldInfoOut.verify|verify} messages.
         * @function encode
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {dfproto.IGetWorldInfoOut} message GetWorldInfoOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorldInfoOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.saveDir);
            if (message.worldName != null && Object.hasOwnProperty.call(message, "worldName"))
                $root.dfproto.NameInfo.encode(message.worldName, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.civId != null && Object.hasOwnProperty.call(message, "civId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.civId);
            if (message.siteId != null && Object.hasOwnProperty.call(message, "siteId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.siteId);
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.groupId);
            if (message.raceId != null && Object.hasOwnProperty.call(message, "raceId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.raceId);
            if (message.playerUnitId != null && Object.hasOwnProperty.call(message, "playerUnitId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.playerUnitId);
            if (message.playerHistfigId != null && Object.hasOwnProperty.call(message, "playerHistfigId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.playerHistfigId);
            if (message.companionHistfigIds != null && message.companionHistfigIds.length)
                for (var i = 0; i < message.companionHistfigIds.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.companionHistfigIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GetWorldInfoOut message, length delimited. Does not implicitly {@link dfproto.GetWorldInfoOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {dfproto.IGetWorldInfoOut} message GetWorldInfoOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorldInfoOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWorldInfoOut message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.GetWorldInfoOut} GetWorldInfoOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorldInfoOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.GetWorldInfoOut();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                case 2:
                    message.saveDir = reader.string();
                    break;
                case 3:
                    message.worldName = $root.dfproto.NameInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.civId = reader.int32();
                    break;
                case 5:
                    message.siteId = reader.int32();
                    break;
                case 6:
                    message.groupId = reader.int32();
                    break;
                case 7:
                    message.raceId = reader.int32();
                    break;
                case 8:
                    message.playerUnitId = reader.int32();
                    break;
                case 9:
                    message.playerHistfigId = reader.int32();
                    break;
                case 10:
                    if (!(message.companionHistfigIds && message.companionHistfigIds.length))
                        message.companionHistfigIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.companionHistfigIds.push(reader.int32());
                    } else
                        message.companionHistfigIds.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("mode"))
                throw $util.ProtocolError("missing required 'mode'", { instance: message });
            if (!message.hasOwnProperty("saveDir"))
                throw $util.ProtocolError("missing required 'saveDir'", { instance: message });
            return message;
        };

        /**
         * Decodes a GetWorldInfoOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.GetWorldInfoOut} GetWorldInfoOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorldInfoOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWorldInfoOut message.
         * @function verify
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWorldInfoOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.mode) {
            default:
                return "mode: enum value expected";
            case 1:
            case 2:
            case 3:
                break;
            }
            if (!$util.isString(message.saveDir))
                return "saveDir: string expected";
            if (message.worldName != null && message.hasOwnProperty("worldName")) {
                var error = $root.dfproto.NameInfo.verify(message.worldName);
                if (error)
                    return "worldName." + error;
            }
            if (message.civId != null && message.hasOwnProperty("civId"))
                if (!$util.isInteger(message.civId))
                    return "civId: integer expected";
            if (message.siteId != null && message.hasOwnProperty("siteId"))
                if (!$util.isInteger(message.siteId))
                    return "siteId: integer expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isInteger(message.groupId))
                    return "groupId: integer expected";
            if (message.raceId != null && message.hasOwnProperty("raceId"))
                if (!$util.isInteger(message.raceId))
                    return "raceId: integer expected";
            if (message.playerUnitId != null && message.hasOwnProperty("playerUnitId"))
                if (!$util.isInteger(message.playerUnitId))
                    return "playerUnitId: integer expected";
            if (message.playerHistfigId != null && message.hasOwnProperty("playerHistfigId"))
                if (!$util.isInteger(message.playerHistfigId))
                    return "playerHistfigId: integer expected";
            if (message.companionHistfigIds != null && message.hasOwnProperty("companionHistfigIds")) {
                if (!Array.isArray(message.companionHistfigIds))
                    return "companionHistfigIds: array expected";
                for (var i = 0; i < message.companionHistfigIds.length; ++i)
                    if (!$util.isInteger(message.companionHistfigIds[i]))
                        return "companionHistfigIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a GetWorldInfoOut message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.GetWorldInfoOut} GetWorldInfoOut
         */
        GetWorldInfoOut.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.GetWorldInfoOut)
                return object;
            var message = new $root.dfproto.GetWorldInfoOut();
            switch (object.mode) {
            case "MODE_DWARF":
            case 1:
                message.mode = 1;
                break;
            case "MODE_ADVENTURE":
            case 2:
                message.mode = 2;
                break;
            case "MODE_LEGENDS":
            case 3:
                message.mode = 3;
                break;
            }
            if (object.saveDir != null)
                message.saveDir = String(object.saveDir);
            if (object.worldName != null) {
                if (typeof object.worldName !== "object")
                    throw TypeError(".dfproto.GetWorldInfoOut.worldName: object expected");
                message.worldName = $root.dfproto.NameInfo.fromObject(object.worldName);
            }
            if (object.civId != null)
                message.civId = object.civId | 0;
            if (object.siteId != null)
                message.siteId = object.siteId | 0;
            if (object.groupId != null)
                message.groupId = object.groupId | 0;
            if (object.raceId != null)
                message.raceId = object.raceId | 0;
            if (object.playerUnitId != null)
                message.playerUnitId = object.playerUnitId | 0;
            if (object.playerHistfigId != null)
                message.playerHistfigId = object.playerHistfigId | 0;
            if (object.companionHistfigIds) {
                if (!Array.isArray(object.companionHistfigIds))
                    throw TypeError(".dfproto.GetWorldInfoOut.companionHistfigIds: array expected");
                message.companionHistfigIds = [];
                for (var i = 0; i < object.companionHistfigIds.length; ++i)
                    message.companionHistfigIds[i] = object.companionHistfigIds[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetWorldInfoOut message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.GetWorldInfoOut
         * @static
         * @param {dfproto.GetWorldInfoOut} message GetWorldInfoOut
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetWorldInfoOut.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.companionHistfigIds = [];
            if (options.defaults) {
                object.mode = options.enums === String ? "MODE_DWARF" : 1;
                object.saveDir = "";
                object.worldName = null;
                object.civId = 0;
                object.siteId = 0;
                object.groupId = 0;
                object.raceId = 0;
                object.playerUnitId = 0;
                object.playerHistfigId = 0;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.dfproto.GetWorldInfoOut.Mode[message.mode] : message.mode;
            if (message.saveDir != null && message.hasOwnProperty("saveDir"))
                object.saveDir = message.saveDir;
            if (message.worldName != null && message.hasOwnProperty("worldName"))
                object.worldName = $root.dfproto.NameInfo.toObject(message.worldName, options);
            if (message.civId != null && message.hasOwnProperty("civId"))
                object.civId = message.civId;
            if (message.siteId != null && message.hasOwnProperty("siteId"))
                object.siteId = message.siteId;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.raceId != null && message.hasOwnProperty("raceId"))
                object.raceId = message.raceId;
            if (message.playerUnitId != null && message.hasOwnProperty("playerUnitId"))
                object.playerUnitId = message.playerUnitId;
            if (message.playerHistfigId != null && message.hasOwnProperty("playerHistfigId"))
                object.playerHistfigId = message.playerHistfigId;
            if (message.companionHistfigIds && message.companionHistfigIds.length) {
                object.companionHistfigIds = [];
                for (var j = 0; j < message.companionHistfigIds.length; ++j)
                    object.companionHistfigIds[j] = message.companionHistfigIds[j];
            }
            return object;
        };

        /**
         * Converts this GetWorldInfoOut to JSON.
         * @function toJSON
         * @memberof dfproto.GetWorldInfoOut
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetWorldInfoOut.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Mode enum.
         * @name dfproto.GetWorldInfoOut.Mode
         * @enum {string}
         * @property {number} MODE_DWARF=1 MODE_DWARF value
         * @property {number} MODE_ADVENTURE=2 MODE_ADVENTURE value
         * @property {number} MODE_LEGENDS=3 MODE_LEGENDS value
         */
        GetWorldInfoOut.Mode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MODE_DWARF"] = 1;
            values[valuesById[2] = "MODE_ADVENTURE"] = 2;
            values[valuesById[3] = "MODE_LEGENDS"] = 3;
            return values;
        })();

        return GetWorldInfoOut;
    })();

    dfproto.ListEnumsOut = (function() {

        /**
         * Properties of a ListEnumsOut.
         * @memberof dfproto
         * @interface IListEnumsOut
         * @property {Array.<dfproto.IEnumItemName>|null} [materialFlags] ListEnumsOut materialFlags
         * @property {Array.<dfproto.IEnumItemName>|null} [inorganicFlags] ListEnumsOut inorganicFlags
         * @property {Array.<dfproto.IEnumItemName>|null} [unitFlags1] ListEnumsOut unitFlags1
         * @property {Array.<dfproto.IEnumItemName>|null} [unitFlags2] ListEnumsOut unitFlags2
         * @property {Array.<dfproto.IEnumItemName>|null} [unitFlags3] ListEnumsOut unitFlags3
         * @property {Array.<dfproto.IEnumItemName>|null} [unitLabor] ListEnumsOut unitLabor
         * @property {Array.<dfproto.IEnumItemName>|null} [jobSkill] ListEnumsOut jobSkill
         * @property {Array.<dfproto.IEnumItemName>|null} [cieAddTagMask1] ListEnumsOut cieAddTagMask1
         * @property {Array.<dfproto.IEnumItemName>|null} [cieAddTagMask2] ListEnumsOut cieAddTagMask2
         * @property {Array.<dfproto.IEnumItemName>|null} [deathInfoFlags] ListEnumsOut deathInfoFlags
         * @property {Array.<dfproto.IEnumItemName>|null} [profession] ListEnumsOut profession
         */

        /**
         * Constructs a new ListEnumsOut.
         * @memberof dfproto
         * @classdesc Represents a ListEnumsOut.
         * @implements IListEnumsOut
         * @constructor
         * @param {dfproto.IListEnumsOut=} [properties] Properties to set
         */
        function ListEnumsOut(properties) {
            this.materialFlags = [];
            this.inorganicFlags = [];
            this.unitFlags1 = [];
            this.unitFlags2 = [];
            this.unitFlags3 = [];
            this.unitLabor = [];
            this.jobSkill = [];
            this.cieAddTagMask1 = [];
            this.cieAddTagMask2 = [];
            this.deathInfoFlags = [];
            this.profession = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListEnumsOut materialFlags.
         * @member {Array.<dfproto.IEnumItemName>} materialFlags
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.materialFlags = $util.emptyArray;

        /**
         * ListEnumsOut inorganicFlags.
         * @member {Array.<dfproto.IEnumItemName>} inorganicFlags
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.inorganicFlags = $util.emptyArray;

        /**
         * ListEnumsOut unitFlags1.
         * @member {Array.<dfproto.IEnumItemName>} unitFlags1
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.unitFlags1 = $util.emptyArray;

        /**
         * ListEnumsOut unitFlags2.
         * @member {Array.<dfproto.IEnumItemName>} unitFlags2
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.unitFlags2 = $util.emptyArray;

        /**
         * ListEnumsOut unitFlags3.
         * @member {Array.<dfproto.IEnumItemName>} unitFlags3
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.unitFlags3 = $util.emptyArray;

        /**
         * ListEnumsOut unitLabor.
         * @member {Array.<dfproto.IEnumItemName>} unitLabor
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.unitLabor = $util.emptyArray;

        /**
         * ListEnumsOut jobSkill.
         * @member {Array.<dfproto.IEnumItemName>} jobSkill
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.jobSkill = $util.emptyArray;

        /**
         * ListEnumsOut cieAddTagMask1.
         * @member {Array.<dfproto.IEnumItemName>} cieAddTagMask1
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.cieAddTagMask1 = $util.emptyArray;

        /**
         * ListEnumsOut cieAddTagMask2.
         * @member {Array.<dfproto.IEnumItemName>} cieAddTagMask2
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.cieAddTagMask2 = $util.emptyArray;

        /**
         * ListEnumsOut deathInfoFlags.
         * @member {Array.<dfproto.IEnumItemName>} deathInfoFlags
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.deathInfoFlags = $util.emptyArray;

        /**
         * ListEnumsOut profession.
         * @member {Array.<dfproto.IEnumItemName>} profession
         * @memberof dfproto.ListEnumsOut
         * @instance
         */
        ListEnumsOut.prototype.profession = $util.emptyArray;

        /**
         * Creates a new ListEnumsOut instance using the specified properties.
         * @function create
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {dfproto.IListEnumsOut=} [properties] Properties to set
         * @returns {dfproto.ListEnumsOut} ListEnumsOut instance
         */
        ListEnumsOut.create = function create(properties) {
            return new ListEnumsOut(properties);
        };

        /**
         * Encodes the specified ListEnumsOut message. Does not implicitly {@link dfproto.ListEnumsOut.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {dfproto.IListEnumsOut} message ListEnumsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListEnumsOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.materialFlags != null && message.materialFlags.length)
                for (var i = 0; i < message.materialFlags.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.materialFlags[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.inorganicFlags != null && message.inorganicFlags.length)
                for (var i = 0; i < message.inorganicFlags.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.inorganicFlags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.unitFlags1 != null && message.unitFlags1.length)
                for (var i = 0; i < message.unitFlags1.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.unitFlags1[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.unitFlags2 != null && message.unitFlags2.length)
                for (var i = 0; i < message.unitFlags2.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.unitFlags2[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.unitFlags3 != null && message.unitFlags3.length)
                for (var i = 0; i < message.unitFlags3.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.unitFlags3[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.unitLabor != null && message.unitLabor.length)
                for (var i = 0; i < message.unitLabor.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.unitLabor[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.jobSkill != null && message.jobSkill.length)
                for (var i = 0; i < message.jobSkill.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.jobSkill[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.cieAddTagMask1 != null && message.cieAddTagMask1.length)
                for (var i = 0; i < message.cieAddTagMask1.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.cieAddTagMask1[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.cieAddTagMask2 != null && message.cieAddTagMask2.length)
                for (var i = 0; i < message.cieAddTagMask2.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.cieAddTagMask2[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.deathInfoFlags != null && message.deathInfoFlags.length)
                for (var i = 0; i < message.deathInfoFlags.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.deathInfoFlags[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.profession != null && message.profession.length)
                for (var i = 0; i < message.profession.length; ++i)
                    $root.dfproto.EnumItemName.encode(message.profession[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListEnumsOut message, length delimited. Does not implicitly {@link dfproto.ListEnumsOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {dfproto.IListEnumsOut} message ListEnumsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListEnumsOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListEnumsOut message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListEnumsOut} ListEnumsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListEnumsOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListEnumsOut();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.materialFlags && message.materialFlags.length))
                        message.materialFlags = [];
                    message.materialFlags.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.inorganicFlags && message.inorganicFlags.length))
                        message.inorganicFlags = [];
                    message.inorganicFlags.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.unitFlags1 && message.unitFlags1.length))
                        message.unitFlags1 = [];
                    message.unitFlags1.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.unitFlags2 && message.unitFlags2.length))
                        message.unitFlags2 = [];
                    message.unitFlags2.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.unitFlags3 && message.unitFlags3.length))
                        message.unitFlags3 = [];
                    message.unitFlags3.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.unitLabor && message.unitLabor.length))
                        message.unitLabor = [];
                    message.unitLabor.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.jobSkill && message.jobSkill.length))
                        message.jobSkill = [];
                    message.jobSkill.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.cieAddTagMask1 && message.cieAddTagMask1.length))
                        message.cieAddTagMask1 = [];
                    message.cieAddTagMask1.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.cieAddTagMask2 && message.cieAddTagMask2.length))
                        message.cieAddTagMask2 = [];
                    message.cieAddTagMask2.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.deathInfoFlags && message.deathInfoFlags.length))
                        message.deathInfoFlags = [];
                    message.deathInfoFlags.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.profession && message.profession.length))
                        message.profession = [];
                    message.profession.push($root.dfproto.EnumItemName.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListEnumsOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListEnumsOut} ListEnumsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListEnumsOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListEnumsOut message.
         * @function verify
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListEnumsOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.materialFlags != null && message.hasOwnProperty("materialFlags")) {
                if (!Array.isArray(message.materialFlags))
                    return "materialFlags: array expected";
                for (var i = 0; i < message.materialFlags.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.materialFlags[i]);
                    if (error)
                        return "materialFlags." + error;
                }
            }
            if (message.inorganicFlags != null && message.hasOwnProperty("inorganicFlags")) {
                if (!Array.isArray(message.inorganicFlags))
                    return "inorganicFlags: array expected";
                for (var i = 0; i < message.inorganicFlags.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.inorganicFlags[i]);
                    if (error)
                        return "inorganicFlags." + error;
                }
            }
            if (message.unitFlags1 != null && message.hasOwnProperty("unitFlags1")) {
                if (!Array.isArray(message.unitFlags1))
                    return "unitFlags1: array expected";
                for (var i = 0; i < message.unitFlags1.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.unitFlags1[i]);
                    if (error)
                        return "unitFlags1." + error;
                }
            }
            if (message.unitFlags2 != null && message.hasOwnProperty("unitFlags2")) {
                if (!Array.isArray(message.unitFlags2))
                    return "unitFlags2: array expected";
                for (var i = 0; i < message.unitFlags2.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.unitFlags2[i]);
                    if (error)
                        return "unitFlags2." + error;
                }
            }
            if (message.unitFlags3 != null && message.hasOwnProperty("unitFlags3")) {
                if (!Array.isArray(message.unitFlags3))
                    return "unitFlags3: array expected";
                for (var i = 0; i < message.unitFlags3.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.unitFlags3[i]);
                    if (error)
                        return "unitFlags3." + error;
                }
            }
            if (message.unitLabor != null && message.hasOwnProperty("unitLabor")) {
                if (!Array.isArray(message.unitLabor))
                    return "unitLabor: array expected";
                for (var i = 0; i < message.unitLabor.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.unitLabor[i]);
                    if (error)
                        return "unitLabor." + error;
                }
            }
            if (message.jobSkill != null && message.hasOwnProperty("jobSkill")) {
                if (!Array.isArray(message.jobSkill))
                    return "jobSkill: array expected";
                for (var i = 0; i < message.jobSkill.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.jobSkill[i]);
                    if (error)
                        return "jobSkill." + error;
                }
            }
            if (message.cieAddTagMask1 != null && message.hasOwnProperty("cieAddTagMask1")) {
                if (!Array.isArray(message.cieAddTagMask1))
                    return "cieAddTagMask1: array expected";
                for (var i = 0; i < message.cieAddTagMask1.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.cieAddTagMask1[i]);
                    if (error)
                        return "cieAddTagMask1." + error;
                }
            }
            if (message.cieAddTagMask2 != null && message.hasOwnProperty("cieAddTagMask2")) {
                if (!Array.isArray(message.cieAddTagMask2))
                    return "cieAddTagMask2: array expected";
                for (var i = 0; i < message.cieAddTagMask2.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.cieAddTagMask2[i]);
                    if (error)
                        return "cieAddTagMask2." + error;
                }
            }
            if (message.deathInfoFlags != null && message.hasOwnProperty("deathInfoFlags")) {
                if (!Array.isArray(message.deathInfoFlags))
                    return "deathInfoFlags: array expected";
                for (var i = 0; i < message.deathInfoFlags.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.deathInfoFlags[i]);
                    if (error)
                        return "deathInfoFlags." + error;
                }
            }
            if (message.profession != null && message.hasOwnProperty("profession")) {
                if (!Array.isArray(message.profession))
                    return "profession: array expected";
                for (var i = 0; i < message.profession.length; ++i) {
                    var error = $root.dfproto.EnumItemName.verify(message.profession[i]);
                    if (error)
                        return "profession." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListEnumsOut message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListEnumsOut} ListEnumsOut
         */
        ListEnumsOut.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListEnumsOut)
                return object;
            var message = new $root.dfproto.ListEnumsOut();
            if (object.materialFlags) {
                if (!Array.isArray(object.materialFlags))
                    throw TypeError(".dfproto.ListEnumsOut.materialFlags: array expected");
                message.materialFlags = [];
                for (var i = 0; i < object.materialFlags.length; ++i) {
                    if (typeof object.materialFlags[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.materialFlags: object expected");
                    message.materialFlags[i] = $root.dfproto.EnumItemName.fromObject(object.materialFlags[i]);
                }
            }
            if (object.inorganicFlags) {
                if (!Array.isArray(object.inorganicFlags))
                    throw TypeError(".dfproto.ListEnumsOut.inorganicFlags: array expected");
                message.inorganicFlags = [];
                for (var i = 0; i < object.inorganicFlags.length; ++i) {
                    if (typeof object.inorganicFlags[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.inorganicFlags: object expected");
                    message.inorganicFlags[i] = $root.dfproto.EnumItemName.fromObject(object.inorganicFlags[i]);
                }
            }
            if (object.unitFlags1) {
                if (!Array.isArray(object.unitFlags1))
                    throw TypeError(".dfproto.ListEnumsOut.unitFlags1: array expected");
                message.unitFlags1 = [];
                for (var i = 0; i < object.unitFlags1.length; ++i) {
                    if (typeof object.unitFlags1[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.unitFlags1: object expected");
                    message.unitFlags1[i] = $root.dfproto.EnumItemName.fromObject(object.unitFlags1[i]);
                }
            }
            if (object.unitFlags2) {
                if (!Array.isArray(object.unitFlags2))
                    throw TypeError(".dfproto.ListEnumsOut.unitFlags2: array expected");
                message.unitFlags2 = [];
                for (var i = 0; i < object.unitFlags2.length; ++i) {
                    if (typeof object.unitFlags2[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.unitFlags2: object expected");
                    message.unitFlags2[i] = $root.dfproto.EnumItemName.fromObject(object.unitFlags2[i]);
                }
            }
            if (object.unitFlags3) {
                if (!Array.isArray(object.unitFlags3))
                    throw TypeError(".dfproto.ListEnumsOut.unitFlags3: array expected");
                message.unitFlags3 = [];
                for (var i = 0; i < object.unitFlags3.length; ++i) {
                    if (typeof object.unitFlags3[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.unitFlags3: object expected");
                    message.unitFlags3[i] = $root.dfproto.EnumItemName.fromObject(object.unitFlags3[i]);
                }
            }
            if (object.unitLabor) {
                if (!Array.isArray(object.unitLabor))
                    throw TypeError(".dfproto.ListEnumsOut.unitLabor: array expected");
                message.unitLabor = [];
                for (var i = 0; i < object.unitLabor.length; ++i) {
                    if (typeof object.unitLabor[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.unitLabor: object expected");
                    message.unitLabor[i] = $root.dfproto.EnumItemName.fromObject(object.unitLabor[i]);
                }
            }
            if (object.jobSkill) {
                if (!Array.isArray(object.jobSkill))
                    throw TypeError(".dfproto.ListEnumsOut.jobSkill: array expected");
                message.jobSkill = [];
                for (var i = 0; i < object.jobSkill.length; ++i) {
                    if (typeof object.jobSkill[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.jobSkill: object expected");
                    message.jobSkill[i] = $root.dfproto.EnumItemName.fromObject(object.jobSkill[i]);
                }
            }
            if (object.cieAddTagMask1) {
                if (!Array.isArray(object.cieAddTagMask1))
                    throw TypeError(".dfproto.ListEnumsOut.cieAddTagMask1: array expected");
                message.cieAddTagMask1 = [];
                for (var i = 0; i < object.cieAddTagMask1.length; ++i) {
                    if (typeof object.cieAddTagMask1[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.cieAddTagMask1: object expected");
                    message.cieAddTagMask1[i] = $root.dfproto.EnumItemName.fromObject(object.cieAddTagMask1[i]);
                }
            }
            if (object.cieAddTagMask2) {
                if (!Array.isArray(object.cieAddTagMask2))
                    throw TypeError(".dfproto.ListEnumsOut.cieAddTagMask2: array expected");
                message.cieAddTagMask2 = [];
                for (var i = 0; i < object.cieAddTagMask2.length; ++i) {
                    if (typeof object.cieAddTagMask2[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.cieAddTagMask2: object expected");
                    message.cieAddTagMask2[i] = $root.dfproto.EnumItemName.fromObject(object.cieAddTagMask2[i]);
                }
            }
            if (object.deathInfoFlags) {
                if (!Array.isArray(object.deathInfoFlags))
                    throw TypeError(".dfproto.ListEnumsOut.deathInfoFlags: array expected");
                message.deathInfoFlags = [];
                for (var i = 0; i < object.deathInfoFlags.length; ++i) {
                    if (typeof object.deathInfoFlags[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.deathInfoFlags: object expected");
                    message.deathInfoFlags[i] = $root.dfproto.EnumItemName.fromObject(object.deathInfoFlags[i]);
                }
            }
            if (object.profession) {
                if (!Array.isArray(object.profession))
                    throw TypeError(".dfproto.ListEnumsOut.profession: array expected");
                message.profession = [];
                for (var i = 0; i < object.profession.length; ++i) {
                    if (typeof object.profession[i] !== "object")
                        throw TypeError(".dfproto.ListEnumsOut.profession: object expected");
                    message.profession[i] = $root.dfproto.EnumItemName.fromObject(object.profession[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListEnumsOut message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListEnumsOut
         * @static
         * @param {dfproto.ListEnumsOut} message ListEnumsOut
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListEnumsOut.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.materialFlags = [];
                object.inorganicFlags = [];
                object.unitFlags1 = [];
                object.unitFlags2 = [];
                object.unitFlags3 = [];
                object.unitLabor = [];
                object.jobSkill = [];
                object.cieAddTagMask1 = [];
                object.cieAddTagMask2 = [];
                object.deathInfoFlags = [];
                object.profession = [];
            }
            if (message.materialFlags && message.materialFlags.length) {
                object.materialFlags = [];
                for (var j = 0; j < message.materialFlags.length; ++j)
                    object.materialFlags[j] = $root.dfproto.EnumItemName.toObject(message.materialFlags[j], options);
            }
            if (message.inorganicFlags && message.inorganicFlags.length) {
                object.inorganicFlags = [];
                for (var j = 0; j < message.inorganicFlags.length; ++j)
                    object.inorganicFlags[j] = $root.dfproto.EnumItemName.toObject(message.inorganicFlags[j], options);
            }
            if (message.unitFlags1 && message.unitFlags1.length) {
                object.unitFlags1 = [];
                for (var j = 0; j < message.unitFlags1.length; ++j)
                    object.unitFlags1[j] = $root.dfproto.EnumItemName.toObject(message.unitFlags1[j], options);
            }
            if (message.unitFlags2 && message.unitFlags2.length) {
                object.unitFlags2 = [];
                for (var j = 0; j < message.unitFlags2.length; ++j)
                    object.unitFlags2[j] = $root.dfproto.EnumItemName.toObject(message.unitFlags2[j], options);
            }
            if (message.unitFlags3 && message.unitFlags3.length) {
                object.unitFlags3 = [];
                for (var j = 0; j < message.unitFlags3.length; ++j)
                    object.unitFlags3[j] = $root.dfproto.EnumItemName.toObject(message.unitFlags3[j], options);
            }
            if (message.unitLabor && message.unitLabor.length) {
                object.unitLabor = [];
                for (var j = 0; j < message.unitLabor.length; ++j)
                    object.unitLabor[j] = $root.dfproto.EnumItemName.toObject(message.unitLabor[j], options);
            }
            if (message.jobSkill && message.jobSkill.length) {
                object.jobSkill = [];
                for (var j = 0; j < message.jobSkill.length; ++j)
                    object.jobSkill[j] = $root.dfproto.EnumItemName.toObject(message.jobSkill[j], options);
            }
            if (message.cieAddTagMask1 && message.cieAddTagMask1.length) {
                object.cieAddTagMask1 = [];
                for (var j = 0; j < message.cieAddTagMask1.length; ++j)
                    object.cieAddTagMask1[j] = $root.dfproto.EnumItemName.toObject(message.cieAddTagMask1[j], options);
            }
            if (message.cieAddTagMask2 && message.cieAddTagMask2.length) {
                object.cieAddTagMask2 = [];
                for (var j = 0; j < message.cieAddTagMask2.length; ++j)
                    object.cieAddTagMask2[j] = $root.dfproto.EnumItemName.toObject(message.cieAddTagMask2[j], options);
            }
            if (message.deathInfoFlags && message.deathInfoFlags.length) {
                object.deathInfoFlags = [];
                for (var j = 0; j < message.deathInfoFlags.length; ++j)
                    object.deathInfoFlags[j] = $root.dfproto.EnumItemName.toObject(message.deathInfoFlags[j], options);
            }
            if (message.profession && message.profession.length) {
                object.profession = [];
                for (var j = 0; j < message.profession.length; ++j)
                    object.profession[j] = $root.dfproto.EnumItemName.toObject(message.profession[j], options);
            }
            return object;
        };

        /**
         * Converts this ListEnumsOut to JSON.
         * @function toJSON
         * @memberof dfproto.ListEnumsOut
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListEnumsOut.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListEnumsOut;
    })();

    dfproto.ListJobSkillsOut = (function() {

        /**
         * Properties of a ListJobSkillsOut.
         * @memberof dfproto
         * @interface IListJobSkillsOut
         * @property {Array.<dfproto.IJobSkillAttr>|null} [skill] ListJobSkillsOut skill
         * @property {Array.<dfproto.IProfessionAttr>|null} [profession] ListJobSkillsOut profession
         * @property {Array.<dfproto.IUnitLaborAttr>|null} [labor] ListJobSkillsOut labor
         */

        /**
         * Constructs a new ListJobSkillsOut.
         * @memberof dfproto
         * @classdesc Represents a ListJobSkillsOut.
         * @implements IListJobSkillsOut
         * @constructor
         * @param {dfproto.IListJobSkillsOut=} [properties] Properties to set
         */
        function ListJobSkillsOut(properties) {
            this.skill = [];
            this.profession = [];
            this.labor = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListJobSkillsOut skill.
         * @member {Array.<dfproto.IJobSkillAttr>} skill
         * @memberof dfproto.ListJobSkillsOut
         * @instance
         */
        ListJobSkillsOut.prototype.skill = $util.emptyArray;

        /**
         * ListJobSkillsOut profession.
         * @member {Array.<dfproto.IProfessionAttr>} profession
         * @memberof dfproto.ListJobSkillsOut
         * @instance
         */
        ListJobSkillsOut.prototype.profession = $util.emptyArray;

        /**
         * ListJobSkillsOut labor.
         * @member {Array.<dfproto.IUnitLaborAttr>} labor
         * @memberof dfproto.ListJobSkillsOut
         * @instance
         */
        ListJobSkillsOut.prototype.labor = $util.emptyArray;

        /**
         * Creates a new ListJobSkillsOut instance using the specified properties.
         * @function create
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {dfproto.IListJobSkillsOut=} [properties] Properties to set
         * @returns {dfproto.ListJobSkillsOut} ListJobSkillsOut instance
         */
        ListJobSkillsOut.create = function create(properties) {
            return new ListJobSkillsOut(properties);
        };

        /**
         * Encodes the specified ListJobSkillsOut message. Does not implicitly {@link dfproto.ListJobSkillsOut.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {dfproto.IListJobSkillsOut} message ListJobSkillsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListJobSkillsOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.skill != null && message.skill.length)
                for (var i = 0; i < message.skill.length; ++i)
                    $root.dfproto.JobSkillAttr.encode(message.skill[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.profession != null && message.profession.length)
                for (var i = 0; i < message.profession.length; ++i)
                    $root.dfproto.ProfessionAttr.encode(message.profession[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.labor != null && message.labor.length)
                for (var i = 0; i < message.labor.length; ++i)
                    $root.dfproto.UnitLaborAttr.encode(message.labor[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListJobSkillsOut message, length delimited. Does not implicitly {@link dfproto.ListJobSkillsOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {dfproto.IListJobSkillsOut} message ListJobSkillsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListJobSkillsOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListJobSkillsOut message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListJobSkillsOut} ListJobSkillsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListJobSkillsOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListJobSkillsOut();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.skill && message.skill.length))
                        message.skill = [];
                    message.skill.push($root.dfproto.JobSkillAttr.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.profession && message.profession.length))
                        message.profession = [];
                    message.profession.push($root.dfproto.ProfessionAttr.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.labor && message.labor.length))
                        message.labor = [];
                    message.labor.push($root.dfproto.UnitLaborAttr.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListJobSkillsOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListJobSkillsOut} ListJobSkillsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListJobSkillsOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListJobSkillsOut message.
         * @function verify
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListJobSkillsOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.skill != null && message.hasOwnProperty("skill")) {
                if (!Array.isArray(message.skill))
                    return "skill: array expected";
                for (var i = 0; i < message.skill.length; ++i) {
                    var error = $root.dfproto.JobSkillAttr.verify(message.skill[i]);
                    if (error)
                        return "skill." + error;
                }
            }
            if (message.profession != null && message.hasOwnProperty("profession")) {
                if (!Array.isArray(message.profession))
                    return "profession: array expected";
                for (var i = 0; i < message.profession.length; ++i) {
                    var error = $root.dfproto.ProfessionAttr.verify(message.profession[i]);
                    if (error)
                        return "profession." + error;
                }
            }
            if (message.labor != null && message.hasOwnProperty("labor")) {
                if (!Array.isArray(message.labor))
                    return "labor: array expected";
                for (var i = 0; i < message.labor.length; ++i) {
                    var error = $root.dfproto.UnitLaborAttr.verify(message.labor[i]);
                    if (error)
                        return "labor." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListJobSkillsOut message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListJobSkillsOut} ListJobSkillsOut
         */
        ListJobSkillsOut.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListJobSkillsOut)
                return object;
            var message = new $root.dfproto.ListJobSkillsOut();
            if (object.skill) {
                if (!Array.isArray(object.skill))
                    throw TypeError(".dfproto.ListJobSkillsOut.skill: array expected");
                message.skill = [];
                for (var i = 0; i < object.skill.length; ++i) {
                    if (typeof object.skill[i] !== "object")
                        throw TypeError(".dfproto.ListJobSkillsOut.skill: object expected");
                    message.skill[i] = $root.dfproto.JobSkillAttr.fromObject(object.skill[i]);
                }
            }
            if (object.profession) {
                if (!Array.isArray(object.profession))
                    throw TypeError(".dfproto.ListJobSkillsOut.profession: array expected");
                message.profession = [];
                for (var i = 0; i < object.profession.length; ++i) {
                    if (typeof object.profession[i] !== "object")
                        throw TypeError(".dfproto.ListJobSkillsOut.profession: object expected");
                    message.profession[i] = $root.dfproto.ProfessionAttr.fromObject(object.profession[i]);
                }
            }
            if (object.labor) {
                if (!Array.isArray(object.labor))
                    throw TypeError(".dfproto.ListJobSkillsOut.labor: array expected");
                message.labor = [];
                for (var i = 0; i < object.labor.length; ++i) {
                    if (typeof object.labor[i] !== "object")
                        throw TypeError(".dfproto.ListJobSkillsOut.labor: object expected");
                    message.labor[i] = $root.dfproto.UnitLaborAttr.fromObject(object.labor[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListJobSkillsOut message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListJobSkillsOut
         * @static
         * @param {dfproto.ListJobSkillsOut} message ListJobSkillsOut
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListJobSkillsOut.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.skill = [];
                object.profession = [];
                object.labor = [];
            }
            if (message.skill && message.skill.length) {
                object.skill = [];
                for (var j = 0; j < message.skill.length; ++j)
                    object.skill[j] = $root.dfproto.JobSkillAttr.toObject(message.skill[j], options);
            }
            if (message.profession && message.profession.length) {
                object.profession = [];
                for (var j = 0; j < message.profession.length; ++j)
                    object.profession[j] = $root.dfproto.ProfessionAttr.toObject(message.profession[j], options);
            }
            if (message.labor && message.labor.length) {
                object.labor = [];
                for (var j = 0; j < message.labor.length; ++j)
                    object.labor[j] = $root.dfproto.UnitLaborAttr.toObject(message.labor[j], options);
            }
            return object;
        };

        /**
         * Converts this ListJobSkillsOut to JSON.
         * @function toJSON
         * @memberof dfproto.ListJobSkillsOut
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListJobSkillsOut.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListJobSkillsOut;
    })();

    dfproto.ListMaterialsIn = (function() {

        /**
         * Properties of a ListMaterialsIn.
         * @memberof dfproto
         * @interface IListMaterialsIn
         * @property {dfproto.IBasicMaterialInfoMask|null} [mask] ListMaterialsIn mask
         * @property {Array.<dfproto.IBasicMaterialId>|null} [idList] ListMaterialsIn idList
         * @property {boolean|null} [builtin] ListMaterialsIn builtin
         * @property {boolean|null} [inorganic] ListMaterialsIn inorganic
         * @property {boolean|null} [creatures] ListMaterialsIn creatures
         * @property {boolean|null} [plants] ListMaterialsIn plants
         */

        /**
         * Constructs a new ListMaterialsIn.
         * @memberof dfproto
         * @classdesc Represents a ListMaterialsIn.
         * @implements IListMaterialsIn
         * @constructor
         * @param {dfproto.IListMaterialsIn=} [properties] Properties to set
         */
        function ListMaterialsIn(properties) {
            this.idList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListMaterialsIn mask.
         * @member {dfproto.IBasicMaterialInfoMask|null|undefined} mask
         * @memberof dfproto.ListMaterialsIn
         * @instance
         */
        ListMaterialsIn.prototype.mask = null;

        /**
         * ListMaterialsIn idList.
         * @member {Array.<dfproto.IBasicMaterialId>} idList
         * @memberof dfproto.ListMaterialsIn
         * @instance
         */
        ListMaterialsIn.prototype.idList = $util.emptyArray;

        /**
         * ListMaterialsIn builtin.
         * @member {boolean} builtin
         * @memberof dfproto.ListMaterialsIn
         * @instance
         */
        ListMaterialsIn.prototype.builtin = false;

        /**
         * ListMaterialsIn inorganic.
         * @member {boolean} inorganic
         * @memberof dfproto.ListMaterialsIn
         * @instance
         */
        ListMaterialsIn.prototype.inorganic = false;

        /**
         * ListMaterialsIn creatures.
         * @member {boolean} creatures
         * @memberof dfproto.ListMaterialsIn
         * @instance
         */
        ListMaterialsIn.prototype.creatures = false;

        /**
         * ListMaterialsIn plants.
         * @member {boolean} plants
         * @memberof dfproto.ListMaterialsIn
         * @instance
         */
        ListMaterialsIn.prototype.plants = false;

        /**
         * Creates a new ListMaterialsIn instance using the specified properties.
         * @function create
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {dfproto.IListMaterialsIn=} [properties] Properties to set
         * @returns {dfproto.ListMaterialsIn} ListMaterialsIn instance
         */
        ListMaterialsIn.create = function create(properties) {
            return new ListMaterialsIn(properties);
        };

        /**
         * Encodes the specified ListMaterialsIn message. Does not implicitly {@link dfproto.ListMaterialsIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {dfproto.IListMaterialsIn} message ListMaterialsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMaterialsIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mask != null && Object.hasOwnProperty.call(message, "mask"))
                $root.dfproto.BasicMaterialInfoMask.encode(message.mask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.idList != null && message.idList.length)
                for (var i = 0; i < message.idList.length; ++i)
                    $root.dfproto.BasicMaterialId.encode(message.idList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.builtin != null && Object.hasOwnProperty.call(message, "builtin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.builtin);
            if (message.inorganic != null && Object.hasOwnProperty.call(message, "inorganic"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.inorganic);
            if (message.creatures != null && Object.hasOwnProperty.call(message, "creatures"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.creatures);
            if (message.plants != null && Object.hasOwnProperty.call(message, "plants"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.plants);
            return writer;
        };

        /**
         * Encodes the specified ListMaterialsIn message, length delimited. Does not implicitly {@link dfproto.ListMaterialsIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {dfproto.IListMaterialsIn} message ListMaterialsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMaterialsIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListMaterialsIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListMaterialsIn} ListMaterialsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMaterialsIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListMaterialsIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mask = $root.dfproto.BasicMaterialInfoMask.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.idList && message.idList.length))
                        message.idList = [];
                    message.idList.push($root.dfproto.BasicMaterialId.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.builtin = reader.bool();
                    break;
                case 4:
                    message.inorganic = reader.bool();
                    break;
                case 5:
                    message.creatures = reader.bool();
                    break;
                case 6:
                    message.plants = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListMaterialsIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListMaterialsIn} ListMaterialsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMaterialsIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListMaterialsIn message.
         * @function verify
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListMaterialsIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mask != null && message.hasOwnProperty("mask")) {
                var error = $root.dfproto.BasicMaterialInfoMask.verify(message.mask);
                if (error)
                    return "mask." + error;
            }
            if (message.idList != null && message.hasOwnProperty("idList")) {
                if (!Array.isArray(message.idList))
                    return "idList: array expected";
                for (var i = 0; i < message.idList.length; ++i) {
                    var error = $root.dfproto.BasicMaterialId.verify(message.idList[i]);
                    if (error)
                        return "idList." + error;
                }
            }
            if (message.builtin != null && message.hasOwnProperty("builtin"))
                if (typeof message.builtin !== "boolean")
                    return "builtin: boolean expected";
            if (message.inorganic != null && message.hasOwnProperty("inorganic"))
                if (typeof message.inorganic !== "boolean")
                    return "inorganic: boolean expected";
            if (message.creatures != null && message.hasOwnProperty("creatures"))
                if (typeof message.creatures !== "boolean")
                    return "creatures: boolean expected";
            if (message.plants != null && message.hasOwnProperty("plants"))
                if (typeof message.plants !== "boolean")
                    return "plants: boolean expected";
            return null;
        };

        /**
         * Creates a ListMaterialsIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListMaterialsIn} ListMaterialsIn
         */
        ListMaterialsIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListMaterialsIn)
                return object;
            var message = new $root.dfproto.ListMaterialsIn();
            if (object.mask != null) {
                if (typeof object.mask !== "object")
                    throw TypeError(".dfproto.ListMaterialsIn.mask: object expected");
                message.mask = $root.dfproto.BasicMaterialInfoMask.fromObject(object.mask);
            }
            if (object.idList) {
                if (!Array.isArray(object.idList))
                    throw TypeError(".dfproto.ListMaterialsIn.idList: array expected");
                message.idList = [];
                for (var i = 0; i < object.idList.length; ++i) {
                    if (typeof object.idList[i] !== "object")
                        throw TypeError(".dfproto.ListMaterialsIn.idList: object expected");
                    message.idList[i] = $root.dfproto.BasicMaterialId.fromObject(object.idList[i]);
                }
            }
            if (object.builtin != null)
                message.builtin = Boolean(object.builtin);
            if (object.inorganic != null)
                message.inorganic = Boolean(object.inorganic);
            if (object.creatures != null)
                message.creatures = Boolean(object.creatures);
            if (object.plants != null)
                message.plants = Boolean(object.plants);
            return message;
        };

        /**
         * Creates a plain object from a ListMaterialsIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListMaterialsIn
         * @static
         * @param {dfproto.ListMaterialsIn} message ListMaterialsIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListMaterialsIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.idList = [];
            if (options.defaults) {
                object.mask = null;
                object.builtin = false;
                object.inorganic = false;
                object.creatures = false;
                object.plants = false;
            }
            if (message.mask != null && message.hasOwnProperty("mask"))
                object.mask = $root.dfproto.BasicMaterialInfoMask.toObject(message.mask, options);
            if (message.idList && message.idList.length) {
                object.idList = [];
                for (var j = 0; j < message.idList.length; ++j)
                    object.idList[j] = $root.dfproto.BasicMaterialId.toObject(message.idList[j], options);
            }
            if (message.builtin != null && message.hasOwnProperty("builtin"))
                object.builtin = message.builtin;
            if (message.inorganic != null && message.hasOwnProperty("inorganic"))
                object.inorganic = message.inorganic;
            if (message.creatures != null && message.hasOwnProperty("creatures"))
                object.creatures = message.creatures;
            if (message.plants != null && message.hasOwnProperty("plants"))
                object.plants = message.plants;
            return object;
        };

        /**
         * Converts this ListMaterialsIn to JSON.
         * @function toJSON
         * @memberof dfproto.ListMaterialsIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListMaterialsIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListMaterialsIn;
    })();

    dfproto.ListMaterialsOut = (function() {

        /**
         * Properties of a ListMaterialsOut.
         * @memberof dfproto
         * @interface IListMaterialsOut
         * @property {Array.<dfproto.IBasicMaterialInfo>|null} [value] ListMaterialsOut value
         */

        /**
         * Constructs a new ListMaterialsOut.
         * @memberof dfproto
         * @classdesc Represents a ListMaterialsOut.
         * @implements IListMaterialsOut
         * @constructor
         * @param {dfproto.IListMaterialsOut=} [properties] Properties to set
         */
        function ListMaterialsOut(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListMaterialsOut value.
         * @member {Array.<dfproto.IBasicMaterialInfo>} value
         * @memberof dfproto.ListMaterialsOut
         * @instance
         */
        ListMaterialsOut.prototype.value = $util.emptyArray;

        /**
         * Creates a new ListMaterialsOut instance using the specified properties.
         * @function create
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {dfproto.IListMaterialsOut=} [properties] Properties to set
         * @returns {dfproto.ListMaterialsOut} ListMaterialsOut instance
         */
        ListMaterialsOut.create = function create(properties) {
            return new ListMaterialsOut(properties);
        };

        /**
         * Encodes the specified ListMaterialsOut message. Does not implicitly {@link dfproto.ListMaterialsOut.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {dfproto.IListMaterialsOut} message ListMaterialsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMaterialsOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length)
                for (var i = 0; i < message.value.length; ++i)
                    $root.dfproto.BasicMaterialInfo.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListMaterialsOut message, length delimited. Does not implicitly {@link dfproto.ListMaterialsOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {dfproto.IListMaterialsOut} message ListMaterialsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMaterialsOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListMaterialsOut message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListMaterialsOut} ListMaterialsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMaterialsOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListMaterialsOut();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    message.value.push($root.dfproto.BasicMaterialInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListMaterialsOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListMaterialsOut} ListMaterialsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMaterialsOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListMaterialsOut message.
         * @function verify
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListMaterialsOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i) {
                    var error = $root.dfproto.BasicMaterialInfo.verify(message.value[i]);
                    if (error)
                        return "value." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListMaterialsOut message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListMaterialsOut} ListMaterialsOut
         */
        ListMaterialsOut.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListMaterialsOut)
                return object;
            var message = new $root.dfproto.ListMaterialsOut();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".dfproto.ListMaterialsOut.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i) {
                    if (typeof object.value[i] !== "object")
                        throw TypeError(".dfproto.ListMaterialsOut.value: object expected");
                    message.value[i] = $root.dfproto.BasicMaterialInfo.fromObject(object.value[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListMaterialsOut message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListMaterialsOut
         * @static
         * @param {dfproto.ListMaterialsOut} message ListMaterialsOut
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListMaterialsOut.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    object.value[j] = $root.dfproto.BasicMaterialInfo.toObject(message.value[j], options);
            }
            return object;
        };

        /**
         * Converts this ListMaterialsOut to JSON.
         * @function toJSON
         * @memberof dfproto.ListMaterialsOut
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListMaterialsOut.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListMaterialsOut;
    })();

    dfproto.ListUnitsIn = (function() {

        /**
         * Properties of a ListUnitsIn.
         * @memberof dfproto
         * @interface IListUnitsIn
         * @property {dfproto.IBasicUnitInfoMask|null} [mask] ListUnitsIn mask
         * @property {Array.<number>|null} [idList] ListUnitsIn idList
         * @property {boolean|null} [scanAll] ListUnitsIn scanAll
         * @property {number|null} [race] ListUnitsIn race
         * @property {number|null} [civId] ListUnitsIn civId
         * @property {boolean|null} [dead] ListUnitsIn dead
         * @property {boolean|null} [alive] ListUnitsIn alive
         * @property {boolean|null} [sane] ListUnitsIn sane
         */

        /**
         * Constructs a new ListUnitsIn.
         * @memberof dfproto
         * @classdesc Represents a ListUnitsIn.
         * @implements IListUnitsIn
         * @constructor
         * @param {dfproto.IListUnitsIn=} [properties] Properties to set
         */
        function ListUnitsIn(properties) {
            this.idList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListUnitsIn mask.
         * @member {dfproto.IBasicUnitInfoMask|null|undefined} mask
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.mask = null;

        /**
         * ListUnitsIn idList.
         * @member {Array.<number>} idList
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.idList = $util.emptyArray;

        /**
         * ListUnitsIn scanAll.
         * @member {boolean} scanAll
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.scanAll = false;

        /**
         * ListUnitsIn race.
         * @member {number} race
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.race = 0;

        /**
         * ListUnitsIn civId.
         * @member {number} civId
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.civId = 0;

        /**
         * ListUnitsIn dead.
         * @member {boolean} dead
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.dead = false;

        /**
         * ListUnitsIn alive.
         * @member {boolean} alive
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.alive = false;

        /**
         * ListUnitsIn sane.
         * @member {boolean} sane
         * @memberof dfproto.ListUnitsIn
         * @instance
         */
        ListUnitsIn.prototype.sane = false;

        /**
         * Creates a new ListUnitsIn instance using the specified properties.
         * @function create
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {dfproto.IListUnitsIn=} [properties] Properties to set
         * @returns {dfproto.ListUnitsIn} ListUnitsIn instance
         */
        ListUnitsIn.create = function create(properties) {
            return new ListUnitsIn(properties);
        };

        /**
         * Encodes the specified ListUnitsIn message. Does not implicitly {@link dfproto.ListUnitsIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {dfproto.IListUnitsIn} message ListUnitsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnitsIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mask != null && Object.hasOwnProperty.call(message, "mask"))
                $root.dfproto.BasicUnitInfoMask.encode(message.mask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.idList != null && message.idList.length)
                for (var i = 0; i < message.idList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.idList[i]);
            if (message.race != null && Object.hasOwnProperty.call(message, "race"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.race);
            if (message.civId != null && Object.hasOwnProperty.call(message, "civId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.civId);
            if (message.scanAll != null && Object.hasOwnProperty.call(message, "scanAll"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.scanAll);
            if (message.dead != null && Object.hasOwnProperty.call(message, "dead"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.dead);
            if (message.alive != null && Object.hasOwnProperty.call(message, "alive"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.alive);
            if (message.sane != null && Object.hasOwnProperty.call(message, "sane"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.sane);
            return writer;
        };

        /**
         * Encodes the specified ListUnitsIn message, length delimited. Does not implicitly {@link dfproto.ListUnitsIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {dfproto.IListUnitsIn} message ListUnitsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnitsIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListUnitsIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListUnitsIn} ListUnitsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnitsIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListUnitsIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mask = $root.dfproto.BasicUnitInfoMask.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.idList && message.idList.length))
                        message.idList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.idList.push(reader.int32());
                    } else
                        message.idList.push(reader.int32());
                    break;
                case 5:
                    message.scanAll = reader.bool();
                    break;
                case 3:
                    message.race = reader.int32();
                    break;
                case 4:
                    message.civId = reader.int32();
                    break;
                case 6:
                    message.dead = reader.bool();
                    break;
                case 7:
                    message.alive = reader.bool();
                    break;
                case 8:
                    message.sane = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListUnitsIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListUnitsIn} ListUnitsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnitsIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListUnitsIn message.
         * @function verify
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListUnitsIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mask != null && message.hasOwnProperty("mask")) {
                var error = $root.dfproto.BasicUnitInfoMask.verify(message.mask);
                if (error)
                    return "mask." + error;
            }
            if (message.idList != null && message.hasOwnProperty("idList")) {
                if (!Array.isArray(message.idList))
                    return "idList: array expected";
                for (var i = 0; i < message.idList.length; ++i)
                    if (!$util.isInteger(message.idList[i]))
                        return "idList: integer[] expected";
            }
            if (message.scanAll != null && message.hasOwnProperty("scanAll"))
                if (typeof message.scanAll !== "boolean")
                    return "scanAll: boolean expected";
            if (message.race != null && message.hasOwnProperty("race"))
                if (!$util.isInteger(message.race))
                    return "race: integer expected";
            if (message.civId != null && message.hasOwnProperty("civId"))
                if (!$util.isInteger(message.civId))
                    return "civId: integer expected";
            if (message.dead != null && message.hasOwnProperty("dead"))
                if (typeof message.dead !== "boolean")
                    return "dead: boolean expected";
            if (message.alive != null && message.hasOwnProperty("alive"))
                if (typeof message.alive !== "boolean")
                    return "alive: boolean expected";
            if (message.sane != null && message.hasOwnProperty("sane"))
                if (typeof message.sane !== "boolean")
                    return "sane: boolean expected";
            return null;
        };

        /**
         * Creates a ListUnitsIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListUnitsIn} ListUnitsIn
         */
        ListUnitsIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListUnitsIn)
                return object;
            var message = new $root.dfproto.ListUnitsIn();
            if (object.mask != null) {
                if (typeof object.mask !== "object")
                    throw TypeError(".dfproto.ListUnitsIn.mask: object expected");
                message.mask = $root.dfproto.BasicUnitInfoMask.fromObject(object.mask);
            }
            if (object.idList) {
                if (!Array.isArray(object.idList))
                    throw TypeError(".dfproto.ListUnitsIn.idList: array expected");
                message.idList = [];
                for (var i = 0; i < object.idList.length; ++i)
                    message.idList[i] = object.idList[i] | 0;
            }
            if (object.scanAll != null)
                message.scanAll = Boolean(object.scanAll);
            if (object.race != null)
                message.race = object.race | 0;
            if (object.civId != null)
                message.civId = object.civId | 0;
            if (object.dead != null)
                message.dead = Boolean(object.dead);
            if (object.alive != null)
                message.alive = Boolean(object.alive);
            if (object.sane != null)
                message.sane = Boolean(object.sane);
            return message;
        };

        /**
         * Creates a plain object from a ListUnitsIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListUnitsIn
         * @static
         * @param {dfproto.ListUnitsIn} message ListUnitsIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListUnitsIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.idList = [];
            if (options.defaults) {
                object.mask = null;
                object.race = 0;
                object.civId = 0;
                object.scanAll = false;
                object.dead = false;
                object.alive = false;
                object.sane = false;
            }
            if (message.mask != null && message.hasOwnProperty("mask"))
                object.mask = $root.dfproto.BasicUnitInfoMask.toObject(message.mask, options);
            if (message.idList && message.idList.length) {
                object.idList = [];
                for (var j = 0; j < message.idList.length; ++j)
                    object.idList[j] = message.idList[j];
            }
            if (message.race != null && message.hasOwnProperty("race"))
                object.race = message.race;
            if (message.civId != null && message.hasOwnProperty("civId"))
                object.civId = message.civId;
            if (message.scanAll != null && message.hasOwnProperty("scanAll"))
                object.scanAll = message.scanAll;
            if (message.dead != null && message.hasOwnProperty("dead"))
                object.dead = message.dead;
            if (message.alive != null && message.hasOwnProperty("alive"))
                object.alive = message.alive;
            if (message.sane != null && message.hasOwnProperty("sane"))
                object.sane = message.sane;
            return object;
        };

        /**
         * Converts this ListUnitsIn to JSON.
         * @function toJSON
         * @memberof dfproto.ListUnitsIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListUnitsIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListUnitsIn;
    })();

    dfproto.ListUnitsOut = (function() {

        /**
         * Properties of a ListUnitsOut.
         * @memberof dfproto
         * @interface IListUnitsOut
         * @property {Array.<dfproto.IBasicUnitInfo>|null} [value] ListUnitsOut value
         */

        /**
         * Constructs a new ListUnitsOut.
         * @memberof dfproto
         * @classdesc Represents a ListUnitsOut.
         * @implements IListUnitsOut
         * @constructor
         * @param {dfproto.IListUnitsOut=} [properties] Properties to set
         */
        function ListUnitsOut(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListUnitsOut value.
         * @member {Array.<dfproto.IBasicUnitInfo>} value
         * @memberof dfproto.ListUnitsOut
         * @instance
         */
        ListUnitsOut.prototype.value = $util.emptyArray;

        /**
         * Creates a new ListUnitsOut instance using the specified properties.
         * @function create
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {dfproto.IListUnitsOut=} [properties] Properties to set
         * @returns {dfproto.ListUnitsOut} ListUnitsOut instance
         */
        ListUnitsOut.create = function create(properties) {
            return new ListUnitsOut(properties);
        };

        /**
         * Encodes the specified ListUnitsOut message. Does not implicitly {@link dfproto.ListUnitsOut.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {dfproto.IListUnitsOut} message ListUnitsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnitsOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length)
                for (var i = 0; i < message.value.length; ++i)
                    $root.dfproto.BasicUnitInfo.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListUnitsOut message, length delimited. Does not implicitly {@link dfproto.ListUnitsOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {dfproto.IListUnitsOut} message ListUnitsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnitsOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListUnitsOut message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListUnitsOut} ListUnitsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnitsOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListUnitsOut();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    message.value.push($root.dfproto.BasicUnitInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListUnitsOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListUnitsOut} ListUnitsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnitsOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListUnitsOut message.
         * @function verify
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListUnitsOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i) {
                    var error = $root.dfproto.BasicUnitInfo.verify(message.value[i]);
                    if (error)
                        return "value." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListUnitsOut message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListUnitsOut} ListUnitsOut
         */
        ListUnitsOut.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListUnitsOut)
                return object;
            var message = new $root.dfproto.ListUnitsOut();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".dfproto.ListUnitsOut.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i) {
                    if (typeof object.value[i] !== "object")
                        throw TypeError(".dfproto.ListUnitsOut.value: object expected");
                    message.value[i] = $root.dfproto.BasicUnitInfo.fromObject(object.value[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListUnitsOut message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListUnitsOut
         * @static
         * @param {dfproto.ListUnitsOut} message ListUnitsOut
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListUnitsOut.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    object.value[j] = $root.dfproto.BasicUnitInfo.toObject(message.value[j], options);
            }
            return object;
        };

        /**
         * Converts this ListUnitsOut to JSON.
         * @function toJSON
         * @memberof dfproto.ListUnitsOut
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListUnitsOut.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListUnitsOut;
    })();

    dfproto.ListSquadsIn = (function() {

        /**
         * Properties of a ListSquadsIn.
         * @memberof dfproto
         * @interface IListSquadsIn
         */

        /**
         * Constructs a new ListSquadsIn.
         * @memberof dfproto
         * @classdesc Represents a ListSquadsIn.
         * @implements IListSquadsIn
         * @constructor
         * @param {dfproto.IListSquadsIn=} [properties] Properties to set
         */
        function ListSquadsIn(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ListSquadsIn instance using the specified properties.
         * @function create
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {dfproto.IListSquadsIn=} [properties] Properties to set
         * @returns {dfproto.ListSquadsIn} ListSquadsIn instance
         */
        ListSquadsIn.create = function create(properties) {
            return new ListSquadsIn(properties);
        };

        /**
         * Encodes the specified ListSquadsIn message. Does not implicitly {@link dfproto.ListSquadsIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {dfproto.IListSquadsIn} message ListSquadsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListSquadsIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ListSquadsIn message, length delimited. Does not implicitly {@link dfproto.ListSquadsIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {dfproto.IListSquadsIn} message ListSquadsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListSquadsIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListSquadsIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListSquadsIn} ListSquadsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListSquadsIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListSquadsIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListSquadsIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListSquadsIn} ListSquadsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListSquadsIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListSquadsIn message.
         * @function verify
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListSquadsIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ListSquadsIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListSquadsIn} ListSquadsIn
         */
        ListSquadsIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListSquadsIn)
                return object;
            return new $root.dfproto.ListSquadsIn();
        };

        /**
         * Creates a plain object from a ListSquadsIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListSquadsIn
         * @static
         * @param {dfproto.ListSquadsIn} message ListSquadsIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListSquadsIn.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ListSquadsIn to JSON.
         * @function toJSON
         * @memberof dfproto.ListSquadsIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListSquadsIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListSquadsIn;
    })();

    dfproto.ListSquadsOut = (function() {

        /**
         * Properties of a ListSquadsOut.
         * @memberof dfproto
         * @interface IListSquadsOut
         * @property {Array.<dfproto.IBasicSquadInfo>|null} [value] ListSquadsOut value
         */

        /**
         * Constructs a new ListSquadsOut.
         * @memberof dfproto
         * @classdesc Represents a ListSquadsOut.
         * @implements IListSquadsOut
         * @constructor
         * @param {dfproto.IListSquadsOut=} [properties] Properties to set
         */
        function ListSquadsOut(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListSquadsOut value.
         * @member {Array.<dfproto.IBasicSquadInfo>} value
         * @memberof dfproto.ListSquadsOut
         * @instance
         */
        ListSquadsOut.prototype.value = $util.emptyArray;

        /**
         * Creates a new ListSquadsOut instance using the specified properties.
         * @function create
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {dfproto.IListSquadsOut=} [properties] Properties to set
         * @returns {dfproto.ListSquadsOut} ListSquadsOut instance
         */
        ListSquadsOut.create = function create(properties) {
            return new ListSquadsOut(properties);
        };

        /**
         * Encodes the specified ListSquadsOut message. Does not implicitly {@link dfproto.ListSquadsOut.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {dfproto.IListSquadsOut} message ListSquadsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListSquadsOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length)
                for (var i = 0; i < message.value.length; ++i)
                    $root.dfproto.BasicSquadInfo.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListSquadsOut message, length delimited. Does not implicitly {@link dfproto.ListSquadsOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {dfproto.IListSquadsOut} message ListSquadsOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListSquadsOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListSquadsOut message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ListSquadsOut} ListSquadsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListSquadsOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ListSquadsOut();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    message.value.push($root.dfproto.BasicSquadInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListSquadsOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ListSquadsOut} ListSquadsOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListSquadsOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListSquadsOut message.
         * @function verify
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListSquadsOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i) {
                    var error = $root.dfproto.BasicSquadInfo.verify(message.value[i]);
                    if (error)
                        return "value." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListSquadsOut message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ListSquadsOut} ListSquadsOut
         */
        ListSquadsOut.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ListSquadsOut)
                return object;
            var message = new $root.dfproto.ListSquadsOut();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".dfproto.ListSquadsOut.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i) {
                    if (typeof object.value[i] !== "object")
                        throw TypeError(".dfproto.ListSquadsOut.value: object expected");
                    message.value[i] = $root.dfproto.BasicSquadInfo.fromObject(object.value[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListSquadsOut message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ListSquadsOut
         * @static
         * @param {dfproto.ListSquadsOut} message ListSquadsOut
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListSquadsOut.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    object.value[j] = $root.dfproto.BasicSquadInfo.toObject(message.value[j], options);
            }
            return object;
        };

        /**
         * Converts this ListSquadsOut to JSON.
         * @function toJSON
         * @memberof dfproto.ListSquadsOut
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListSquadsOut.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListSquadsOut;
    })();

    dfproto.SetUnitLaborsIn = (function() {

        /**
         * Properties of a SetUnitLaborsIn.
         * @memberof dfproto
         * @interface ISetUnitLaborsIn
         * @property {Array.<dfproto.IUnitLaborState>|null} [change] SetUnitLaborsIn change
         */

        /**
         * Constructs a new SetUnitLaborsIn.
         * @memberof dfproto
         * @classdesc Represents a SetUnitLaborsIn.
         * @implements ISetUnitLaborsIn
         * @constructor
         * @param {dfproto.ISetUnitLaborsIn=} [properties] Properties to set
         */
        function SetUnitLaborsIn(properties) {
            this.change = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetUnitLaborsIn change.
         * @member {Array.<dfproto.IUnitLaborState>} change
         * @memberof dfproto.SetUnitLaborsIn
         * @instance
         */
        SetUnitLaborsIn.prototype.change = $util.emptyArray;

        /**
         * Creates a new SetUnitLaborsIn instance using the specified properties.
         * @function create
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {dfproto.ISetUnitLaborsIn=} [properties] Properties to set
         * @returns {dfproto.SetUnitLaborsIn} SetUnitLaborsIn instance
         */
        SetUnitLaborsIn.create = function create(properties) {
            return new SetUnitLaborsIn(properties);
        };

        /**
         * Encodes the specified SetUnitLaborsIn message. Does not implicitly {@link dfproto.SetUnitLaborsIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {dfproto.ISetUnitLaborsIn} message SetUnitLaborsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetUnitLaborsIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.change != null && message.change.length)
                for (var i = 0; i < message.change.length; ++i)
                    $root.dfproto.UnitLaborState.encode(message.change[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetUnitLaborsIn message, length delimited. Does not implicitly {@link dfproto.SetUnitLaborsIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {dfproto.ISetUnitLaborsIn} message SetUnitLaborsIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetUnitLaborsIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetUnitLaborsIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.SetUnitLaborsIn} SetUnitLaborsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetUnitLaborsIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.SetUnitLaborsIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.change && message.change.length))
                        message.change = [];
                    message.change.push($root.dfproto.UnitLaborState.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetUnitLaborsIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.SetUnitLaborsIn} SetUnitLaborsIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetUnitLaborsIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetUnitLaborsIn message.
         * @function verify
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetUnitLaborsIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.change != null && message.hasOwnProperty("change")) {
                if (!Array.isArray(message.change))
                    return "change: array expected";
                for (var i = 0; i < message.change.length; ++i) {
                    var error = $root.dfproto.UnitLaborState.verify(message.change[i]);
                    if (error)
                        return "change." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SetUnitLaborsIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.SetUnitLaborsIn} SetUnitLaborsIn
         */
        SetUnitLaborsIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.SetUnitLaborsIn)
                return object;
            var message = new $root.dfproto.SetUnitLaborsIn();
            if (object.change) {
                if (!Array.isArray(object.change))
                    throw TypeError(".dfproto.SetUnitLaborsIn.change: array expected");
                message.change = [];
                for (var i = 0; i < object.change.length; ++i) {
                    if (typeof object.change[i] !== "object")
                        throw TypeError(".dfproto.SetUnitLaborsIn.change: object expected");
                    message.change[i] = $root.dfproto.UnitLaborState.fromObject(object.change[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SetUnitLaborsIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.SetUnitLaborsIn
         * @static
         * @param {dfproto.SetUnitLaborsIn} message SetUnitLaborsIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetUnitLaborsIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.change = [];
            if (message.change && message.change.length) {
                object.change = [];
                for (var j = 0; j < message.change.length; ++j)
                    object.change[j] = $root.dfproto.UnitLaborState.toObject(message.change[j], options);
            }
            return object;
        };

        /**
         * Converts this SetUnitLaborsIn to JSON.
         * @function toJSON
         * @memberof dfproto.SetUnitLaborsIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetUnitLaborsIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetUnitLaborsIn;
    })();

    dfproto.EnumItemName = (function() {

        /**
         * Properties of an EnumItemName.
         * @memberof dfproto
         * @interface IEnumItemName
         * @property {number} value EnumItemName value
         * @property {string|null} [name] EnumItemName name
         * @property {number|null} [bitSize] EnumItemName bitSize
         */

        /**
         * Constructs a new EnumItemName.
         * @memberof dfproto
         * @classdesc Represents an EnumItemName.
         * @implements IEnumItemName
         * @constructor
         * @param {dfproto.IEnumItemName=} [properties] Properties to set
         */
        function EnumItemName(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumItemName value.
         * @member {number} value
         * @memberof dfproto.EnumItemName
         * @instance
         */
        EnumItemName.prototype.value = 0;

        /**
         * EnumItemName name.
         * @member {string} name
         * @memberof dfproto.EnumItemName
         * @instance
         */
        EnumItemName.prototype.name = "";

        /**
         * EnumItemName bitSize.
         * @member {number} bitSize
         * @memberof dfproto.EnumItemName
         * @instance
         */
        EnumItemName.prototype.bitSize = 1;

        /**
         * Creates a new EnumItemName instance using the specified properties.
         * @function create
         * @memberof dfproto.EnumItemName
         * @static
         * @param {dfproto.IEnumItemName=} [properties] Properties to set
         * @returns {dfproto.EnumItemName} EnumItemName instance
         */
        EnumItemName.create = function create(properties) {
            return new EnumItemName(properties);
        };

        /**
         * Encodes the specified EnumItemName message. Does not implicitly {@link dfproto.EnumItemName.verify|verify} messages.
         * @function encode
         * @memberof dfproto.EnumItemName
         * @static
         * @param {dfproto.IEnumItemName} message EnumItemName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumItemName.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.bitSize != null && Object.hasOwnProperty.call(message, "bitSize"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bitSize);
            return writer;
        };

        /**
         * Encodes the specified EnumItemName message, length delimited. Does not implicitly {@link dfproto.EnumItemName.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.EnumItemName
         * @static
         * @param {dfproto.IEnumItemName} message EnumItemName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnumItemName.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnumItemName message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.EnumItemName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.EnumItemName} EnumItemName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumItemName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.EnumItemName();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.bitSize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an EnumItemName message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.EnumItemName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.EnumItemName} EnumItemName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnumItemName.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnumItemName message.
         * @function verify
         * @memberof dfproto.EnumItemName
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumItemName.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.value))
                return "value: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.bitSize != null && message.hasOwnProperty("bitSize"))
                if (!$util.isInteger(message.bitSize))
                    return "bitSize: integer expected";
            return null;
        };

        /**
         * Creates an EnumItemName message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.EnumItemName
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.EnumItemName} EnumItemName
         */
        EnumItemName.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.EnumItemName)
                return object;
            var message = new $root.dfproto.EnumItemName();
            if (object.value != null)
                message.value = object.value | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.bitSize != null)
                message.bitSize = object.bitSize | 0;
            return message;
        };

        /**
         * Creates a plain object from an EnumItemName message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.EnumItemName
         * @static
         * @param {dfproto.EnumItemName} message EnumItemName
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumItemName.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.value = 0;
                object.name = "";
                object.bitSize = 1;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.bitSize != null && message.hasOwnProperty("bitSize"))
                object.bitSize = message.bitSize;
            return object;
        };

        /**
         * Converts this EnumItemName to JSON.
         * @function toJSON
         * @memberof dfproto.EnumItemName
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumItemName.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumItemName;
    })();

    dfproto.BasicMaterialId = (function() {

        /**
         * Properties of a BasicMaterialId.
         * @memberof dfproto
         * @interface IBasicMaterialId
         * @property {number} type BasicMaterialId type
         * @property {number} index BasicMaterialId index
         */

        /**
         * Constructs a new BasicMaterialId.
         * @memberof dfproto
         * @classdesc Represents a BasicMaterialId.
         * @implements IBasicMaterialId
         * @constructor
         * @param {dfproto.IBasicMaterialId=} [properties] Properties to set
         */
        function BasicMaterialId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicMaterialId type.
         * @member {number} type
         * @memberof dfproto.BasicMaterialId
         * @instance
         */
        BasicMaterialId.prototype.type = 0;

        /**
         * BasicMaterialId index.
         * @member {number} index
         * @memberof dfproto.BasicMaterialId
         * @instance
         */
        BasicMaterialId.prototype.index = 0;

        /**
         * Creates a new BasicMaterialId instance using the specified properties.
         * @function create
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {dfproto.IBasicMaterialId=} [properties] Properties to set
         * @returns {dfproto.BasicMaterialId} BasicMaterialId instance
         */
        BasicMaterialId.create = function create(properties) {
            return new BasicMaterialId(properties);
        };

        /**
         * Encodes the specified BasicMaterialId message. Does not implicitly {@link dfproto.BasicMaterialId.verify|verify} messages.
         * @function encode
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {dfproto.IBasicMaterialId} message BasicMaterialId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicMaterialId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.index);
            return writer;
        };

        /**
         * Encodes the specified BasicMaterialId message, length delimited. Does not implicitly {@link dfproto.BasicMaterialId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {dfproto.IBasicMaterialId} message BasicMaterialId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicMaterialId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicMaterialId message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.BasicMaterialId} BasicMaterialId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicMaterialId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.BasicMaterialId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.index = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicMaterialId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.BasicMaterialId} BasicMaterialId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicMaterialId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicMaterialId message.
         * @function verify
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicMaterialId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            return null;
        };

        /**
         * Creates a BasicMaterialId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.BasicMaterialId} BasicMaterialId
         */
        BasicMaterialId.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.BasicMaterialId)
                return object;
            var message = new $root.dfproto.BasicMaterialId();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a BasicMaterialId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.BasicMaterialId
         * @static
         * @param {dfproto.BasicMaterialId} message BasicMaterialId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicMaterialId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.index = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this BasicMaterialId to JSON.
         * @function toJSON
         * @memberof dfproto.BasicMaterialId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicMaterialId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicMaterialId;
    })();

    dfproto.BasicMaterialInfo = (function() {

        /**
         * Properties of a BasicMaterialInfo.
         * @memberof dfproto
         * @interface IBasicMaterialInfo
         * @property {number} type BasicMaterialInfo type
         * @property {number} index BasicMaterialInfo index
         * @property {string} token BasicMaterialInfo token
         * @property {Array.<number>|null} [flags] BasicMaterialInfo flags
         * @property {number|null} [subtype] BasicMaterialInfo subtype
         * @property {number|null} [creatureId] BasicMaterialInfo creatureId
         * @property {number|null} [plantId] BasicMaterialInfo plantId
         * @property {number|null} [histfigId] BasicMaterialInfo histfigId
         * @property {string|null} [namePrefix] BasicMaterialInfo namePrefix
         * @property {Array.<number>|null} [stateColor] BasicMaterialInfo stateColor
         * @property {Array.<string>|null} [stateName] BasicMaterialInfo stateName
         * @property {Array.<string>|null} [stateAdj] BasicMaterialInfo stateAdj
         * @property {Array.<string>|null} [reactionClass] BasicMaterialInfo reactionClass
         * @property {Array.<dfproto.BasicMaterialInfo.IProduct>|null} [reactionProduct] BasicMaterialInfo reactionProduct
         * @property {Array.<number>|null} [inorganicFlags] BasicMaterialInfo inorganicFlags
         */

        /**
         * Constructs a new BasicMaterialInfo.
         * @memberof dfproto
         * @classdesc Represents a BasicMaterialInfo.
         * @implements IBasicMaterialInfo
         * @constructor
         * @param {dfproto.IBasicMaterialInfo=} [properties] Properties to set
         */
        function BasicMaterialInfo(properties) {
            this.flags = [];
            this.stateColor = [];
            this.stateName = [];
            this.stateAdj = [];
            this.reactionClass = [];
            this.reactionProduct = [];
            this.inorganicFlags = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicMaterialInfo type.
         * @member {number} type
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.type = 0;

        /**
         * BasicMaterialInfo index.
         * @member {number} index
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.index = 0;

        /**
         * BasicMaterialInfo token.
         * @member {string} token
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.token = "";

        /**
         * BasicMaterialInfo flags.
         * @member {Array.<number>} flags
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.flags = $util.emptyArray;

        /**
         * BasicMaterialInfo subtype.
         * @member {number} subtype
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.subtype = -1;

        /**
         * BasicMaterialInfo creatureId.
         * @member {number} creatureId
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.creatureId = -1;

        /**
         * BasicMaterialInfo plantId.
         * @member {number} plantId
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.plantId = -1;

        /**
         * BasicMaterialInfo histfigId.
         * @member {number} histfigId
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.histfigId = -1;

        /**
         * BasicMaterialInfo namePrefix.
         * @member {string} namePrefix
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.namePrefix = "";

        /**
         * BasicMaterialInfo stateColor.
         * @member {Array.<number>} stateColor
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.stateColor = $util.emptyArray;

        /**
         * BasicMaterialInfo stateName.
         * @member {Array.<string>} stateName
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.stateName = $util.emptyArray;

        /**
         * BasicMaterialInfo stateAdj.
         * @member {Array.<string>} stateAdj
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.stateAdj = $util.emptyArray;

        /**
         * BasicMaterialInfo reactionClass.
         * @member {Array.<string>} reactionClass
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.reactionClass = $util.emptyArray;

        /**
         * BasicMaterialInfo reactionProduct.
         * @member {Array.<dfproto.BasicMaterialInfo.IProduct>} reactionProduct
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.reactionProduct = $util.emptyArray;

        /**
         * BasicMaterialInfo inorganicFlags.
         * @member {Array.<number>} inorganicFlags
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         */
        BasicMaterialInfo.prototype.inorganicFlags = $util.emptyArray;

        /**
         * Creates a new BasicMaterialInfo instance using the specified properties.
         * @function create
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {dfproto.IBasicMaterialInfo=} [properties] Properties to set
         * @returns {dfproto.BasicMaterialInfo} BasicMaterialInfo instance
         */
        BasicMaterialInfo.create = function create(properties) {
            return new BasicMaterialInfo(properties);
        };

        /**
         * Encodes the specified BasicMaterialInfo message. Does not implicitly {@link dfproto.BasicMaterialInfo.verify|verify} messages.
         * @function encode
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {dfproto.IBasicMaterialInfo} message BasicMaterialInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicMaterialInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.index);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
            if (message.flags != null && message.flags.length)
                for (var i = 0; i < message.flags.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.flags[i]);
            if (message.subtype != null && Object.hasOwnProperty.call(message, "subtype"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.subtype);
            if (message.creatureId != null && Object.hasOwnProperty.call(message, "creatureId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.creatureId);
            if (message.plantId != null && Object.hasOwnProperty.call(message, "plantId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.plantId);
            if (message.histfigId != null && Object.hasOwnProperty.call(message, "histfigId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.histfigId);
            if (message.namePrefix != null && Object.hasOwnProperty.call(message, "namePrefix"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.namePrefix);
            if (message.stateColor != null && message.stateColor.length)
                for (var i = 0; i < message.stateColor.length; ++i)
                    writer.uint32(/* id 10, wireType 5 =*/85).fixed32(message.stateColor[i]);
            if (message.stateName != null && message.stateName.length)
                for (var i = 0; i < message.stateName.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.stateName[i]);
            if (message.stateAdj != null && message.stateAdj.length)
                for (var i = 0; i < message.stateAdj.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.stateAdj[i]);
            if (message.reactionClass != null && message.reactionClass.length)
                for (var i = 0; i < message.reactionClass.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.reactionClass[i]);
            if (message.reactionProduct != null && message.reactionProduct.length)
                for (var i = 0; i < message.reactionProduct.length; ++i)
                    $root.dfproto.BasicMaterialInfo.Product.encode(message.reactionProduct[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.inorganicFlags != null && message.inorganicFlags.length)
                for (var i = 0; i < message.inorganicFlags.length; ++i)
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.inorganicFlags[i]);
            return writer;
        };

        /**
         * Encodes the specified BasicMaterialInfo message, length delimited. Does not implicitly {@link dfproto.BasicMaterialInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {dfproto.IBasicMaterialInfo} message BasicMaterialInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicMaterialInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicMaterialInfo message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.BasicMaterialInfo} BasicMaterialInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicMaterialInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.BasicMaterialInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.index = reader.sint32();
                    break;
                case 3:
                    message.token = reader.string();
                    break;
                case 4:
                    if (!(message.flags && message.flags.length))
                        message.flags = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.flags.push(reader.int32());
                    } else
                        message.flags.push(reader.int32());
                    break;
                case 5:
                    message.subtype = reader.int32();
                    break;
                case 6:
                    message.creatureId = reader.int32();
                    break;
                case 7:
                    message.plantId = reader.int32();
                    break;
                case 8:
                    message.histfigId = reader.int32();
                    break;
                case 9:
                    message.namePrefix = reader.string();
                    break;
                case 10:
                    if (!(message.stateColor && message.stateColor.length))
                        message.stateColor = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stateColor.push(reader.fixed32());
                    } else
                        message.stateColor.push(reader.fixed32());
                    break;
                case 11:
                    if (!(message.stateName && message.stateName.length))
                        message.stateName = [];
                    message.stateName.push(reader.string());
                    break;
                case 12:
                    if (!(message.stateAdj && message.stateAdj.length))
                        message.stateAdj = [];
                    message.stateAdj.push(reader.string());
                    break;
                case 13:
                    if (!(message.reactionClass && message.reactionClass.length))
                        message.reactionClass = [];
                    message.reactionClass.push(reader.string());
                    break;
                case 14:
                    if (!(message.reactionProduct && message.reactionProduct.length))
                        message.reactionProduct = [];
                    message.reactionProduct.push($root.dfproto.BasicMaterialInfo.Product.decode(reader, reader.uint32()));
                    break;
                case 15:
                    if (!(message.inorganicFlags && message.inorganicFlags.length))
                        message.inorganicFlags = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.inorganicFlags.push(reader.int32());
                    } else
                        message.inorganicFlags.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            if (!message.hasOwnProperty("token"))
                throw $util.ProtocolError("missing required 'token'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicMaterialInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.BasicMaterialInfo} BasicMaterialInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicMaterialInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicMaterialInfo message.
         * @function verify
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicMaterialInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            if (!$util.isString(message.token))
                return "token: string expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (var i = 0; i < message.flags.length; ++i)
                    if (!$util.isInteger(message.flags[i]))
                        return "flags: integer[] expected";
            }
            if (message.subtype != null && message.hasOwnProperty("subtype"))
                if (!$util.isInteger(message.subtype))
                    return "subtype: integer expected";
            if (message.creatureId != null && message.hasOwnProperty("creatureId"))
                if (!$util.isInteger(message.creatureId))
                    return "creatureId: integer expected";
            if (message.plantId != null && message.hasOwnProperty("plantId"))
                if (!$util.isInteger(message.plantId))
                    return "plantId: integer expected";
            if (message.histfigId != null && message.hasOwnProperty("histfigId"))
                if (!$util.isInteger(message.histfigId))
                    return "histfigId: integer expected";
            if (message.namePrefix != null && message.hasOwnProperty("namePrefix"))
                if (!$util.isString(message.namePrefix))
                    return "namePrefix: string expected";
            if (message.stateColor != null && message.hasOwnProperty("stateColor")) {
                if (!Array.isArray(message.stateColor))
                    return "stateColor: array expected";
                for (var i = 0; i < message.stateColor.length; ++i)
                    if (!$util.isInteger(message.stateColor[i]))
                        return "stateColor: integer[] expected";
            }
            if (message.stateName != null && message.hasOwnProperty("stateName")) {
                if (!Array.isArray(message.stateName))
                    return "stateName: array expected";
                for (var i = 0; i < message.stateName.length; ++i)
                    if (!$util.isString(message.stateName[i]))
                        return "stateName: string[] expected";
            }
            if (message.stateAdj != null && message.hasOwnProperty("stateAdj")) {
                if (!Array.isArray(message.stateAdj))
                    return "stateAdj: array expected";
                for (var i = 0; i < message.stateAdj.length; ++i)
                    if (!$util.isString(message.stateAdj[i]))
                        return "stateAdj: string[] expected";
            }
            if (message.reactionClass != null && message.hasOwnProperty("reactionClass")) {
                if (!Array.isArray(message.reactionClass))
                    return "reactionClass: array expected";
                for (var i = 0; i < message.reactionClass.length; ++i)
                    if (!$util.isString(message.reactionClass[i]))
                        return "reactionClass: string[] expected";
            }
            if (message.reactionProduct != null && message.hasOwnProperty("reactionProduct")) {
                if (!Array.isArray(message.reactionProduct))
                    return "reactionProduct: array expected";
                for (var i = 0; i < message.reactionProduct.length; ++i) {
                    var error = $root.dfproto.BasicMaterialInfo.Product.verify(message.reactionProduct[i]);
                    if (error)
                        return "reactionProduct." + error;
                }
            }
            if (message.inorganicFlags != null && message.hasOwnProperty("inorganicFlags")) {
                if (!Array.isArray(message.inorganicFlags))
                    return "inorganicFlags: array expected";
                for (var i = 0; i < message.inorganicFlags.length; ++i)
                    if (!$util.isInteger(message.inorganicFlags[i]))
                        return "inorganicFlags: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BasicMaterialInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.BasicMaterialInfo} BasicMaterialInfo
         */
        BasicMaterialInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.BasicMaterialInfo)
                return object;
            var message = new $root.dfproto.BasicMaterialInfo();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.index != null)
                message.index = object.index | 0;
            if (object.token != null)
                message.token = String(object.token);
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".dfproto.BasicMaterialInfo.flags: array expected");
                message.flags = [];
                for (var i = 0; i < object.flags.length; ++i)
                    message.flags[i] = object.flags[i] | 0;
            }
            if (object.subtype != null)
                message.subtype = object.subtype | 0;
            if (object.creatureId != null)
                message.creatureId = object.creatureId | 0;
            if (object.plantId != null)
                message.plantId = object.plantId | 0;
            if (object.histfigId != null)
                message.histfigId = object.histfigId | 0;
            if (object.namePrefix != null)
                message.namePrefix = String(object.namePrefix);
            if (object.stateColor) {
                if (!Array.isArray(object.stateColor))
                    throw TypeError(".dfproto.BasicMaterialInfo.stateColor: array expected");
                message.stateColor = [];
                for (var i = 0; i < object.stateColor.length; ++i)
                    message.stateColor[i] = object.stateColor[i] >>> 0;
            }
            if (object.stateName) {
                if (!Array.isArray(object.stateName))
                    throw TypeError(".dfproto.BasicMaterialInfo.stateName: array expected");
                message.stateName = [];
                for (var i = 0; i < object.stateName.length; ++i)
                    message.stateName[i] = String(object.stateName[i]);
            }
            if (object.stateAdj) {
                if (!Array.isArray(object.stateAdj))
                    throw TypeError(".dfproto.BasicMaterialInfo.stateAdj: array expected");
                message.stateAdj = [];
                for (var i = 0; i < object.stateAdj.length; ++i)
                    message.stateAdj[i] = String(object.stateAdj[i]);
            }
            if (object.reactionClass) {
                if (!Array.isArray(object.reactionClass))
                    throw TypeError(".dfproto.BasicMaterialInfo.reactionClass: array expected");
                message.reactionClass = [];
                for (var i = 0; i < object.reactionClass.length; ++i)
                    message.reactionClass[i] = String(object.reactionClass[i]);
            }
            if (object.reactionProduct) {
                if (!Array.isArray(object.reactionProduct))
                    throw TypeError(".dfproto.BasicMaterialInfo.reactionProduct: array expected");
                message.reactionProduct = [];
                for (var i = 0; i < object.reactionProduct.length; ++i) {
                    if (typeof object.reactionProduct[i] !== "object")
                        throw TypeError(".dfproto.BasicMaterialInfo.reactionProduct: object expected");
                    message.reactionProduct[i] = $root.dfproto.BasicMaterialInfo.Product.fromObject(object.reactionProduct[i]);
                }
            }
            if (object.inorganicFlags) {
                if (!Array.isArray(object.inorganicFlags))
                    throw TypeError(".dfproto.BasicMaterialInfo.inorganicFlags: array expected");
                message.inorganicFlags = [];
                for (var i = 0; i < object.inorganicFlags.length; ++i)
                    message.inorganicFlags[i] = object.inorganicFlags[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BasicMaterialInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.BasicMaterialInfo
         * @static
         * @param {dfproto.BasicMaterialInfo} message BasicMaterialInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicMaterialInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.flags = [];
                object.stateColor = [];
                object.stateName = [];
                object.stateAdj = [];
                object.reactionClass = [];
                object.reactionProduct = [];
                object.inorganicFlags = [];
            }
            if (options.defaults) {
                object.type = 0;
                object.index = 0;
                object.token = "";
                object.subtype = -1;
                object.creatureId = -1;
                object.plantId = -1;
                object.histfigId = -1;
                object.namePrefix = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (var j = 0; j < message.flags.length; ++j)
                    object.flags[j] = message.flags[j];
            }
            if (message.subtype != null && message.hasOwnProperty("subtype"))
                object.subtype = message.subtype;
            if (message.creatureId != null && message.hasOwnProperty("creatureId"))
                object.creatureId = message.creatureId;
            if (message.plantId != null && message.hasOwnProperty("plantId"))
                object.plantId = message.plantId;
            if (message.histfigId != null && message.hasOwnProperty("histfigId"))
                object.histfigId = message.histfigId;
            if (message.namePrefix != null && message.hasOwnProperty("namePrefix"))
                object.namePrefix = message.namePrefix;
            if (message.stateColor && message.stateColor.length) {
                object.stateColor = [];
                for (var j = 0; j < message.stateColor.length; ++j)
                    object.stateColor[j] = message.stateColor[j];
            }
            if (message.stateName && message.stateName.length) {
                object.stateName = [];
                for (var j = 0; j < message.stateName.length; ++j)
                    object.stateName[j] = message.stateName[j];
            }
            if (message.stateAdj && message.stateAdj.length) {
                object.stateAdj = [];
                for (var j = 0; j < message.stateAdj.length; ++j)
                    object.stateAdj[j] = message.stateAdj[j];
            }
            if (message.reactionClass && message.reactionClass.length) {
                object.reactionClass = [];
                for (var j = 0; j < message.reactionClass.length; ++j)
                    object.reactionClass[j] = message.reactionClass[j];
            }
            if (message.reactionProduct && message.reactionProduct.length) {
                object.reactionProduct = [];
                for (var j = 0; j < message.reactionProduct.length; ++j)
                    object.reactionProduct[j] = $root.dfproto.BasicMaterialInfo.Product.toObject(message.reactionProduct[j], options);
            }
            if (message.inorganicFlags && message.inorganicFlags.length) {
                object.inorganicFlags = [];
                for (var j = 0; j < message.inorganicFlags.length; ++j)
                    object.inorganicFlags[j] = message.inorganicFlags[j];
            }
            return object;
        };

        /**
         * Converts this BasicMaterialInfo to JSON.
         * @function toJSON
         * @memberof dfproto.BasicMaterialInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicMaterialInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        BasicMaterialInfo.Product = (function() {

            /**
             * Properties of a Product.
             * @memberof dfproto.BasicMaterialInfo
             * @interface IProduct
             * @property {string} id Product id
             * @property {number} type Product type
             * @property {number} index Product index
             */

            /**
             * Constructs a new Product.
             * @memberof dfproto.BasicMaterialInfo
             * @classdesc Represents a Product.
             * @implements IProduct
             * @constructor
             * @param {dfproto.BasicMaterialInfo.IProduct=} [properties] Properties to set
             */
            function Product(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Product id.
             * @member {string} id
             * @memberof dfproto.BasicMaterialInfo.Product
             * @instance
             */
            Product.prototype.id = "";

            /**
             * Product type.
             * @member {number} type
             * @memberof dfproto.BasicMaterialInfo.Product
             * @instance
             */
            Product.prototype.type = 0;

            /**
             * Product index.
             * @member {number} index
             * @memberof dfproto.BasicMaterialInfo.Product
             * @instance
             */
            Product.prototype.index = 0;

            /**
             * Creates a new Product instance using the specified properties.
             * @function create
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {dfproto.BasicMaterialInfo.IProduct=} [properties] Properties to set
             * @returns {dfproto.BasicMaterialInfo.Product} Product instance
             */
            Product.create = function create(properties) {
                return new Product(properties);
            };

            /**
             * Encodes the specified Product message. Does not implicitly {@link dfproto.BasicMaterialInfo.Product.verify|verify} messages.
             * @function encode
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {dfproto.BasicMaterialInfo.IProduct} message Product message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Product.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.index);
                return writer;
            };

            /**
             * Encodes the specified Product message, length delimited. Does not implicitly {@link dfproto.BasicMaterialInfo.Product.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {dfproto.BasicMaterialInfo.IProduct} message Product message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Product.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Product message from the specified reader or buffer.
             * @function decode
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dfproto.BasicMaterialInfo.Product} Product
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Product.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.BasicMaterialInfo.Product();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.index = reader.sint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("index"))
                    throw $util.ProtocolError("missing required 'index'", { instance: message });
                return message;
            };

            /**
             * Decodes a Product message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dfproto.BasicMaterialInfo.Product} Product
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Product.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Product message.
             * @function verify
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Product.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.id))
                    return "id: string expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
                return null;
            };

            /**
             * Creates a Product message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dfproto.BasicMaterialInfo.Product} Product
             */
            Product.fromObject = function fromObject(object) {
                if (object instanceof $root.dfproto.BasicMaterialInfo.Product)
                    return object;
                var message = new $root.dfproto.BasicMaterialInfo.Product();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.index != null)
                    message.index = object.index | 0;
                return message;
            };

            /**
             * Creates a plain object from a Product message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dfproto.BasicMaterialInfo.Product
             * @static
             * @param {dfproto.BasicMaterialInfo.Product} message Product
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Product.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.type = 0;
                    object.index = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                return object;
            };

            /**
             * Converts this Product to JSON.
             * @function toJSON
             * @memberof dfproto.BasicMaterialInfo.Product
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Product.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Product;
        })();

        return BasicMaterialInfo;
    })();

    dfproto.BasicMaterialInfoMask = (function() {

        /**
         * Properties of a BasicMaterialInfoMask.
         * @memberof dfproto
         * @interface IBasicMaterialInfoMask
         * @property {Array.<dfproto.BasicMaterialInfoMask.StateType>|null} [states] BasicMaterialInfoMask states
         * @property {number|null} [temperature] BasicMaterialInfoMask temperature
         * @property {boolean|null} [flags] BasicMaterialInfoMask flags
         * @property {boolean|null} [reaction] BasicMaterialInfoMask reaction
         */

        /**
         * Constructs a new BasicMaterialInfoMask.
         * @memberof dfproto
         * @classdesc Represents a BasicMaterialInfoMask.
         * @implements IBasicMaterialInfoMask
         * @constructor
         * @param {dfproto.IBasicMaterialInfoMask=} [properties] Properties to set
         */
        function BasicMaterialInfoMask(properties) {
            this.states = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicMaterialInfoMask states.
         * @member {Array.<dfproto.BasicMaterialInfoMask.StateType>} states
         * @memberof dfproto.BasicMaterialInfoMask
         * @instance
         */
        BasicMaterialInfoMask.prototype.states = $util.emptyArray;

        /**
         * BasicMaterialInfoMask temperature.
         * @member {number} temperature
         * @memberof dfproto.BasicMaterialInfoMask
         * @instance
         */
        BasicMaterialInfoMask.prototype.temperature = 10015;

        /**
         * BasicMaterialInfoMask flags.
         * @member {boolean} flags
         * @memberof dfproto.BasicMaterialInfoMask
         * @instance
         */
        BasicMaterialInfoMask.prototype.flags = false;

        /**
         * BasicMaterialInfoMask reaction.
         * @member {boolean} reaction
         * @memberof dfproto.BasicMaterialInfoMask
         * @instance
         */
        BasicMaterialInfoMask.prototype.reaction = false;

        /**
         * Creates a new BasicMaterialInfoMask instance using the specified properties.
         * @function create
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {dfproto.IBasicMaterialInfoMask=} [properties] Properties to set
         * @returns {dfproto.BasicMaterialInfoMask} BasicMaterialInfoMask instance
         */
        BasicMaterialInfoMask.create = function create(properties) {
            return new BasicMaterialInfoMask(properties);
        };

        /**
         * Encodes the specified BasicMaterialInfoMask message. Does not implicitly {@link dfproto.BasicMaterialInfoMask.verify|verify} messages.
         * @function encode
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {dfproto.IBasicMaterialInfoMask} message BasicMaterialInfoMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicMaterialInfoMask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.states != null && message.states.length)
                for (var i = 0; i < message.states.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.states[i]);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.flags);
            if (message.reaction != null && Object.hasOwnProperty.call(message, "reaction"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.reaction);
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.temperature);
            return writer;
        };

        /**
         * Encodes the specified BasicMaterialInfoMask message, length delimited. Does not implicitly {@link dfproto.BasicMaterialInfoMask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {dfproto.IBasicMaterialInfoMask} message BasicMaterialInfoMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicMaterialInfoMask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicMaterialInfoMask message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.BasicMaterialInfoMask} BasicMaterialInfoMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicMaterialInfoMask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.BasicMaterialInfoMask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.states && message.states.length))
                        message.states = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.states.push(reader.int32());
                    } else
                        message.states.push(reader.int32());
                    break;
                case 4:
                    message.temperature = reader.int32();
                    break;
                case 2:
                    message.flags = reader.bool();
                    break;
                case 3:
                    message.reaction = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BasicMaterialInfoMask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.BasicMaterialInfoMask} BasicMaterialInfoMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicMaterialInfoMask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicMaterialInfoMask message.
         * @function verify
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicMaterialInfoMask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.states != null && message.hasOwnProperty("states")) {
                if (!Array.isArray(message.states))
                    return "states: array expected";
                for (var i = 0; i < message.states.length; ++i)
                    switch (message.states[i]) {
                    default:
                        return "states: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
            }
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                if (!$util.isInteger(message.temperature))
                    return "temperature: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (typeof message.flags !== "boolean")
                    return "flags: boolean expected";
            if (message.reaction != null && message.hasOwnProperty("reaction"))
                if (typeof message.reaction !== "boolean")
                    return "reaction: boolean expected";
            return null;
        };

        /**
         * Creates a BasicMaterialInfoMask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.BasicMaterialInfoMask} BasicMaterialInfoMask
         */
        BasicMaterialInfoMask.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.BasicMaterialInfoMask)
                return object;
            var message = new $root.dfproto.BasicMaterialInfoMask();
            if (object.states) {
                if (!Array.isArray(object.states))
                    throw TypeError(".dfproto.BasicMaterialInfoMask.states: array expected");
                message.states = [];
                for (var i = 0; i < object.states.length; ++i)
                    switch (object.states[i]) {
                    default:
                    case "Solid":
                    case 0:
                        message.states[i] = 0;
                        break;
                    case "Liquid":
                    case 1:
                        message.states[i] = 1;
                        break;
                    case "Gas":
                    case 2:
                        message.states[i] = 2;
                        break;
                    case "Powder":
                    case 3:
                        message.states[i] = 3;
                        break;
                    case "Paste":
                    case 4:
                        message.states[i] = 4;
                        break;
                    case "Pressed":
                    case 5:
                        message.states[i] = 5;
                        break;
                    }
            }
            if (object.temperature != null)
                message.temperature = object.temperature | 0;
            if (object.flags != null)
                message.flags = Boolean(object.flags);
            if (object.reaction != null)
                message.reaction = Boolean(object.reaction);
            return message;
        };

        /**
         * Creates a plain object from a BasicMaterialInfoMask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.BasicMaterialInfoMask
         * @static
         * @param {dfproto.BasicMaterialInfoMask} message BasicMaterialInfoMask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicMaterialInfoMask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.states = [];
            if (options.defaults) {
                object.flags = false;
                object.reaction = false;
                object.temperature = 10015;
            }
            if (message.states && message.states.length) {
                object.states = [];
                for (var j = 0; j < message.states.length; ++j)
                    object.states[j] = options.enums === String ? $root.dfproto.BasicMaterialInfoMask.StateType[message.states[j]] : message.states[j];
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.reaction != null && message.hasOwnProperty("reaction"))
                object.reaction = message.reaction;
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                object.temperature = message.temperature;
            return object;
        };

        /**
         * Converts this BasicMaterialInfoMask to JSON.
         * @function toJSON
         * @memberof dfproto.BasicMaterialInfoMask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicMaterialInfoMask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * StateType enum.
         * @name dfproto.BasicMaterialInfoMask.StateType
         * @enum {string}
         * @property {number} Solid=0 Solid value
         * @property {number} Liquid=1 Liquid value
         * @property {number} Gas=2 Gas value
         * @property {number} Powder=3 Powder value
         * @property {number} Paste=4 Paste value
         * @property {number} Pressed=5 Pressed value
         */
        BasicMaterialInfoMask.StateType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Solid"] = 0;
            values[valuesById[1] = "Liquid"] = 1;
            values[valuesById[2] = "Gas"] = 2;
            values[valuesById[3] = "Powder"] = 3;
            values[valuesById[4] = "Paste"] = 4;
            values[valuesById[5] = "Pressed"] = 5;
            return values;
        })();

        return BasicMaterialInfoMask;
    })();

    dfproto.JobSkillAttr = (function() {

        /**
         * Properties of a JobSkillAttr.
         * @memberof dfproto
         * @interface IJobSkillAttr
         * @property {number} id JobSkillAttr id
         * @property {string} key JobSkillAttr key
         * @property {string|null} [caption] JobSkillAttr caption
         * @property {string|null} [captionNoun] JobSkillAttr captionNoun
         * @property {number|null} [profession] JobSkillAttr profession
         * @property {number|null} [labor] JobSkillAttr labor
         * @property {string|null} [type] JobSkillAttr type
         */

        /**
         * Constructs a new JobSkillAttr.
         * @memberof dfproto
         * @classdesc Represents a JobSkillAttr.
         * @implements IJobSkillAttr
         * @constructor
         * @param {dfproto.IJobSkillAttr=} [properties] Properties to set
         */
        function JobSkillAttr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JobSkillAttr id.
         * @member {number} id
         * @memberof dfproto.JobSkillAttr
         * @instance
         */
        JobSkillAttr.prototype.id = 0;

        /**
         * JobSkillAttr key.
         * @member {string} key
         * @memberof dfproto.JobSkillAttr
         * @instance
         */
        JobSkillAttr.prototype.key = "";

        /**
         * JobSkillAttr caption.
         * @member {string} caption
         * @memberof dfproto.JobSkillAttr
         * @instance
         */
        JobSkillAttr.prototype.caption = "";

        /**
         * JobSkillAttr captionNoun.
         * @member {string} captionNoun
         * @memberof dfproto.JobSkillAttr
         * @instance
         */
        JobSkillAttr.prototype.captionNoun = "";

        /**
         * JobSkillAttr profession.
         * @member {number} profession
         * @memberof dfproto.JobSkillAttr
         * @instance
         */
        JobSkillAttr.prototype.profession = 0;

        /**
         * JobSkillAttr labor.
         * @member {number} labor
         * @memberof dfproto.JobSkillAttr
         * @instance
         */
        JobSkillAttr.prototype.labor = 0;

        /**
         * JobSkillAttr type.
         * @member {string} type
         * @memberof dfproto.JobSkillAttr
         * @instance
         */
        JobSkillAttr.prototype.type = "";

        /**
         * Creates a new JobSkillAttr instance using the specified properties.
         * @function create
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {dfproto.IJobSkillAttr=} [properties] Properties to set
         * @returns {dfproto.JobSkillAttr} JobSkillAttr instance
         */
        JobSkillAttr.create = function create(properties) {
            return new JobSkillAttr(properties);
        };

        /**
         * Encodes the specified JobSkillAttr message. Does not implicitly {@link dfproto.JobSkillAttr.verify|verify} messages.
         * @function encode
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {dfproto.IJobSkillAttr} message JobSkillAttr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JobSkillAttr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
            if (message.captionNoun != null && Object.hasOwnProperty.call(message, "captionNoun"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.captionNoun);
            if (message.profession != null && Object.hasOwnProperty.call(message, "profession"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.profession);
            if (message.labor != null && Object.hasOwnProperty.call(message, "labor"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.labor);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.type);
            return writer;
        };

        /**
         * Encodes the specified JobSkillAttr message, length delimited. Does not implicitly {@link dfproto.JobSkillAttr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {dfproto.IJobSkillAttr} message JobSkillAttr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JobSkillAttr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JobSkillAttr message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.JobSkillAttr} JobSkillAttr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JobSkillAttr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.JobSkillAttr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.key = reader.string();
                    break;
                case 3:
                    message.caption = reader.string();
                    break;
                case 4:
                    message.captionNoun = reader.string();
                    break;
                case 5:
                    message.profession = reader.int32();
                    break;
                case 6:
                    message.labor = reader.int32();
                    break;
                case 7:
                    message.type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            return message;
        };

        /**
         * Decodes a JobSkillAttr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.JobSkillAttr} JobSkillAttr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JobSkillAttr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JobSkillAttr message.
         * @function verify
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JobSkillAttr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isString(message.key))
                return "key: string expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.captionNoun != null && message.hasOwnProperty("captionNoun"))
                if (!$util.isString(message.captionNoun))
                    return "captionNoun: string expected";
            if (message.profession != null && message.hasOwnProperty("profession"))
                if (!$util.isInteger(message.profession))
                    return "profession: integer expected";
            if (message.labor != null && message.hasOwnProperty("labor"))
                if (!$util.isInteger(message.labor))
                    return "labor: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            return null;
        };

        /**
         * Creates a JobSkillAttr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.JobSkillAttr} JobSkillAttr
         */
        JobSkillAttr.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.JobSkillAttr)
                return object;
            var message = new $root.dfproto.JobSkillAttr();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.key != null)
                message.key = String(object.key);
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.captionNoun != null)
                message.captionNoun = String(object.captionNoun);
            if (object.profession != null)
                message.profession = object.profession | 0;
            if (object.labor != null)
                message.labor = object.labor | 0;
            if (object.type != null)
                message.type = String(object.type);
            return message;
        };

        /**
         * Creates a plain object from a JobSkillAttr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.JobSkillAttr
         * @static
         * @param {dfproto.JobSkillAttr} message JobSkillAttr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JobSkillAttr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.key = "";
                object.caption = "";
                object.captionNoun = "";
                object.profession = 0;
                object.labor = 0;
                object.type = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.captionNoun != null && message.hasOwnProperty("captionNoun"))
                object.captionNoun = message.captionNoun;
            if (message.profession != null && message.hasOwnProperty("profession"))
                object.profession = message.profession;
            if (message.labor != null && message.hasOwnProperty("labor"))
                object.labor = message.labor;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this JobSkillAttr to JSON.
         * @function toJSON
         * @memberof dfproto.JobSkillAttr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JobSkillAttr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return JobSkillAttr;
    })();

    dfproto.ProfessionAttr = (function() {

        /**
         * Properties of a ProfessionAttr.
         * @memberof dfproto
         * @interface IProfessionAttr
         * @property {number} id ProfessionAttr id
         * @property {string} key ProfessionAttr key
         * @property {string|null} [caption] ProfessionAttr caption
         * @property {boolean|null} [military] ProfessionAttr military
         * @property {boolean|null} [canAssignLabor] ProfessionAttr canAssignLabor
         * @property {number|null} [parent] ProfessionAttr parent
         */

        /**
         * Constructs a new ProfessionAttr.
         * @memberof dfproto
         * @classdesc Represents a ProfessionAttr.
         * @implements IProfessionAttr
         * @constructor
         * @param {dfproto.IProfessionAttr=} [properties] Properties to set
         */
        function ProfessionAttr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProfessionAttr id.
         * @member {number} id
         * @memberof dfproto.ProfessionAttr
         * @instance
         */
        ProfessionAttr.prototype.id = 0;

        /**
         * ProfessionAttr key.
         * @member {string} key
         * @memberof dfproto.ProfessionAttr
         * @instance
         */
        ProfessionAttr.prototype.key = "";

        /**
         * ProfessionAttr caption.
         * @member {string} caption
         * @memberof dfproto.ProfessionAttr
         * @instance
         */
        ProfessionAttr.prototype.caption = "";

        /**
         * ProfessionAttr military.
         * @member {boolean} military
         * @memberof dfproto.ProfessionAttr
         * @instance
         */
        ProfessionAttr.prototype.military = false;

        /**
         * ProfessionAttr canAssignLabor.
         * @member {boolean} canAssignLabor
         * @memberof dfproto.ProfessionAttr
         * @instance
         */
        ProfessionAttr.prototype.canAssignLabor = false;

        /**
         * ProfessionAttr parent.
         * @member {number} parent
         * @memberof dfproto.ProfessionAttr
         * @instance
         */
        ProfessionAttr.prototype.parent = 0;

        /**
         * Creates a new ProfessionAttr instance using the specified properties.
         * @function create
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {dfproto.IProfessionAttr=} [properties] Properties to set
         * @returns {dfproto.ProfessionAttr} ProfessionAttr instance
         */
        ProfessionAttr.create = function create(properties) {
            return new ProfessionAttr(properties);
        };

        /**
         * Encodes the specified ProfessionAttr message. Does not implicitly {@link dfproto.ProfessionAttr.verify|verify} messages.
         * @function encode
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {dfproto.IProfessionAttr} message ProfessionAttr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfessionAttr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
            if (message.military != null && Object.hasOwnProperty.call(message, "military"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.military);
            if (message.canAssignLabor != null && Object.hasOwnProperty.call(message, "canAssignLabor"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canAssignLabor);
            if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.parent);
            return writer;
        };

        /**
         * Encodes the specified ProfessionAttr message, length delimited. Does not implicitly {@link dfproto.ProfessionAttr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {dfproto.IProfessionAttr} message ProfessionAttr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfessionAttr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProfessionAttr message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.ProfessionAttr} ProfessionAttr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfessionAttr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.ProfessionAttr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.key = reader.string();
                    break;
                case 3:
                    message.caption = reader.string();
                    break;
                case 4:
                    message.military = reader.bool();
                    break;
                case 5:
                    message.canAssignLabor = reader.bool();
                    break;
                case 6:
                    message.parent = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            return message;
        };

        /**
         * Decodes a ProfessionAttr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.ProfessionAttr} ProfessionAttr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfessionAttr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProfessionAttr message.
         * @function verify
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProfessionAttr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isString(message.key))
                return "key: string expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.military != null && message.hasOwnProperty("military"))
                if (typeof message.military !== "boolean")
                    return "military: boolean expected";
            if (message.canAssignLabor != null && message.hasOwnProperty("canAssignLabor"))
                if (typeof message.canAssignLabor !== "boolean")
                    return "canAssignLabor: boolean expected";
            if (message.parent != null && message.hasOwnProperty("parent"))
                if (!$util.isInteger(message.parent))
                    return "parent: integer expected";
            return null;
        };

        /**
         * Creates a ProfessionAttr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.ProfessionAttr} ProfessionAttr
         */
        ProfessionAttr.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.ProfessionAttr)
                return object;
            var message = new $root.dfproto.ProfessionAttr();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.key != null)
                message.key = String(object.key);
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.military != null)
                message.military = Boolean(object.military);
            if (object.canAssignLabor != null)
                message.canAssignLabor = Boolean(object.canAssignLabor);
            if (object.parent != null)
                message.parent = object.parent | 0;
            return message;
        };

        /**
         * Creates a plain object from a ProfessionAttr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.ProfessionAttr
         * @static
         * @param {dfproto.ProfessionAttr} message ProfessionAttr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProfessionAttr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.key = "";
                object.caption = "";
                object.military = false;
                object.canAssignLabor = false;
                object.parent = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.military != null && message.hasOwnProperty("military"))
                object.military = message.military;
            if (message.canAssignLabor != null && message.hasOwnProperty("canAssignLabor"))
                object.canAssignLabor = message.canAssignLabor;
            if (message.parent != null && message.hasOwnProperty("parent"))
                object.parent = message.parent;
            return object;
        };

        /**
         * Converts this ProfessionAttr to JSON.
         * @function toJSON
         * @memberof dfproto.ProfessionAttr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProfessionAttr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProfessionAttr;
    })();

    dfproto.UnitLaborAttr = (function() {

        /**
         * Properties of an UnitLaborAttr.
         * @memberof dfproto
         * @interface IUnitLaborAttr
         * @property {number} id UnitLaborAttr id
         * @property {string} key UnitLaborAttr key
         * @property {string|null} [caption] UnitLaborAttr caption
         */

        /**
         * Constructs a new UnitLaborAttr.
         * @memberof dfproto
         * @classdesc Represents an UnitLaborAttr.
         * @implements IUnitLaborAttr
         * @constructor
         * @param {dfproto.IUnitLaborAttr=} [properties] Properties to set
         */
        function UnitLaborAttr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitLaborAttr id.
         * @member {number} id
         * @memberof dfproto.UnitLaborAttr
         * @instance
         */
        UnitLaborAttr.prototype.id = 0;

        /**
         * UnitLaborAttr key.
         * @member {string} key
         * @memberof dfproto.UnitLaborAttr
         * @instance
         */
        UnitLaborAttr.prototype.key = "";

        /**
         * UnitLaborAttr caption.
         * @member {string} caption
         * @memberof dfproto.UnitLaborAttr
         * @instance
         */
        UnitLaborAttr.prototype.caption = "";

        /**
         * Creates a new UnitLaborAttr instance using the specified properties.
         * @function create
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {dfproto.IUnitLaborAttr=} [properties] Properties to set
         * @returns {dfproto.UnitLaborAttr} UnitLaborAttr instance
         */
        UnitLaborAttr.create = function create(properties) {
            return new UnitLaborAttr(properties);
        };

        /**
         * Encodes the specified UnitLaborAttr message. Does not implicitly {@link dfproto.UnitLaborAttr.verify|verify} messages.
         * @function encode
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {dfproto.IUnitLaborAttr} message UnitLaborAttr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitLaborAttr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
            return writer;
        };

        /**
         * Encodes the specified UnitLaborAttr message, length delimited. Does not implicitly {@link dfproto.UnitLaborAttr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {dfproto.IUnitLaborAttr} message UnitLaborAttr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitLaborAttr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitLaborAttr message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.UnitLaborAttr} UnitLaborAttr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitLaborAttr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.UnitLaborAttr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.key = reader.string();
                    break;
                case 3:
                    message.caption = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnitLaborAttr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.UnitLaborAttr} UnitLaborAttr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitLaborAttr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitLaborAttr message.
         * @function verify
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitLaborAttr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isString(message.key))
                return "key: string expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            return null;
        };

        /**
         * Creates an UnitLaborAttr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.UnitLaborAttr} UnitLaborAttr
         */
        UnitLaborAttr.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.UnitLaborAttr)
                return object;
            var message = new $root.dfproto.UnitLaborAttr();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.key != null)
                message.key = String(object.key);
            if (object.caption != null)
                message.caption = String(object.caption);
            return message;
        };

        /**
         * Creates a plain object from an UnitLaborAttr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.UnitLaborAttr
         * @static
         * @param {dfproto.UnitLaborAttr} message UnitLaborAttr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitLaborAttr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.key = "";
                object.caption = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            return object;
        };

        /**
         * Converts this UnitLaborAttr to JSON.
         * @function toJSON
         * @memberof dfproto.UnitLaborAttr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitLaborAttr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitLaborAttr;
    })();

    dfproto.NameInfo = (function() {

        /**
         * Properties of a NameInfo.
         * @memberof dfproto
         * @interface INameInfo
         * @property {string|null} [firstName] NameInfo firstName
         * @property {string|null} [nickname] NameInfo nickname
         * @property {number|null} [languageId] NameInfo languageId
         * @property {string|null} [lastName] NameInfo lastName
         * @property {string|null} [englishName] NameInfo englishName
         */

        /**
         * Constructs a new NameInfo.
         * @memberof dfproto
         * @classdesc Represents a NameInfo.
         * @implements INameInfo
         * @constructor
         * @param {dfproto.INameInfo=} [properties] Properties to set
         */
        function NameInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NameInfo firstName.
         * @member {string} firstName
         * @memberof dfproto.NameInfo
         * @instance
         */
        NameInfo.prototype.firstName = "";

        /**
         * NameInfo nickname.
         * @member {string} nickname
         * @memberof dfproto.NameInfo
         * @instance
         */
        NameInfo.prototype.nickname = "";

        /**
         * NameInfo languageId.
         * @member {number} languageId
         * @memberof dfproto.NameInfo
         * @instance
         */
        NameInfo.prototype.languageId = -1;

        /**
         * NameInfo lastName.
         * @member {string} lastName
         * @memberof dfproto.NameInfo
         * @instance
         */
        NameInfo.prototype.lastName = "";

        /**
         * NameInfo englishName.
         * @member {string} englishName
         * @memberof dfproto.NameInfo
         * @instance
         */
        NameInfo.prototype.englishName = "";

        /**
         * Creates a new NameInfo instance using the specified properties.
         * @function create
         * @memberof dfproto.NameInfo
         * @static
         * @param {dfproto.INameInfo=} [properties] Properties to set
         * @returns {dfproto.NameInfo} NameInfo instance
         */
        NameInfo.create = function create(properties) {
            return new NameInfo(properties);
        };

        /**
         * Encodes the specified NameInfo message. Does not implicitly {@link dfproto.NameInfo.verify|verify} messages.
         * @function encode
         * @memberof dfproto.NameInfo
         * @static
         * @param {dfproto.INameInfo} message NameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NameInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.firstName != null && Object.hasOwnProperty.call(message, "firstName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.firstName);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.languageId != null && Object.hasOwnProperty.call(message, "languageId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.languageId);
            if (message.lastName != null && Object.hasOwnProperty.call(message, "lastName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.lastName);
            if (message.englishName != null && Object.hasOwnProperty.call(message, "englishName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.englishName);
            return writer;
        };

        /**
         * Encodes the specified NameInfo message, length delimited. Does not implicitly {@link dfproto.NameInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.NameInfo
         * @static
         * @param {dfproto.INameInfo} message NameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NameInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NameInfo message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.NameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.NameInfo} NameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NameInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.NameInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.firstName = reader.string();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    message.languageId = reader.int32();
                    break;
                case 4:
                    message.lastName = reader.string();
                    break;
                case 5:
                    message.englishName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NameInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.NameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.NameInfo} NameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NameInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NameInfo message.
         * @function verify
         * @memberof dfproto.NameInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NameInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                if (!$util.isString(message.firstName))
                    return "firstName: string expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.languageId != null && message.hasOwnProperty("languageId"))
                if (!$util.isInteger(message.languageId))
                    return "languageId: integer expected";
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                if (!$util.isString(message.lastName))
                    return "lastName: string expected";
            if (message.englishName != null && message.hasOwnProperty("englishName"))
                if (!$util.isString(message.englishName))
                    return "englishName: string expected";
            return null;
        };

        /**
         * Creates a NameInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.NameInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.NameInfo} NameInfo
         */
        NameInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.NameInfo)
                return object;
            var message = new $root.dfproto.NameInfo();
            if (object.firstName != null)
                message.firstName = String(object.firstName);
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.languageId != null)
                message.languageId = object.languageId | 0;
            if (object.lastName != null)
                message.lastName = String(object.lastName);
            if (object.englishName != null)
                message.englishName = String(object.englishName);
            return message;
        };

        /**
         * Creates a plain object from a NameInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.NameInfo
         * @static
         * @param {dfproto.NameInfo} message NameInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NameInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.firstName = "";
                object.nickname = "";
                object.languageId = -1;
                object.lastName = "";
                object.englishName = "";
            }
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                object.firstName = message.firstName;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.languageId != null && message.hasOwnProperty("languageId"))
                object.languageId = message.languageId;
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                object.lastName = message.lastName;
            if (message.englishName != null && message.hasOwnProperty("englishName"))
                object.englishName = message.englishName;
            return object;
        };

        /**
         * Converts this NameInfo to JSON.
         * @function toJSON
         * @memberof dfproto.NameInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NameInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NameInfo;
    })();

    dfproto.NameTriple = (function() {

        /**
         * Properties of a NameTriple.
         * @memberof dfproto
         * @interface INameTriple
         * @property {string} normal NameTriple normal
         * @property {string|null} [plural] NameTriple plural
         * @property {string|null} [adjective] NameTriple adjective
         */

        /**
         * Constructs a new NameTriple.
         * @memberof dfproto
         * @classdesc Represents a NameTriple.
         * @implements INameTriple
         * @constructor
         * @param {dfproto.INameTriple=} [properties] Properties to set
         */
        function NameTriple(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NameTriple normal.
         * @member {string} normal
         * @memberof dfproto.NameTriple
         * @instance
         */
        NameTriple.prototype.normal = "";

        /**
         * NameTriple plural.
         * @member {string} plural
         * @memberof dfproto.NameTriple
         * @instance
         */
        NameTriple.prototype.plural = "";

        /**
         * NameTriple adjective.
         * @member {string} adjective
         * @memberof dfproto.NameTriple
         * @instance
         */
        NameTriple.prototype.adjective = "";

        /**
         * Creates a new NameTriple instance using the specified properties.
         * @function create
         * @memberof dfproto.NameTriple
         * @static
         * @param {dfproto.INameTriple=} [properties] Properties to set
         * @returns {dfproto.NameTriple} NameTriple instance
         */
        NameTriple.create = function create(properties) {
            return new NameTriple(properties);
        };

        /**
         * Encodes the specified NameTriple message. Does not implicitly {@link dfproto.NameTriple.verify|verify} messages.
         * @function encode
         * @memberof dfproto.NameTriple
         * @static
         * @param {dfproto.INameTriple} message NameTriple message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NameTriple.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.normal);
            if (message.plural != null && Object.hasOwnProperty.call(message, "plural"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.plural);
            if (message.adjective != null && Object.hasOwnProperty.call(message, "adjective"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.adjective);
            return writer;
        };

        /**
         * Encodes the specified NameTriple message, length delimited. Does not implicitly {@link dfproto.NameTriple.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.NameTriple
         * @static
         * @param {dfproto.INameTriple} message NameTriple message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NameTriple.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NameTriple message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.NameTriple
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.NameTriple} NameTriple
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NameTriple.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.NameTriple();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.normal = reader.string();
                    break;
                case 2:
                    message.plural = reader.string();
                    break;
                case 3:
                    message.adjective = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("normal"))
                throw $util.ProtocolError("missing required 'normal'", { instance: message });
            return message;
        };

        /**
         * Decodes a NameTriple message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.NameTriple
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.NameTriple} NameTriple
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NameTriple.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NameTriple message.
         * @function verify
         * @memberof dfproto.NameTriple
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NameTriple.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.normal))
                return "normal: string expected";
            if (message.plural != null && message.hasOwnProperty("plural"))
                if (!$util.isString(message.plural))
                    return "plural: string expected";
            if (message.adjective != null && message.hasOwnProperty("adjective"))
                if (!$util.isString(message.adjective))
                    return "adjective: string expected";
            return null;
        };

        /**
         * Creates a NameTriple message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.NameTriple
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.NameTriple} NameTriple
         */
        NameTriple.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.NameTriple)
                return object;
            var message = new $root.dfproto.NameTriple();
            if (object.normal != null)
                message.normal = String(object.normal);
            if (object.plural != null)
                message.plural = String(object.plural);
            if (object.adjective != null)
                message.adjective = String(object.adjective);
            return message;
        };

        /**
         * Creates a plain object from a NameTriple message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.NameTriple
         * @static
         * @param {dfproto.NameTriple} message NameTriple
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NameTriple.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.normal = "";
                object.plural = "";
                object.adjective = "";
            }
            if (message.normal != null && message.hasOwnProperty("normal"))
                object.normal = message.normal;
            if (message.plural != null && message.hasOwnProperty("plural"))
                object.plural = message.plural;
            if (message.adjective != null && message.hasOwnProperty("adjective"))
                object.adjective = message.adjective;
            return object;
        };

        /**
         * Converts this NameTriple to JSON.
         * @function toJSON
         * @memberof dfproto.NameTriple
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NameTriple.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NameTriple;
    })();

    dfproto.UnitCurseInfo = (function() {

        /**
         * Properties of an UnitCurseInfo.
         * @memberof dfproto
         * @interface IUnitCurseInfo
         * @property {number} addTags1 UnitCurseInfo addTags1
         * @property {number} remTags1 UnitCurseInfo remTags1
         * @property {number} addTags2 UnitCurseInfo addTags2
         * @property {number} remTags2 UnitCurseInfo remTags2
         * @property {dfproto.INameTriple|null} [name] UnitCurseInfo name
         */

        /**
         * Constructs a new UnitCurseInfo.
         * @memberof dfproto
         * @classdesc Represents an UnitCurseInfo.
         * @implements IUnitCurseInfo
         * @constructor
         * @param {dfproto.IUnitCurseInfo=} [properties] Properties to set
         */
        function UnitCurseInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitCurseInfo addTags1.
         * @member {number} addTags1
         * @memberof dfproto.UnitCurseInfo
         * @instance
         */
        UnitCurseInfo.prototype.addTags1 = 0;

        /**
         * UnitCurseInfo remTags1.
         * @member {number} remTags1
         * @memberof dfproto.UnitCurseInfo
         * @instance
         */
        UnitCurseInfo.prototype.remTags1 = 0;

        /**
         * UnitCurseInfo addTags2.
         * @member {number} addTags2
         * @memberof dfproto.UnitCurseInfo
         * @instance
         */
        UnitCurseInfo.prototype.addTags2 = 0;

        /**
         * UnitCurseInfo remTags2.
         * @member {number} remTags2
         * @memberof dfproto.UnitCurseInfo
         * @instance
         */
        UnitCurseInfo.prototype.remTags2 = 0;

        /**
         * UnitCurseInfo name.
         * @member {dfproto.INameTriple|null|undefined} name
         * @memberof dfproto.UnitCurseInfo
         * @instance
         */
        UnitCurseInfo.prototype.name = null;

        /**
         * Creates a new UnitCurseInfo instance using the specified properties.
         * @function create
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {dfproto.IUnitCurseInfo=} [properties] Properties to set
         * @returns {dfproto.UnitCurseInfo} UnitCurseInfo instance
         */
        UnitCurseInfo.create = function create(properties) {
            return new UnitCurseInfo(properties);
        };

        /**
         * Encodes the specified UnitCurseInfo message. Does not implicitly {@link dfproto.UnitCurseInfo.verify|verify} messages.
         * @function encode
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {dfproto.IUnitCurseInfo} message UnitCurseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitCurseInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.addTags1);
            writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.remTags1);
            writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.addTags2);
            writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.remTags2);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                $root.dfproto.NameTriple.encode(message.name, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnitCurseInfo message, length delimited. Does not implicitly {@link dfproto.UnitCurseInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {dfproto.IUnitCurseInfo} message UnitCurseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitCurseInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitCurseInfo message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.UnitCurseInfo} UnitCurseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitCurseInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.UnitCurseInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addTags1 = reader.fixed32();
                    break;
                case 2:
                    message.remTags1 = reader.fixed32();
                    break;
                case 3:
                    message.addTags2 = reader.fixed32();
                    break;
                case 4:
                    message.remTags2 = reader.fixed32();
                    break;
                case 5:
                    message.name = $root.dfproto.NameTriple.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("addTags1"))
                throw $util.ProtocolError("missing required 'addTags1'", { instance: message });
            if (!message.hasOwnProperty("remTags1"))
                throw $util.ProtocolError("missing required 'remTags1'", { instance: message });
            if (!message.hasOwnProperty("addTags2"))
                throw $util.ProtocolError("missing required 'addTags2'", { instance: message });
            if (!message.hasOwnProperty("remTags2"))
                throw $util.ProtocolError("missing required 'remTags2'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnitCurseInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.UnitCurseInfo} UnitCurseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitCurseInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitCurseInfo message.
         * @function verify
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitCurseInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.addTags1))
                return "addTags1: integer expected";
            if (!$util.isInteger(message.remTags1))
                return "remTags1: integer expected";
            if (!$util.isInteger(message.addTags2))
                return "addTags2: integer expected";
            if (!$util.isInteger(message.remTags2))
                return "remTags2: integer expected";
            if (message.name != null && message.hasOwnProperty("name")) {
                var error = $root.dfproto.NameTriple.verify(message.name);
                if (error)
                    return "name." + error;
            }
            return null;
        };

        /**
         * Creates an UnitCurseInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.UnitCurseInfo} UnitCurseInfo
         */
        UnitCurseInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.UnitCurseInfo)
                return object;
            var message = new $root.dfproto.UnitCurseInfo();
            if (object.addTags1 != null)
                message.addTags1 = object.addTags1 >>> 0;
            if (object.remTags1 != null)
                message.remTags1 = object.remTags1 >>> 0;
            if (object.addTags2 != null)
                message.addTags2 = object.addTags2 >>> 0;
            if (object.remTags2 != null)
                message.remTags2 = object.remTags2 >>> 0;
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".dfproto.UnitCurseInfo.name: object expected");
                message.name = $root.dfproto.NameTriple.fromObject(object.name);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnitCurseInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.UnitCurseInfo
         * @static
         * @param {dfproto.UnitCurseInfo} message UnitCurseInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitCurseInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.addTags1 = 0;
                object.remTags1 = 0;
                object.addTags2 = 0;
                object.remTags2 = 0;
                object.name = null;
            }
            if (message.addTags1 != null && message.hasOwnProperty("addTags1"))
                object.addTags1 = message.addTags1;
            if (message.remTags1 != null && message.hasOwnProperty("remTags1"))
                object.remTags1 = message.remTags1;
            if (message.addTags2 != null && message.hasOwnProperty("addTags2"))
                object.addTags2 = message.addTags2;
            if (message.remTags2 != null && message.hasOwnProperty("remTags2"))
                object.remTags2 = message.remTags2;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = $root.dfproto.NameTriple.toObject(message.name, options);
            return object;
        };

        /**
         * Converts this UnitCurseInfo to JSON.
         * @function toJSON
         * @memberof dfproto.UnitCurseInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitCurseInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitCurseInfo;
    })();

    dfproto.SkillInfo = (function() {

        /**
         * Properties of a SkillInfo.
         * @memberof dfproto
         * @interface ISkillInfo
         * @property {number} id SkillInfo id
         * @property {number} level SkillInfo level
         * @property {number} experience SkillInfo experience
         */

        /**
         * Constructs a new SkillInfo.
         * @memberof dfproto
         * @classdesc Represents a SkillInfo.
         * @implements ISkillInfo
         * @constructor
         * @param {dfproto.ISkillInfo=} [properties] Properties to set
         */
        function SkillInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillInfo id.
         * @member {number} id
         * @memberof dfproto.SkillInfo
         * @instance
         */
        SkillInfo.prototype.id = 0;

        /**
         * SkillInfo level.
         * @member {number} level
         * @memberof dfproto.SkillInfo
         * @instance
         */
        SkillInfo.prototype.level = 0;

        /**
         * SkillInfo experience.
         * @member {number} experience
         * @memberof dfproto.SkillInfo
         * @instance
         */
        SkillInfo.prototype.experience = 0;

        /**
         * Creates a new SkillInfo instance using the specified properties.
         * @function create
         * @memberof dfproto.SkillInfo
         * @static
         * @param {dfproto.ISkillInfo=} [properties] Properties to set
         * @returns {dfproto.SkillInfo} SkillInfo instance
         */
        SkillInfo.create = function create(properties) {
            return new SkillInfo(properties);
        };

        /**
         * Encodes the specified SkillInfo message. Does not implicitly {@link dfproto.SkillInfo.verify|verify} messages.
         * @function encode
         * @memberof dfproto.SkillInfo
         * @static
         * @param {dfproto.ISkillInfo} message SkillInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.experience);
            return writer;
        };

        /**
         * Encodes the specified SkillInfo message, length delimited. Does not implicitly {@link dfproto.SkillInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.SkillInfo
         * @static
         * @param {dfproto.ISkillInfo} message SkillInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SkillInfo message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.SkillInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.SkillInfo} SkillInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.SkillInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                case 3:
                    message.experience = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("level"))
                throw $util.ProtocolError("missing required 'level'", { instance: message });
            if (!message.hasOwnProperty("experience"))
                throw $util.ProtocolError("missing required 'experience'", { instance: message });
            return message;
        };

        /**
         * Decodes a SkillInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.SkillInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.SkillInfo} SkillInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SkillInfo message.
         * @function verify
         * @memberof dfproto.SkillInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SkillInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.level))
                return "level: integer expected";
            if (!$util.isInteger(message.experience))
                return "experience: integer expected";
            return null;
        };

        /**
         * Creates a SkillInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.SkillInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.SkillInfo} SkillInfo
         */
        SkillInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.SkillInfo)
                return object;
            var message = new $root.dfproto.SkillInfo();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.level != null)
                message.level = object.level | 0;
            if (object.experience != null)
                message.experience = object.experience | 0;
            return message;
        };

        /**
         * Creates a plain object from a SkillInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.SkillInfo
         * @static
         * @param {dfproto.SkillInfo} message SkillInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SkillInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.level = 0;
                object.experience = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.experience != null && message.hasOwnProperty("experience"))
                object.experience = message.experience;
            return object;
        };

        /**
         * Converts this SkillInfo to JSON.
         * @function toJSON
         * @memberof dfproto.SkillInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SkillInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SkillInfo;
    })();

    dfproto.UnitMiscTrait = (function() {

        /**
         * Properties of an UnitMiscTrait.
         * @memberof dfproto
         * @interface IUnitMiscTrait
         * @property {number} id UnitMiscTrait id
         * @property {number} value UnitMiscTrait value
         */

        /**
         * Constructs a new UnitMiscTrait.
         * @memberof dfproto
         * @classdesc Represents an UnitMiscTrait.
         * @implements IUnitMiscTrait
         * @constructor
         * @param {dfproto.IUnitMiscTrait=} [properties] Properties to set
         */
        function UnitMiscTrait(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitMiscTrait id.
         * @member {number} id
         * @memberof dfproto.UnitMiscTrait
         * @instance
         */
        UnitMiscTrait.prototype.id = 0;

        /**
         * UnitMiscTrait value.
         * @member {number} value
         * @memberof dfproto.UnitMiscTrait
         * @instance
         */
        UnitMiscTrait.prototype.value = 0;

        /**
         * Creates a new UnitMiscTrait instance using the specified properties.
         * @function create
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {dfproto.IUnitMiscTrait=} [properties] Properties to set
         * @returns {dfproto.UnitMiscTrait} UnitMiscTrait instance
         */
        UnitMiscTrait.create = function create(properties) {
            return new UnitMiscTrait(properties);
        };

        /**
         * Encodes the specified UnitMiscTrait message. Does not implicitly {@link dfproto.UnitMiscTrait.verify|verify} messages.
         * @function encode
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {dfproto.IUnitMiscTrait} message UnitMiscTrait message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitMiscTrait.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
            return writer;
        };

        /**
         * Encodes the specified UnitMiscTrait message, length delimited. Does not implicitly {@link dfproto.UnitMiscTrait.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {dfproto.IUnitMiscTrait} message UnitMiscTrait message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitMiscTrait.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitMiscTrait message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.UnitMiscTrait} UnitMiscTrait
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitMiscTrait.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.UnitMiscTrait();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnitMiscTrait message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.UnitMiscTrait} UnitMiscTrait
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitMiscTrait.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitMiscTrait message.
         * @function verify
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitMiscTrait.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.value))
                return "value: integer expected";
            return null;
        };

        /**
         * Creates an UnitMiscTrait message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.UnitMiscTrait} UnitMiscTrait
         */
        UnitMiscTrait.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.UnitMiscTrait)
                return object;
            var message = new $root.dfproto.UnitMiscTrait();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.value != null)
                message.value = object.value | 0;
            return message;
        };

        /**
         * Creates a plain object from an UnitMiscTrait message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.UnitMiscTrait
         * @static
         * @param {dfproto.UnitMiscTrait} message UnitMiscTrait
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitMiscTrait.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.value = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this UnitMiscTrait to JSON.
         * @function toJSON
         * @memberof dfproto.UnitMiscTrait
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitMiscTrait.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitMiscTrait;
    })();

    dfproto.BasicUnitInfo = (function() {

        /**
         * Properties of a BasicUnitInfo.
         * @memberof dfproto
         * @interface IBasicUnitInfo
         * @property {number} unitId BasicUnitInfo unitId
         * @property {number} posX BasicUnitInfo posX
         * @property {number} posY BasicUnitInfo posY
         * @property {number} posZ BasicUnitInfo posZ
         * @property {dfproto.INameInfo|null} [name] BasicUnitInfo name
         * @property {number} flags1 BasicUnitInfo flags1
         * @property {number} flags2 BasicUnitInfo flags2
         * @property {number} flags3 BasicUnitInfo flags3
         * @property {number} race BasicUnitInfo race
         * @property {number} caste BasicUnitInfo caste
         * @property {number|null} [gender] BasicUnitInfo gender
         * @property {number|null} [civId] BasicUnitInfo civId
         * @property {number|null} [histfigId] BasicUnitInfo histfigId
         * @property {number|null} [deathId] BasicUnitInfo deathId
         * @property {number|null} [deathFlags] BasicUnitInfo deathFlags
         * @property {number|null} [squadId] BasicUnitInfo squadId
         * @property {number|null} [squadPosition] BasicUnitInfo squadPosition
         * @property {number|null} [profession] BasicUnitInfo profession
         * @property {string|null} [customProfession] BasicUnitInfo customProfession
         * @property {Array.<number>|null} [labors] BasicUnitInfo labors
         * @property {Array.<dfproto.ISkillInfo>|null} [skills] BasicUnitInfo skills
         * @property {Array.<dfproto.IUnitMiscTrait>|null} [miscTraits] BasicUnitInfo miscTraits
         * @property {dfproto.IUnitCurseInfo|null} [curse] BasicUnitInfo curse
         * @property {Array.<number>|null} [burrows] BasicUnitInfo burrows
         */

        /**
         * Constructs a new BasicUnitInfo.
         * @memberof dfproto
         * @classdesc Represents a BasicUnitInfo.
         * @implements IBasicUnitInfo
         * @constructor
         * @param {dfproto.IBasicUnitInfo=} [properties] Properties to set
         */
        function BasicUnitInfo(properties) {
            this.labors = [];
            this.skills = [];
            this.miscTraits = [];
            this.burrows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicUnitInfo unitId.
         * @member {number} unitId
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.unitId = 0;

        /**
         * BasicUnitInfo posX.
         * @member {number} posX
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.posX = 0;

        /**
         * BasicUnitInfo posY.
         * @member {number} posY
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.posY = 0;

        /**
         * BasicUnitInfo posZ.
         * @member {number} posZ
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.posZ = 0;

        /**
         * BasicUnitInfo name.
         * @member {dfproto.INameInfo|null|undefined} name
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.name = null;

        /**
         * BasicUnitInfo flags1.
         * @member {number} flags1
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.flags1 = 0;

        /**
         * BasicUnitInfo flags2.
         * @member {number} flags2
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.flags2 = 0;

        /**
         * BasicUnitInfo flags3.
         * @member {number} flags3
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.flags3 = 0;

        /**
         * BasicUnitInfo race.
         * @member {number} race
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.race = 0;

        /**
         * BasicUnitInfo caste.
         * @member {number} caste
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.caste = 0;

        /**
         * BasicUnitInfo gender.
         * @member {number} gender
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.gender = -1;

        /**
         * BasicUnitInfo civId.
         * @member {number} civId
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.civId = -1;

        /**
         * BasicUnitInfo histfigId.
         * @member {number} histfigId
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.histfigId = -1;

        /**
         * BasicUnitInfo deathId.
         * @member {number} deathId
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.deathId = -1;

        /**
         * BasicUnitInfo deathFlags.
         * @member {number} deathFlags
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.deathFlags = 0;

        /**
         * BasicUnitInfo squadId.
         * @member {number} squadId
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.squadId = -1;

        /**
         * BasicUnitInfo squadPosition.
         * @member {number} squadPosition
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.squadPosition = -1;

        /**
         * BasicUnitInfo profession.
         * @member {number} profession
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.profession = -1;

        /**
         * BasicUnitInfo customProfession.
         * @member {string} customProfession
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.customProfession = "";

        /**
         * BasicUnitInfo labors.
         * @member {Array.<number>} labors
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.labors = $util.emptyArray;

        /**
         * BasicUnitInfo skills.
         * @member {Array.<dfproto.ISkillInfo>} skills
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.skills = $util.emptyArray;

        /**
         * BasicUnitInfo miscTraits.
         * @member {Array.<dfproto.IUnitMiscTrait>} miscTraits
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.miscTraits = $util.emptyArray;

        /**
         * BasicUnitInfo curse.
         * @member {dfproto.IUnitCurseInfo|null|undefined} curse
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.curse = null;

        /**
         * BasicUnitInfo burrows.
         * @member {Array.<number>} burrows
         * @memberof dfproto.BasicUnitInfo
         * @instance
         */
        BasicUnitInfo.prototype.burrows = $util.emptyArray;

        /**
         * Creates a new BasicUnitInfo instance using the specified properties.
         * @function create
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {dfproto.IBasicUnitInfo=} [properties] Properties to set
         * @returns {dfproto.BasicUnitInfo} BasicUnitInfo instance
         */
        BasicUnitInfo.create = function create(properties) {
            return new BasicUnitInfo(properties);
        };

        /**
         * Encodes the specified BasicUnitInfo message. Does not implicitly {@link dfproto.BasicUnitInfo.verify|verify} messages.
         * @function encode
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {dfproto.IBasicUnitInfo} message BasicUnitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicUnitInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.unitId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                $root.dfproto.NameInfo.encode(message.name, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.flags1);
            writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.flags2);
            writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.flags3);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.race);
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.caste);
            if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.gender);
            if (message.civId != null && Object.hasOwnProperty.call(message, "civId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.civId);
            if (message.histfigId != null && Object.hasOwnProperty.call(message, "histfigId"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.histfigId);
            if (message.labors != null && message.labors.length)
                for (var i = 0; i < message.labors.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.labors[i]);
            if (message.skills != null && message.skills.length)
                for (var i = 0; i < message.skills.length; ++i)
                    $root.dfproto.SkillInfo.encode(message.skills[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            writer.uint32(/* id 13, wireType 0 =*/104).int32(message.posX);
            writer.uint32(/* id 14, wireType 0 =*/112).int32(message.posY);
            writer.uint32(/* id 15, wireType 0 =*/120).int32(message.posZ);
            if (message.curse != null && Object.hasOwnProperty.call(message, "curse"))
                $root.dfproto.UnitCurseInfo.encode(message.curse, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.deathId != null && Object.hasOwnProperty.call(message, "deathId"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.deathId);
            if (message.deathFlags != null && Object.hasOwnProperty.call(message, "deathFlags"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.deathFlags);
            if (message.squadId != null && Object.hasOwnProperty.call(message, "squadId"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.squadId);
            if (message.squadPosition != null && Object.hasOwnProperty.call(message, "squadPosition"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.squadPosition);
            if (message.burrows != null && message.burrows.length)
                for (var i = 0; i < message.burrows.length; ++i)
                    writer.uint32(/* id 21, wireType 0 =*/168).int32(message.burrows[i]);
            if (message.profession != null && Object.hasOwnProperty.call(message, "profession"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.profession);
            if (message.customProfession != null && Object.hasOwnProperty.call(message, "customProfession"))
                writer.uint32(/* id 23, wireType 2 =*/186).string(message.customProfession);
            if (message.miscTraits != null && message.miscTraits.length)
                for (var i = 0; i < message.miscTraits.length; ++i)
                    $root.dfproto.UnitMiscTrait.encode(message.miscTraits[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BasicUnitInfo message, length delimited. Does not implicitly {@link dfproto.BasicUnitInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {dfproto.IBasicUnitInfo} message BasicUnitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicUnitInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicUnitInfo message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.BasicUnitInfo} BasicUnitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicUnitInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.BasicUnitInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.unitId = reader.int32();
                    break;
                case 13:
                    message.posX = reader.int32();
                    break;
                case 14:
                    message.posY = reader.int32();
                    break;
                case 15:
                    message.posZ = reader.int32();
                    break;
                case 2:
                    message.name = $root.dfproto.NameInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.flags1 = reader.fixed32();
                    break;
                case 4:
                    message.flags2 = reader.fixed32();
                    break;
                case 5:
                    message.flags3 = reader.fixed32();
                    break;
                case 6:
                    message.race = reader.int32();
                    break;
                case 7:
                    message.caste = reader.int32();
                    break;
                case 8:
                    message.gender = reader.int32();
                    break;
                case 9:
                    message.civId = reader.int32();
                    break;
                case 10:
                    message.histfigId = reader.int32();
                    break;
                case 17:
                    message.deathId = reader.int32();
                    break;
                case 18:
                    message.deathFlags = reader.uint32();
                    break;
                case 19:
                    message.squadId = reader.int32();
                    break;
                case 20:
                    message.squadPosition = reader.int32();
                    break;
                case 22:
                    message.profession = reader.int32();
                    break;
                case 23:
                    message.customProfession = reader.string();
                    break;
                case 11:
                    if (!(message.labors && message.labors.length))
                        message.labors = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.labors.push(reader.int32());
                    } else
                        message.labors.push(reader.int32());
                    break;
                case 12:
                    if (!(message.skills && message.skills.length))
                        message.skills = [];
                    message.skills.push($root.dfproto.SkillInfo.decode(reader, reader.uint32()));
                    break;
                case 24:
                    if (!(message.miscTraits && message.miscTraits.length))
                        message.miscTraits = [];
                    message.miscTraits.push($root.dfproto.UnitMiscTrait.decode(reader, reader.uint32()));
                    break;
                case 16:
                    message.curse = $root.dfproto.UnitCurseInfo.decode(reader, reader.uint32());
                    break;
                case 21:
                    if (!(message.burrows && message.burrows.length))
                        message.burrows = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.burrows.push(reader.int32());
                    } else
                        message.burrows.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("unitId"))
                throw $util.ProtocolError("missing required 'unitId'", { instance: message });
            if (!message.hasOwnProperty("posX"))
                throw $util.ProtocolError("missing required 'posX'", { instance: message });
            if (!message.hasOwnProperty("posY"))
                throw $util.ProtocolError("missing required 'posY'", { instance: message });
            if (!message.hasOwnProperty("posZ"))
                throw $util.ProtocolError("missing required 'posZ'", { instance: message });
            if (!message.hasOwnProperty("flags1"))
                throw $util.ProtocolError("missing required 'flags1'", { instance: message });
            if (!message.hasOwnProperty("flags2"))
                throw $util.ProtocolError("missing required 'flags2'", { instance: message });
            if (!message.hasOwnProperty("flags3"))
                throw $util.ProtocolError("missing required 'flags3'", { instance: message });
            if (!message.hasOwnProperty("race"))
                throw $util.ProtocolError("missing required 'race'", { instance: message });
            if (!message.hasOwnProperty("caste"))
                throw $util.ProtocolError("missing required 'caste'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicUnitInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.BasicUnitInfo} BasicUnitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicUnitInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicUnitInfo message.
         * @function verify
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicUnitInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.unitId))
                return "unitId: integer expected";
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
            if (!$util.isInteger(message.posZ))
                return "posZ: integer expected";
            if (message.name != null && message.hasOwnProperty("name")) {
                var error = $root.dfproto.NameInfo.verify(message.name);
                if (error)
                    return "name." + error;
            }
            if (!$util.isInteger(message.flags1))
                return "flags1: integer expected";
            if (!$util.isInteger(message.flags2))
                return "flags2: integer expected";
            if (!$util.isInteger(message.flags3))
                return "flags3: integer expected";
            if (!$util.isInteger(message.race))
                return "race: integer expected";
            if (!$util.isInteger(message.caste))
                return "caste: integer expected";
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            if (message.civId != null && message.hasOwnProperty("civId"))
                if (!$util.isInteger(message.civId))
                    return "civId: integer expected";
            if (message.histfigId != null && message.hasOwnProperty("histfigId"))
                if (!$util.isInteger(message.histfigId))
                    return "histfigId: integer expected";
            if (message.deathId != null && message.hasOwnProperty("deathId"))
                if (!$util.isInteger(message.deathId))
                    return "deathId: integer expected";
            if (message.deathFlags != null && message.hasOwnProperty("deathFlags"))
                if (!$util.isInteger(message.deathFlags))
                    return "deathFlags: integer expected";
            if (message.squadId != null && message.hasOwnProperty("squadId"))
                if (!$util.isInteger(message.squadId))
                    return "squadId: integer expected";
            if (message.squadPosition != null && message.hasOwnProperty("squadPosition"))
                if (!$util.isInteger(message.squadPosition))
                    return "squadPosition: integer expected";
            if (message.profession != null && message.hasOwnProperty("profession"))
                if (!$util.isInteger(message.profession))
                    return "profession: integer expected";
            if (message.customProfession != null && message.hasOwnProperty("customProfession"))
                if (!$util.isString(message.customProfession))
                    return "customProfession: string expected";
            if (message.labors != null && message.hasOwnProperty("labors")) {
                if (!Array.isArray(message.labors))
                    return "labors: array expected";
                for (var i = 0; i < message.labors.length; ++i)
                    if (!$util.isInteger(message.labors[i]))
                        return "labors: integer[] expected";
            }
            if (message.skills != null && message.hasOwnProperty("skills")) {
                if (!Array.isArray(message.skills))
                    return "skills: array expected";
                for (var i = 0; i < message.skills.length; ++i) {
                    var error = $root.dfproto.SkillInfo.verify(message.skills[i]);
                    if (error)
                        return "skills." + error;
                }
            }
            if (message.miscTraits != null && message.hasOwnProperty("miscTraits")) {
                if (!Array.isArray(message.miscTraits))
                    return "miscTraits: array expected";
                for (var i = 0; i < message.miscTraits.length; ++i) {
                    var error = $root.dfproto.UnitMiscTrait.verify(message.miscTraits[i]);
                    if (error)
                        return "miscTraits." + error;
                }
            }
            if (message.curse != null && message.hasOwnProperty("curse")) {
                var error = $root.dfproto.UnitCurseInfo.verify(message.curse);
                if (error)
                    return "curse." + error;
            }
            if (message.burrows != null && message.hasOwnProperty("burrows")) {
                if (!Array.isArray(message.burrows))
                    return "burrows: array expected";
                for (var i = 0; i < message.burrows.length; ++i)
                    if (!$util.isInteger(message.burrows[i]))
                        return "burrows: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BasicUnitInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.BasicUnitInfo} BasicUnitInfo
         */
        BasicUnitInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.BasicUnitInfo)
                return object;
            var message = new $root.dfproto.BasicUnitInfo();
            if (object.unitId != null)
                message.unitId = object.unitId | 0;
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.posZ != null)
                message.posZ = object.posZ | 0;
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".dfproto.BasicUnitInfo.name: object expected");
                message.name = $root.dfproto.NameInfo.fromObject(object.name);
            }
            if (object.flags1 != null)
                message.flags1 = object.flags1 >>> 0;
            if (object.flags2 != null)
                message.flags2 = object.flags2 >>> 0;
            if (object.flags3 != null)
                message.flags3 = object.flags3 >>> 0;
            if (object.race != null)
                message.race = object.race | 0;
            if (object.caste != null)
                message.caste = object.caste | 0;
            if (object.gender != null)
                message.gender = object.gender | 0;
            if (object.civId != null)
                message.civId = object.civId | 0;
            if (object.histfigId != null)
                message.histfigId = object.histfigId | 0;
            if (object.deathId != null)
                message.deathId = object.deathId | 0;
            if (object.deathFlags != null)
                message.deathFlags = object.deathFlags >>> 0;
            if (object.squadId != null)
                message.squadId = object.squadId | 0;
            if (object.squadPosition != null)
                message.squadPosition = object.squadPosition | 0;
            if (object.profession != null)
                message.profession = object.profession | 0;
            if (object.customProfession != null)
                message.customProfession = String(object.customProfession);
            if (object.labors) {
                if (!Array.isArray(object.labors))
                    throw TypeError(".dfproto.BasicUnitInfo.labors: array expected");
                message.labors = [];
                for (var i = 0; i < object.labors.length; ++i)
                    message.labors[i] = object.labors[i] | 0;
            }
            if (object.skills) {
                if (!Array.isArray(object.skills))
                    throw TypeError(".dfproto.BasicUnitInfo.skills: array expected");
                message.skills = [];
                for (var i = 0; i < object.skills.length; ++i) {
                    if (typeof object.skills[i] !== "object")
                        throw TypeError(".dfproto.BasicUnitInfo.skills: object expected");
                    message.skills[i] = $root.dfproto.SkillInfo.fromObject(object.skills[i]);
                }
            }
            if (object.miscTraits) {
                if (!Array.isArray(object.miscTraits))
                    throw TypeError(".dfproto.BasicUnitInfo.miscTraits: array expected");
                message.miscTraits = [];
                for (var i = 0; i < object.miscTraits.length; ++i) {
                    if (typeof object.miscTraits[i] !== "object")
                        throw TypeError(".dfproto.BasicUnitInfo.miscTraits: object expected");
                    message.miscTraits[i] = $root.dfproto.UnitMiscTrait.fromObject(object.miscTraits[i]);
                }
            }
            if (object.curse != null) {
                if (typeof object.curse !== "object")
                    throw TypeError(".dfproto.BasicUnitInfo.curse: object expected");
                message.curse = $root.dfproto.UnitCurseInfo.fromObject(object.curse);
            }
            if (object.burrows) {
                if (!Array.isArray(object.burrows))
                    throw TypeError(".dfproto.BasicUnitInfo.burrows: array expected");
                message.burrows = [];
                for (var i = 0; i < object.burrows.length; ++i)
                    message.burrows[i] = object.burrows[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BasicUnitInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.BasicUnitInfo
         * @static
         * @param {dfproto.BasicUnitInfo} message BasicUnitInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicUnitInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.labors = [];
                object.skills = [];
                object.burrows = [];
                object.miscTraits = [];
            }
            if (options.defaults) {
                object.unitId = 0;
                object.name = null;
                object.flags1 = 0;
                object.flags2 = 0;
                object.flags3 = 0;
                object.race = 0;
                object.caste = 0;
                object.gender = -1;
                object.civId = -1;
                object.histfigId = -1;
                object.posX = 0;
                object.posY = 0;
                object.posZ = 0;
                object.curse = null;
                object.deathId = -1;
                object.deathFlags = 0;
                object.squadId = -1;
                object.squadPosition = -1;
                object.profession = -1;
                object.customProfession = "";
            }
            if (message.unitId != null && message.hasOwnProperty("unitId"))
                object.unitId = message.unitId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = $root.dfproto.NameInfo.toObject(message.name, options);
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                object.flags1 = message.flags1;
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                object.flags2 = message.flags2;
            if (message.flags3 != null && message.hasOwnProperty("flags3"))
                object.flags3 = message.flags3;
            if (message.race != null && message.hasOwnProperty("race"))
                object.race = message.race;
            if (message.caste != null && message.hasOwnProperty("caste"))
                object.caste = message.caste;
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.civId != null && message.hasOwnProperty("civId"))
                object.civId = message.civId;
            if (message.histfigId != null && message.hasOwnProperty("histfigId"))
                object.histfigId = message.histfigId;
            if (message.labors && message.labors.length) {
                object.labors = [];
                for (var j = 0; j < message.labors.length; ++j)
                    object.labors[j] = message.labors[j];
            }
            if (message.skills && message.skills.length) {
                object.skills = [];
                for (var j = 0; j < message.skills.length; ++j)
                    object.skills[j] = $root.dfproto.SkillInfo.toObject(message.skills[j], options);
            }
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                object.posZ = message.posZ;
            if (message.curse != null && message.hasOwnProperty("curse"))
                object.curse = $root.dfproto.UnitCurseInfo.toObject(message.curse, options);
            if (message.deathId != null && message.hasOwnProperty("deathId"))
                object.deathId = message.deathId;
            if (message.deathFlags != null && message.hasOwnProperty("deathFlags"))
                object.deathFlags = message.deathFlags;
            if (message.squadId != null && message.hasOwnProperty("squadId"))
                object.squadId = message.squadId;
            if (message.squadPosition != null && message.hasOwnProperty("squadPosition"))
                object.squadPosition = message.squadPosition;
            if (message.burrows && message.burrows.length) {
                object.burrows = [];
                for (var j = 0; j < message.burrows.length; ++j)
                    object.burrows[j] = message.burrows[j];
            }
            if (message.profession != null && message.hasOwnProperty("profession"))
                object.profession = message.profession;
            if (message.customProfession != null && message.hasOwnProperty("customProfession"))
                object.customProfession = message.customProfession;
            if (message.miscTraits && message.miscTraits.length) {
                object.miscTraits = [];
                for (var j = 0; j < message.miscTraits.length; ++j)
                    object.miscTraits[j] = $root.dfproto.UnitMiscTrait.toObject(message.miscTraits[j], options);
            }
            return object;
        };

        /**
         * Converts this BasicUnitInfo to JSON.
         * @function toJSON
         * @memberof dfproto.BasicUnitInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicUnitInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicUnitInfo;
    })();

    dfproto.BasicUnitInfoMask = (function() {

        /**
         * Properties of a BasicUnitInfoMask.
         * @memberof dfproto
         * @interface IBasicUnitInfoMask
         * @property {boolean|null} [labors] BasicUnitInfoMask labors
         * @property {boolean|null} [skills] BasicUnitInfoMask skills
         * @property {boolean|null} [profession] BasicUnitInfoMask profession
         * @property {boolean|null} [miscTraits] BasicUnitInfoMask miscTraits
         */

        /**
         * Constructs a new BasicUnitInfoMask.
         * @memberof dfproto
         * @classdesc Represents a BasicUnitInfoMask.
         * @implements IBasicUnitInfoMask
         * @constructor
         * @param {dfproto.IBasicUnitInfoMask=} [properties] Properties to set
         */
        function BasicUnitInfoMask(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicUnitInfoMask labors.
         * @member {boolean} labors
         * @memberof dfproto.BasicUnitInfoMask
         * @instance
         */
        BasicUnitInfoMask.prototype.labors = false;

        /**
         * BasicUnitInfoMask skills.
         * @member {boolean} skills
         * @memberof dfproto.BasicUnitInfoMask
         * @instance
         */
        BasicUnitInfoMask.prototype.skills = false;

        /**
         * BasicUnitInfoMask profession.
         * @member {boolean} profession
         * @memberof dfproto.BasicUnitInfoMask
         * @instance
         */
        BasicUnitInfoMask.prototype.profession = false;

        /**
         * BasicUnitInfoMask miscTraits.
         * @member {boolean} miscTraits
         * @memberof dfproto.BasicUnitInfoMask
         * @instance
         */
        BasicUnitInfoMask.prototype.miscTraits = false;

        /**
         * Creates a new BasicUnitInfoMask instance using the specified properties.
         * @function create
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {dfproto.IBasicUnitInfoMask=} [properties] Properties to set
         * @returns {dfproto.BasicUnitInfoMask} BasicUnitInfoMask instance
         */
        BasicUnitInfoMask.create = function create(properties) {
            return new BasicUnitInfoMask(properties);
        };

        /**
         * Encodes the specified BasicUnitInfoMask message. Does not implicitly {@link dfproto.BasicUnitInfoMask.verify|verify} messages.
         * @function encode
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {dfproto.IBasicUnitInfoMask} message BasicUnitInfoMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicUnitInfoMask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.labors != null && Object.hasOwnProperty.call(message, "labors"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.labors);
            if (message.skills != null && Object.hasOwnProperty.call(message, "skills"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.skills);
            if (message.profession != null && Object.hasOwnProperty.call(message, "profession"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.profession);
            if (message.miscTraits != null && Object.hasOwnProperty.call(message, "miscTraits"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.miscTraits);
            return writer;
        };

        /**
         * Encodes the specified BasicUnitInfoMask message, length delimited. Does not implicitly {@link dfproto.BasicUnitInfoMask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {dfproto.IBasicUnitInfoMask} message BasicUnitInfoMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicUnitInfoMask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicUnitInfoMask message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.BasicUnitInfoMask} BasicUnitInfoMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicUnitInfoMask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.BasicUnitInfoMask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.labors = reader.bool();
                    break;
                case 2:
                    message.skills = reader.bool();
                    break;
                case 3:
                    message.profession = reader.bool();
                    break;
                case 4:
                    message.miscTraits = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BasicUnitInfoMask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.BasicUnitInfoMask} BasicUnitInfoMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicUnitInfoMask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicUnitInfoMask message.
         * @function verify
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicUnitInfoMask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.labors != null && message.hasOwnProperty("labors"))
                if (typeof message.labors !== "boolean")
                    return "labors: boolean expected";
            if (message.skills != null && message.hasOwnProperty("skills"))
                if (typeof message.skills !== "boolean")
                    return "skills: boolean expected";
            if (message.profession != null && message.hasOwnProperty("profession"))
                if (typeof message.profession !== "boolean")
                    return "profession: boolean expected";
            if (message.miscTraits != null && message.hasOwnProperty("miscTraits"))
                if (typeof message.miscTraits !== "boolean")
                    return "miscTraits: boolean expected";
            return null;
        };

        /**
         * Creates a BasicUnitInfoMask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.BasicUnitInfoMask} BasicUnitInfoMask
         */
        BasicUnitInfoMask.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.BasicUnitInfoMask)
                return object;
            var message = new $root.dfproto.BasicUnitInfoMask();
            if (object.labors != null)
                message.labors = Boolean(object.labors);
            if (object.skills != null)
                message.skills = Boolean(object.skills);
            if (object.profession != null)
                message.profession = Boolean(object.profession);
            if (object.miscTraits != null)
                message.miscTraits = Boolean(object.miscTraits);
            return message;
        };

        /**
         * Creates a plain object from a BasicUnitInfoMask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.BasicUnitInfoMask
         * @static
         * @param {dfproto.BasicUnitInfoMask} message BasicUnitInfoMask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicUnitInfoMask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.labors = false;
                object.skills = false;
                object.profession = false;
                object.miscTraits = false;
            }
            if (message.labors != null && message.hasOwnProperty("labors"))
                object.labors = message.labors;
            if (message.skills != null && message.hasOwnProperty("skills"))
                object.skills = message.skills;
            if (message.profession != null && message.hasOwnProperty("profession"))
                object.profession = message.profession;
            if (message.miscTraits != null && message.hasOwnProperty("miscTraits"))
                object.miscTraits = message.miscTraits;
            return object;
        };

        /**
         * Converts this BasicUnitInfoMask to JSON.
         * @function toJSON
         * @memberof dfproto.BasicUnitInfoMask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicUnitInfoMask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicUnitInfoMask;
    })();

    dfproto.BasicSquadInfo = (function() {

        /**
         * Properties of a BasicSquadInfo.
         * @memberof dfproto
         * @interface IBasicSquadInfo
         * @property {number} squadId BasicSquadInfo squadId
         * @property {dfproto.INameInfo|null} [name] BasicSquadInfo name
         * @property {string|null} [alias] BasicSquadInfo alias
         * @property {Array.<number>|null} [members] BasicSquadInfo members
         */

        /**
         * Constructs a new BasicSquadInfo.
         * @memberof dfproto
         * @classdesc Represents a BasicSquadInfo.
         * @implements IBasicSquadInfo
         * @constructor
         * @param {dfproto.IBasicSquadInfo=} [properties] Properties to set
         */
        function BasicSquadInfo(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicSquadInfo squadId.
         * @member {number} squadId
         * @memberof dfproto.BasicSquadInfo
         * @instance
         */
        BasicSquadInfo.prototype.squadId = 0;

        /**
         * BasicSquadInfo name.
         * @member {dfproto.INameInfo|null|undefined} name
         * @memberof dfproto.BasicSquadInfo
         * @instance
         */
        BasicSquadInfo.prototype.name = null;

        /**
         * BasicSquadInfo alias.
         * @member {string} alias
         * @memberof dfproto.BasicSquadInfo
         * @instance
         */
        BasicSquadInfo.prototype.alias = "";

        /**
         * BasicSquadInfo members.
         * @member {Array.<number>} members
         * @memberof dfproto.BasicSquadInfo
         * @instance
         */
        BasicSquadInfo.prototype.members = $util.emptyArray;

        /**
         * Creates a new BasicSquadInfo instance using the specified properties.
         * @function create
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {dfproto.IBasicSquadInfo=} [properties] Properties to set
         * @returns {dfproto.BasicSquadInfo} BasicSquadInfo instance
         */
        BasicSquadInfo.create = function create(properties) {
            return new BasicSquadInfo(properties);
        };

        /**
         * Encodes the specified BasicSquadInfo message. Does not implicitly {@link dfproto.BasicSquadInfo.verify|verify} messages.
         * @function encode
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {dfproto.IBasicSquadInfo} message BasicSquadInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicSquadInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.squadId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                $root.dfproto.NameInfo.encode(message.name, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.alias);
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.members[i]);
            return writer;
        };

        /**
         * Encodes the specified BasicSquadInfo message, length delimited. Does not implicitly {@link dfproto.BasicSquadInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {dfproto.IBasicSquadInfo} message BasicSquadInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicSquadInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicSquadInfo message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.BasicSquadInfo} BasicSquadInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicSquadInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.BasicSquadInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.squadId = reader.int32();
                    break;
                case 2:
                    message.name = $root.dfproto.NameInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.alias = reader.string();
                    break;
                case 4:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.members.push(reader.sint32());
                    } else
                        message.members.push(reader.sint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("squadId"))
                throw $util.ProtocolError("missing required 'squadId'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicSquadInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.BasicSquadInfo} BasicSquadInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicSquadInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicSquadInfo message.
         * @function verify
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicSquadInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.squadId))
                return "squadId: integer expected";
            if (message.name != null && message.hasOwnProperty("name")) {
                var error = $root.dfproto.NameInfo.verify(message.name);
                if (error)
                    return "name." + error;
            }
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i)
                    if (!$util.isInteger(message.members[i]))
                        return "members: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BasicSquadInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.BasicSquadInfo} BasicSquadInfo
         */
        BasicSquadInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.BasicSquadInfo)
                return object;
            var message = new $root.dfproto.BasicSquadInfo();
            if (object.squadId != null)
                message.squadId = object.squadId | 0;
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".dfproto.BasicSquadInfo.name: object expected");
                message.name = $root.dfproto.NameInfo.fromObject(object.name);
            }
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".dfproto.BasicSquadInfo.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i)
                    message.members[i] = object.members[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BasicSquadInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.BasicSquadInfo
         * @static
         * @param {dfproto.BasicSquadInfo} message BasicSquadInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicSquadInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (options.defaults) {
                object.squadId = 0;
                object.name = null;
                object.alias = "";
            }
            if (message.squadId != null && message.hasOwnProperty("squadId"))
                object.squadId = message.squadId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = $root.dfproto.NameInfo.toObject(message.name, options);
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = message.members[j];
            }
            return object;
        };

        /**
         * Converts this BasicSquadInfo to JSON.
         * @function toJSON
         * @memberof dfproto.BasicSquadInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicSquadInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicSquadInfo;
    })();

    dfproto.UnitLaborState = (function() {

        /**
         * Properties of an UnitLaborState.
         * @memberof dfproto
         * @interface IUnitLaborState
         * @property {number} unitId UnitLaborState unitId
         * @property {number} labor UnitLaborState labor
         * @property {boolean} value UnitLaborState value
         */

        /**
         * Constructs a new UnitLaborState.
         * @memberof dfproto
         * @classdesc Represents an UnitLaborState.
         * @implements IUnitLaborState
         * @constructor
         * @param {dfproto.IUnitLaborState=} [properties] Properties to set
         */
        function UnitLaborState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitLaborState unitId.
         * @member {number} unitId
         * @memberof dfproto.UnitLaborState
         * @instance
         */
        UnitLaborState.prototype.unitId = 0;

        /**
         * UnitLaborState labor.
         * @member {number} labor
         * @memberof dfproto.UnitLaborState
         * @instance
         */
        UnitLaborState.prototype.labor = 0;

        /**
         * UnitLaborState value.
         * @member {boolean} value
         * @memberof dfproto.UnitLaborState
         * @instance
         */
        UnitLaborState.prototype.value = false;

        /**
         * Creates a new UnitLaborState instance using the specified properties.
         * @function create
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {dfproto.IUnitLaborState=} [properties] Properties to set
         * @returns {dfproto.UnitLaborState} UnitLaborState instance
         */
        UnitLaborState.create = function create(properties) {
            return new UnitLaborState(properties);
        };

        /**
         * Encodes the specified UnitLaborState message. Does not implicitly {@link dfproto.UnitLaborState.verify|verify} messages.
         * @function encode
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {dfproto.IUnitLaborState} message UnitLaborState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitLaborState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.unitId);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.labor);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.value);
            return writer;
        };

        /**
         * Encodes the specified UnitLaborState message, length delimited. Does not implicitly {@link dfproto.UnitLaborState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {dfproto.IUnitLaborState} message UnitLaborState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitLaborState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitLaborState message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.UnitLaborState} UnitLaborState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitLaborState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.UnitLaborState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.unitId = reader.int32();
                    break;
                case 2:
                    message.labor = reader.int32();
                    break;
                case 3:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("unitId"))
                throw $util.ProtocolError("missing required 'unitId'", { instance: message });
            if (!message.hasOwnProperty("labor"))
                throw $util.ProtocolError("missing required 'labor'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnitLaborState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.UnitLaborState} UnitLaborState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitLaborState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitLaborState message.
         * @function verify
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitLaborState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.unitId))
                return "unitId: integer expected";
            if (!$util.isInteger(message.labor))
                return "labor: integer expected";
            if (typeof message.value !== "boolean")
                return "value: boolean expected";
            return null;
        };

        /**
         * Creates an UnitLaborState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.UnitLaborState} UnitLaborState
         */
        UnitLaborState.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.UnitLaborState)
                return object;
            var message = new $root.dfproto.UnitLaborState();
            if (object.unitId != null)
                message.unitId = object.unitId | 0;
            if (object.labor != null)
                message.labor = object.labor | 0;
            if (object.value != null)
                message.value = Boolean(object.value);
            return message;
        };

        /**
         * Creates a plain object from an UnitLaborState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.UnitLaborState
         * @static
         * @param {dfproto.UnitLaborState} message UnitLaborState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitLaborState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unitId = 0;
                object.labor = 0;
                object.value = false;
            }
            if (message.unitId != null && message.hasOwnProperty("unitId"))
                object.unitId = message.unitId;
            if (message.labor != null && message.hasOwnProperty("labor"))
                object.labor = message.labor;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this UnitLaborState to JSON.
         * @function toJSON
         * @memberof dfproto.UnitLaborState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitLaborState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitLaborState;
    })();

    dfproto.CoreTextFragment = (function() {

        /**
         * Properties of a CoreTextFragment.
         * @memberof dfproto
         * @interface ICoreTextFragment
         * @property {string} text CoreTextFragment text
         * @property {dfproto.CoreTextFragment.Color|null} [color] CoreTextFragment color
         */

        /**
         * Constructs a new CoreTextFragment.
         * @memberof dfproto
         * @classdesc Represents a CoreTextFragment.
         * @implements ICoreTextFragment
         * @constructor
         * @param {dfproto.ICoreTextFragment=} [properties] Properties to set
         */
        function CoreTextFragment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreTextFragment text.
         * @member {string} text
         * @memberof dfproto.CoreTextFragment
         * @instance
         */
        CoreTextFragment.prototype.text = "";

        /**
         * CoreTextFragment color.
         * @member {dfproto.CoreTextFragment.Color} color
         * @memberof dfproto.CoreTextFragment
         * @instance
         */
        CoreTextFragment.prototype.color = 0;

        /**
         * Creates a new CoreTextFragment instance using the specified properties.
         * @function create
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {dfproto.ICoreTextFragment=} [properties] Properties to set
         * @returns {dfproto.CoreTextFragment} CoreTextFragment instance
         */
        CoreTextFragment.create = function create(properties) {
            return new CoreTextFragment(properties);
        };

        /**
         * Encodes the specified CoreTextFragment message. Does not implicitly {@link dfproto.CoreTextFragment.verify|verify} messages.
         * @function encode
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {dfproto.ICoreTextFragment} message CoreTextFragment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreTextFragment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
            return writer;
        };

        /**
         * Encodes the specified CoreTextFragment message, length delimited. Does not implicitly {@link dfproto.CoreTextFragment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {dfproto.ICoreTextFragment} message CoreTextFragment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreTextFragment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreTextFragment message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.CoreTextFragment} CoreTextFragment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreTextFragment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.CoreTextFragment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.color = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("text"))
                throw $util.ProtocolError("missing required 'text'", { instance: message });
            return message;
        };

        /**
         * Decodes a CoreTextFragment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.CoreTextFragment} CoreTextFragment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreTextFragment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreTextFragment message.
         * @function verify
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreTextFragment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.text))
                return "text: string expected";
            if (message.color != null && message.hasOwnProperty("color"))
                switch (message.color) {
                default:
                    return "color: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    break;
                }
            return null;
        };

        /**
         * Creates a CoreTextFragment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.CoreTextFragment} CoreTextFragment
         */
        CoreTextFragment.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.CoreTextFragment)
                return object;
            var message = new $root.dfproto.CoreTextFragment();
            if (object.text != null)
                message.text = String(object.text);
            switch (object.color) {
            case "COLOR_BLACK":
            case 0:
                message.color = 0;
                break;
            case "COLOR_BLUE":
            case 1:
                message.color = 1;
                break;
            case "COLOR_GREEN":
            case 2:
                message.color = 2;
                break;
            case "COLOR_CYAN":
            case 3:
                message.color = 3;
                break;
            case "COLOR_RED":
            case 4:
                message.color = 4;
                break;
            case "COLOR_MAGENTA":
            case 5:
                message.color = 5;
                break;
            case "COLOR_BROWN":
            case 6:
                message.color = 6;
                break;
            case "COLOR_GREY":
            case 7:
                message.color = 7;
                break;
            case "COLOR_DARKGREY":
            case 8:
                message.color = 8;
                break;
            case "COLOR_LIGHTBLUE":
            case 9:
                message.color = 9;
                break;
            case "COLOR_LIGHTGREEN":
            case 10:
                message.color = 10;
                break;
            case "COLOR_LIGHTCYAN":
            case 11:
                message.color = 11;
                break;
            case "COLOR_LIGHTRED":
            case 12:
                message.color = 12;
                break;
            case "COLOR_LIGHTMAGENTA":
            case 13:
                message.color = 13;
                break;
            case "COLOR_YELLOW":
            case 14:
                message.color = 14;
                break;
            case "COLOR_WHITE":
            case 15:
                message.color = 15;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreTextFragment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.CoreTextFragment
         * @static
         * @param {dfproto.CoreTextFragment} message CoreTextFragment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreTextFragment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.text = "";
                object.color = options.enums === String ? "COLOR_BLACK" : 0;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = options.enums === String ? $root.dfproto.CoreTextFragment.Color[message.color] : message.color;
            return object;
        };

        /**
         * Converts this CoreTextFragment to JSON.
         * @function toJSON
         * @memberof dfproto.CoreTextFragment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreTextFragment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Color enum.
         * @name dfproto.CoreTextFragment.Color
         * @enum {string}
         * @property {number} COLOR_BLACK=0 COLOR_BLACK value
         * @property {number} COLOR_BLUE=1 COLOR_BLUE value
         * @property {number} COLOR_GREEN=2 COLOR_GREEN value
         * @property {number} COLOR_CYAN=3 COLOR_CYAN value
         * @property {number} COLOR_RED=4 COLOR_RED value
         * @property {number} COLOR_MAGENTA=5 COLOR_MAGENTA value
         * @property {number} COLOR_BROWN=6 COLOR_BROWN value
         * @property {number} COLOR_GREY=7 COLOR_GREY value
         * @property {number} COLOR_DARKGREY=8 COLOR_DARKGREY value
         * @property {number} COLOR_LIGHTBLUE=9 COLOR_LIGHTBLUE value
         * @property {number} COLOR_LIGHTGREEN=10 COLOR_LIGHTGREEN value
         * @property {number} COLOR_LIGHTCYAN=11 COLOR_LIGHTCYAN value
         * @property {number} COLOR_LIGHTRED=12 COLOR_LIGHTRED value
         * @property {number} COLOR_LIGHTMAGENTA=13 COLOR_LIGHTMAGENTA value
         * @property {number} COLOR_YELLOW=14 COLOR_YELLOW value
         * @property {number} COLOR_WHITE=15 COLOR_WHITE value
         */
        CoreTextFragment.Color = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COLOR_BLACK"] = 0;
            values[valuesById[1] = "COLOR_BLUE"] = 1;
            values[valuesById[2] = "COLOR_GREEN"] = 2;
            values[valuesById[3] = "COLOR_CYAN"] = 3;
            values[valuesById[4] = "COLOR_RED"] = 4;
            values[valuesById[5] = "COLOR_MAGENTA"] = 5;
            values[valuesById[6] = "COLOR_BROWN"] = 6;
            values[valuesById[7] = "COLOR_GREY"] = 7;
            values[valuesById[8] = "COLOR_DARKGREY"] = 8;
            values[valuesById[9] = "COLOR_LIGHTBLUE"] = 9;
            values[valuesById[10] = "COLOR_LIGHTGREEN"] = 10;
            values[valuesById[11] = "COLOR_LIGHTCYAN"] = 11;
            values[valuesById[12] = "COLOR_LIGHTRED"] = 12;
            values[valuesById[13] = "COLOR_LIGHTMAGENTA"] = 13;
            values[valuesById[14] = "COLOR_YELLOW"] = 14;
            values[valuesById[15] = "COLOR_WHITE"] = 15;
            return values;
        })();

        return CoreTextFragment;
    })();

    dfproto.CoreTextNotification = (function() {

        /**
         * Properties of a CoreTextNotification.
         * @memberof dfproto
         * @interface ICoreTextNotification
         * @property {Array.<dfproto.ICoreTextFragment>|null} [fragments] CoreTextNotification fragments
         */

        /**
         * Constructs a new CoreTextNotification.
         * @memberof dfproto
         * @classdesc Represents a CoreTextNotification.
         * @implements ICoreTextNotification
         * @constructor
         * @param {dfproto.ICoreTextNotification=} [properties] Properties to set
         */
        function CoreTextNotification(properties) {
            this.fragments = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreTextNotification fragments.
         * @member {Array.<dfproto.ICoreTextFragment>} fragments
         * @memberof dfproto.CoreTextNotification
         * @instance
         */
        CoreTextNotification.prototype.fragments = $util.emptyArray;

        /**
         * Creates a new CoreTextNotification instance using the specified properties.
         * @function create
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {dfproto.ICoreTextNotification=} [properties] Properties to set
         * @returns {dfproto.CoreTextNotification} CoreTextNotification instance
         */
        CoreTextNotification.create = function create(properties) {
            return new CoreTextNotification(properties);
        };

        /**
         * Encodes the specified CoreTextNotification message. Does not implicitly {@link dfproto.CoreTextNotification.verify|verify} messages.
         * @function encode
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {dfproto.ICoreTextNotification} message CoreTextNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreTextNotification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fragments != null && message.fragments.length)
                for (var i = 0; i < message.fragments.length; ++i)
                    $root.dfproto.CoreTextFragment.encode(message.fragments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CoreTextNotification message, length delimited. Does not implicitly {@link dfproto.CoreTextNotification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {dfproto.ICoreTextNotification} message CoreTextNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreTextNotification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreTextNotification message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.CoreTextNotification} CoreTextNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreTextNotification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.CoreTextNotification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fragments && message.fragments.length))
                        message.fragments = [];
                    message.fragments.push($root.dfproto.CoreTextFragment.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoreTextNotification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.CoreTextNotification} CoreTextNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreTextNotification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreTextNotification message.
         * @function verify
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreTextNotification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fragments != null && message.hasOwnProperty("fragments")) {
                if (!Array.isArray(message.fragments))
                    return "fragments: array expected";
                for (var i = 0; i < message.fragments.length; ++i) {
                    var error = $root.dfproto.CoreTextFragment.verify(message.fragments[i]);
                    if (error)
                        return "fragments." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CoreTextNotification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.CoreTextNotification} CoreTextNotification
         */
        CoreTextNotification.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.CoreTextNotification)
                return object;
            var message = new $root.dfproto.CoreTextNotification();
            if (object.fragments) {
                if (!Array.isArray(object.fragments))
                    throw TypeError(".dfproto.CoreTextNotification.fragments: array expected");
                message.fragments = [];
                for (var i = 0; i < object.fragments.length; ++i) {
                    if (typeof object.fragments[i] !== "object")
                        throw TypeError(".dfproto.CoreTextNotification.fragments: object expected");
                    message.fragments[i] = $root.dfproto.CoreTextFragment.fromObject(object.fragments[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreTextNotification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.CoreTextNotification
         * @static
         * @param {dfproto.CoreTextNotification} message CoreTextNotification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreTextNotification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fragments = [];
            if (message.fragments && message.fragments.length) {
                object.fragments = [];
                for (var j = 0; j < message.fragments.length; ++j)
                    object.fragments[j] = $root.dfproto.CoreTextFragment.toObject(message.fragments[j], options);
            }
            return object;
        };

        /**
         * Converts this CoreTextNotification to JSON.
         * @function toJSON
         * @memberof dfproto.CoreTextNotification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreTextNotification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoreTextNotification;
    })();

    dfproto.CoreErrorNotification = (function() {

        /**
         * Properties of a CoreErrorNotification.
         * @memberof dfproto
         * @interface ICoreErrorNotification
         * @property {dfproto.CoreErrorNotification.ErrorCode} code CoreErrorNotification code
         */

        /**
         * Constructs a new CoreErrorNotification.
         * @memberof dfproto
         * @classdesc Represents a CoreErrorNotification.
         * @implements ICoreErrorNotification
         * @constructor
         * @param {dfproto.ICoreErrorNotification=} [properties] Properties to set
         */
        function CoreErrorNotification(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreErrorNotification code.
         * @member {dfproto.CoreErrorNotification.ErrorCode} code
         * @memberof dfproto.CoreErrorNotification
         * @instance
         */
        CoreErrorNotification.prototype.code = -3;

        /**
         * Creates a new CoreErrorNotification instance using the specified properties.
         * @function create
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {dfproto.ICoreErrorNotification=} [properties] Properties to set
         * @returns {dfproto.CoreErrorNotification} CoreErrorNotification instance
         */
        CoreErrorNotification.create = function create(properties) {
            return new CoreErrorNotification(properties);
        };

        /**
         * Encodes the specified CoreErrorNotification message. Does not implicitly {@link dfproto.CoreErrorNotification.verify|verify} messages.
         * @function encode
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {dfproto.ICoreErrorNotification} message CoreErrorNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreErrorNotification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
            return writer;
        };

        /**
         * Encodes the specified CoreErrorNotification message, length delimited. Does not implicitly {@link dfproto.CoreErrorNotification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {dfproto.ICoreErrorNotification} message CoreErrorNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreErrorNotification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreErrorNotification message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.CoreErrorNotification} CoreErrorNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreErrorNotification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.CoreErrorNotification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            return message;
        };

        /**
         * Decodes a CoreErrorNotification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.CoreErrorNotification} CoreErrorNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreErrorNotification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreErrorNotification message.
         * @function verify
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreErrorNotification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.code) {
            default:
                return "code: enum value expected";
            case -3:
            case -2:
            case -1:
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
            return null;
        };

        /**
         * Creates a CoreErrorNotification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.CoreErrorNotification} CoreErrorNotification
         */
        CoreErrorNotification.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.CoreErrorNotification)
                return object;
            var message = new $root.dfproto.CoreErrorNotification();
            switch (object.code) {
            case "CR_LINK_FAILURE":
            case -3:
                message.code = -3;
                break;
            case "CR_WOULD_BREAK":
            case -2:
                message.code = -2;
                break;
            case "CR_NOT_IMPLEMENTED":
            case -1:
                message.code = -1;
                break;
            case "CR_OK":
            case 0:
                message.code = 0;
                break;
            case "CR_FAILURE":
            case 1:
                message.code = 1;
                break;
            case "CR_WRONG_USAGE":
            case 2:
                message.code = 2;
                break;
            case "CR_NOT_FOUND":
            case 3:
                message.code = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreErrorNotification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.CoreErrorNotification
         * @static
         * @param {dfproto.CoreErrorNotification} message CoreErrorNotification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreErrorNotification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.code = options.enums === String ? "CR_LINK_FAILURE" : -3;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.enums === String ? $root.dfproto.CoreErrorNotification.ErrorCode[message.code] : message.code;
            return object;
        };

        /**
         * Converts this CoreErrorNotification to JSON.
         * @function toJSON
         * @memberof dfproto.CoreErrorNotification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreErrorNotification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ErrorCode enum.
         * @name dfproto.CoreErrorNotification.ErrorCode
         * @enum {string}
         * @property {number} CR_LINK_FAILURE=-3 CR_LINK_FAILURE value
         * @property {number} CR_WOULD_BREAK=-2 CR_WOULD_BREAK value
         * @property {number} CR_NOT_IMPLEMENTED=-1 CR_NOT_IMPLEMENTED value
         * @property {number} CR_OK=0 CR_OK value
         * @property {number} CR_FAILURE=1 CR_FAILURE value
         * @property {number} CR_WRONG_USAGE=2 CR_WRONG_USAGE value
         * @property {number} CR_NOT_FOUND=3 CR_NOT_FOUND value
         */
        CoreErrorNotification.ErrorCode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[-3] = "CR_LINK_FAILURE"] = -3;
            values[valuesById[-2] = "CR_WOULD_BREAK"] = -2;
            values[valuesById[-1] = "CR_NOT_IMPLEMENTED"] = -1;
            values[valuesById[0] = "CR_OK"] = 0;
            values[valuesById[1] = "CR_FAILURE"] = 1;
            values[valuesById[2] = "CR_WRONG_USAGE"] = 2;
            values[valuesById[3] = "CR_NOT_FOUND"] = 3;
            return values;
        })();

        return CoreErrorNotification;
    })();

    dfproto.EmptyMessage = (function() {

        /**
         * Properties of an EmptyMessage.
         * @memberof dfproto
         * @interface IEmptyMessage
         */

        /**
         * Constructs a new EmptyMessage.
         * @memberof dfproto
         * @classdesc Represents an EmptyMessage.
         * @implements IEmptyMessage
         * @constructor
         * @param {dfproto.IEmptyMessage=} [properties] Properties to set
         */
        function EmptyMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new EmptyMessage instance using the specified properties.
         * @function create
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {dfproto.IEmptyMessage=} [properties] Properties to set
         * @returns {dfproto.EmptyMessage} EmptyMessage instance
         */
        EmptyMessage.create = function create(properties) {
            return new EmptyMessage(properties);
        };

        /**
         * Encodes the specified EmptyMessage message. Does not implicitly {@link dfproto.EmptyMessage.verify|verify} messages.
         * @function encode
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {dfproto.IEmptyMessage} message EmptyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmptyMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified EmptyMessage message, length delimited. Does not implicitly {@link dfproto.EmptyMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {dfproto.IEmptyMessage} message EmptyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmptyMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmptyMessage message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.EmptyMessage} EmptyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmptyMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.EmptyMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmptyMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.EmptyMessage} EmptyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmptyMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmptyMessage message.
         * @function verify
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmptyMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an EmptyMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.EmptyMessage} EmptyMessage
         */
        EmptyMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.EmptyMessage)
                return object;
            return new $root.dfproto.EmptyMessage();
        };

        /**
         * Creates a plain object from an EmptyMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.EmptyMessage
         * @static
         * @param {dfproto.EmptyMessage} message EmptyMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmptyMessage.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this EmptyMessage to JSON.
         * @function toJSON
         * @memberof dfproto.EmptyMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmptyMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmptyMessage;
    })();

    dfproto.IntMessage = (function() {

        /**
         * Properties of an IntMessage.
         * @memberof dfproto
         * @interface IIntMessage
         * @property {number} value IntMessage value
         */

        /**
         * Constructs a new IntMessage.
         * @memberof dfproto
         * @classdesc Represents an IntMessage.
         * @implements IIntMessage
         * @constructor
         * @param {dfproto.IIntMessage=} [properties] Properties to set
         */
        function IntMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntMessage value.
         * @member {number} value
         * @memberof dfproto.IntMessage
         * @instance
         */
        IntMessage.prototype.value = 0;

        /**
         * Creates a new IntMessage instance using the specified properties.
         * @function create
         * @memberof dfproto.IntMessage
         * @static
         * @param {dfproto.IIntMessage=} [properties] Properties to set
         * @returns {dfproto.IntMessage} IntMessage instance
         */
        IntMessage.create = function create(properties) {
            return new IntMessage(properties);
        };

        /**
         * Encodes the specified IntMessage message. Does not implicitly {@link dfproto.IntMessage.verify|verify} messages.
         * @function encode
         * @memberof dfproto.IntMessage
         * @static
         * @param {dfproto.IIntMessage} message IntMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
            return writer;
        };

        /**
         * Encodes the specified IntMessage message, length delimited. Does not implicitly {@link dfproto.IntMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.IntMessage
         * @static
         * @param {dfproto.IIntMessage} message IntMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IntMessage message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.IntMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.IntMessage} IntMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.IntMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an IntMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.IntMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.IntMessage} IntMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IntMessage message.
         * @function verify
         * @memberof dfproto.IntMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IntMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.value))
                return "value: integer expected";
            return null;
        };

        /**
         * Creates an IntMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.IntMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.IntMessage} IntMessage
         */
        IntMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.IntMessage)
                return object;
            var message = new $root.dfproto.IntMessage();
            if (object.value != null)
                message.value = object.value | 0;
            return message;
        };

        /**
         * Creates a plain object from an IntMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.IntMessage
         * @static
         * @param {dfproto.IntMessage} message IntMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IntMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.value = 0;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this IntMessage to JSON.
         * @function toJSON
         * @memberof dfproto.IntMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IntMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IntMessage;
    })();

    dfproto.IntListMessage = (function() {

        /**
         * Properties of an IntListMessage.
         * @memberof dfproto
         * @interface IIntListMessage
         * @property {Array.<number>|null} [value] IntListMessage value
         */

        /**
         * Constructs a new IntListMessage.
         * @memberof dfproto
         * @classdesc Represents an IntListMessage.
         * @implements IIntListMessage
         * @constructor
         * @param {dfproto.IIntListMessage=} [properties] Properties to set
         */
        function IntListMessage(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntListMessage value.
         * @member {Array.<number>} value
         * @memberof dfproto.IntListMessage
         * @instance
         */
        IntListMessage.prototype.value = $util.emptyArray;

        /**
         * Creates a new IntListMessage instance using the specified properties.
         * @function create
         * @memberof dfproto.IntListMessage
         * @static
         * @param {dfproto.IIntListMessage=} [properties] Properties to set
         * @returns {dfproto.IntListMessage} IntListMessage instance
         */
        IntListMessage.create = function create(properties) {
            return new IntListMessage(properties);
        };

        /**
         * Encodes the specified IntListMessage message. Does not implicitly {@link dfproto.IntListMessage.verify|verify} messages.
         * @function encode
         * @memberof dfproto.IntListMessage
         * @static
         * @param {dfproto.IIntListMessage} message IntListMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntListMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length)
                for (var i = 0; i < message.value.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value[i]);
            return writer;
        };

        /**
         * Encodes the specified IntListMessage message, length delimited. Does not implicitly {@link dfproto.IntListMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.IntListMessage
         * @static
         * @param {dfproto.IIntListMessage} message IntListMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntListMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IntListMessage message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.IntListMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.IntListMessage} IntListMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntListMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.IntListMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.value.push(reader.int32());
                    } else
                        message.value.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IntListMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.IntListMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.IntListMessage} IntListMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntListMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IntListMessage message.
         * @function verify
         * @memberof dfproto.IntListMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IntListMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i)
                    if (!$util.isInteger(message.value[i]))
                        return "value: integer[] expected";
            }
            return null;
        };

        /**
         * Creates an IntListMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.IntListMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.IntListMessage} IntListMessage
         */
        IntListMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.IntListMessage)
                return object;
            var message = new $root.dfproto.IntListMessage();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".dfproto.IntListMessage.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i)
                    message.value[i] = object.value[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from an IntListMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.IntListMessage
         * @static
         * @param {dfproto.IntListMessage} message IntListMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IntListMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    object.value[j] = message.value[j];
            }
            return object;
        };

        /**
         * Converts this IntListMessage to JSON.
         * @function toJSON
         * @memberof dfproto.IntListMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IntListMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IntListMessage;
    })();

    dfproto.StringMessage = (function() {

        /**
         * Properties of a StringMessage.
         * @memberof dfproto
         * @interface IStringMessage
         * @property {string} value StringMessage value
         */

        /**
         * Constructs a new StringMessage.
         * @memberof dfproto
         * @classdesc Represents a StringMessage.
         * @implements IStringMessage
         * @constructor
         * @param {dfproto.IStringMessage=} [properties] Properties to set
         */
        function StringMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringMessage value.
         * @member {string} value
         * @memberof dfproto.StringMessage
         * @instance
         */
        StringMessage.prototype.value = "";

        /**
         * Creates a new StringMessage instance using the specified properties.
         * @function create
         * @memberof dfproto.StringMessage
         * @static
         * @param {dfproto.IStringMessage=} [properties] Properties to set
         * @returns {dfproto.StringMessage} StringMessage instance
         */
        StringMessage.create = function create(properties) {
            return new StringMessage(properties);
        };

        /**
         * Encodes the specified StringMessage message. Does not implicitly {@link dfproto.StringMessage.verify|verify} messages.
         * @function encode
         * @memberof dfproto.StringMessage
         * @static
         * @param {dfproto.IStringMessage} message StringMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified StringMessage message, length delimited. Does not implicitly {@link dfproto.StringMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.StringMessage
         * @static
         * @param {dfproto.IStringMessage} message StringMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StringMessage message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.StringMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.StringMessage} StringMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.StringMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a StringMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.StringMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.StringMessage} StringMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StringMessage message.
         * @function verify
         * @memberof dfproto.StringMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StringMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            return null;
        };

        /**
         * Creates a StringMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.StringMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.StringMessage} StringMessage
         */
        StringMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.StringMessage)
                return object;
            var message = new $root.dfproto.StringMessage();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a StringMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.StringMessage
         * @static
         * @param {dfproto.StringMessage} message StringMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StringMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.value = "";
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this StringMessage to JSON.
         * @function toJSON
         * @memberof dfproto.StringMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StringMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StringMessage;
    })();

    dfproto.StringListMessage = (function() {

        /**
         * Properties of a StringListMessage.
         * @memberof dfproto
         * @interface IStringListMessage
         * @property {Array.<string>|null} [value] StringListMessage value
         */

        /**
         * Constructs a new StringListMessage.
         * @memberof dfproto
         * @classdesc Represents a StringListMessage.
         * @implements IStringListMessage
         * @constructor
         * @param {dfproto.IStringListMessage=} [properties] Properties to set
         */
        function StringListMessage(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringListMessage value.
         * @member {Array.<string>} value
         * @memberof dfproto.StringListMessage
         * @instance
         */
        StringListMessage.prototype.value = $util.emptyArray;

        /**
         * Creates a new StringListMessage instance using the specified properties.
         * @function create
         * @memberof dfproto.StringListMessage
         * @static
         * @param {dfproto.IStringListMessage=} [properties] Properties to set
         * @returns {dfproto.StringListMessage} StringListMessage instance
         */
        StringListMessage.create = function create(properties) {
            return new StringListMessage(properties);
        };

        /**
         * Encodes the specified StringListMessage message. Does not implicitly {@link dfproto.StringListMessage.verify|verify} messages.
         * @function encode
         * @memberof dfproto.StringListMessage
         * @static
         * @param {dfproto.IStringListMessage} message StringListMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringListMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length)
                for (var i = 0; i < message.value.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value[i]);
            return writer;
        };

        /**
         * Encodes the specified StringListMessage message, length delimited. Does not implicitly {@link dfproto.StringListMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.StringListMessage
         * @static
         * @param {dfproto.IStringListMessage} message StringListMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringListMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StringListMessage message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.StringListMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.StringListMessage} StringListMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringListMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.StringListMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    message.value.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StringListMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.StringListMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.StringListMessage} StringListMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringListMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StringListMessage message.
         * @function verify
         * @memberof dfproto.StringListMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StringListMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i)
                    if (!$util.isString(message.value[i]))
                        return "value: string[] expected";
            }
            return null;
        };

        /**
         * Creates a StringListMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.StringListMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.StringListMessage} StringListMessage
         */
        StringListMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.StringListMessage)
                return object;
            var message = new $root.dfproto.StringListMessage();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".dfproto.StringListMessage.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i)
                    message.value[i] = String(object.value[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a StringListMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.StringListMessage
         * @static
         * @param {dfproto.StringListMessage} message StringListMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StringListMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    object.value[j] = message.value[j];
            }
            return object;
        };

        /**
         * Converts this StringListMessage to JSON.
         * @function toJSON
         * @memberof dfproto.StringListMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StringListMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StringListMessage;
    })();

    dfproto.CoreBindRequest = (function() {

        /**
         * Properties of a CoreBindRequest.
         * @memberof dfproto
         * @interface ICoreBindRequest
         * @property {string} method CoreBindRequest method
         * @property {string} inputMsg CoreBindRequest inputMsg
         * @property {string} outputMsg CoreBindRequest outputMsg
         * @property {string|null} [plugin] CoreBindRequest plugin
         */

        /**
         * Constructs a new CoreBindRequest.
         * @memberof dfproto
         * @classdesc Represents a CoreBindRequest.
         * @implements ICoreBindRequest
         * @constructor
         * @param {dfproto.ICoreBindRequest=} [properties] Properties to set
         */
        function CoreBindRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreBindRequest method.
         * @member {string} method
         * @memberof dfproto.CoreBindRequest
         * @instance
         */
        CoreBindRequest.prototype.method = "";

        /**
         * CoreBindRequest inputMsg.
         * @member {string} inputMsg
         * @memberof dfproto.CoreBindRequest
         * @instance
         */
        CoreBindRequest.prototype.inputMsg = "";

        /**
         * CoreBindRequest outputMsg.
         * @member {string} outputMsg
         * @memberof dfproto.CoreBindRequest
         * @instance
         */
        CoreBindRequest.prototype.outputMsg = "";

        /**
         * CoreBindRequest plugin.
         * @member {string} plugin
         * @memberof dfproto.CoreBindRequest
         * @instance
         */
        CoreBindRequest.prototype.plugin = "";

        /**
         * Creates a new CoreBindRequest instance using the specified properties.
         * @function create
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {dfproto.ICoreBindRequest=} [properties] Properties to set
         * @returns {dfproto.CoreBindRequest} CoreBindRequest instance
         */
        CoreBindRequest.create = function create(properties) {
            return new CoreBindRequest(properties);
        };

        /**
         * Encodes the specified CoreBindRequest message. Does not implicitly {@link dfproto.CoreBindRequest.verify|verify} messages.
         * @function encode
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {dfproto.ICoreBindRequest} message CoreBindRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreBindRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.method);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputMsg);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputMsg);
            if (message.plugin != null && Object.hasOwnProperty.call(message, "plugin"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.plugin);
            return writer;
        };

        /**
         * Encodes the specified CoreBindRequest message, length delimited. Does not implicitly {@link dfproto.CoreBindRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {dfproto.ICoreBindRequest} message CoreBindRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreBindRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreBindRequest message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.CoreBindRequest} CoreBindRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreBindRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.CoreBindRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.method = reader.string();
                    break;
                case 2:
                    message.inputMsg = reader.string();
                    break;
                case 3:
                    message.outputMsg = reader.string();
                    break;
                case 4:
                    message.plugin = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("method"))
                throw $util.ProtocolError("missing required 'method'", { instance: message });
            if (!message.hasOwnProperty("inputMsg"))
                throw $util.ProtocolError("missing required 'inputMsg'", { instance: message });
            if (!message.hasOwnProperty("outputMsg"))
                throw $util.ProtocolError("missing required 'outputMsg'", { instance: message });
            return message;
        };

        /**
         * Decodes a CoreBindRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.CoreBindRequest} CoreBindRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreBindRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreBindRequest message.
         * @function verify
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreBindRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.method))
                return "method: string expected";
            if (!$util.isString(message.inputMsg))
                return "inputMsg: string expected";
            if (!$util.isString(message.outputMsg))
                return "outputMsg: string expected";
            if (message.plugin != null && message.hasOwnProperty("plugin"))
                if (!$util.isString(message.plugin))
                    return "plugin: string expected";
            return null;
        };

        /**
         * Creates a CoreBindRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.CoreBindRequest} CoreBindRequest
         */
        CoreBindRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.CoreBindRequest)
                return object;
            var message = new $root.dfproto.CoreBindRequest();
            if (object.method != null)
                message.method = String(object.method);
            if (object.inputMsg != null)
                message.inputMsg = String(object.inputMsg);
            if (object.outputMsg != null)
                message.outputMsg = String(object.outputMsg);
            if (object.plugin != null)
                message.plugin = String(object.plugin);
            return message;
        };

        /**
         * Creates a plain object from a CoreBindRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.CoreBindRequest
         * @static
         * @param {dfproto.CoreBindRequest} message CoreBindRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreBindRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.method = "";
                object.inputMsg = "";
                object.outputMsg = "";
                object.plugin = "";
            }
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = message.method;
            if (message.inputMsg != null && message.hasOwnProperty("inputMsg"))
                object.inputMsg = message.inputMsg;
            if (message.outputMsg != null && message.hasOwnProperty("outputMsg"))
                object.outputMsg = message.outputMsg;
            if (message.plugin != null && message.hasOwnProperty("plugin"))
                object.plugin = message.plugin;
            return object;
        };

        /**
         * Converts this CoreBindRequest to JSON.
         * @function toJSON
         * @memberof dfproto.CoreBindRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreBindRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoreBindRequest;
    })();

    dfproto.CoreBindReply = (function() {

        /**
         * Properties of a CoreBindReply.
         * @memberof dfproto
         * @interface ICoreBindReply
         * @property {number} assignedId CoreBindReply assignedId
         */

        /**
         * Constructs a new CoreBindReply.
         * @memberof dfproto
         * @classdesc Represents a CoreBindReply.
         * @implements ICoreBindReply
         * @constructor
         * @param {dfproto.ICoreBindReply=} [properties] Properties to set
         */
        function CoreBindReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreBindReply assignedId.
         * @member {number} assignedId
         * @memberof dfproto.CoreBindReply
         * @instance
         */
        CoreBindReply.prototype.assignedId = 0;

        /**
         * Creates a new CoreBindReply instance using the specified properties.
         * @function create
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {dfproto.ICoreBindReply=} [properties] Properties to set
         * @returns {dfproto.CoreBindReply} CoreBindReply instance
         */
        CoreBindReply.create = function create(properties) {
            return new CoreBindReply(properties);
        };

        /**
         * Encodes the specified CoreBindReply message. Does not implicitly {@link dfproto.CoreBindReply.verify|verify} messages.
         * @function encode
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {dfproto.ICoreBindReply} message CoreBindReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreBindReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.assignedId);
            return writer;
        };

        /**
         * Encodes the specified CoreBindReply message, length delimited. Does not implicitly {@link dfproto.CoreBindReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {dfproto.ICoreBindReply} message CoreBindReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreBindReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreBindReply message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.CoreBindReply} CoreBindReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreBindReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.CoreBindReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.assignedId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("assignedId"))
                throw $util.ProtocolError("missing required 'assignedId'", { instance: message });
            return message;
        };

        /**
         * Decodes a CoreBindReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.CoreBindReply} CoreBindReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreBindReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreBindReply message.
         * @function verify
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreBindReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.assignedId))
                return "assignedId: integer expected";
            return null;
        };

        /**
         * Creates a CoreBindReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.CoreBindReply} CoreBindReply
         */
        CoreBindReply.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.CoreBindReply)
                return object;
            var message = new $root.dfproto.CoreBindReply();
            if (object.assignedId != null)
                message.assignedId = object.assignedId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CoreBindReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.CoreBindReply
         * @static
         * @param {dfproto.CoreBindReply} message CoreBindReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreBindReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.assignedId = 0;
            if (message.assignedId != null && message.hasOwnProperty("assignedId"))
                object.assignedId = message.assignedId;
            return object;
        };

        /**
         * Converts this CoreBindReply to JSON.
         * @function toJSON
         * @memberof dfproto.CoreBindReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreBindReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoreBindReply;
    })();

    dfproto.CoreRunCommandRequest = (function() {

        /**
         * Properties of a CoreRunCommandRequest.
         * @memberof dfproto
         * @interface ICoreRunCommandRequest
         * @property {string} command CoreRunCommandRequest command
         * @property {Array.<string>|null} ["arguments"] CoreRunCommandRequest arguments
         */

        /**
         * Constructs a new CoreRunCommandRequest.
         * @memberof dfproto
         * @classdesc Represents a CoreRunCommandRequest.
         * @implements ICoreRunCommandRequest
         * @constructor
         * @param {dfproto.ICoreRunCommandRequest=} [properties] Properties to set
         */
        function CoreRunCommandRequest(properties) {
            this["arguments"] = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreRunCommandRequest command.
         * @member {string} command
         * @memberof dfproto.CoreRunCommandRequest
         * @instance
         */
        CoreRunCommandRequest.prototype.command = "";

        /**
         * CoreRunCommandRequest arguments.
         * @member {Array.<string>} arguments
         * @memberof dfproto.CoreRunCommandRequest
         * @instance
         */
        CoreRunCommandRequest.prototype["arguments"] = $util.emptyArray;

        /**
         * Creates a new CoreRunCommandRequest instance using the specified properties.
         * @function create
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {dfproto.ICoreRunCommandRequest=} [properties] Properties to set
         * @returns {dfproto.CoreRunCommandRequest} CoreRunCommandRequest instance
         */
        CoreRunCommandRequest.create = function create(properties) {
            return new CoreRunCommandRequest(properties);
        };

        /**
         * Encodes the specified CoreRunCommandRequest message. Does not implicitly {@link dfproto.CoreRunCommandRequest.verify|verify} messages.
         * @function encode
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {dfproto.ICoreRunCommandRequest} message CoreRunCommandRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreRunCommandRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            if (message["arguments"] != null && message["arguments"].length)
                for (var i = 0; i < message["arguments"].length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["arguments"][i]);
            return writer;
        };

        /**
         * Encodes the specified CoreRunCommandRequest message, length delimited. Does not implicitly {@link dfproto.CoreRunCommandRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {dfproto.ICoreRunCommandRequest} message CoreRunCommandRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreRunCommandRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreRunCommandRequest message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.CoreRunCommandRequest} CoreRunCommandRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreRunCommandRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.CoreRunCommandRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                case 2:
                    if (!(message["arguments"] && message["arguments"].length))
                        message["arguments"] = [];
                    message["arguments"].push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("command"))
                throw $util.ProtocolError("missing required 'command'", { instance: message });
            return message;
        };

        /**
         * Decodes a CoreRunCommandRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.CoreRunCommandRequest} CoreRunCommandRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreRunCommandRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreRunCommandRequest message.
         * @function verify
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreRunCommandRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.command))
                return "command: string expected";
            if (message["arguments"] != null && message.hasOwnProperty("arguments")) {
                if (!Array.isArray(message["arguments"]))
                    return "arguments: array expected";
                for (var i = 0; i < message["arguments"].length; ++i)
                    if (!$util.isString(message["arguments"][i]))
                        return "arguments: string[] expected";
            }
            return null;
        };

        /**
         * Creates a CoreRunCommandRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.CoreRunCommandRequest} CoreRunCommandRequest
         */
        CoreRunCommandRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.CoreRunCommandRequest)
                return object;
            var message = new $root.dfproto.CoreRunCommandRequest();
            if (object.command != null)
                message.command = String(object.command);
            if (object["arguments"]) {
                if (!Array.isArray(object["arguments"]))
                    throw TypeError(".dfproto.CoreRunCommandRequest.arguments: array expected");
                message["arguments"] = [];
                for (var i = 0; i < object["arguments"].length; ++i)
                    message["arguments"][i] = String(object["arguments"][i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreRunCommandRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.CoreRunCommandRequest
         * @static
         * @param {dfproto.CoreRunCommandRequest} message CoreRunCommandRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreRunCommandRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object["arguments"] = [];
            if (options.defaults)
                object.command = "";
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message["arguments"] && message["arguments"].length) {
                object["arguments"] = [];
                for (var j = 0; j < message["arguments"].length; ++j)
                    object["arguments"][j] = message["arguments"][j];
            }
            return object;
        };

        /**
         * Converts this CoreRunCommandRequest to JSON.
         * @function toJSON
         * @memberof dfproto.CoreRunCommandRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreRunCommandRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoreRunCommandRequest;
    })();

    dfproto.CoreRunLuaRequest = (function() {

        /**
         * Properties of a CoreRunLuaRequest.
         * @memberof dfproto
         * @interface ICoreRunLuaRequest
         * @property {string} module CoreRunLuaRequest module
         * @property {string} "function" CoreRunLuaRequest function
         * @property {Array.<string>|null} ["arguments"] CoreRunLuaRequest arguments
         */

        /**
         * Constructs a new CoreRunLuaRequest.
         * @memberof dfproto
         * @classdesc Represents a CoreRunLuaRequest.
         * @implements ICoreRunLuaRequest
         * @constructor
         * @param {dfproto.ICoreRunLuaRequest=} [properties] Properties to set
         */
        function CoreRunLuaRequest(properties) {
            this["arguments"] = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreRunLuaRequest module.
         * @member {string} module
         * @memberof dfproto.CoreRunLuaRequest
         * @instance
         */
        CoreRunLuaRequest.prototype.module = "";

        /**
         * CoreRunLuaRequest function.
         * @member {string} function
         * @memberof dfproto.CoreRunLuaRequest
         * @instance
         */
        CoreRunLuaRequest.prototype["function"] = "";

        /**
         * CoreRunLuaRequest arguments.
         * @member {Array.<string>} arguments
         * @memberof dfproto.CoreRunLuaRequest
         * @instance
         */
        CoreRunLuaRequest.prototype["arguments"] = $util.emptyArray;

        /**
         * Creates a new CoreRunLuaRequest instance using the specified properties.
         * @function create
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {dfproto.ICoreRunLuaRequest=} [properties] Properties to set
         * @returns {dfproto.CoreRunLuaRequest} CoreRunLuaRequest instance
         */
        CoreRunLuaRequest.create = function create(properties) {
            return new CoreRunLuaRequest(properties);
        };

        /**
         * Encodes the specified CoreRunLuaRequest message. Does not implicitly {@link dfproto.CoreRunLuaRequest.verify|verify} messages.
         * @function encode
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {dfproto.ICoreRunLuaRequest} message CoreRunLuaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreRunLuaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.module);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message["function"]);
            if (message["arguments"] != null && message["arguments"].length)
                for (var i = 0; i < message["arguments"].length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message["arguments"][i]);
            return writer;
        };

        /**
         * Encodes the specified CoreRunLuaRequest message, length delimited. Does not implicitly {@link dfproto.CoreRunLuaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {dfproto.ICoreRunLuaRequest} message CoreRunLuaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreRunLuaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreRunLuaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.CoreRunLuaRequest} CoreRunLuaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreRunLuaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.CoreRunLuaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.module = reader.string();
                    break;
                case 2:
                    message["function"] = reader.string();
                    break;
                case 3:
                    if (!(message["arguments"] && message["arguments"].length))
                        message["arguments"] = [];
                    message["arguments"].push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("module"))
                throw $util.ProtocolError("missing required 'module'", { instance: message });
            if (!message.hasOwnProperty("function"))
                throw $util.ProtocolError("missing required 'function'", { instance: message });
            return message;
        };

        /**
         * Decodes a CoreRunLuaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.CoreRunLuaRequest} CoreRunLuaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreRunLuaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreRunLuaRequest message.
         * @function verify
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreRunLuaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.module))
                return "module: string expected";
            if (!$util.isString(message["function"]))
                return "function: string expected";
            if (message["arguments"] != null && message.hasOwnProperty("arguments")) {
                if (!Array.isArray(message["arguments"]))
                    return "arguments: array expected";
                for (var i = 0; i < message["arguments"].length; ++i)
                    if (!$util.isString(message["arguments"][i]))
                        return "arguments: string[] expected";
            }
            return null;
        };

        /**
         * Creates a CoreRunLuaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.CoreRunLuaRequest} CoreRunLuaRequest
         */
        CoreRunLuaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.CoreRunLuaRequest)
                return object;
            var message = new $root.dfproto.CoreRunLuaRequest();
            if (object.module != null)
                message.module = String(object.module);
            if (object["function"] != null)
                message["function"] = String(object["function"]);
            if (object["arguments"]) {
                if (!Array.isArray(object["arguments"]))
                    throw TypeError(".dfproto.CoreRunLuaRequest.arguments: array expected");
                message["arguments"] = [];
                for (var i = 0; i < object["arguments"].length; ++i)
                    message["arguments"][i] = String(object["arguments"][i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreRunLuaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.CoreRunLuaRequest
         * @static
         * @param {dfproto.CoreRunLuaRequest} message CoreRunLuaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreRunLuaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object["arguments"] = [];
            if (options.defaults) {
                object.module = "";
                object["function"] = "";
            }
            if (message.module != null && message.hasOwnProperty("module"))
                object.module = message.module;
            if (message["function"] != null && message.hasOwnProperty("function"))
                object["function"] = message["function"];
            if (message["arguments"] && message["arguments"].length) {
                object["arguments"] = [];
                for (var j = 0; j < message["arguments"].length; ++j)
                    object["arguments"][j] = message["arguments"][j];
            }
            return object;
        };

        /**
         * Converts this CoreRunLuaRequest to JSON.
         * @function toJSON
         * @memberof dfproto.CoreRunLuaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreRunLuaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoreRunLuaRequest;
    })();

    dfproto.RenameSquadIn = (function() {

        /**
         * Properties of a RenameSquadIn.
         * @memberof dfproto
         * @interface IRenameSquadIn
         * @property {number} squadId RenameSquadIn squadId
         * @property {string|null} [nickname] RenameSquadIn nickname
         * @property {string|null} [alias] RenameSquadIn alias
         */

        /**
         * Constructs a new RenameSquadIn.
         * @memberof dfproto
         * @classdesc Represents a RenameSquadIn.
         * @implements IRenameSquadIn
         * @constructor
         * @param {dfproto.IRenameSquadIn=} [properties] Properties to set
         */
        function RenameSquadIn(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameSquadIn squadId.
         * @member {number} squadId
         * @memberof dfproto.RenameSquadIn
         * @instance
         */
        RenameSquadIn.prototype.squadId = 0;

        /**
         * RenameSquadIn nickname.
         * @member {string} nickname
         * @memberof dfproto.RenameSquadIn
         * @instance
         */
        RenameSquadIn.prototype.nickname = "";

        /**
         * RenameSquadIn alias.
         * @member {string} alias
         * @memberof dfproto.RenameSquadIn
         * @instance
         */
        RenameSquadIn.prototype.alias = "";

        /**
         * Creates a new RenameSquadIn instance using the specified properties.
         * @function create
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.IRenameSquadIn=} [properties] Properties to set
         * @returns {dfproto.RenameSquadIn} RenameSquadIn instance
         */
        RenameSquadIn.create = function create(properties) {
            return new RenameSquadIn(properties);
        };

        /**
         * Encodes the specified RenameSquadIn message. Does not implicitly {@link dfproto.RenameSquadIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.IRenameSquadIn} message RenameSquadIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameSquadIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.squadId);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.alias);
            return writer;
        };

        /**
         * Encodes the specified RenameSquadIn message, length delimited. Does not implicitly {@link dfproto.RenameSquadIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.IRenameSquadIn} message RenameSquadIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameSquadIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameSquadIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.RenameSquadIn} RenameSquadIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameSquadIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.RenameSquadIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.squadId = reader.int32();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    message.alias = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("squadId"))
                throw $util.ProtocolError("missing required 'squadId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RenameSquadIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.RenameSquadIn} RenameSquadIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameSquadIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameSquadIn message.
         * @function verify
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameSquadIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.squadId))
                return "squadId: integer expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            return null;
        };

        /**
         * Creates a RenameSquadIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.RenameSquadIn} RenameSquadIn
         */
        RenameSquadIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.RenameSquadIn)
                return object;
            var message = new $root.dfproto.RenameSquadIn();
            if (object.squadId != null)
                message.squadId = object.squadId | 0;
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.alias != null)
                message.alias = String(object.alias);
            return message;
        };

        /**
         * Creates a plain object from a RenameSquadIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.RenameSquadIn
         * @static
         * @param {dfproto.RenameSquadIn} message RenameSquadIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameSquadIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.squadId = 0;
                object.nickname = "";
                object.alias = "";
            }
            if (message.squadId != null && message.hasOwnProperty("squadId"))
                object.squadId = message.squadId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            return object;
        };

        /**
         * Converts this RenameSquadIn to JSON.
         * @function toJSON
         * @memberof dfproto.RenameSquadIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameSquadIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RenameSquadIn;
    })();

    dfproto.RenameUnitIn = (function() {

        /**
         * Properties of a RenameUnitIn.
         * @memberof dfproto
         * @interface IRenameUnitIn
         * @property {number} unitId RenameUnitIn unitId
         * @property {string|null} [nickname] RenameUnitIn nickname
         * @property {string|null} [profession] RenameUnitIn profession
         */

        /**
         * Constructs a new RenameUnitIn.
         * @memberof dfproto
         * @classdesc Represents a RenameUnitIn.
         * @implements IRenameUnitIn
         * @constructor
         * @param {dfproto.IRenameUnitIn=} [properties] Properties to set
         */
        function RenameUnitIn(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameUnitIn unitId.
         * @member {number} unitId
         * @memberof dfproto.RenameUnitIn
         * @instance
         */
        RenameUnitIn.prototype.unitId = 0;

        /**
         * RenameUnitIn nickname.
         * @member {string} nickname
         * @memberof dfproto.RenameUnitIn
         * @instance
         */
        RenameUnitIn.prototype.nickname = "";

        /**
         * RenameUnitIn profession.
         * @member {string} profession
         * @memberof dfproto.RenameUnitIn
         * @instance
         */
        RenameUnitIn.prototype.profession = "";

        /**
         * Creates a new RenameUnitIn instance using the specified properties.
         * @function create
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.IRenameUnitIn=} [properties] Properties to set
         * @returns {dfproto.RenameUnitIn} RenameUnitIn instance
         */
        RenameUnitIn.create = function create(properties) {
            return new RenameUnitIn(properties);
        };

        /**
         * Encodes the specified RenameUnitIn message. Does not implicitly {@link dfproto.RenameUnitIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.IRenameUnitIn} message RenameUnitIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameUnitIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.unitId);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.profession != null && Object.hasOwnProperty.call(message, "profession"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.profession);
            return writer;
        };

        /**
         * Encodes the specified RenameUnitIn message, length delimited. Does not implicitly {@link dfproto.RenameUnitIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.IRenameUnitIn} message RenameUnitIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameUnitIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameUnitIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.RenameUnitIn} RenameUnitIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameUnitIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.RenameUnitIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.unitId = reader.int32();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    message.profession = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("unitId"))
                throw $util.ProtocolError("missing required 'unitId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RenameUnitIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.RenameUnitIn} RenameUnitIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameUnitIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameUnitIn message.
         * @function verify
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameUnitIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.unitId))
                return "unitId: integer expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.profession != null && message.hasOwnProperty("profession"))
                if (!$util.isString(message.profession))
                    return "profession: string expected";
            return null;
        };

        /**
         * Creates a RenameUnitIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.RenameUnitIn} RenameUnitIn
         */
        RenameUnitIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.RenameUnitIn)
                return object;
            var message = new $root.dfproto.RenameUnitIn();
            if (object.unitId != null)
                message.unitId = object.unitId | 0;
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.profession != null)
                message.profession = String(object.profession);
            return message;
        };

        /**
         * Creates a plain object from a RenameUnitIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.RenameUnitIn
         * @static
         * @param {dfproto.RenameUnitIn} message RenameUnitIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameUnitIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unitId = 0;
                object.nickname = "";
                object.profession = "";
            }
            if (message.unitId != null && message.hasOwnProperty("unitId"))
                object.unitId = message.unitId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.profession != null && message.hasOwnProperty("profession"))
                object.profession = message.profession;
            return object;
        };

        /**
         * Converts this RenameUnitIn to JSON.
         * @function toJSON
         * @memberof dfproto.RenameUnitIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameUnitIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RenameUnitIn;
    })();

    dfproto.RenameBuildingIn = (function() {

        /**
         * Properties of a RenameBuildingIn.
         * @memberof dfproto
         * @interface IRenameBuildingIn
         * @property {number} buildingId RenameBuildingIn buildingId
         * @property {string|null} [name] RenameBuildingIn name
         */

        /**
         * Constructs a new RenameBuildingIn.
         * @memberof dfproto
         * @classdesc Represents a RenameBuildingIn.
         * @implements IRenameBuildingIn
         * @constructor
         * @param {dfproto.IRenameBuildingIn=} [properties] Properties to set
         */
        function RenameBuildingIn(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenameBuildingIn buildingId.
         * @member {number} buildingId
         * @memberof dfproto.RenameBuildingIn
         * @instance
         */
        RenameBuildingIn.prototype.buildingId = 0;

        /**
         * RenameBuildingIn name.
         * @member {string} name
         * @memberof dfproto.RenameBuildingIn
         * @instance
         */
        RenameBuildingIn.prototype.name = "";

        /**
         * Creates a new RenameBuildingIn instance using the specified properties.
         * @function create
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.IRenameBuildingIn=} [properties] Properties to set
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn instance
         */
        RenameBuildingIn.create = function create(properties) {
            return new RenameBuildingIn(properties);
        };

        /**
         * Encodes the specified RenameBuildingIn message. Does not implicitly {@link dfproto.RenameBuildingIn.verify|verify} messages.
         * @function encode
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.IRenameBuildingIn} message RenameBuildingIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameBuildingIn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buildingId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified RenameBuildingIn message, length delimited. Does not implicitly {@link dfproto.RenameBuildingIn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.IRenameBuildingIn} message RenameBuildingIn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameBuildingIn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenameBuildingIn message from the specified reader or buffer.
         * @function decode
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameBuildingIn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dfproto.RenameBuildingIn();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buildingId = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("buildingId"))
                throw $util.ProtocolError("missing required 'buildingId'", { instance: message });
            return message;
        };

        /**
         * Decodes a RenameBuildingIn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameBuildingIn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenameBuildingIn message.
         * @function verify
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameBuildingIn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.buildingId))
                return "buildingId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a RenameBuildingIn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dfproto.RenameBuildingIn} RenameBuildingIn
         */
        RenameBuildingIn.fromObject = function fromObject(object) {
            if (object instanceof $root.dfproto.RenameBuildingIn)
                return object;
            var message = new $root.dfproto.RenameBuildingIn();
            if (object.buildingId != null)
                message.buildingId = object.buildingId | 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a RenameBuildingIn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dfproto.RenameBuildingIn
         * @static
         * @param {dfproto.RenameBuildingIn} message RenameBuildingIn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameBuildingIn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buildingId = 0;
                object.name = "";
            }
            if (message.buildingId != null && message.hasOwnProperty("buildingId"))
                object.buildingId = message.buildingId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this RenameBuildingIn to JSON.
         * @function toJSON
         * @memberof dfproto.RenameBuildingIn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameBuildingIn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RenameBuildingIn;
    })();

    return dfproto;
})();

$root.AdventureControl = (function() {

    /**
     * Namespace AdventureControl.
     * @exports AdventureControl
     * @namespace
     */
    var AdventureControl = {};

    /**
     * AdvmodeMenu enum.
     * @name AdventureControl.AdvmodeMenu
     * @enum {string}
     * @property {number} Default=0 Default value
     * @property {number} Look=1 Look value
     * @property {number} ConversationAddress=2 ConversationAddress value
     * @property {number} ConversationSelect=3 ConversationSelect value
     * @property {number} ConversationSpeak=4 ConversationSpeak value
     * @property {number} Inventory=5 Inventory value
     * @property {number} Drop=6 Drop value
     * @property {number} ThrowItem=7 ThrowItem value
     * @property {number} Wear=8 Wear value
     * @property {number} Remove=9 Remove value
     * @property {number} Interact=10 Interact value
     * @property {number} Put=11 Put value
     * @property {number} PutContainer=12 PutContainer value
     * @property {number} Eat=13 Eat value
     * @property {number} ThrowAim=14 ThrowAim value
     * @property {number} Fire=15 Fire value
     * @property {number} Get=16 Get value
     * @property {number} Unk17=17 Unk17 value
     * @property {number} CombatPrefs=18 CombatPrefs value
     * @property {number} Companions=19 Companions value
     * @property {number} MovementPrefs=20 MovementPrefs value
     * @property {number} SpeedPrefs=21 SpeedPrefs value
     * @property {number} InteractAction=22 InteractAction value
     * @property {number} MoveCarefully=23 MoveCarefully value
     * @property {number} Announcements=24 Announcements value
     * @property {number} UseBuilding=25 UseBuilding value
     * @property {number} Travel=26 Travel value
     * @property {number} Unk27=27 Unk27 value
     * @property {number} Unk28=28 Unk28 value
     * @property {number} SleepConfirm=29 SleepConfirm value
     * @property {number} SelectInteractionTarget=30 SelectInteractionTarget value
     * @property {number} Unk31=31 Unk31 value
     * @property {number} Unk32=32 Unk32 value
     * @property {number} FallAction=33 FallAction value
     * @property {number} ViewTracks=34 ViewTracks value
     * @property {number} Jump=35 Jump value
     * @property {number} Unk36=36 Unk36 value
     * @property {number} AttackConfirm=37 AttackConfirm value
     * @property {number} AttackType=38 AttackType value
     * @property {number} AttackBodypart=39 AttackBodypart value
     * @property {number} AttackStrike=40 AttackStrike value
     * @property {number} Unk41=41 Unk41 value
     * @property {number} Unk42=42 Unk42 value
     * @property {number} DodgeDirection=43 DodgeDirection value
     * @property {number} Unk44=44 Unk44 value
     * @property {number} Unk45=45 Unk45 value
     * @property {number} Build=46 Build value
     */
    AdventureControl.AdvmodeMenu = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Default"] = 0;
        values[valuesById[1] = "Look"] = 1;
        values[valuesById[2] = "ConversationAddress"] = 2;
        values[valuesById[3] = "ConversationSelect"] = 3;
        values[valuesById[4] = "ConversationSpeak"] = 4;
        values[valuesById[5] = "Inventory"] = 5;
        values[valuesById[6] = "Drop"] = 6;
        values[valuesById[7] = "ThrowItem"] = 7;
        values[valuesById[8] = "Wear"] = 8;
        values[valuesById[9] = "Remove"] = 9;
        values[valuesById[10] = "Interact"] = 10;
        values[valuesById[11] = "Put"] = 11;
        values[valuesById[12] = "PutContainer"] = 12;
        values[valuesById[13] = "Eat"] = 13;
        values[valuesById[14] = "ThrowAim"] = 14;
        values[valuesById[15] = "Fire"] = 15;
        values[valuesById[16] = "Get"] = 16;
        values[valuesById[17] = "Unk17"] = 17;
        values[valuesById[18] = "CombatPrefs"] = 18;
        values[valuesById[19] = "Companions"] = 19;
        values[valuesById[20] = "MovementPrefs"] = 20;
        values[valuesById[21] = "SpeedPrefs"] = 21;
        values[valuesById[22] = "InteractAction"] = 22;
        values[valuesById[23] = "MoveCarefully"] = 23;
        values[valuesById[24] = "Announcements"] = 24;
        values[valuesById[25] = "UseBuilding"] = 25;
        values[valuesById[26] = "Travel"] = 26;
        values[valuesById[27] = "Unk27"] = 27;
        values[valuesById[28] = "Unk28"] = 28;
        values[valuesById[29] = "SleepConfirm"] = 29;
        values[valuesById[30] = "SelectInteractionTarget"] = 30;
        values[valuesById[31] = "Unk31"] = 31;
        values[valuesById[32] = "Unk32"] = 32;
        values[valuesById[33] = "FallAction"] = 33;
        values[valuesById[34] = "ViewTracks"] = 34;
        values[valuesById[35] = "Jump"] = 35;
        values[valuesById[36] = "Unk36"] = 36;
        values[valuesById[37] = "AttackConfirm"] = 37;
        values[valuesById[38] = "AttackType"] = 38;
        values[valuesById[39] = "AttackBodypart"] = 39;
        values[valuesById[40] = "AttackStrike"] = 40;
        values[valuesById[41] = "Unk41"] = 41;
        values[valuesById[42] = "Unk42"] = 42;
        values[valuesById[43] = "DodgeDirection"] = 43;
        values[valuesById[44] = "Unk44"] = 44;
        values[valuesById[45] = "Unk45"] = 45;
        values[valuesById[46] = "Build"] = 46;
        return values;
    })();

    /**
     * CarefulMovementType enum.
     * @name AdventureControl.CarefulMovementType
     * @enum {string}
     * @property {number} DEFAULT_MOVEMENT=0 DEFAULT_MOVEMENT value
     * @property {number} RELEASE_ITEM_HOLD=1 RELEASE_ITEM_HOLD value
     * @property {number} RELEASE_TILE_HOLD=2 RELEASE_TILE_HOLD value
     * @property {number} ATTACK_CREATURE=3 ATTACK_CREATURE value
     * @property {number} HOLD_TILE=4 HOLD_TILE value
     * @property {number} MOVE=5 MOVE value
     * @property {number} CLIMB=6 CLIMB value
     * @property {number} HOLD_ITEM=7 HOLD_ITEM value
     * @property {number} BUILDING_INTERACT=8 BUILDING_INTERACT value
     * @property {number} ITEM_INTERACT=9 ITEM_INTERACT value
     * @property {number} ITEM_INTERACT_GUIDE=10 ITEM_INTERACT_GUIDE value
     * @property {number} ITEM_INTERACT_RIDE=11 ITEM_INTERACT_RIDE value
     * @property {number} ITEM_INTERACT_PUSH=12 ITEM_INTERACT_PUSH value
     */
    AdventureControl.CarefulMovementType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_MOVEMENT"] = 0;
        values[valuesById[1] = "RELEASE_ITEM_HOLD"] = 1;
        values[valuesById[2] = "RELEASE_TILE_HOLD"] = 2;
        values[valuesById[3] = "ATTACK_CREATURE"] = 3;
        values[valuesById[4] = "HOLD_TILE"] = 4;
        values[valuesById[5] = "MOVE"] = 5;
        values[valuesById[6] = "CLIMB"] = 6;
        values[valuesById[7] = "HOLD_ITEM"] = 7;
        values[valuesById[8] = "BUILDING_INTERACT"] = 8;
        values[valuesById[9] = "ITEM_INTERACT"] = 9;
        values[valuesById[10] = "ITEM_INTERACT_GUIDE"] = 10;
        values[valuesById[11] = "ITEM_INTERACT_RIDE"] = 11;
        values[valuesById[12] = "ITEM_INTERACT_PUSH"] = 12;
        return values;
    })();

    /**
     * MiscMoveType enum.
     * @name AdventureControl.MiscMoveType
     * @enum {string}
     * @property {number} SET_CLIMB=0 SET_CLIMB value
     * @property {number} SET_STAND=1 SET_STAND value
     * @property {number} SET_CANCEL=2 SET_CANCEL value
     */
    AdventureControl.MiscMoveType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SET_CLIMB"] = 0;
        values[valuesById[1] = "SET_STAND"] = 1;
        values[valuesById[2] = "SET_CANCEL"] = 2;
        return values;
    })();

    AdventureControl.MoveCommandParams = (function() {

        /**
         * Properties of a MoveCommandParams.
         * @memberof AdventureControl
         * @interface IMoveCommandParams
         * @property {RemoteFortressReader.ICoord|null} [direction] MoveCommandParams direction
         */

        /**
         * Constructs a new MoveCommandParams.
         * @memberof AdventureControl
         * @classdesc Represents a MoveCommandParams.
         * @implements IMoveCommandParams
         * @constructor
         * @param {AdventureControl.IMoveCommandParams=} [properties] Properties to set
         */
        function MoveCommandParams(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoveCommandParams direction.
         * @member {RemoteFortressReader.ICoord|null|undefined} direction
         * @memberof AdventureControl.MoveCommandParams
         * @instance
         */
        MoveCommandParams.prototype.direction = null;

        /**
         * Creates a new MoveCommandParams instance using the specified properties.
         * @function create
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {AdventureControl.IMoveCommandParams=} [properties] Properties to set
         * @returns {AdventureControl.MoveCommandParams} MoveCommandParams instance
         */
        MoveCommandParams.create = function create(properties) {
            return new MoveCommandParams(properties);
        };

        /**
         * Encodes the specified MoveCommandParams message. Does not implicitly {@link AdventureControl.MoveCommandParams.verify|verify} messages.
         * @function encode
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {AdventureControl.IMoveCommandParams} message MoveCommandParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveCommandParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                $root.RemoteFortressReader.Coord.encode(message.direction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MoveCommandParams message, length delimited. Does not implicitly {@link AdventureControl.MoveCommandParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {AdventureControl.IMoveCommandParams} message MoveCommandParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveCommandParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoveCommandParams message from the specified reader or buffer.
         * @function decode
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdventureControl.MoveCommandParams} MoveCommandParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveCommandParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdventureControl.MoveCommandParams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.direction = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoveCommandParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdventureControl.MoveCommandParams} MoveCommandParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveCommandParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoveCommandParams message.
         * @function verify
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoveCommandParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.direction != null && message.hasOwnProperty("direction")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.direction);
                if (error)
                    return "direction." + error;
            }
            return null;
        };

        /**
         * Creates a MoveCommandParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AdventureControl.MoveCommandParams} MoveCommandParams
         */
        MoveCommandParams.fromObject = function fromObject(object) {
            if (object instanceof $root.AdventureControl.MoveCommandParams)
                return object;
            var message = new $root.AdventureControl.MoveCommandParams();
            if (object.direction != null) {
                if (typeof object.direction !== "object")
                    throw TypeError(".AdventureControl.MoveCommandParams.direction: object expected");
                message.direction = $root.RemoteFortressReader.Coord.fromObject(object.direction);
            }
            return message;
        };

        /**
         * Creates a plain object from a MoveCommandParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AdventureControl.MoveCommandParams
         * @static
         * @param {AdventureControl.MoveCommandParams} message MoveCommandParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MoveCommandParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.direction = null;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = $root.RemoteFortressReader.Coord.toObject(message.direction, options);
            return object;
        };

        /**
         * Converts this MoveCommandParams to JSON.
         * @function toJSON
         * @memberof AdventureControl.MoveCommandParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MoveCommandParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MoveCommandParams;
    })();

    AdventureControl.MovementOption = (function() {

        /**
         * Properties of a MovementOption.
         * @memberof AdventureControl
         * @interface IMovementOption
         * @property {RemoteFortressReader.ICoord|null} [dest] MovementOption dest
         * @property {RemoteFortressReader.ICoord|null} [source] MovementOption source
         * @property {RemoteFortressReader.ICoord|null} [grab] MovementOption grab
         * @property {AdventureControl.CarefulMovementType|null} [movementType] MovementOption movementType
         */

        /**
         * Constructs a new MovementOption.
         * @memberof AdventureControl
         * @classdesc Represents a MovementOption.
         * @implements IMovementOption
         * @constructor
         * @param {AdventureControl.IMovementOption=} [properties] Properties to set
         */
        function MovementOption(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MovementOption dest.
         * @member {RemoteFortressReader.ICoord|null|undefined} dest
         * @memberof AdventureControl.MovementOption
         * @instance
         */
        MovementOption.prototype.dest = null;

        /**
         * MovementOption source.
         * @member {RemoteFortressReader.ICoord|null|undefined} source
         * @memberof AdventureControl.MovementOption
         * @instance
         */
        MovementOption.prototype.source = null;

        /**
         * MovementOption grab.
         * @member {RemoteFortressReader.ICoord|null|undefined} grab
         * @memberof AdventureControl.MovementOption
         * @instance
         */
        MovementOption.prototype.grab = null;

        /**
         * MovementOption movementType.
         * @member {AdventureControl.CarefulMovementType} movementType
         * @memberof AdventureControl.MovementOption
         * @instance
         */
        MovementOption.prototype.movementType = 0;

        /**
         * Creates a new MovementOption instance using the specified properties.
         * @function create
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {AdventureControl.IMovementOption=} [properties] Properties to set
         * @returns {AdventureControl.MovementOption} MovementOption instance
         */
        MovementOption.create = function create(properties) {
            return new MovementOption(properties);
        };

        /**
         * Encodes the specified MovementOption message. Does not implicitly {@link AdventureControl.MovementOption.verify|verify} messages.
         * @function encode
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {AdventureControl.IMovementOption} message MovementOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovementOption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                $root.RemoteFortressReader.Coord.encode(message.dest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                $root.RemoteFortressReader.Coord.encode(message.source, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.grab != null && Object.hasOwnProperty.call(message, "grab"))
                $root.RemoteFortressReader.Coord.encode(message.grab, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.movementType != null && Object.hasOwnProperty.call(message, "movementType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.movementType);
            return writer;
        };

        /**
         * Encodes the specified MovementOption message, length delimited. Does not implicitly {@link AdventureControl.MovementOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {AdventureControl.IMovementOption} message MovementOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovementOption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MovementOption message from the specified reader or buffer.
         * @function decode
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdventureControl.MovementOption} MovementOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovementOption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdventureControl.MovementOption();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dest = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.source = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.grab = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.movementType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MovementOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdventureControl.MovementOption} MovementOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovementOption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MovementOption message.
         * @function verify
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MovementOption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.dest);
                if (error)
                    return "dest." + error;
            }
            if (message.source != null && message.hasOwnProperty("source")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.source);
                if (error)
                    return "source." + error;
            }
            if (message.grab != null && message.hasOwnProperty("grab")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.grab);
                if (error)
                    return "grab." + error;
            }
            if (message.movementType != null && message.hasOwnProperty("movementType"))
                switch (message.movementType) {
                default:
                    return "movementType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            return null;
        };

        /**
         * Creates a MovementOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AdventureControl.MovementOption} MovementOption
         */
        MovementOption.fromObject = function fromObject(object) {
            if (object instanceof $root.AdventureControl.MovementOption)
                return object;
            var message = new $root.AdventureControl.MovementOption();
            if (object.dest != null) {
                if (typeof object.dest !== "object")
                    throw TypeError(".AdventureControl.MovementOption.dest: object expected");
                message.dest = $root.RemoteFortressReader.Coord.fromObject(object.dest);
            }
            if (object.source != null) {
                if (typeof object.source !== "object")
                    throw TypeError(".AdventureControl.MovementOption.source: object expected");
                message.source = $root.RemoteFortressReader.Coord.fromObject(object.source);
            }
            if (object.grab != null) {
                if (typeof object.grab !== "object")
                    throw TypeError(".AdventureControl.MovementOption.grab: object expected");
                message.grab = $root.RemoteFortressReader.Coord.fromObject(object.grab);
            }
            switch (object.movementType) {
            case "DEFAULT_MOVEMENT":
            case 0:
                message.movementType = 0;
                break;
            case "RELEASE_ITEM_HOLD":
            case 1:
                message.movementType = 1;
                break;
            case "RELEASE_TILE_HOLD":
            case 2:
                message.movementType = 2;
                break;
            case "ATTACK_CREATURE":
            case 3:
                message.movementType = 3;
                break;
            case "HOLD_TILE":
            case 4:
                message.movementType = 4;
                break;
            case "MOVE":
            case 5:
                message.movementType = 5;
                break;
            case "CLIMB":
            case 6:
                message.movementType = 6;
                break;
            case "HOLD_ITEM":
            case 7:
                message.movementType = 7;
                break;
            case "BUILDING_INTERACT":
            case 8:
                message.movementType = 8;
                break;
            case "ITEM_INTERACT":
            case 9:
                message.movementType = 9;
                break;
            case "ITEM_INTERACT_GUIDE":
            case 10:
                message.movementType = 10;
                break;
            case "ITEM_INTERACT_RIDE":
            case 11:
                message.movementType = 11;
                break;
            case "ITEM_INTERACT_PUSH":
            case 12:
                message.movementType = 12;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MovementOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AdventureControl.MovementOption
         * @static
         * @param {AdventureControl.MovementOption} message MovementOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MovementOption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dest = null;
                object.source = null;
                object.grab = null;
                object.movementType = options.enums === String ? "DEFAULT_MOVEMENT" : 0;
            }
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = $root.RemoteFortressReader.Coord.toObject(message.dest, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = $root.RemoteFortressReader.Coord.toObject(message.source, options);
            if (message.grab != null && message.hasOwnProperty("grab"))
                object.grab = $root.RemoteFortressReader.Coord.toObject(message.grab, options);
            if (message.movementType != null && message.hasOwnProperty("movementType"))
                object.movementType = options.enums === String ? $root.AdventureControl.CarefulMovementType[message.movementType] : message.movementType;
            return object;
        };

        /**
         * Converts this MovementOption to JSON.
         * @function toJSON
         * @memberof AdventureControl.MovementOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MovementOption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MovementOption;
    })();

    AdventureControl.MenuContents = (function() {

        /**
         * Properties of a MenuContents.
         * @memberof AdventureControl
         * @interface IMenuContents
         * @property {AdventureControl.AdvmodeMenu|null} [currentMenu] MenuContents currentMenu
         * @property {Array.<AdventureControl.IMovementOption>|null} [movements] MenuContents movements
         */

        /**
         * Constructs a new MenuContents.
         * @memberof AdventureControl
         * @classdesc Represents a MenuContents.
         * @implements IMenuContents
         * @constructor
         * @param {AdventureControl.IMenuContents=} [properties] Properties to set
         */
        function MenuContents(properties) {
            this.movements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MenuContents currentMenu.
         * @member {AdventureControl.AdvmodeMenu} currentMenu
         * @memberof AdventureControl.MenuContents
         * @instance
         */
        MenuContents.prototype.currentMenu = 0;

        /**
         * MenuContents movements.
         * @member {Array.<AdventureControl.IMovementOption>} movements
         * @memberof AdventureControl.MenuContents
         * @instance
         */
        MenuContents.prototype.movements = $util.emptyArray;

        /**
         * Creates a new MenuContents instance using the specified properties.
         * @function create
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {AdventureControl.IMenuContents=} [properties] Properties to set
         * @returns {AdventureControl.MenuContents} MenuContents instance
         */
        MenuContents.create = function create(properties) {
            return new MenuContents(properties);
        };

        /**
         * Encodes the specified MenuContents message. Does not implicitly {@link AdventureControl.MenuContents.verify|verify} messages.
         * @function encode
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {AdventureControl.IMenuContents} message MenuContents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MenuContents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentMenu != null && Object.hasOwnProperty.call(message, "currentMenu"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currentMenu);
            if (message.movements != null && message.movements.length)
                for (var i = 0; i < message.movements.length; ++i)
                    $root.AdventureControl.MovementOption.encode(message.movements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MenuContents message, length delimited. Does not implicitly {@link AdventureControl.MenuContents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {AdventureControl.IMenuContents} message MenuContents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MenuContents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MenuContents message from the specified reader or buffer.
         * @function decode
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdventureControl.MenuContents} MenuContents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MenuContents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdventureControl.MenuContents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currentMenu = reader.int32();
                    break;
                case 2:
                    if (!(message.movements && message.movements.length))
                        message.movements = [];
                    message.movements.push($root.AdventureControl.MovementOption.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MenuContents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdventureControl.MenuContents} MenuContents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MenuContents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MenuContents message.
         * @function verify
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MenuContents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentMenu != null && message.hasOwnProperty("currentMenu"))
                switch (message.currentMenu) {
                default:
                    return "currentMenu: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                    break;
                }
            if (message.movements != null && message.hasOwnProperty("movements")) {
                if (!Array.isArray(message.movements))
                    return "movements: array expected";
                for (var i = 0; i < message.movements.length; ++i) {
                    var error = $root.AdventureControl.MovementOption.verify(message.movements[i]);
                    if (error)
                        return "movements." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MenuContents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AdventureControl.MenuContents} MenuContents
         */
        MenuContents.fromObject = function fromObject(object) {
            if (object instanceof $root.AdventureControl.MenuContents)
                return object;
            var message = new $root.AdventureControl.MenuContents();
            switch (object.currentMenu) {
            case "Default":
            case 0:
                message.currentMenu = 0;
                break;
            case "Look":
            case 1:
                message.currentMenu = 1;
                break;
            case "ConversationAddress":
            case 2:
                message.currentMenu = 2;
                break;
            case "ConversationSelect":
            case 3:
                message.currentMenu = 3;
                break;
            case "ConversationSpeak":
            case 4:
                message.currentMenu = 4;
                break;
            case "Inventory":
            case 5:
                message.currentMenu = 5;
                break;
            case "Drop":
            case 6:
                message.currentMenu = 6;
                break;
            case "ThrowItem":
            case 7:
                message.currentMenu = 7;
                break;
            case "Wear":
            case 8:
                message.currentMenu = 8;
                break;
            case "Remove":
            case 9:
                message.currentMenu = 9;
                break;
            case "Interact":
            case 10:
                message.currentMenu = 10;
                break;
            case "Put":
            case 11:
                message.currentMenu = 11;
                break;
            case "PutContainer":
            case 12:
                message.currentMenu = 12;
                break;
            case "Eat":
            case 13:
                message.currentMenu = 13;
                break;
            case "ThrowAim":
            case 14:
                message.currentMenu = 14;
                break;
            case "Fire":
            case 15:
                message.currentMenu = 15;
                break;
            case "Get":
            case 16:
                message.currentMenu = 16;
                break;
            case "Unk17":
            case 17:
                message.currentMenu = 17;
                break;
            case "CombatPrefs":
            case 18:
                message.currentMenu = 18;
                break;
            case "Companions":
            case 19:
                message.currentMenu = 19;
                break;
            case "MovementPrefs":
            case 20:
                message.currentMenu = 20;
                break;
            case "SpeedPrefs":
            case 21:
                message.currentMenu = 21;
                break;
            case "InteractAction":
            case 22:
                message.currentMenu = 22;
                break;
            case "MoveCarefully":
            case 23:
                message.currentMenu = 23;
                break;
            case "Announcements":
            case 24:
                message.currentMenu = 24;
                break;
            case "UseBuilding":
            case 25:
                message.currentMenu = 25;
                break;
            case "Travel":
            case 26:
                message.currentMenu = 26;
                break;
            case "Unk27":
            case 27:
                message.currentMenu = 27;
                break;
            case "Unk28":
            case 28:
                message.currentMenu = 28;
                break;
            case "SleepConfirm":
            case 29:
                message.currentMenu = 29;
                break;
            case "SelectInteractionTarget":
            case 30:
                message.currentMenu = 30;
                break;
            case "Unk31":
            case 31:
                message.currentMenu = 31;
                break;
            case "Unk32":
            case 32:
                message.currentMenu = 32;
                break;
            case "FallAction":
            case 33:
                message.currentMenu = 33;
                break;
            case "ViewTracks":
            case 34:
                message.currentMenu = 34;
                break;
            case "Jump":
            case 35:
                message.currentMenu = 35;
                break;
            case "Unk36":
            case 36:
                message.currentMenu = 36;
                break;
            case "AttackConfirm":
            case 37:
                message.currentMenu = 37;
                break;
            case "AttackType":
            case 38:
                message.currentMenu = 38;
                break;
            case "AttackBodypart":
            case 39:
                message.currentMenu = 39;
                break;
            case "AttackStrike":
            case 40:
                message.currentMenu = 40;
                break;
            case "Unk41":
            case 41:
                message.currentMenu = 41;
                break;
            case "Unk42":
            case 42:
                message.currentMenu = 42;
                break;
            case "DodgeDirection":
            case 43:
                message.currentMenu = 43;
                break;
            case "Unk44":
            case 44:
                message.currentMenu = 44;
                break;
            case "Unk45":
            case 45:
                message.currentMenu = 45;
                break;
            case "Build":
            case 46:
                message.currentMenu = 46;
                break;
            }
            if (object.movements) {
                if (!Array.isArray(object.movements))
                    throw TypeError(".AdventureControl.MenuContents.movements: array expected");
                message.movements = [];
                for (var i = 0; i < object.movements.length; ++i) {
                    if (typeof object.movements[i] !== "object")
                        throw TypeError(".AdventureControl.MenuContents.movements: object expected");
                    message.movements[i] = $root.AdventureControl.MovementOption.fromObject(object.movements[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MenuContents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AdventureControl.MenuContents
         * @static
         * @param {AdventureControl.MenuContents} message MenuContents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MenuContents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.movements = [];
            if (options.defaults)
                object.currentMenu = options.enums === String ? "Default" : 0;
            if (message.currentMenu != null && message.hasOwnProperty("currentMenu"))
                object.currentMenu = options.enums === String ? $root.AdventureControl.AdvmodeMenu[message.currentMenu] : message.currentMenu;
            if (message.movements && message.movements.length) {
                object.movements = [];
                for (var j = 0; j < message.movements.length; ++j)
                    object.movements[j] = $root.AdventureControl.MovementOption.toObject(message.movements[j], options);
            }
            return object;
        };

        /**
         * Converts this MenuContents to JSON.
         * @function toJSON
         * @memberof AdventureControl.MenuContents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MenuContents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MenuContents;
    })();

    AdventureControl.MiscMoveParams = (function() {

        /**
         * Properties of a MiscMoveParams.
         * @memberof AdventureControl
         * @interface IMiscMoveParams
         * @property {AdventureControl.MiscMoveType|null} [type] MiscMoveParams type
         */

        /**
         * Constructs a new MiscMoveParams.
         * @memberof AdventureControl
         * @classdesc Represents a MiscMoveParams.
         * @implements IMiscMoveParams
         * @constructor
         * @param {AdventureControl.IMiscMoveParams=} [properties] Properties to set
         */
        function MiscMoveParams(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MiscMoveParams type.
         * @member {AdventureControl.MiscMoveType} type
         * @memberof AdventureControl.MiscMoveParams
         * @instance
         */
        MiscMoveParams.prototype.type = 0;

        /**
         * Creates a new MiscMoveParams instance using the specified properties.
         * @function create
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {AdventureControl.IMiscMoveParams=} [properties] Properties to set
         * @returns {AdventureControl.MiscMoveParams} MiscMoveParams instance
         */
        MiscMoveParams.create = function create(properties) {
            return new MiscMoveParams(properties);
        };

        /**
         * Encodes the specified MiscMoveParams message. Does not implicitly {@link AdventureControl.MiscMoveParams.verify|verify} messages.
         * @function encode
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {AdventureControl.IMiscMoveParams} message MiscMoveParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MiscMoveParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified MiscMoveParams message, length delimited. Does not implicitly {@link AdventureControl.MiscMoveParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {AdventureControl.IMiscMoveParams} message MiscMoveParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MiscMoveParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MiscMoveParams message from the specified reader or buffer.
         * @function decode
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AdventureControl.MiscMoveParams} MiscMoveParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MiscMoveParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AdventureControl.MiscMoveParams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MiscMoveParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AdventureControl.MiscMoveParams} MiscMoveParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MiscMoveParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MiscMoveParams message.
         * @function verify
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MiscMoveParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a MiscMoveParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AdventureControl.MiscMoveParams} MiscMoveParams
         */
        MiscMoveParams.fromObject = function fromObject(object) {
            if (object instanceof $root.AdventureControl.MiscMoveParams)
                return object;
            var message = new $root.AdventureControl.MiscMoveParams();
            switch (object.type) {
            case "SET_CLIMB":
            case 0:
                message.type = 0;
                break;
            case "SET_STAND":
            case 1:
                message.type = 1;
                break;
            case "SET_CANCEL":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MiscMoveParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AdventureControl.MiscMoveParams
         * @static
         * @param {AdventureControl.MiscMoveParams} message MiscMoveParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MiscMoveParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "SET_CLIMB" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.AdventureControl.MiscMoveType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this MiscMoveParams to JSON.
         * @function toJSON
         * @memberof AdventureControl.MiscMoveParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MiscMoveParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MiscMoveParams;
    })();

    return AdventureControl;
})();

$root.RemoteFortressReader = (function() {

    /**
     * Namespace RemoteFortressReader.
     * @exports RemoteFortressReader
     * @namespace
     */
    var RemoteFortressReader = {};

    /**
     * TiletypeShape enum.
     * @name RemoteFortressReader.TiletypeShape
     * @enum {string}
     * @property {number} NO_SHAPE=-1 NO_SHAPE value
     * @property {number} EMPTY=0 EMPTY value
     * @property {number} FLOOR=1 FLOOR value
     * @property {number} BOULDER=2 BOULDER value
     * @property {number} PEBBLES=3 PEBBLES value
     * @property {number} WALL=4 WALL value
     * @property {number} FORTIFICATION=5 FORTIFICATION value
     * @property {number} STAIR_UP=6 STAIR_UP value
     * @property {number} STAIR_DOWN=7 STAIR_DOWN value
     * @property {number} STAIR_UPDOWN=8 STAIR_UPDOWN value
     * @property {number} RAMP=9 RAMP value
     * @property {number} RAMP_TOP=10 RAMP_TOP value
     * @property {number} BROOK_BED=11 BROOK_BED value
     * @property {number} BROOK_TOP=12 BROOK_TOP value
     * @property {number} TREE_SHAPE=13 TREE_SHAPE value
     * @property {number} SAPLING=14 SAPLING value
     * @property {number} SHRUB=15 SHRUB value
     * @property {number} ENDLESS_PIT=16 ENDLESS_PIT value
     * @property {number} BRANCH=17 BRANCH value
     * @property {number} TRUNK_BRANCH=18 TRUNK_BRANCH value
     * @property {number} TWIG=19 TWIG value
     */
    RemoteFortressReader.TiletypeShape = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_SHAPE"] = -1;
        values[valuesById[0] = "EMPTY"] = 0;
        values[valuesById[1] = "FLOOR"] = 1;
        values[valuesById[2] = "BOULDER"] = 2;
        values[valuesById[3] = "PEBBLES"] = 3;
        values[valuesById[4] = "WALL"] = 4;
        values[valuesById[5] = "FORTIFICATION"] = 5;
        values[valuesById[6] = "STAIR_UP"] = 6;
        values[valuesById[7] = "STAIR_DOWN"] = 7;
        values[valuesById[8] = "STAIR_UPDOWN"] = 8;
        values[valuesById[9] = "RAMP"] = 9;
        values[valuesById[10] = "RAMP_TOP"] = 10;
        values[valuesById[11] = "BROOK_BED"] = 11;
        values[valuesById[12] = "BROOK_TOP"] = 12;
        values[valuesById[13] = "TREE_SHAPE"] = 13;
        values[valuesById[14] = "SAPLING"] = 14;
        values[valuesById[15] = "SHRUB"] = 15;
        values[valuesById[16] = "ENDLESS_PIT"] = 16;
        values[valuesById[17] = "BRANCH"] = 17;
        values[valuesById[18] = "TRUNK_BRANCH"] = 18;
        values[valuesById[19] = "TWIG"] = 19;
        return values;
    })();

    /**
     * TiletypeSpecial enum.
     * @name RemoteFortressReader.TiletypeSpecial
     * @enum {string}
     * @property {number} NO_SPECIAL=-1 NO_SPECIAL value
     * @property {number} NORMAL=0 NORMAL value
     * @property {number} RIVER_SOURCE=1 RIVER_SOURCE value
     * @property {number} WATERFALL=2 WATERFALL value
     * @property {number} SMOOTH=3 SMOOTH value
     * @property {number} FURROWED=4 FURROWED value
     * @property {number} WET=5 WET value
     * @property {number} DEAD=6 DEAD value
     * @property {number} WORN_1=7 WORN_1 value
     * @property {number} WORN_2=8 WORN_2 value
     * @property {number} WORN_3=9 WORN_3 value
     * @property {number} TRACK=10 TRACK value
     * @property {number} SMOOTH_DEAD=11 SMOOTH_DEAD value
     */
    RemoteFortressReader.TiletypeSpecial = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_SPECIAL"] = -1;
        values[valuesById[0] = "NORMAL"] = 0;
        values[valuesById[1] = "RIVER_SOURCE"] = 1;
        values[valuesById[2] = "WATERFALL"] = 2;
        values[valuesById[3] = "SMOOTH"] = 3;
        values[valuesById[4] = "FURROWED"] = 4;
        values[valuesById[5] = "WET"] = 5;
        values[valuesById[6] = "DEAD"] = 6;
        values[valuesById[7] = "WORN_1"] = 7;
        values[valuesById[8] = "WORN_2"] = 8;
        values[valuesById[9] = "WORN_3"] = 9;
        values[valuesById[10] = "TRACK"] = 10;
        values[valuesById[11] = "SMOOTH_DEAD"] = 11;
        return values;
    })();

    /**
     * TiletypeMaterial enum.
     * @name RemoteFortressReader.TiletypeMaterial
     * @enum {string}
     * @property {number} NO_MATERIAL=-1 NO_MATERIAL value
     * @property {number} AIR=0 AIR value
     * @property {number} SOIL=1 SOIL value
     * @property {number} STONE=2 STONE value
     * @property {number} FEATURE=3 FEATURE value
     * @property {number} LAVA_STONE=4 LAVA_STONE value
     * @property {number} MINERAL=5 MINERAL value
     * @property {number} FROZEN_LIQUID=6 FROZEN_LIQUID value
     * @property {number} CONSTRUCTION=7 CONSTRUCTION value
     * @property {number} GRASS_LIGHT=8 GRASS_LIGHT value
     * @property {number} GRASS_DARK=9 GRASS_DARK value
     * @property {number} GRASS_DRY=10 GRASS_DRY value
     * @property {number} GRASS_DEAD=11 GRASS_DEAD value
     * @property {number} PLANT=12 PLANT value
     * @property {number} HFS=13 HFS value
     * @property {number} CAMPFIRE=14 CAMPFIRE value
     * @property {number} FIRE=15 FIRE value
     * @property {number} ASHES=16 ASHES value
     * @property {number} MAGMA=17 MAGMA value
     * @property {number} DRIFTWOOD=18 DRIFTWOOD value
     * @property {number} POOL=19 POOL value
     * @property {number} BROOK=20 BROOK value
     * @property {number} RIVER=21 RIVER value
     * @property {number} ROOT=22 ROOT value
     * @property {number} TREE_MATERIAL=23 TREE_MATERIAL value
     * @property {number} MUSHROOM=24 MUSHROOM value
     * @property {number} UNDERWORLD_GATE=25 UNDERWORLD_GATE value
     */
    RemoteFortressReader.TiletypeMaterial = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_MATERIAL"] = -1;
        values[valuesById[0] = "AIR"] = 0;
        values[valuesById[1] = "SOIL"] = 1;
        values[valuesById[2] = "STONE"] = 2;
        values[valuesById[3] = "FEATURE"] = 3;
        values[valuesById[4] = "LAVA_STONE"] = 4;
        values[valuesById[5] = "MINERAL"] = 5;
        values[valuesById[6] = "FROZEN_LIQUID"] = 6;
        values[valuesById[7] = "CONSTRUCTION"] = 7;
        values[valuesById[8] = "GRASS_LIGHT"] = 8;
        values[valuesById[9] = "GRASS_DARK"] = 9;
        values[valuesById[10] = "GRASS_DRY"] = 10;
        values[valuesById[11] = "GRASS_DEAD"] = 11;
        values[valuesById[12] = "PLANT"] = 12;
        values[valuesById[13] = "HFS"] = 13;
        values[valuesById[14] = "CAMPFIRE"] = 14;
        values[valuesById[15] = "FIRE"] = 15;
        values[valuesById[16] = "ASHES"] = 16;
        values[valuesById[17] = "MAGMA"] = 17;
        values[valuesById[18] = "DRIFTWOOD"] = 18;
        values[valuesById[19] = "POOL"] = 19;
        values[valuesById[20] = "BROOK"] = 20;
        values[valuesById[21] = "RIVER"] = 21;
        values[valuesById[22] = "ROOT"] = 22;
        values[valuesById[23] = "TREE_MATERIAL"] = 23;
        values[valuesById[24] = "MUSHROOM"] = 24;
        values[valuesById[25] = "UNDERWORLD_GATE"] = 25;
        return values;
    })();

    /**
     * TiletypeVariant enum.
     * @name RemoteFortressReader.TiletypeVariant
     * @enum {string}
     * @property {number} NO_VARIANT=-1 NO_VARIANT value
     * @property {number} VAR_1=0 VAR_1 value
     * @property {number} VAR_2=1 VAR_2 value
     * @property {number} VAR_3=2 VAR_3 value
     * @property {number} VAR_4=3 VAR_4 value
     */
    RemoteFortressReader.TiletypeVariant = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "NO_VARIANT"] = -1;
        values[valuesById[0] = "VAR_1"] = 0;
        values[valuesById[1] = "VAR_2"] = 1;
        values[valuesById[2] = "VAR_3"] = 2;
        values[valuesById[3] = "VAR_4"] = 3;
        return values;
    })();

    /**
     * WorldPoles enum.
     * @name RemoteFortressReader.WorldPoles
     * @enum {string}
     * @property {number} NO_POLES=0 NO_POLES value
     * @property {number} NORTH_POLE=1 NORTH_POLE value
     * @property {number} SOUTH_POLE=2 SOUTH_POLE value
     * @property {number} BOTH_POLES=3 BOTH_POLES value
     */
    RemoteFortressReader.WorldPoles = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_POLES"] = 0;
        values[valuesById[1] = "NORTH_POLE"] = 1;
        values[valuesById[2] = "SOUTH_POLE"] = 2;
        values[valuesById[3] = "BOTH_POLES"] = 3;
        return values;
    })();

    /**
     * BuildingDirection enum.
     * @name RemoteFortressReader.BuildingDirection
     * @enum {string}
     * @property {number} NORTH=0 NORTH value
     * @property {number} EAST=1 EAST value
     * @property {number} SOUTH=2 SOUTH value
     * @property {number} WEST=3 WEST value
     * @property {number} NONE=4 NONE value
     */
    RemoteFortressReader.BuildingDirection = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NORTH"] = 0;
        values[valuesById[1] = "EAST"] = 1;
        values[valuesById[2] = "SOUTH"] = 2;
        values[valuesById[3] = "WEST"] = 3;
        values[valuesById[4] = "NONE"] = 4;
        return values;
    })();

    /**
     * TileDigDesignation enum.
     * @name RemoteFortressReader.TileDigDesignation
     * @enum {string}
     * @property {number} NO_DIG=0 no designation
     * @property {number} DEFAULT_DIG=1 dig walls, remove stairs and ramps, gather plants, fell trees
     * @property {number} UP_DOWN_STAIR_DIG=2 UP_DOWN_STAIR_DIG value
     * @property {number} CHANNEL_DIG=3 CHANNEL_DIG value
     * @property {number} RAMP_DIG=4 RAMP_DIG value
     * @property {number} DOWN_STAIR_DIG=5 DOWN_STAIR_DIG value
     * @property {number} UP_STAIR_DIG=6 UP_STAIR_DIG value
     */
    RemoteFortressReader.TileDigDesignation = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_DIG"] = 0;
        values[valuesById[1] = "DEFAULT_DIG"] = 1;
        values[valuesById[2] = "UP_DOWN_STAIR_DIG"] = 2;
        values[valuesById[3] = "CHANNEL_DIG"] = 3;
        values[valuesById[4] = "RAMP_DIG"] = 4;
        values[valuesById[5] = "DOWN_STAIR_DIG"] = 5;
        values[valuesById[6] = "UP_STAIR_DIG"] = 6;
        return values;
    })();

    /**
     * HairStyle enum.
     * @name RemoteFortressReader.HairStyle
     * @enum {string}
     * @property {number} UNKEMPT=-1 UNKEMPT value
     * @property {number} NEATLY_COMBED=0 NEATLY_COMBED value
     * @property {number} BRAIDED=1 BRAIDED value
     * @property {number} DOUBLE_BRAID=2 DOUBLE_BRAID value
     * @property {number} PONY_TAILS=3 PONY_TAILS value
     * @property {number} CLEAN_SHAVEN=4 CLEAN_SHAVEN value
     */
    RemoteFortressReader.HairStyle = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "UNKEMPT"] = -1;
        values[valuesById[0] = "NEATLY_COMBED"] = 0;
        values[valuesById[1] = "BRAIDED"] = 1;
        values[valuesById[2] = "DOUBLE_BRAID"] = 2;
        values[valuesById[3] = "PONY_TAILS"] = 3;
        values[valuesById[4] = "CLEAN_SHAVEN"] = 4;
        return values;
    })();

    /**
     * InventoryMode enum.
     * @name RemoteFortressReader.InventoryMode
     * @enum {string}
     * @property {number} Hauled=0 Hauled value
     * @property {number} Weapon=1 also shield, crutch
     * @property {number} Worn=2 quiver
     * @property {number} Piercing=3 Piercing value
     * @property {number} Flask=4 attached to clothing
     * @property {number} WrappedAround=5 e.g. bandage
     * @property {number} StuckIn=6 StuckIn value
     * @property {number} InMouth=7 string descr like Worn
     * @property {number} Pet=8 Left shoulder, right shoulder, or head, selected randomly using pet_seed
     * @property {number} SewnInto=9 SewnInto value
     * @property {number} Strapped=10 Strapped value
     */
    RemoteFortressReader.InventoryMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Hauled"] = 0;
        values[valuesById[1] = "Weapon"] = 1;
        values[valuesById[2] = "Worn"] = 2;
        values[valuesById[3] = "Piercing"] = 3;
        values[valuesById[4] = "Flask"] = 4;
        values[valuesById[5] = "WrappedAround"] = 5;
        values[valuesById[6] = "StuckIn"] = 6;
        values[valuesById[7] = "InMouth"] = 7;
        values[valuesById[8] = "Pet"] = 8;
        values[valuesById[9] = "SewnInto"] = 9;
        values[valuesById[10] = "Strapped"] = 10;
        return values;
    })();

    RemoteFortressReader.Coord = (function() {

        /**
         * Properties of a Coord.
         * @memberof RemoteFortressReader
         * @interface ICoord
         * @property {number|null} [x] Coord x
         * @property {number|null} [y] Coord y
         * @property {number|null} [z] Coord z
         */

        /**
         * Constructs a new Coord.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Coord.
         * @implements ICoord
         * @constructor
         * @param {RemoteFortressReader.ICoord=} [properties] Properties to set
         */
        function Coord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coord x.
         * @member {number} x
         * @memberof RemoteFortressReader.Coord
         * @instance
         */
        Coord.prototype.x = 0;

        /**
         * Coord y.
         * @member {number} y
         * @memberof RemoteFortressReader.Coord
         * @instance
         */
        Coord.prototype.y = 0;

        /**
         * Coord z.
         * @member {number} z
         * @memberof RemoteFortressReader.Coord
         * @instance
         */
        Coord.prototype.z = 0;

        /**
         * Creates a new Coord instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.ICoord=} [properties] Properties to set
         * @returns {RemoteFortressReader.Coord} Coord instance
         */
        Coord.create = function create(properties) {
            return new Coord(properties);
        };

        /**
         * Encodes the specified Coord message. Does not implicitly {@link RemoteFortressReader.Coord.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.ICoord} message Coord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.z);
            return writer;
        };

        /**
         * Encodes the specified Coord message, length delimited. Does not implicitly {@link RemoteFortressReader.Coord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.ICoord} message Coord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coord message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Coord} Coord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Coord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.z = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Coord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Coord} Coord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coord message.
         * @function verify
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            return null;
        };

        /**
         * Creates a Coord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Coord} Coord
         */
        Coord.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Coord)
                return object;
            var message = new $root.RemoteFortressReader.Coord();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.z != null)
                message.z = object.z | 0;
            return message;
        };

        /**
         * Creates a plain object from a Coord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Coord
         * @static
         * @param {RemoteFortressReader.Coord} message Coord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            return object;
        };

        /**
         * Converts this Coord to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Coord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coord;
    })();

    RemoteFortressReader.Tiletype = (function() {

        /**
         * Properties of a Tiletype.
         * @memberof RemoteFortressReader
         * @interface ITiletype
         * @property {number} id Tiletype id
         * @property {string|null} [name] Tiletype name
         * @property {string|null} [caption] Tiletype caption
         * @property {RemoteFortressReader.TiletypeShape|null} [shape] Tiletype shape
         * @property {RemoteFortressReader.TiletypeSpecial|null} [special] Tiletype special
         * @property {RemoteFortressReader.TiletypeMaterial|null} [material] Tiletype material
         * @property {RemoteFortressReader.TiletypeVariant|null} [variant] Tiletype variant
         * @property {string|null} [direction] Tiletype direction
         */

        /**
         * Constructs a new Tiletype.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Tiletype.
         * @implements ITiletype
         * @constructor
         * @param {RemoteFortressReader.ITiletype=} [properties] Properties to set
         */
        function Tiletype(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tiletype id.
         * @member {number} id
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.id = 0;

        /**
         * Tiletype name.
         * @member {string} name
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.name = "";

        /**
         * Tiletype caption.
         * @member {string} caption
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.caption = "";

        /**
         * Tiletype shape.
         * @member {RemoteFortressReader.TiletypeShape} shape
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.shape = -1;

        /**
         * Tiletype special.
         * @member {RemoteFortressReader.TiletypeSpecial} special
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.special = -1;

        /**
         * Tiletype material.
         * @member {RemoteFortressReader.TiletypeMaterial} material
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.material = -1;

        /**
         * Tiletype variant.
         * @member {RemoteFortressReader.TiletypeVariant} variant
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.variant = -1;

        /**
         * Tiletype direction.
         * @member {string} direction
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         */
        Tiletype.prototype.direction = "";

        /**
         * Creates a new Tiletype instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.ITiletype=} [properties] Properties to set
         * @returns {RemoteFortressReader.Tiletype} Tiletype instance
         */
        Tiletype.create = function create(properties) {
            return new Tiletype(properties);
        };

        /**
         * Encodes the specified Tiletype message. Does not implicitly {@link RemoteFortressReader.Tiletype.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.ITiletype} message Tiletype message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tiletype.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
            if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.shape);
            if (message.special != null && Object.hasOwnProperty.call(message, "special"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.special);
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.material);
            if (message.variant != null && Object.hasOwnProperty.call(message, "variant"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.variant);
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.direction);
            return writer;
        };

        /**
         * Encodes the specified Tiletype message, length delimited. Does not implicitly {@link RemoteFortressReader.Tiletype.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.ITiletype} message Tiletype message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tiletype.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tiletype message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Tiletype} Tiletype
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tiletype.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Tiletype();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.caption = reader.string();
                    break;
                case 4:
                    message.shape = reader.int32();
                    break;
                case 5:
                    message.special = reader.int32();
                    break;
                case 6:
                    message.material = reader.int32();
                    break;
                case 7:
                    message.variant = reader.int32();
                    break;
                case 8:
                    message.direction = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a Tiletype message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Tiletype} Tiletype
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tiletype.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tiletype message.
         * @function verify
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tiletype.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.shape != null && message.hasOwnProperty("shape"))
                switch (message.shape) {
                default:
                    return "shape: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                    break;
                }
            if (message.special != null && message.hasOwnProperty("special"))
                switch (message.special) {
                default:
                    return "special: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.material != null && message.hasOwnProperty("material"))
                switch (message.material) {
                default:
                    return "material: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                    break;
                }
            if (message.variant != null && message.hasOwnProperty("variant"))
                switch (message.variant) {
                default:
                    return "variant: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.direction != null && message.hasOwnProperty("direction"))
                if (!$util.isString(message.direction))
                    return "direction: string expected";
            return null;
        };

        /**
         * Creates a Tiletype message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Tiletype} Tiletype
         */
        Tiletype.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Tiletype)
                return object;
            var message = new $root.RemoteFortressReader.Tiletype();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.caption != null)
                message.caption = String(object.caption);
            switch (object.shape) {
            case "NO_SHAPE":
            case -1:
                message.shape = -1;
                break;
            case "EMPTY":
            case 0:
                message.shape = 0;
                break;
            case "FLOOR":
            case 1:
                message.shape = 1;
                break;
            case "BOULDER":
            case 2:
                message.shape = 2;
                break;
            case "PEBBLES":
            case 3:
                message.shape = 3;
                break;
            case "WALL":
            case 4:
                message.shape = 4;
                break;
            case "FORTIFICATION":
            case 5:
                message.shape = 5;
                break;
            case "STAIR_UP":
            case 6:
                message.shape = 6;
                break;
            case "STAIR_DOWN":
            case 7:
                message.shape = 7;
                break;
            case "STAIR_UPDOWN":
            case 8:
                message.shape = 8;
                break;
            case "RAMP":
            case 9:
                message.shape = 9;
                break;
            case "RAMP_TOP":
            case 10:
                message.shape = 10;
                break;
            case "BROOK_BED":
            case 11:
                message.shape = 11;
                break;
            case "BROOK_TOP":
            case 12:
                message.shape = 12;
                break;
            case "TREE_SHAPE":
            case 13:
                message.shape = 13;
                break;
            case "SAPLING":
            case 14:
                message.shape = 14;
                break;
            case "SHRUB":
            case 15:
                message.shape = 15;
                break;
            case "ENDLESS_PIT":
            case 16:
                message.shape = 16;
                break;
            case "BRANCH":
            case 17:
                message.shape = 17;
                break;
            case "TRUNK_BRANCH":
            case 18:
                message.shape = 18;
                break;
            case "TWIG":
            case 19:
                message.shape = 19;
                break;
            }
            switch (object.special) {
            case "NO_SPECIAL":
            case -1:
                message.special = -1;
                break;
            case "NORMAL":
            case 0:
                message.special = 0;
                break;
            case "RIVER_SOURCE":
            case 1:
                message.special = 1;
                break;
            case "WATERFALL":
            case 2:
                message.special = 2;
                break;
            case "SMOOTH":
            case 3:
                message.special = 3;
                break;
            case "FURROWED":
            case 4:
                message.special = 4;
                break;
            case "WET":
            case 5:
                message.special = 5;
                break;
            case "DEAD":
            case 6:
                message.special = 6;
                break;
            case "WORN_1":
            case 7:
                message.special = 7;
                break;
            case "WORN_2":
            case 8:
                message.special = 8;
                break;
            case "WORN_3":
            case 9:
                message.special = 9;
                break;
            case "TRACK":
            case 10:
                message.special = 10;
                break;
            case "SMOOTH_DEAD":
            case 11:
                message.special = 11;
                break;
            }
            switch (object.material) {
            case "NO_MATERIAL":
            case -1:
                message.material = -1;
                break;
            case "AIR":
            case 0:
                message.material = 0;
                break;
            case "SOIL":
            case 1:
                message.material = 1;
                break;
            case "STONE":
            case 2:
                message.material = 2;
                break;
            case "FEATURE":
            case 3:
                message.material = 3;
                break;
            case "LAVA_STONE":
            case 4:
                message.material = 4;
                break;
            case "MINERAL":
            case 5:
                message.material = 5;
                break;
            case "FROZEN_LIQUID":
            case 6:
                message.material = 6;
                break;
            case "CONSTRUCTION":
            case 7:
                message.material = 7;
                break;
            case "GRASS_LIGHT":
            case 8:
                message.material = 8;
                break;
            case "GRASS_DARK":
            case 9:
                message.material = 9;
                break;
            case "GRASS_DRY":
            case 10:
                message.material = 10;
                break;
            case "GRASS_DEAD":
            case 11:
                message.material = 11;
                break;
            case "PLANT":
            case 12:
                message.material = 12;
                break;
            case "HFS":
            case 13:
                message.material = 13;
                break;
            case "CAMPFIRE":
            case 14:
                message.material = 14;
                break;
            case "FIRE":
            case 15:
                message.material = 15;
                break;
            case "ASHES":
            case 16:
                message.material = 16;
                break;
            case "MAGMA":
            case 17:
                message.material = 17;
                break;
            case "DRIFTWOOD":
            case 18:
                message.material = 18;
                break;
            case "POOL":
            case 19:
                message.material = 19;
                break;
            case "BROOK":
            case 20:
                message.material = 20;
                break;
            case "RIVER":
            case 21:
                message.material = 21;
                break;
            case "ROOT":
            case 22:
                message.material = 22;
                break;
            case "TREE_MATERIAL":
            case 23:
                message.material = 23;
                break;
            case "MUSHROOM":
            case 24:
                message.material = 24;
                break;
            case "UNDERWORLD_GATE":
            case 25:
                message.material = 25;
                break;
            }
            switch (object.variant) {
            case "NO_VARIANT":
            case -1:
                message.variant = -1;
                break;
            case "VAR_1":
            case 0:
                message.variant = 0;
                break;
            case "VAR_2":
            case 1:
                message.variant = 1;
                break;
            case "VAR_3":
            case 2:
                message.variant = 2;
                break;
            case "VAR_4":
            case 3:
                message.variant = 3;
                break;
            }
            if (object.direction != null)
                message.direction = String(object.direction);
            return message;
        };

        /**
         * Creates a plain object from a Tiletype message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Tiletype
         * @static
         * @param {RemoteFortressReader.Tiletype} message Tiletype
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tiletype.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.name = "";
                object.caption = "";
                object.shape = options.enums === String ? "NO_SHAPE" : -1;
                object.special = options.enums === String ? "NO_SPECIAL" : -1;
                object.material = options.enums === String ? "NO_MATERIAL" : -1;
                object.variant = options.enums === String ? "NO_VARIANT" : -1;
                object.direction = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = options.enums === String ? $root.RemoteFortressReader.TiletypeShape[message.shape] : message.shape;
            if (message.special != null && message.hasOwnProperty("special"))
                object.special = options.enums === String ? $root.RemoteFortressReader.TiletypeSpecial[message.special] : message.special;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = options.enums === String ? $root.RemoteFortressReader.TiletypeMaterial[message.material] : message.material;
            if (message.variant != null && message.hasOwnProperty("variant"))
                object.variant = options.enums === String ? $root.RemoteFortressReader.TiletypeVariant[message.variant] : message.variant;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = message.direction;
            return object;
        };

        /**
         * Converts this Tiletype to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Tiletype
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tiletype.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tiletype;
    })();

    RemoteFortressReader.TiletypeList = (function() {

        /**
         * Properties of a TiletypeList.
         * @memberof RemoteFortressReader
         * @interface ITiletypeList
         * @property {Array.<RemoteFortressReader.ITiletype>|null} [tiletypeList] TiletypeList tiletypeList
         */

        /**
         * Constructs a new TiletypeList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TiletypeList.
         * @implements ITiletypeList
         * @constructor
         * @param {RemoteFortressReader.ITiletypeList=} [properties] Properties to set
         */
        function TiletypeList(properties) {
            this.tiletypeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TiletypeList tiletypeList.
         * @member {Array.<RemoteFortressReader.ITiletype>} tiletypeList
         * @memberof RemoteFortressReader.TiletypeList
         * @instance
         */
        TiletypeList.prototype.tiletypeList = $util.emptyArray;

        /**
         * Creates a new TiletypeList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.ITiletypeList=} [properties] Properties to set
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList instance
         */
        TiletypeList.create = function create(properties) {
            return new TiletypeList(properties);
        };

        /**
         * Encodes the specified TiletypeList message. Does not implicitly {@link RemoteFortressReader.TiletypeList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.ITiletypeList} message TiletypeList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiletypeList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tiletypeList != null && message.tiletypeList.length)
                for (var i = 0; i < message.tiletypeList.length; ++i)
                    $root.RemoteFortressReader.Tiletype.encode(message.tiletypeList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TiletypeList message, length delimited. Does not implicitly {@link RemoteFortressReader.TiletypeList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.ITiletypeList} message TiletypeList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiletypeList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TiletypeList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiletypeList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TiletypeList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tiletypeList && message.tiletypeList.length))
                        message.tiletypeList = [];
                    message.tiletypeList.push($root.RemoteFortressReader.Tiletype.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TiletypeList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiletypeList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TiletypeList message.
         * @function verify
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TiletypeList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tiletypeList != null && message.hasOwnProperty("tiletypeList")) {
                if (!Array.isArray(message.tiletypeList))
                    return "tiletypeList: array expected";
                for (var i = 0; i < message.tiletypeList.length; ++i) {
                    var error = $root.RemoteFortressReader.Tiletype.verify(message.tiletypeList[i]);
                    if (error)
                        return "tiletypeList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TiletypeList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TiletypeList} TiletypeList
         */
        TiletypeList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TiletypeList)
                return object;
            var message = new $root.RemoteFortressReader.TiletypeList();
            if (object.tiletypeList) {
                if (!Array.isArray(object.tiletypeList))
                    throw TypeError(".RemoteFortressReader.TiletypeList.tiletypeList: array expected");
                message.tiletypeList = [];
                for (var i = 0; i < object.tiletypeList.length; ++i) {
                    if (typeof object.tiletypeList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.TiletypeList.tiletypeList: object expected");
                    message.tiletypeList[i] = $root.RemoteFortressReader.Tiletype.fromObject(object.tiletypeList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TiletypeList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TiletypeList
         * @static
         * @param {RemoteFortressReader.TiletypeList} message TiletypeList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TiletypeList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tiletypeList = [];
            if (message.tiletypeList && message.tiletypeList.length) {
                object.tiletypeList = [];
                for (var j = 0; j < message.tiletypeList.length; ++j)
                    object.tiletypeList[j] = $root.RemoteFortressReader.Tiletype.toObject(message.tiletypeList[j], options);
            }
            return object;
        };

        /**
         * Converts this TiletypeList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TiletypeList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TiletypeList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TiletypeList;
    })();

    RemoteFortressReader.BuildingExtents = (function() {

        /**
         * Properties of a BuildingExtents.
         * @memberof RemoteFortressReader
         * @interface IBuildingExtents
         * @property {number} posX BuildingExtents posX
         * @property {number} posY BuildingExtents posY
         * @property {number} width BuildingExtents width
         * @property {number} height BuildingExtents height
         * @property {Array.<number>|null} [extents] BuildingExtents extents
         */

        /**
         * Constructs a new BuildingExtents.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingExtents.
         * @implements IBuildingExtents
         * @constructor
         * @param {RemoteFortressReader.IBuildingExtents=} [properties] Properties to set
         */
        function BuildingExtents(properties) {
            this.extents = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingExtents posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.posX = 0;

        /**
         * BuildingExtents posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.posY = 0;

        /**
         * BuildingExtents width.
         * @member {number} width
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.width = 0;

        /**
         * BuildingExtents height.
         * @member {number} height
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.height = 0;

        /**
         * BuildingExtents extents.
         * @member {Array.<number>} extents
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         */
        BuildingExtents.prototype.extents = $util.emptyArray;

        /**
         * Creates a new BuildingExtents instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.IBuildingExtents=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents instance
         */
        BuildingExtents.create = function create(properties) {
            return new BuildingExtents(properties);
        };

        /**
         * Encodes the specified BuildingExtents message. Does not implicitly {@link RemoteFortressReader.BuildingExtents.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.IBuildingExtents} message BuildingExtents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingExtents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.height);
            if (message.extents != null && message.extents.length)
                for (var i = 0; i < message.extents.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.extents[i]);
            return writer;
        };

        /**
         * Encodes the specified BuildingExtents message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingExtents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.IBuildingExtents} message BuildingExtents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingExtents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingExtents message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingExtents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingExtents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.posX = reader.int32();
                    break;
                case 2:
                    message.posY = reader.int32();
                    break;
                case 3:
                    message.width = reader.int32();
                    break;
                case 4:
                    message.height = reader.int32();
                    break;
                case 5:
                    if (!(message.extents && message.extents.length))
                        message.extents = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.extents.push(reader.int32());
                    } else
                        message.extents.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("posX"))
                throw $util.ProtocolError("missing required 'posX'", { instance: message });
            if (!message.hasOwnProperty("posY"))
                throw $util.ProtocolError("missing required 'posY'", { instance: message });
            if (!message.hasOwnProperty("width"))
                throw $util.ProtocolError("missing required 'width'", { instance: message });
            if (!message.hasOwnProperty("height"))
                throw $util.ProtocolError("missing required 'height'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingExtents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingExtents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingExtents message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingExtents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
            if (!$util.isInteger(message.width))
                return "width: integer expected";
            if (!$util.isInteger(message.height))
                return "height: integer expected";
            if (message.extents != null && message.hasOwnProperty("extents")) {
                if (!Array.isArray(message.extents))
                    return "extents: array expected";
                for (var i = 0; i < message.extents.length; ++i)
                    if (!$util.isInteger(message.extents[i]))
                        return "extents: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BuildingExtents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingExtents} BuildingExtents
         */
        BuildingExtents.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingExtents)
                return object;
            var message = new $root.RemoteFortressReader.BuildingExtents();
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.width != null)
                message.width = object.width | 0;
            if (object.height != null)
                message.height = object.height | 0;
            if (object.extents) {
                if (!Array.isArray(object.extents))
                    throw TypeError(".RemoteFortressReader.BuildingExtents.extents: array expected");
                message.extents = [];
                for (var i = 0; i < object.extents.length; ++i)
                    message.extents[i] = object.extents[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BuildingExtents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingExtents
         * @static
         * @param {RemoteFortressReader.BuildingExtents} message BuildingExtents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingExtents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.extents = [];
            if (options.defaults) {
                object.posX = 0;
                object.posY = 0;
                object.width = 0;
                object.height = 0;
            }
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.extents && message.extents.length) {
                object.extents = [];
                for (var j = 0; j < message.extents.length; ++j)
                    object.extents[j] = message.extents[j];
            }
            return object;
        };

        /**
         * Converts this BuildingExtents to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingExtents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingExtents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingExtents;
    })();

    RemoteFortressReader.BuildingItem = (function() {

        /**
         * Properties of a BuildingItem.
         * @memberof RemoteFortressReader
         * @interface IBuildingItem
         * @property {RemoteFortressReader.IItem|null} [item] BuildingItem item
         * @property {number|null} [mode] BuildingItem mode
         */

        /**
         * Constructs a new BuildingItem.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingItem.
         * @implements IBuildingItem
         * @constructor
         * @param {RemoteFortressReader.IBuildingItem=} [properties] Properties to set
         */
        function BuildingItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingItem item.
         * @member {RemoteFortressReader.IItem|null|undefined} item
         * @memberof RemoteFortressReader.BuildingItem
         * @instance
         */
        BuildingItem.prototype.item = null;

        /**
         * BuildingItem mode.
         * @member {number} mode
         * @memberof RemoteFortressReader.BuildingItem
         * @instance
         */
        BuildingItem.prototype.mode = 0;

        /**
         * Creates a new BuildingItem instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.IBuildingItem=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem instance
         */
        BuildingItem.create = function create(properties) {
            return new BuildingItem(properties);
        };

        /**
         * Encodes the specified BuildingItem message. Does not implicitly {@link RemoteFortressReader.BuildingItem.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.IBuildingItem} message BuildingItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.RemoteFortressReader.Item.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
            return writer;
        };

        /**
         * Encodes the specified BuildingItem message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.IBuildingItem} message BuildingItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingItem message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.RemoteFortressReader.Item.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuildingItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingItem message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.Item.verify(message.item);
                if (error)
                    return "item." + error;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                if (!$util.isInteger(message.mode))
                    return "mode: integer expected";
            return null;
        };

        /**
         * Creates a BuildingItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingItem} BuildingItem
         */
        BuildingItem.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingItem)
                return object;
            var message = new $root.RemoteFortressReader.BuildingItem();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingItem.item: object expected");
                message.item = $root.RemoteFortressReader.Item.fromObject(object.item);
            }
            if (object.mode != null)
                message.mode = object.mode | 0;
            return message;
        };

        /**
         * Creates a plain object from a BuildingItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingItem
         * @static
         * @param {RemoteFortressReader.BuildingItem} message BuildingItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item = null;
                object.mode = 0;
            }
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.Item.toObject(message.item, options);
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = message.mode;
            return object;
        };

        /**
         * Converts this BuildingItem to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingItem;
    })();

    RemoteFortressReader.BuildingInstance = (function() {

        /**
         * Properties of a BuildingInstance.
         * @memberof RemoteFortressReader
         * @interface IBuildingInstance
         * @property {number} index BuildingInstance index
         * @property {number|null} [posXMin] BuildingInstance posXMin
         * @property {number|null} [posYMin] BuildingInstance posYMin
         * @property {number|null} [posZMin] BuildingInstance posZMin
         * @property {number|null} [posXMax] BuildingInstance posXMax
         * @property {number|null} [posYMax] BuildingInstance posYMax
         * @property {number|null} [posZMax] BuildingInstance posZMax
         * @property {RemoteFortressReader.IBuildingType|null} [buildingType] BuildingInstance buildingType
         * @property {RemoteFortressReader.IMatPair|null} [material] BuildingInstance material
         * @property {number|null} [buildingFlags] BuildingInstance buildingFlags
         * @property {boolean|null} [isRoom] BuildingInstance isRoom
         * @property {RemoteFortressReader.IBuildingExtents|null} [room] BuildingInstance room
         * @property {RemoteFortressReader.BuildingDirection|null} [direction] BuildingInstance direction
         * @property {Array.<RemoteFortressReader.IBuildingItem>|null} [items] BuildingInstance items
         * @property {number|null} [active] BuildingInstance active
         */

        /**
         * Constructs a new BuildingInstance.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingInstance.
         * @implements IBuildingInstance
         * @constructor
         * @param {RemoteFortressReader.IBuildingInstance=} [properties] Properties to set
         */
        function BuildingInstance(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingInstance index.
         * @member {number} index
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.index = 0;

        /**
         * BuildingInstance posXMin.
         * @member {number} posXMin
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posXMin = 0;

        /**
         * BuildingInstance posYMin.
         * @member {number} posYMin
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posYMin = 0;

        /**
         * BuildingInstance posZMin.
         * @member {number} posZMin
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posZMin = 0;

        /**
         * BuildingInstance posXMax.
         * @member {number} posXMax
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posXMax = 0;

        /**
         * BuildingInstance posYMax.
         * @member {number} posYMax
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posYMax = 0;

        /**
         * BuildingInstance posZMax.
         * @member {number} posZMax
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.posZMax = 0;

        /**
         * BuildingInstance buildingType.
         * @member {RemoteFortressReader.IBuildingType|null|undefined} buildingType
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.buildingType = null;

        /**
         * BuildingInstance material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.material = null;

        /**
         * BuildingInstance buildingFlags.
         * @member {number} buildingFlags
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.buildingFlags = 0;

        /**
         * BuildingInstance isRoom.
         * @member {boolean} isRoom
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.isRoom = false;

        /**
         * BuildingInstance room.
         * @member {RemoteFortressReader.IBuildingExtents|null|undefined} room
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.room = null;

        /**
         * BuildingInstance direction.
         * @member {RemoteFortressReader.BuildingDirection} direction
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.direction = 0;

        /**
         * BuildingInstance items.
         * @member {Array.<RemoteFortressReader.IBuildingItem>} items
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.items = $util.emptyArray;

        /**
         * BuildingInstance active.
         * @member {number} active
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         */
        BuildingInstance.prototype.active = 0;

        /**
         * Creates a new BuildingInstance instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.IBuildingInstance=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance instance
         */
        BuildingInstance.create = function create(properties) {
            return new BuildingInstance(properties);
        };

        /**
         * Encodes the specified BuildingInstance message. Does not implicitly {@link RemoteFortressReader.BuildingInstance.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.IBuildingInstance} message BuildingInstance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingInstance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.posXMin != null && Object.hasOwnProperty.call(message, "posXMin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posXMin);
            if (message.posYMin != null && Object.hasOwnProperty.call(message, "posYMin"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posYMin);
            if (message.posZMin != null && Object.hasOwnProperty.call(message, "posZMin"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.posZMin);
            if (message.posXMax != null && Object.hasOwnProperty.call(message, "posXMax"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.posXMax);
            if (message.posYMax != null && Object.hasOwnProperty.call(message, "posYMax"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.posYMax);
            if (message.posZMax != null && Object.hasOwnProperty.call(message, "posZMax"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.posZMax);
            if (message.buildingType != null && Object.hasOwnProperty.call(message, "buildingType"))
                $root.RemoteFortressReader.BuildingType.encode(message.buildingType, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.buildingFlags != null && Object.hasOwnProperty.call(message, "buildingFlags"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.buildingFlags);
            if (message.isRoom != null && Object.hasOwnProperty.call(message, "isRoom"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isRoom);
            if (message.room != null && Object.hasOwnProperty.call(message, "room"))
                $root.RemoteFortressReader.BuildingExtents.encode(message.room, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.direction);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.RemoteFortressReader.BuildingItem.encode(message.items[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.active);
            return writer;
        };

        /**
         * Encodes the specified BuildingInstance message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingInstance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.IBuildingInstance} message BuildingInstance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingInstance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingInstance message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingInstance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingInstance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.posXMin = reader.int32();
                    break;
                case 3:
                    message.posYMin = reader.int32();
                    break;
                case 4:
                    message.posZMin = reader.int32();
                    break;
                case 5:
                    message.posXMax = reader.int32();
                    break;
                case 6:
                    message.posYMax = reader.int32();
                    break;
                case 7:
                    message.posZMax = reader.int32();
                    break;
                case 8:
                    message.buildingType = $root.RemoteFortressReader.BuildingType.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.buildingFlags = reader.uint32();
                    break;
                case 11:
                    message.isRoom = reader.bool();
                    break;
                case 12:
                    message.room = $root.RemoteFortressReader.BuildingExtents.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.direction = reader.int32();
                    break;
                case 14:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.RemoteFortressReader.BuildingItem.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.active = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingInstance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingInstance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingInstance message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingInstance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            if (message.posXMin != null && message.hasOwnProperty("posXMin"))
                if (!$util.isInteger(message.posXMin))
                    return "posXMin: integer expected";
            if (message.posYMin != null && message.hasOwnProperty("posYMin"))
                if (!$util.isInteger(message.posYMin))
                    return "posYMin: integer expected";
            if (message.posZMin != null && message.hasOwnProperty("posZMin"))
                if (!$util.isInteger(message.posZMin))
                    return "posZMin: integer expected";
            if (message.posXMax != null && message.hasOwnProperty("posXMax"))
                if (!$util.isInteger(message.posXMax))
                    return "posXMax: integer expected";
            if (message.posYMax != null && message.hasOwnProperty("posYMax"))
                if (!$util.isInteger(message.posYMax))
                    return "posYMax: integer expected";
            if (message.posZMax != null && message.hasOwnProperty("posZMax"))
                if (!$util.isInteger(message.posZMax))
                    return "posZMax: integer expected";
            if (message.buildingType != null && message.hasOwnProperty("buildingType")) {
                var error = $root.RemoteFortressReader.BuildingType.verify(message.buildingType);
                if (error)
                    return "buildingType." + error;
            }
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.buildingFlags != null && message.hasOwnProperty("buildingFlags"))
                if (!$util.isInteger(message.buildingFlags))
                    return "buildingFlags: integer expected";
            if (message.isRoom != null && message.hasOwnProperty("isRoom"))
                if (typeof message.isRoom !== "boolean")
                    return "isRoom: boolean expected";
            if (message.room != null && message.hasOwnProperty("room")) {
                var error = $root.RemoteFortressReader.BuildingExtents.verify(message.room);
                if (error)
                    return "room." + error;
            }
            if (message.direction != null && message.hasOwnProperty("direction"))
                switch (message.direction) {
                default:
                    return "direction: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.RemoteFortressReader.BuildingItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.active != null && message.hasOwnProperty("active"))
                if (!$util.isInteger(message.active))
                    return "active: integer expected";
            return null;
        };

        /**
         * Creates a BuildingInstance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingInstance} BuildingInstance
         */
        BuildingInstance.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingInstance)
                return object;
            var message = new $root.RemoteFortressReader.BuildingInstance();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.posXMin != null)
                message.posXMin = object.posXMin | 0;
            if (object.posYMin != null)
                message.posYMin = object.posYMin | 0;
            if (object.posZMin != null)
                message.posZMin = object.posZMin | 0;
            if (object.posXMax != null)
                message.posXMax = object.posXMax | 0;
            if (object.posYMax != null)
                message.posYMax = object.posYMax | 0;
            if (object.posZMax != null)
                message.posZMax = object.posZMax | 0;
            if (object.buildingType != null) {
                if (typeof object.buildingType !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingInstance.buildingType: object expected");
                message.buildingType = $root.RemoteFortressReader.BuildingType.fromObject(object.buildingType);
            }
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingInstance.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.buildingFlags != null)
                message.buildingFlags = object.buildingFlags >>> 0;
            if (object.isRoom != null)
                message.isRoom = Boolean(object.isRoom);
            if (object.room != null) {
                if (typeof object.room !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingInstance.room: object expected");
                message.room = $root.RemoteFortressReader.BuildingExtents.fromObject(object.room);
            }
            switch (object.direction) {
            case "NORTH":
            case 0:
                message.direction = 0;
                break;
            case "EAST":
            case 1:
                message.direction = 1;
                break;
            case "SOUTH":
            case 2:
                message.direction = 2;
                break;
            case "WEST":
            case 3:
                message.direction = 3;
                break;
            case "NONE":
            case 4:
                message.direction = 4;
                break;
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".RemoteFortressReader.BuildingInstance.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BuildingInstance.items: object expected");
                    message.items[i] = $root.RemoteFortressReader.BuildingItem.fromObject(object.items[i]);
                }
            }
            if (object.active != null)
                message.active = object.active | 0;
            return message;
        };

        /**
         * Creates a plain object from a BuildingInstance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingInstance
         * @static
         * @param {RemoteFortressReader.BuildingInstance} message BuildingInstance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingInstance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.index = 0;
                object.posXMin = 0;
                object.posYMin = 0;
                object.posZMin = 0;
                object.posXMax = 0;
                object.posYMax = 0;
                object.posZMax = 0;
                object.buildingType = null;
                object.material = null;
                object.buildingFlags = 0;
                object.isRoom = false;
                object.room = null;
                object.direction = options.enums === String ? "NORTH" : 0;
                object.active = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.posXMin != null && message.hasOwnProperty("posXMin"))
                object.posXMin = message.posXMin;
            if (message.posYMin != null && message.hasOwnProperty("posYMin"))
                object.posYMin = message.posYMin;
            if (message.posZMin != null && message.hasOwnProperty("posZMin"))
                object.posZMin = message.posZMin;
            if (message.posXMax != null && message.hasOwnProperty("posXMax"))
                object.posXMax = message.posXMax;
            if (message.posYMax != null && message.hasOwnProperty("posYMax"))
                object.posYMax = message.posYMax;
            if (message.posZMax != null && message.hasOwnProperty("posZMax"))
                object.posZMax = message.posZMax;
            if (message.buildingType != null && message.hasOwnProperty("buildingType"))
                object.buildingType = $root.RemoteFortressReader.BuildingType.toObject(message.buildingType, options);
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.buildingFlags != null && message.hasOwnProperty("buildingFlags"))
                object.buildingFlags = message.buildingFlags;
            if (message.isRoom != null && message.hasOwnProperty("isRoom"))
                object.isRoom = message.isRoom;
            if (message.room != null && message.hasOwnProperty("room"))
                object.room = $root.RemoteFortressReader.BuildingExtents.toObject(message.room, options);
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = options.enums === String ? $root.RemoteFortressReader.BuildingDirection[message.direction] : message.direction;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.RemoteFortressReader.BuildingItem.toObject(message.items[j], options);
            }
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            return object;
        };

        /**
         * Converts this BuildingInstance to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingInstance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingInstance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingInstance;
    })();

    RemoteFortressReader.RiverEdge = (function() {

        /**
         * Properties of a RiverEdge.
         * @memberof RemoteFortressReader
         * @interface IRiverEdge
         * @property {number|null} [minPos] RiverEdge minPos
         * @property {number|null} [maxPos] RiverEdge maxPos
         * @property {number|null} [active] RiverEdge active
         * @property {number|null} [elevation] RiverEdge elevation
         */

        /**
         * Constructs a new RiverEdge.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RiverEdge.
         * @implements IRiverEdge
         * @constructor
         * @param {RemoteFortressReader.IRiverEdge=} [properties] Properties to set
         */
        function RiverEdge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RiverEdge minPos.
         * @member {number} minPos
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.minPos = 0;

        /**
         * RiverEdge maxPos.
         * @member {number} maxPos
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.maxPos = 0;

        /**
         * RiverEdge active.
         * @member {number} active
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.active = 0;

        /**
         * RiverEdge elevation.
         * @member {number} elevation
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         */
        RiverEdge.prototype.elevation = 0;

        /**
         * Creates a new RiverEdge instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.IRiverEdge=} [properties] Properties to set
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge instance
         */
        RiverEdge.create = function create(properties) {
            return new RiverEdge(properties);
        };

        /**
         * Encodes the specified RiverEdge message. Does not implicitly {@link RemoteFortressReader.RiverEdge.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.IRiverEdge} message RiverEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverEdge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minPos != null && Object.hasOwnProperty.call(message, "minPos"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minPos);
            if (message.maxPos != null && Object.hasOwnProperty.call(message, "maxPos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxPos);
            if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.active);
            if (message.elevation != null && Object.hasOwnProperty.call(message, "elevation"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.elevation);
            return writer;
        };

        /**
         * Encodes the specified RiverEdge message, length delimited. Does not implicitly {@link RemoteFortressReader.RiverEdge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.IRiverEdge} message RiverEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverEdge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RiverEdge message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverEdge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RiverEdge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.minPos = reader.int32();
                    break;
                case 2:
                    message.maxPos = reader.int32();
                    break;
                case 3:
                    message.active = reader.int32();
                    break;
                case 4:
                    message.elevation = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RiverEdge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverEdge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RiverEdge message.
         * @function verify
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RiverEdge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minPos != null && message.hasOwnProperty("minPos"))
                if (!$util.isInteger(message.minPos))
                    return "minPos: integer expected";
            if (message.maxPos != null && message.hasOwnProperty("maxPos"))
                if (!$util.isInteger(message.maxPos))
                    return "maxPos: integer expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (!$util.isInteger(message.active))
                    return "active: integer expected";
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                if (!$util.isInteger(message.elevation))
                    return "elevation: integer expected";
            return null;
        };

        /**
         * Creates a RiverEdge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RiverEdge} RiverEdge
         */
        RiverEdge.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RiverEdge)
                return object;
            var message = new $root.RemoteFortressReader.RiverEdge();
            if (object.minPos != null)
                message.minPos = object.minPos | 0;
            if (object.maxPos != null)
                message.maxPos = object.maxPos | 0;
            if (object.active != null)
                message.active = object.active | 0;
            if (object.elevation != null)
                message.elevation = object.elevation | 0;
            return message;
        };

        /**
         * Creates a plain object from a RiverEdge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RiverEdge
         * @static
         * @param {RemoteFortressReader.RiverEdge} message RiverEdge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RiverEdge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.minPos = 0;
                object.maxPos = 0;
                object.active = 0;
                object.elevation = 0;
            }
            if (message.minPos != null && message.hasOwnProperty("minPos"))
                object.minPos = message.minPos;
            if (message.maxPos != null && message.hasOwnProperty("maxPos"))
                object.maxPos = message.maxPos;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                object.elevation = message.elevation;
            return object;
        };

        /**
         * Converts this RiverEdge to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RiverEdge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RiverEdge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RiverEdge;
    })();

    RemoteFortressReader.RiverTile = (function() {

        /**
         * Properties of a RiverTile.
         * @memberof RemoteFortressReader
         * @interface IRiverTile
         * @property {RemoteFortressReader.IRiverEdge|null} [north] RiverTile north
         * @property {RemoteFortressReader.IRiverEdge|null} [south] RiverTile south
         * @property {RemoteFortressReader.IRiverEdge|null} [east] RiverTile east
         * @property {RemoteFortressReader.IRiverEdge|null} [west] RiverTile west
         */

        /**
         * Constructs a new RiverTile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RiverTile.
         * @implements IRiverTile
         * @constructor
         * @param {RemoteFortressReader.IRiverTile=} [properties] Properties to set
         */
        function RiverTile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RiverTile north.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} north
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.north = null;

        /**
         * RiverTile south.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} south
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.south = null;

        /**
         * RiverTile east.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} east
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.east = null;

        /**
         * RiverTile west.
         * @member {RemoteFortressReader.IRiverEdge|null|undefined} west
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         */
        RiverTile.prototype.west = null;

        /**
         * Creates a new RiverTile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.IRiverTile=} [properties] Properties to set
         * @returns {RemoteFortressReader.RiverTile} RiverTile instance
         */
        RiverTile.create = function create(properties) {
            return new RiverTile(properties);
        };

        /**
         * Encodes the specified RiverTile message. Does not implicitly {@link RemoteFortressReader.RiverTile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.IRiverTile} message RiverTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.north != null && Object.hasOwnProperty.call(message, "north"))
                $root.RemoteFortressReader.RiverEdge.encode(message.north, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.south != null && Object.hasOwnProperty.call(message, "south"))
                $root.RemoteFortressReader.RiverEdge.encode(message.south, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.east != null && Object.hasOwnProperty.call(message, "east"))
                $root.RemoteFortressReader.RiverEdge.encode(message.east, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.west != null && Object.hasOwnProperty.call(message, "west"))
                $root.RemoteFortressReader.RiverEdge.encode(message.west, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RiverTile message, length delimited. Does not implicitly {@link RemoteFortressReader.RiverTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.IRiverTile} message RiverTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RiverTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RiverTile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RiverTile} RiverTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RiverTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.north = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.south = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.east = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.west = $root.RemoteFortressReader.RiverEdge.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RiverTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RiverTile} RiverTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RiverTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RiverTile message.
         * @function verify
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RiverTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.north != null && message.hasOwnProperty("north")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.north);
                if (error)
                    return "north." + error;
            }
            if (message.south != null && message.hasOwnProperty("south")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.south);
                if (error)
                    return "south." + error;
            }
            if (message.east != null && message.hasOwnProperty("east")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.east);
                if (error)
                    return "east." + error;
            }
            if (message.west != null && message.hasOwnProperty("west")) {
                var error = $root.RemoteFortressReader.RiverEdge.verify(message.west);
                if (error)
                    return "west." + error;
            }
            return null;
        };

        /**
         * Creates a RiverTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RiverTile} RiverTile
         */
        RiverTile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RiverTile)
                return object;
            var message = new $root.RemoteFortressReader.RiverTile();
            if (object.north != null) {
                if (typeof object.north !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.north: object expected");
                message.north = $root.RemoteFortressReader.RiverEdge.fromObject(object.north);
            }
            if (object.south != null) {
                if (typeof object.south !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.south: object expected");
                message.south = $root.RemoteFortressReader.RiverEdge.fromObject(object.south);
            }
            if (object.east != null) {
                if (typeof object.east !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.east: object expected");
                message.east = $root.RemoteFortressReader.RiverEdge.fromObject(object.east);
            }
            if (object.west != null) {
                if (typeof object.west !== "object")
                    throw TypeError(".RemoteFortressReader.RiverTile.west: object expected");
                message.west = $root.RemoteFortressReader.RiverEdge.fromObject(object.west);
            }
            return message;
        };

        /**
         * Creates a plain object from a RiverTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RiverTile
         * @static
         * @param {RemoteFortressReader.RiverTile} message RiverTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RiverTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.north = null;
                object.south = null;
                object.east = null;
                object.west = null;
            }
            if (message.north != null && message.hasOwnProperty("north"))
                object.north = $root.RemoteFortressReader.RiverEdge.toObject(message.north, options);
            if (message.south != null && message.hasOwnProperty("south"))
                object.south = $root.RemoteFortressReader.RiverEdge.toObject(message.south, options);
            if (message.east != null && message.hasOwnProperty("east"))
                object.east = $root.RemoteFortressReader.RiverEdge.toObject(message.east, options);
            if (message.west != null && message.hasOwnProperty("west"))
                object.west = $root.RemoteFortressReader.RiverEdge.toObject(message.west, options);
            return object;
        };

        /**
         * Converts this RiverTile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RiverTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RiverTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RiverTile;
    })();

    /**
     * MatterState enum.
     * @name RemoteFortressReader.MatterState
     * @enum {string}
     * @property {number} Solid=0 Solid value
     * @property {number} Liquid=1 Liquid value
     * @property {number} Gas=2 Gas value
     * @property {number} Powder=3 Powder value
     * @property {number} Paste=4 Paste value
     * @property {number} Pressed=5 Pressed value
     */
    RemoteFortressReader.MatterState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Solid"] = 0;
        values[valuesById[1] = "Liquid"] = 1;
        values[valuesById[2] = "Gas"] = 2;
        values[valuesById[3] = "Powder"] = 3;
        values[valuesById[4] = "Paste"] = 4;
        values[valuesById[5] = "Pressed"] = 5;
        return values;
    })();

    RemoteFortressReader.Spatter = (function() {

        /**
         * Properties of a Spatter.
         * @memberof RemoteFortressReader
         * @interface ISpatter
         * @property {RemoteFortressReader.IMatPair|null} [material] Spatter material
         * @property {number|null} [amount] Spatter amount
         * @property {RemoteFortressReader.MatterState|null} [state] Spatter state
         * @property {RemoteFortressReader.IMatPair|null} [item] Spatter item
         */

        /**
         * Constructs a new Spatter.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Spatter.
         * @implements ISpatter
         * @constructor
         * @param {RemoteFortressReader.ISpatter=} [properties] Properties to set
         */
        function Spatter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Spatter material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.material = null;

        /**
         * Spatter amount.
         * @member {number} amount
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.amount = 0;

        /**
         * Spatter state.
         * @member {RemoteFortressReader.MatterState} state
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.state = 0;

        /**
         * Spatter item.
         * @member {RemoteFortressReader.IMatPair|null|undefined} item
         * @memberof RemoteFortressReader.Spatter
         * @instance
         */
        Spatter.prototype.item = null;

        /**
         * Creates a new Spatter instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.ISpatter=} [properties] Properties to set
         * @returns {RemoteFortressReader.Spatter} Spatter instance
         */
        Spatter.create = function create(properties) {
            return new Spatter(properties);
        };

        /**
         * Encodes the specified Spatter message. Does not implicitly {@link RemoteFortressReader.Spatter.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.ISpatter} message Spatter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spatter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.amount);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.RemoteFortressReader.MatPair.encode(message.item, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Spatter message, length delimited. Does not implicitly {@link RemoteFortressReader.Spatter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.ISpatter} message Spatter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spatter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Spatter message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Spatter} Spatter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spatter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Spatter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.amount = reader.int32();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.item = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Spatter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Spatter} Spatter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spatter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Spatter message.
         * @function verify
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Spatter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a Spatter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Spatter} Spatter
         */
        Spatter.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Spatter)
                return object;
            var message = new $root.RemoteFortressReader.Spatter();
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.Spatter.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.amount != null)
                message.amount = object.amount | 0;
            switch (object.state) {
            case "Solid":
            case 0:
                message.state = 0;
                break;
            case "Liquid":
            case 1:
                message.state = 1;
                break;
            case "Gas":
            case 2:
                message.state = 2;
                break;
            case "Powder":
            case 3:
                message.state = 3;
                break;
            case "Paste":
            case 4:
                message.state = 4;
                break;
            case "Pressed":
            case 5:
                message.state = 5;
                break;
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.Spatter.item: object expected");
                message.item = $root.RemoteFortressReader.MatPair.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a Spatter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Spatter
         * @static
         * @param {RemoteFortressReader.Spatter} message Spatter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Spatter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.material = null;
                object.amount = 0;
                object.state = options.enums === String ? "Solid" : 0;
                object.item = null;
            }
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.RemoteFortressReader.MatterState[message.state] : message.state;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.MatPair.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this Spatter to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Spatter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Spatter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Spatter;
    })();

    RemoteFortressReader.SpatterPile = (function() {

        /**
         * Properties of a SpatterPile.
         * @memberof RemoteFortressReader
         * @interface ISpatterPile
         * @property {Array.<RemoteFortressReader.ISpatter>|null} [spatters] SpatterPile spatters
         */

        /**
         * Constructs a new SpatterPile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SpatterPile.
         * @implements ISpatterPile
         * @constructor
         * @param {RemoteFortressReader.ISpatterPile=} [properties] Properties to set
         */
        function SpatterPile(properties) {
            this.spatters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpatterPile spatters.
         * @member {Array.<RemoteFortressReader.ISpatter>} spatters
         * @memberof RemoteFortressReader.SpatterPile
         * @instance
         */
        SpatterPile.prototype.spatters = $util.emptyArray;

        /**
         * Creates a new SpatterPile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.ISpatterPile=} [properties] Properties to set
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile instance
         */
        SpatterPile.create = function create(properties) {
            return new SpatterPile(properties);
        };

        /**
         * Encodes the specified SpatterPile message. Does not implicitly {@link RemoteFortressReader.SpatterPile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.ISpatterPile} message SpatterPile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatterPile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spatters != null && message.spatters.length)
                for (var i = 0; i < message.spatters.length; ++i)
                    $root.RemoteFortressReader.Spatter.encode(message.spatters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SpatterPile message, length delimited. Does not implicitly {@link RemoteFortressReader.SpatterPile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.ISpatterPile} message SpatterPile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatterPile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpatterPile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatterPile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SpatterPile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.spatters && message.spatters.length))
                        message.spatters = [];
                    message.spatters.push($root.RemoteFortressReader.Spatter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpatterPile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatterPile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpatterPile message.
         * @function verify
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpatterPile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spatters != null && message.hasOwnProperty("spatters")) {
                if (!Array.isArray(message.spatters))
                    return "spatters: array expected";
                for (var i = 0; i < message.spatters.length; ++i) {
                    var error = $root.RemoteFortressReader.Spatter.verify(message.spatters[i]);
                    if (error)
                        return "spatters." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SpatterPile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SpatterPile} SpatterPile
         */
        SpatterPile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SpatterPile)
                return object;
            var message = new $root.RemoteFortressReader.SpatterPile();
            if (object.spatters) {
                if (!Array.isArray(object.spatters))
                    throw TypeError(".RemoteFortressReader.SpatterPile.spatters: array expected");
                message.spatters = [];
                for (var i = 0; i < object.spatters.length; ++i) {
                    if (typeof object.spatters[i] !== "object")
                        throw TypeError(".RemoteFortressReader.SpatterPile.spatters: object expected");
                    message.spatters[i] = $root.RemoteFortressReader.Spatter.fromObject(object.spatters[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SpatterPile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SpatterPile
         * @static
         * @param {RemoteFortressReader.SpatterPile} message SpatterPile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpatterPile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.spatters = [];
            if (message.spatters && message.spatters.length) {
                object.spatters = [];
                for (var j = 0; j < message.spatters.length; ++j)
                    object.spatters[j] = $root.RemoteFortressReader.Spatter.toObject(message.spatters[j], options);
            }
            return object;
        };

        /**
         * Converts this SpatterPile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SpatterPile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpatterPile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SpatterPile;
    })();

    RemoteFortressReader.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof RemoteFortressReader
         * @interface IItem
         * @property {number|null} [id] Item id
         * @property {RemoteFortressReader.ICoord|null} [pos] Item pos
         * @property {number|null} [flags1] Item flags1
         * @property {number|null} [flags2] Item flags2
         * @property {RemoteFortressReader.IMatPair|null} [type] Item type
         * @property {RemoteFortressReader.IMatPair|null} [material] Item material
         * @property {RemoteFortressReader.IColorDefinition|null} [dye] Item dye
         * @property {number|null} [stackSize] Item stackSize
         * @property {number|null} [subposX] Item subposX
         * @property {number|null} [subposY] Item subposY
         * @property {number|null} [subposZ] Item subposZ
         * @property {boolean|null} [projectile] Item projectile
         * @property {number|null} [velocityX] Item velocityX
         * @property {number|null} [velocityY] Item velocityY
         * @property {number|null} [velocityZ] Item velocityZ
         * @property {number|null} [volume] Item volume
         * @property {Array.<RemoteFortressReader.IItemImprovement>|null} [improvements] Item improvements
         * @property {RemoteFortressReader.IArtImage|null} [image] Item image
         */

        /**
         * Constructs a new Item.
         * @memberof RemoteFortressReader
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {RemoteFortressReader.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            this.improvements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item id.
         * @member {number} id
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.id = 0;

        /**
         * Item pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.pos = null;

        /**
         * Item flags1.
         * @member {number} flags1
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.flags1 = 0;

        /**
         * Item flags2.
         * @member {number} flags2
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.flags2 = 0;

        /**
         * Item type.
         * @member {RemoteFortressReader.IMatPair|null|undefined} type
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.type = null;

        /**
         * Item material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.material = null;

        /**
         * Item dye.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} dye
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.dye = null;

        /**
         * Item stackSize.
         * @member {number} stackSize
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.stackSize = 0;

        /**
         * Item subposX.
         * @member {number} subposX
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.subposX = 0;

        /**
         * Item subposY.
         * @member {number} subposY
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.subposY = 0;

        /**
         * Item subposZ.
         * @member {number} subposZ
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.subposZ = 0;

        /**
         * Item projectile.
         * @member {boolean} projectile
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.projectile = false;

        /**
         * Item velocityX.
         * @member {number} velocityX
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.velocityX = 0;

        /**
         * Item velocityY.
         * @member {number} velocityY
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.velocityY = 0;

        /**
         * Item velocityZ.
         * @member {number} velocityZ
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.velocityZ = 0;

        /**
         * Item volume.
         * @member {number} volume
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.volume = 0;

        /**
         * Item improvements.
         * @member {Array.<RemoteFortressReader.IItemImprovement>} improvements
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.improvements = $util.emptyArray;

        /**
         * Item image.
         * @member {RemoteFortressReader.IArtImage|null|undefined} image
         * @memberof RemoteFortressReader.Item
         * @instance
         */
        Item.prototype.image = null;

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.IItem=} [properties] Properties to set
         * @returns {RemoteFortressReader.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link RemoteFortressReader.Item.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.flags1 != null && Object.hasOwnProperty.call(message, "flags1"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags1);
            if (message.flags2 != null && Object.hasOwnProperty.call(message, "flags2"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.flags2);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                $root.RemoteFortressReader.MatPair.encode(message.type, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.dye != null && Object.hasOwnProperty.call(message, "dye"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.dye, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.stackSize != null && Object.hasOwnProperty.call(message, "stackSize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.stackSize);
            if (message.subposX != null && Object.hasOwnProperty.call(message, "subposX"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.subposX);
            if (message.subposY != null && Object.hasOwnProperty.call(message, "subposY"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.subposY);
            if (message.subposZ != null && Object.hasOwnProperty.call(message, "subposZ"))
                writer.uint32(/* id 11, wireType 5 =*/93).float(message.subposZ);
            if (message.projectile != null && Object.hasOwnProperty.call(message, "projectile"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.projectile);
            if (message.velocityX != null && Object.hasOwnProperty.call(message, "velocityX"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.velocityX);
            if (message.velocityY != null && Object.hasOwnProperty.call(message, "velocityY"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.velocityY);
            if (message.velocityZ != null && Object.hasOwnProperty.call(message, "velocityZ"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.velocityZ);
            if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.volume);
            if (message.improvements != null && message.improvements.length)
                for (var i = 0; i < message.improvements.length; ++i)
                    $root.RemoteFortressReader.ItemImprovement.encode(message.improvements[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                $root.RemoteFortressReader.ArtImage.encode(message.image, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link RemoteFortressReader.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.flags1 = reader.uint32();
                    break;
                case 4:
                    message.flags2 = reader.uint32();
                    break;
                case 5:
                    message.type = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.dye = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.stackSize = reader.int32();
                    break;
                case 9:
                    message.subposX = reader.float();
                    break;
                case 10:
                    message.subposY = reader.float();
                    break;
                case 11:
                    message.subposZ = reader.float();
                    break;
                case 12:
                    message.projectile = reader.bool();
                    break;
                case 13:
                    message.velocityX = reader.float();
                    break;
                case 14:
                    message.velocityY = reader.float();
                    break;
                case 15:
                    message.velocityZ = reader.float();
                    break;
                case 16:
                    message.volume = reader.int32();
                    break;
                case 17:
                    if (!(message.improvements && message.improvements.length))
                        message.improvements = [];
                    message.improvements.push($root.RemoteFortressReader.ItemImprovement.decode(reader, reader.uint32()));
                    break;
                case 18:
                    message.image = $root.RemoteFortressReader.ArtImage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                if (!$util.isInteger(message.flags1))
                    return "flags1: integer expected";
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                if (!$util.isInteger(message.flags2))
                    return "flags2: integer expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.type);
                if (error)
                    return "type." + error;
            }
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.dye != null && message.hasOwnProperty("dye")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.dye);
                if (error)
                    return "dye." + error;
            }
            if (message.stackSize != null && message.hasOwnProperty("stackSize"))
                if (!$util.isInteger(message.stackSize))
                    return "stackSize: integer expected";
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                if (typeof message.subposX !== "number")
                    return "subposX: number expected";
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                if (typeof message.subposY !== "number")
                    return "subposY: number expected";
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                if (typeof message.subposZ !== "number")
                    return "subposZ: number expected";
            if (message.projectile != null && message.hasOwnProperty("projectile"))
                if (typeof message.projectile !== "boolean")
                    return "projectile: boolean expected";
            if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                if (typeof message.velocityX !== "number")
                    return "velocityX: number expected";
            if (message.velocityY != null && message.hasOwnProperty("velocityY"))
                if (typeof message.velocityY !== "number")
                    return "velocityY: number expected";
            if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                if (typeof message.velocityZ !== "number")
                    return "velocityZ: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume))
                    return "volume: integer expected";
            if (message.improvements != null && message.hasOwnProperty("improvements")) {
                if (!Array.isArray(message.improvements))
                    return "improvements: array expected";
                for (var i = 0; i < message.improvements.length; ++i) {
                    var error = $root.RemoteFortressReader.ItemImprovement.verify(message.improvements[i]);
                    if (error)
                        return "improvements." + error;
                }
            }
            if (message.image != null && message.hasOwnProperty("image")) {
                var error = $root.RemoteFortressReader.ArtImage.verify(message.image);
                if (error)
                    return "image." + error;
            }
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Item)
                return object;
            var message = new $root.RemoteFortressReader.Item();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Item.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.flags1 != null)
                message.flags1 = object.flags1 >>> 0;
            if (object.flags2 != null)
                message.flags2 = object.flags2 >>> 0;
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".RemoteFortressReader.Item.type: object expected");
                message.type = $root.RemoteFortressReader.MatPair.fromObject(object.type);
            }
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.Item.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.dye != null) {
                if (typeof object.dye !== "object")
                    throw TypeError(".RemoteFortressReader.Item.dye: object expected");
                message.dye = $root.RemoteFortressReader.ColorDefinition.fromObject(object.dye);
            }
            if (object.stackSize != null)
                message.stackSize = object.stackSize | 0;
            if (object.subposX != null)
                message.subposX = Number(object.subposX);
            if (object.subposY != null)
                message.subposY = Number(object.subposY);
            if (object.subposZ != null)
                message.subposZ = Number(object.subposZ);
            if (object.projectile != null)
                message.projectile = Boolean(object.projectile);
            if (object.velocityX != null)
                message.velocityX = Number(object.velocityX);
            if (object.velocityY != null)
                message.velocityY = Number(object.velocityY);
            if (object.velocityZ != null)
                message.velocityZ = Number(object.velocityZ);
            if (object.volume != null)
                message.volume = object.volume | 0;
            if (object.improvements) {
                if (!Array.isArray(object.improvements))
                    throw TypeError(".RemoteFortressReader.Item.improvements: array expected");
                message.improvements = [];
                for (var i = 0; i < object.improvements.length; ++i) {
                    if (typeof object.improvements[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Item.improvements: object expected");
                    message.improvements[i] = $root.RemoteFortressReader.ItemImprovement.fromObject(object.improvements[i]);
                }
            }
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".RemoteFortressReader.Item.image: object expected");
                message.image = $root.RemoteFortressReader.ArtImage.fromObject(object.image);
            }
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Item
         * @static
         * @param {RemoteFortressReader.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.improvements = [];
            if (options.defaults) {
                object.id = 0;
                object.pos = null;
                object.flags1 = 0;
                object.flags2 = 0;
                object.type = null;
                object.material = null;
                object.dye = null;
                object.stackSize = 0;
                object.subposX = 0;
                object.subposY = 0;
                object.subposZ = 0;
                object.projectile = false;
                object.velocityX = 0;
                object.velocityY = 0;
                object.velocityZ = 0;
                object.volume = 0;
                object.image = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                object.flags1 = message.flags1;
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                object.flags2 = message.flags2;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.RemoteFortressReader.MatPair.toObject(message.type, options);
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.dye != null && message.hasOwnProperty("dye"))
                object.dye = $root.RemoteFortressReader.ColorDefinition.toObject(message.dye, options);
            if (message.stackSize != null && message.hasOwnProperty("stackSize"))
                object.stackSize = message.stackSize;
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                object.subposX = options.json && !isFinite(message.subposX) ? String(message.subposX) : message.subposX;
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                object.subposY = options.json && !isFinite(message.subposY) ? String(message.subposY) : message.subposY;
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                object.subposZ = options.json && !isFinite(message.subposZ) ? String(message.subposZ) : message.subposZ;
            if (message.projectile != null && message.hasOwnProperty("projectile"))
                object.projectile = message.projectile;
            if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                object.velocityX = options.json && !isFinite(message.velocityX) ? String(message.velocityX) : message.velocityX;
            if (message.velocityY != null && message.hasOwnProperty("velocityY"))
                object.velocityY = options.json && !isFinite(message.velocityY) ? String(message.velocityY) : message.velocityY;
            if (message.velocityZ != null && message.hasOwnProperty("velocityZ"))
                object.velocityZ = options.json && !isFinite(message.velocityZ) ? String(message.velocityZ) : message.velocityZ;
            if (message.volume != null && message.hasOwnProperty("volume"))
                object.volume = message.volume;
            if (message.improvements && message.improvements.length) {
                object.improvements = [];
                for (var j = 0; j < message.improvements.length; ++j)
                    object.improvements[j] = $root.RemoteFortressReader.ItemImprovement.toObject(message.improvements[j], options);
            }
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.RemoteFortressReader.ArtImage.toObject(message.image, options);
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Item;
    })();

    RemoteFortressReader.MapBlock = (function() {

        /**
         * Properties of a MapBlock.
         * @memberof RemoteFortressReader
         * @interface IMapBlock
         * @property {number} mapX MapBlock mapX
         * @property {number} mapY MapBlock mapY
         * @property {number} mapZ MapBlock mapZ
         * @property {Array.<number>|null} [tiles] MapBlock tiles
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [materials] MapBlock materials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [layerMaterials] MapBlock layerMaterials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [veinMaterials] MapBlock veinMaterials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [baseMaterials] MapBlock baseMaterials
         * @property {Array.<number>|null} [magma] MapBlock magma
         * @property {Array.<number>|null} [water] MapBlock water
         * @property {Array.<boolean>|null} [hidden] MapBlock hidden
         * @property {Array.<boolean>|null} [light] MapBlock light
         * @property {Array.<boolean>|null} [subterranean] MapBlock subterranean
         * @property {Array.<boolean>|null} [outside] MapBlock outside
         * @property {Array.<boolean>|null} [aquifer] MapBlock aquifer
         * @property {Array.<boolean>|null} [waterStagnant] MapBlock waterStagnant
         * @property {Array.<boolean>|null} [waterSalt] MapBlock waterSalt
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [constructionItems] MapBlock constructionItems
         * @property {Array.<RemoteFortressReader.IBuildingInstance>|null} [buildings] MapBlock buildings
         * @property {Array.<number>|null} [treePercent] MapBlock treePercent
         * @property {Array.<number>|null} [treeX] MapBlock treeX
         * @property {Array.<number>|null} [treeY] MapBlock treeY
         * @property {Array.<number>|null} [treeZ] MapBlock treeZ
         * @property {Array.<RemoteFortressReader.TileDigDesignation>|null} [tileDigDesignation] MapBlock tileDigDesignation
         * @property {Array.<RemoteFortressReader.ISpatterPile>|null} [spatterPile] MapBlock spatterPile
         * @property {Array.<RemoteFortressReader.IItem>|null} [items] MapBlock items
         * @property {Array.<boolean>|null} [tileDigDesignationMarker] MapBlock tileDigDesignationMarker
         * @property {Array.<boolean>|null} [tileDigDesignationAuto] MapBlock tileDigDesignationAuto
         * @property {Array.<number>|null} [grassPercent] MapBlock grassPercent
         * @property {Array.<RemoteFortressReader.IFlowInfo>|null} [flows] MapBlock flows
         */

        /**
         * Constructs a new MapBlock.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MapBlock.
         * @implements IMapBlock
         * @constructor
         * @param {RemoteFortressReader.IMapBlock=} [properties] Properties to set
         */
        function MapBlock(properties) {
            this.tiles = [];
            this.materials = [];
            this.layerMaterials = [];
            this.veinMaterials = [];
            this.baseMaterials = [];
            this.magma = [];
            this.water = [];
            this.hidden = [];
            this.light = [];
            this.subterranean = [];
            this.outside = [];
            this.aquifer = [];
            this.waterStagnant = [];
            this.waterSalt = [];
            this.constructionItems = [];
            this.buildings = [];
            this.treePercent = [];
            this.treeX = [];
            this.treeY = [];
            this.treeZ = [];
            this.tileDigDesignation = [];
            this.spatterPile = [];
            this.items = [];
            this.tileDigDesignationMarker = [];
            this.tileDigDesignationAuto = [];
            this.grassPercent = [];
            this.flows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapBlock mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.mapX = 0;

        /**
         * MapBlock mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.mapY = 0;

        /**
         * MapBlock mapZ.
         * @member {number} mapZ
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.mapZ = 0;

        /**
         * MapBlock tiles.
         * @member {Array.<number>} tiles
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tiles = $util.emptyArray;

        /**
         * MapBlock materials.
         * @member {Array.<RemoteFortressReader.IMatPair>} materials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.materials = $util.emptyArray;

        /**
         * MapBlock layerMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} layerMaterials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.layerMaterials = $util.emptyArray;

        /**
         * MapBlock veinMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} veinMaterials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.veinMaterials = $util.emptyArray;

        /**
         * MapBlock baseMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} baseMaterials
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.baseMaterials = $util.emptyArray;

        /**
         * MapBlock magma.
         * @member {Array.<number>} magma
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.magma = $util.emptyArray;

        /**
         * MapBlock water.
         * @member {Array.<number>} water
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.water = $util.emptyArray;

        /**
         * MapBlock hidden.
         * @member {Array.<boolean>} hidden
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.hidden = $util.emptyArray;

        /**
         * MapBlock light.
         * @member {Array.<boolean>} light
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.light = $util.emptyArray;

        /**
         * MapBlock subterranean.
         * @member {Array.<boolean>} subterranean
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.subterranean = $util.emptyArray;

        /**
         * MapBlock outside.
         * @member {Array.<boolean>} outside
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.outside = $util.emptyArray;

        /**
         * MapBlock aquifer.
         * @member {Array.<boolean>} aquifer
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.aquifer = $util.emptyArray;

        /**
         * MapBlock waterStagnant.
         * @member {Array.<boolean>} waterStagnant
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.waterStagnant = $util.emptyArray;

        /**
         * MapBlock waterSalt.
         * @member {Array.<boolean>} waterSalt
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.waterSalt = $util.emptyArray;

        /**
         * MapBlock constructionItems.
         * @member {Array.<RemoteFortressReader.IMatPair>} constructionItems
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.constructionItems = $util.emptyArray;

        /**
         * MapBlock buildings.
         * @member {Array.<RemoteFortressReader.IBuildingInstance>} buildings
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.buildings = $util.emptyArray;

        /**
         * MapBlock treePercent.
         * @member {Array.<number>} treePercent
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treePercent = $util.emptyArray;

        /**
         * MapBlock treeX.
         * @member {Array.<number>} treeX
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treeX = $util.emptyArray;

        /**
         * MapBlock treeY.
         * @member {Array.<number>} treeY
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treeY = $util.emptyArray;

        /**
         * MapBlock treeZ.
         * @member {Array.<number>} treeZ
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.treeZ = $util.emptyArray;

        /**
         * MapBlock tileDigDesignation.
         * @member {Array.<RemoteFortressReader.TileDigDesignation>} tileDigDesignation
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tileDigDesignation = $util.emptyArray;

        /**
         * MapBlock spatterPile.
         * @member {Array.<RemoteFortressReader.ISpatterPile>} spatterPile
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.spatterPile = $util.emptyArray;

        /**
         * MapBlock items.
         * @member {Array.<RemoteFortressReader.IItem>} items
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.items = $util.emptyArray;

        /**
         * MapBlock tileDigDesignationMarker.
         * @member {Array.<boolean>} tileDigDesignationMarker
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tileDigDesignationMarker = $util.emptyArray;

        /**
         * MapBlock tileDigDesignationAuto.
         * @member {Array.<boolean>} tileDigDesignationAuto
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.tileDigDesignationAuto = $util.emptyArray;

        /**
         * MapBlock grassPercent.
         * @member {Array.<number>} grassPercent
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.grassPercent = $util.emptyArray;

        /**
         * MapBlock flows.
         * @member {Array.<RemoteFortressReader.IFlowInfo>} flows
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         */
        MapBlock.prototype.flows = $util.emptyArray;

        /**
         * Creates a new MapBlock instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.IMapBlock=} [properties] Properties to set
         * @returns {RemoteFortressReader.MapBlock} MapBlock instance
         */
        MapBlock.create = function create(properties) {
            return new MapBlock(properties);
        };

        /**
         * Encodes the specified MapBlock message. Does not implicitly {@link RemoteFortressReader.MapBlock.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.IMapBlock} message MapBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapBlock.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mapX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapY);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mapZ);
            if (message.tiles != null && message.tiles.length)
                for (var i = 0; i < message.tiles.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tiles[i]);
            if (message.materials != null && message.materials.length)
                for (var i = 0; i < message.materials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.materials[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.layerMaterials != null && message.layerMaterials.length)
                for (var i = 0; i < message.layerMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.layerMaterials[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.veinMaterials != null && message.veinMaterials.length)
                for (var i = 0; i < message.veinMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.veinMaterials[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.baseMaterials != null && message.baseMaterials.length)
                for (var i = 0; i < message.baseMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.baseMaterials[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.magma != null && message.magma.length)
                for (var i = 0; i < message.magma.length; ++i)
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.magma[i]);
            if (message.water != null && message.water.length)
                for (var i = 0; i < message.water.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.water[i]);
            if (message.hidden != null && message.hidden.length)
                for (var i = 0; i < message.hidden.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.hidden[i]);
            if (message.light != null && message.light.length)
                for (var i = 0; i < message.light.length; ++i)
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.light[i]);
            if (message.subterranean != null && message.subterranean.length)
                for (var i = 0; i < message.subterranean.length; ++i)
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.subterranean[i]);
            if (message.outside != null && message.outside.length)
                for (var i = 0; i < message.outside.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.outside[i]);
            if (message.aquifer != null && message.aquifer.length)
                for (var i = 0; i < message.aquifer.length; ++i)
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.aquifer[i]);
            if (message.waterStagnant != null && message.waterStagnant.length)
                for (var i = 0; i < message.waterStagnant.length; ++i)
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.waterStagnant[i]);
            if (message.waterSalt != null && message.waterSalt.length)
                for (var i = 0; i < message.waterSalt.length; ++i)
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.waterSalt[i]);
            if (message.constructionItems != null && message.constructionItems.length)
                for (var i = 0; i < message.constructionItems.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.constructionItems[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.buildings != null && message.buildings.length)
                for (var i = 0; i < message.buildings.length; ++i)
                    $root.RemoteFortressReader.BuildingInstance.encode(message.buildings[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.treePercent != null && message.treePercent.length)
                for (var i = 0; i < message.treePercent.length; ++i)
                    writer.uint32(/* id 20, wireType 0 =*/160).int32(message.treePercent[i]);
            if (message.treeX != null && message.treeX.length)
                for (var i = 0; i < message.treeX.length; ++i)
                    writer.uint32(/* id 21, wireType 0 =*/168).int32(message.treeX[i]);
            if (message.treeY != null && message.treeY.length)
                for (var i = 0; i < message.treeY.length; ++i)
                    writer.uint32(/* id 22, wireType 0 =*/176).int32(message.treeY[i]);
            if (message.treeZ != null && message.treeZ.length)
                for (var i = 0; i < message.treeZ.length; ++i)
                    writer.uint32(/* id 23, wireType 0 =*/184).int32(message.treeZ[i]);
            if (message.tileDigDesignation != null && message.tileDigDesignation.length)
                for (var i = 0; i < message.tileDigDesignation.length; ++i)
                    writer.uint32(/* id 24, wireType 0 =*/192).int32(message.tileDigDesignation[i]);
            if (message.spatterPile != null && message.spatterPile.length)
                for (var i = 0; i < message.spatterPile.length; ++i)
                    $root.RemoteFortressReader.SpatterPile.encode(message.spatterPile[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.RemoteFortressReader.Item.encode(message.items[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.tileDigDesignationMarker != null && message.tileDigDesignationMarker.length)
                for (var i = 0; i < message.tileDigDesignationMarker.length; ++i)
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.tileDigDesignationMarker[i]);
            if (message.tileDigDesignationAuto != null && message.tileDigDesignationAuto.length)
                for (var i = 0; i < message.tileDigDesignationAuto.length; ++i)
                    writer.uint32(/* id 28, wireType 0 =*/224).bool(message.tileDigDesignationAuto[i]);
            if (message.grassPercent != null && message.grassPercent.length)
                for (var i = 0; i < message.grassPercent.length; ++i)
                    writer.uint32(/* id 29, wireType 0 =*/232).int32(message.grassPercent[i]);
            if (message.flows != null && message.flows.length)
                for (var i = 0; i < message.flows.length; ++i)
                    $root.RemoteFortressReader.FlowInfo.encode(message.flows[i], writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MapBlock message, length delimited. Does not implicitly {@link RemoteFortressReader.MapBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.IMapBlock} message MapBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapBlock.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapBlock message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MapBlock} MapBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapBlock.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MapBlock();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mapX = reader.int32();
                    break;
                case 2:
                    message.mapY = reader.int32();
                    break;
                case 3:
                    message.mapZ = reader.int32();
                    break;
                case 4:
                    if (!(message.tiles && message.tiles.length))
                        message.tiles = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tiles.push(reader.int32());
                    } else
                        message.tiles.push(reader.int32());
                    break;
                case 5:
                    if (!(message.materials && message.materials.length))
                        message.materials = [];
                    message.materials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.layerMaterials && message.layerMaterials.length))
                        message.layerMaterials = [];
                    message.layerMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.veinMaterials && message.veinMaterials.length))
                        message.veinMaterials = [];
                    message.veinMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.baseMaterials && message.baseMaterials.length))
                        message.baseMaterials = [];
                    message.baseMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.magma && message.magma.length))
                        message.magma = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.magma.push(reader.int32());
                    } else
                        message.magma.push(reader.int32());
                    break;
                case 10:
                    if (!(message.water && message.water.length))
                        message.water = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.water.push(reader.int32());
                    } else
                        message.water.push(reader.int32());
                    break;
                case 11:
                    if (!(message.hidden && message.hidden.length))
                        message.hidden = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.hidden.push(reader.bool());
                    } else
                        message.hidden.push(reader.bool());
                    break;
                case 12:
                    if (!(message.light && message.light.length))
                        message.light = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.light.push(reader.bool());
                    } else
                        message.light.push(reader.bool());
                    break;
                case 13:
                    if (!(message.subterranean && message.subterranean.length))
                        message.subterranean = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.subterranean.push(reader.bool());
                    } else
                        message.subterranean.push(reader.bool());
                    break;
                case 14:
                    if (!(message.outside && message.outside.length))
                        message.outside = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.outside.push(reader.bool());
                    } else
                        message.outside.push(reader.bool());
                    break;
                case 15:
                    if (!(message.aquifer && message.aquifer.length))
                        message.aquifer = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.aquifer.push(reader.bool());
                    } else
                        message.aquifer.push(reader.bool());
                    break;
                case 16:
                    if (!(message.waterStagnant && message.waterStagnant.length))
                        message.waterStagnant = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waterStagnant.push(reader.bool());
                    } else
                        message.waterStagnant.push(reader.bool());
                    break;
                case 17:
                    if (!(message.waterSalt && message.waterSalt.length))
                        message.waterSalt = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waterSalt.push(reader.bool());
                    } else
                        message.waterSalt.push(reader.bool());
                    break;
                case 18:
                    if (!(message.constructionItems && message.constructionItems.length))
                        message.constructionItems = [];
                    message.constructionItems.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 19:
                    if (!(message.buildings && message.buildings.length))
                        message.buildings = [];
                    message.buildings.push($root.RemoteFortressReader.BuildingInstance.decode(reader, reader.uint32()));
                    break;
                case 20:
                    if (!(message.treePercent && message.treePercent.length))
                        message.treePercent = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treePercent.push(reader.int32());
                    } else
                        message.treePercent.push(reader.int32());
                    break;
                case 21:
                    if (!(message.treeX && message.treeX.length))
                        message.treeX = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treeX.push(reader.int32());
                    } else
                        message.treeX.push(reader.int32());
                    break;
                case 22:
                    if (!(message.treeY && message.treeY.length))
                        message.treeY = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treeY.push(reader.int32());
                    } else
                        message.treeY.push(reader.int32());
                    break;
                case 23:
                    if (!(message.treeZ && message.treeZ.length))
                        message.treeZ = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.treeZ.push(reader.int32());
                    } else
                        message.treeZ.push(reader.int32());
                    break;
                case 24:
                    if (!(message.tileDigDesignation && message.tileDigDesignation.length))
                        message.tileDigDesignation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileDigDesignation.push(reader.int32());
                    } else
                        message.tileDigDesignation.push(reader.int32());
                    break;
                case 25:
                    if (!(message.spatterPile && message.spatterPile.length))
                        message.spatterPile = [];
                    message.spatterPile.push($root.RemoteFortressReader.SpatterPile.decode(reader, reader.uint32()));
                    break;
                case 26:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.RemoteFortressReader.Item.decode(reader, reader.uint32()));
                    break;
                case 27:
                    if (!(message.tileDigDesignationMarker && message.tileDigDesignationMarker.length))
                        message.tileDigDesignationMarker = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileDigDesignationMarker.push(reader.bool());
                    } else
                        message.tileDigDesignationMarker.push(reader.bool());
                    break;
                case 28:
                    if (!(message.tileDigDesignationAuto && message.tileDigDesignationAuto.length))
                        message.tileDigDesignationAuto = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileDigDesignationAuto.push(reader.bool());
                    } else
                        message.tileDigDesignationAuto.push(reader.bool());
                    break;
                case 29:
                    if (!(message.grassPercent && message.grassPercent.length))
                        message.grassPercent = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.grassPercent.push(reader.int32());
                    } else
                        message.grassPercent.push(reader.int32());
                    break;
                case 30:
                    if (!(message.flows && message.flows.length))
                        message.flows = [];
                    message.flows.push($root.RemoteFortressReader.FlowInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("mapX"))
                throw $util.ProtocolError("missing required 'mapX'", { instance: message });
            if (!message.hasOwnProperty("mapY"))
                throw $util.ProtocolError("missing required 'mapY'", { instance: message });
            if (!message.hasOwnProperty("mapZ"))
                throw $util.ProtocolError("missing required 'mapZ'", { instance: message });
            return message;
        };

        /**
         * Decodes a MapBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MapBlock} MapBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapBlock.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapBlock message.
         * @function verify
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapBlock.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.mapX))
                return "mapX: integer expected";
            if (!$util.isInteger(message.mapY))
                return "mapY: integer expected";
            if (!$util.isInteger(message.mapZ))
                return "mapZ: integer expected";
            if (message.tiles != null && message.hasOwnProperty("tiles")) {
                if (!Array.isArray(message.tiles))
                    return "tiles: array expected";
                for (var i = 0; i < message.tiles.length; ++i)
                    if (!$util.isInteger(message.tiles[i]))
                        return "tiles: integer[] expected";
            }
            if (message.materials != null && message.hasOwnProperty("materials")) {
                if (!Array.isArray(message.materials))
                    return "materials: array expected";
                for (var i = 0; i < message.materials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.materials[i]);
                    if (error)
                        return "materials." + error;
                }
            }
            if (message.layerMaterials != null && message.hasOwnProperty("layerMaterials")) {
                if (!Array.isArray(message.layerMaterials))
                    return "layerMaterials: array expected";
                for (var i = 0; i < message.layerMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.layerMaterials[i]);
                    if (error)
                        return "layerMaterials." + error;
                }
            }
            if (message.veinMaterials != null && message.hasOwnProperty("veinMaterials")) {
                if (!Array.isArray(message.veinMaterials))
                    return "veinMaterials: array expected";
                for (var i = 0; i < message.veinMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.veinMaterials[i]);
                    if (error)
                        return "veinMaterials." + error;
                }
            }
            if (message.baseMaterials != null && message.hasOwnProperty("baseMaterials")) {
                if (!Array.isArray(message.baseMaterials))
                    return "baseMaterials: array expected";
                for (var i = 0; i < message.baseMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.baseMaterials[i]);
                    if (error)
                        return "baseMaterials." + error;
                }
            }
            if (message.magma != null && message.hasOwnProperty("magma")) {
                if (!Array.isArray(message.magma))
                    return "magma: array expected";
                for (var i = 0; i < message.magma.length; ++i)
                    if (!$util.isInteger(message.magma[i]))
                        return "magma: integer[] expected";
            }
            if (message.water != null && message.hasOwnProperty("water")) {
                if (!Array.isArray(message.water))
                    return "water: array expected";
                for (var i = 0; i < message.water.length; ++i)
                    if (!$util.isInteger(message.water[i]))
                        return "water: integer[] expected";
            }
            if (message.hidden != null && message.hasOwnProperty("hidden")) {
                if (!Array.isArray(message.hidden))
                    return "hidden: array expected";
                for (var i = 0; i < message.hidden.length; ++i)
                    if (typeof message.hidden[i] !== "boolean")
                        return "hidden: boolean[] expected";
            }
            if (message.light != null && message.hasOwnProperty("light")) {
                if (!Array.isArray(message.light))
                    return "light: array expected";
                for (var i = 0; i < message.light.length; ++i)
                    if (typeof message.light[i] !== "boolean")
                        return "light: boolean[] expected";
            }
            if (message.subterranean != null && message.hasOwnProperty("subterranean")) {
                if (!Array.isArray(message.subterranean))
                    return "subterranean: array expected";
                for (var i = 0; i < message.subterranean.length; ++i)
                    if (typeof message.subterranean[i] !== "boolean")
                        return "subterranean: boolean[] expected";
            }
            if (message.outside != null && message.hasOwnProperty("outside")) {
                if (!Array.isArray(message.outside))
                    return "outside: array expected";
                for (var i = 0; i < message.outside.length; ++i)
                    if (typeof message.outside[i] !== "boolean")
                        return "outside: boolean[] expected";
            }
            if (message.aquifer != null && message.hasOwnProperty("aquifer")) {
                if (!Array.isArray(message.aquifer))
                    return "aquifer: array expected";
                for (var i = 0; i < message.aquifer.length; ++i)
                    if (typeof message.aquifer[i] !== "boolean")
                        return "aquifer: boolean[] expected";
            }
            if (message.waterStagnant != null && message.hasOwnProperty("waterStagnant")) {
                if (!Array.isArray(message.waterStagnant))
                    return "waterStagnant: array expected";
                for (var i = 0; i < message.waterStagnant.length; ++i)
                    if (typeof message.waterStagnant[i] !== "boolean")
                        return "waterStagnant: boolean[] expected";
            }
            if (message.waterSalt != null && message.hasOwnProperty("waterSalt")) {
                if (!Array.isArray(message.waterSalt))
                    return "waterSalt: array expected";
                for (var i = 0; i < message.waterSalt.length; ++i)
                    if (typeof message.waterSalt[i] !== "boolean")
                        return "waterSalt: boolean[] expected";
            }
            if (message.constructionItems != null && message.hasOwnProperty("constructionItems")) {
                if (!Array.isArray(message.constructionItems))
                    return "constructionItems: array expected";
                for (var i = 0; i < message.constructionItems.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.constructionItems[i]);
                    if (error)
                        return "constructionItems." + error;
                }
            }
            if (message.buildings != null && message.hasOwnProperty("buildings")) {
                if (!Array.isArray(message.buildings))
                    return "buildings: array expected";
                for (var i = 0; i < message.buildings.length; ++i) {
                    var error = $root.RemoteFortressReader.BuildingInstance.verify(message.buildings[i]);
                    if (error)
                        return "buildings." + error;
                }
            }
            if (message.treePercent != null && message.hasOwnProperty("treePercent")) {
                if (!Array.isArray(message.treePercent))
                    return "treePercent: array expected";
                for (var i = 0; i < message.treePercent.length; ++i)
                    if (!$util.isInteger(message.treePercent[i]))
                        return "treePercent: integer[] expected";
            }
            if (message.treeX != null && message.hasOwnProperty("treeX")) {
                if (!Array.isArray(message.treeX))
                    return "treeX: array expected";
                for (var i = 0; i < message.treeX.length; ++i)
                    if (!$util.isInteger(message.treeX[i]))
                        return "treeX: integer[] expected";
            }
            if (message.treeY != null && message.hasOwnProperty("treeY")) {
                if (!Array.isArray(message.treeY))
                    return "treeY: array expected";
                for (var i = 0; i < message.treeY.length; ++i)
                    if (!$util.isInteger(message.treeY[i]))
                        return "treeY: integer[] expected";
            }
            if (message.treeZ != null && message.hasOwnProperty("treeZ")) {
                if (!Array.isArray(message.treeZ))
                    return "treeZ: array expected";
                for (var i = 0; i < message.treeZ.length; ++i)
                    if (!$util.isInteger(message.treeZ[i]))
                        return "treeZ: integer[] expected";
            }
            if (message.tileDigDesignation != null && message.hasOwnProperty("tileDigDesignation")) {
                if (!Array.isArray(message.tileDigDesignation))
                    return "tileDigDesignation: array expected";
                for (var i = 0; i < message.tileDigDesignation.length; ++i)
                    switch (message.tileDigDesignation[i]) {
                    default:
                        return "tileDigDesignation: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
            }
            if (message.spatterPile != null && message.hasOwnProperty("spatterPile")) {
                if (!Array.isArray(message.spatterPile))
                    return "spatterPile: array expected";
                for (var i = 0; i < message.spatterPile.length; ++i) {
                    var error = $root.RemoteFortressReader.SpatterPile.verify(message.spatterPile[i]);
                    if (error)
                        return "spatterPile." + error;
                }
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.RemoteFortressReader.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.tileDigDesignationMarker != null && message.hasOwnProperty("tileDigDesignationMarker")) {
                if (!Array.isArray(message.tileDigDesignationMarker))
                    return "tileDigDesignationMarker: array expected";
                for (var i = 0; i < message.tileDigDesignationMarker.length; ++i)
                    if (typeof message.tileDigDesignationMarker[i] !== "boolean")
                        return "tileDigDesignationMarker: boolean[] expected";
            }
            if (message.tileDigDesignationAuto != null && message.hasOwnProperty("tileDigDesignationAuto")) {
                if (!Array.isArray(message.tileDigDesignationAuto))
                    return "tileDigDesignationAuto: array expected";
                for (var i = 0; i < message.tileDigDesignationAuto.length; ++i)
                    if (typeof message.tileDigDesignationAuto[i] !== "boolean")
                        return "tileDigDesignationAuto: boolean[] expected";
            }
            if (message.grassPercent != null && message.hasOwnProperty("grassPercent")) {
                if (!Array.isArray(message.grassPercent))
                    return "grassPercent: array expected";
                for (var i = 0; i < message.grassPercent.length; ++i)
                    if (!$util.isInteger(message.grassPercent[i]))
                        return "grassPercent: integer[] expected";
            }
            if (message.flows != null && message.hasOwnProperty("flows")) {
                if (!Array.isArray(message.flows))
                    return "flows: array expected";
                for (var i = 0; i < message.flows.length; ++i) {
                    var error = $root.RemoteFortressReader.FlowInfo.verify(message.flows[i]);
                    if (error)
                        return "flows." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MapBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MapBlock} MapBlock
         */
        MapBlock.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MapBlock)
                return object;
            var message = new $root.RemoteFortressReader.MapBlock();
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.mapZ != null)
                message.mapZ = object.mapZ | 0;
            if (object.tiles) {
                if (!Array.isArray(object.tiles))
                    throw TypeError(".RemoteFortressReader.MapBlock.tiles: array expected");
                message.tiles = [];
                for (var i = 0; i < object.tiles.length; ++i)
                    message.tiles[i] = object.tiles[i] | 0;
            }
            if (object.materials) {
                if (!Array.isArray(object.materials))
                    throw TypeError(".RemoteFortressReader.MapBlock.materials: array expected");
                message.materials = [];
                for (var i = 0; i < object.materials.length; ++i) {
                    if (typeof object.materials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.materials: object expected");
                    message.materials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.materials[i]);
                }
            }
            if (object.layerMaterials) {
                if (!Array.isArray(object.layerMaterials))
                    throw TypeError(".RemoteFortressReader.MapBlock.layerMaterials: array expected");
                message.layerMaterials = [];
                for (var i = 0; i < object.layerMaterials.length; ++i) {
                    if (typeof object.layerMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.layerMaterials: object expected");
                    message.layerMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.layerMaterials[i]);
                }
            }
            if (object.veinMaterials) {
                if (!Array.isArray(object.veinMaterials))
                    throw TypeError(".RemoteFortressReader.MapBlock.veinMaterials: array expected");
                message.veinMaterials = [];
                for (var i = 0; i < object.veinMaterials.length; ++i) {
                    if (typeof object.veinMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.veinMaterials: object expected");
                    message.veinMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.veinMaterials[i]);
                }
            }
            if (object.baseMaterials) {
                if (!Array.isArray(object.baseMaterials))
                    throw TypeError(".RemoteFortressReader.MapBlock.baseMaterials: array expected");
                message.baseMaterials = [];
                for (var i = 0; i < object.baseMaterials.length; ++i) {
                    if (typeof object.baseMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.baseMaterials: object expected");
                    message.baseMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.baseMaterials[i]);
                }
            }
            if (object.magma) {
                if (!Array.isArray(object.magma))
                    throw TypeError(".RemoteFortressReader.MapBlock.magma: array expected");
                message.magma = [];
                for (var i = 0; i < object.magma.length; ++i)
                    message.magma[i] = object.magma[i] | 0;
            }
            if (object.water) {
                if (!Array.isArray(object.water))
                    throw TypeError(".RemoteFortressReader.MapBlock.water: array expected");
                message.water = [];
                for (var i = 0; i < object.water.length; ++i)
                    message.water[i] = object.water[i] | 0;
            }
            if (object.hidden) {
                if (!Array.isArray(object.hidden))
                    throw TypeError(".RemoteFortressReader.MapBlock.hidden: array expected");
                message.hidden = [];
                for (var i = 0; i < object.hidden.length; ++i)
                    message.hidden[i] = Boolean(object.hidden[i]);
            }
            if (object.light) {
                if (!Array.isArray(object.light))
                    throw TypeError(".RemoteFortressReader.MapBlock.light: array expected");
                message.light = [];
                for (var i = 0; i < object.light.length; ++i)
                    message.light[i] = Boolean(object.light[i]);
            }
            if (object.subterranean) {
                if (!Array.isArray(object.subterranean))
                    throw TypeError(".RemoteFortressReader.MapBlock.subterranean: array expected");
                message.subterranean = [];
                for (var i = 0; i < object.subterranean.length; ++i)
                    message.subterranean[i] = Boolean(object.subterranean[i]);
            }
            if (object.outside) {
                if (!Array.isArray(object.outside))
                    throw TypeError(".RemoteFortressReader.MapBlock.outside: array expected");
                message.outside = [];
                for (var i = 0; i < object.outside.length; ++i)
                    message.outside[i] = Boolean(object.outside[i]);
            }
            if (object.aquifer) {
                if (!Array.isArray(object.aquifer))
                    throw TypeError(".RemoteFortressReader.MapBlock.aquifer: array expected");
                message.aquifer = [];
                for (var i = 0; i < object.aquifer.length; ++i)
                    message.aquifer[i] = Boolean(object.aquifer[i]);
            }
            if (object.waterStagnant) {
                if (!Array.isArray(object.waterStagnant))
                    throw TypeError(".RemoteFortressReader.MapBlock.waterStagnant: array expected");
                message.waterStagnant = [];
                for (var i = 0; i < object.waterStagnant.length; ++i)
                    message.waterStagnant[i] = Boolean(object.waterStagnant[i]);
            }
            if (object.waterSalt) {
                if (!Array.isArray(object.waterSalt))
                    throw TypeError(".RemoteFortressReader.MapBlock.waterSalt: array expected");
                message.waterSalt = [];
                for (var i = 0; i < object.waterSalt.length; ++i)
                    message.waterSalt[i] = Boolean(object.waterSalt[i]);
            }
            if (object.constructionItems) {
                if (!Array.isArray(object.constructionItems))
                    throw TypeError(".RemoteFortressReader.MapBlock.constructionItems: array expected");
                message.constructionItems = [];
                for (var i = 0; i < object.constructionItems.length; ++i) {
                    if (typeof object.constructionItems[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.constructionItems: object expected");
                    message.constructionItems[i] = $root.RemoteFortressReader.MatPair.fromObject(object.constructionItems[i]);
                }
            }
            if (object.buildings) {
                if (!Array.isArray(object.buildings))
                    throw TypeError(".RemoteFortressReader.MapBlock.buildings: array expected");
                message.buildings = [];
                for (var i = 0; i < object.buildings.length; ++i) {
                    if (typeof object.buildings[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.buildings: object expected");
                    message.buildings[i] = $root.RemoteFortressReader.BuildingInstance.fromObject(object.buildings[i]);
                }
            }
            if (object.treePercent) {
                if (!Array.isArray(object.treePercent))
                    throw TypeError(".RemoteFortressReader.MapBlock.treePercent: array expected");
                message.treePercent = [];
                for (var i = 0; i < object.treePercent.length; ++i)
                    message.treePercent[i] = object.treePercent[i] | 0;
            }
            if (object.treeX) {
                if (!Array.isArray(object.treeX))
                    throw TypeError(".RemoteFortressReader.MapBlock.treeX: array expected");
                message.treeX = [];
                for (var i = 0; i < object.treeX.length; ++i)
                    message.treeX[i] = object.treeX[i] | 0;
            }
            if (object.treeY) {
                if (!Array.isArray(object.treeY))
                    throw TypeError(".RemoteFortressReader.MapBlock.treeY: array expected");
                message.treeY = [];
                for (var i = 0; i < object.treeY.length; ++i)
                    message.treeY[i] = object.treeY[i] | 0;
            }
            if (object.treeZ) {
                if (!Array.isArray(object.treeZ))
                    throw TypeError(".RemoteFortressReader.MapBlock.treeZ: array expected");
                message.treeZ = [];
                for (var i = 0; i < object.treeZ.length; ++i)
                    message.treeZ[i] = object.treeZ[i] | 0;
            }
            if (object.tileDigDesignation) {
                if (!Array.isArray(object.tileDigDesignation))
                    throw TypeError(".RemoteFortressReader.MapBlock.tileDigDesignation: array expected");
                message.tileDigDesignation = [];
                for (var i = 0; i < object.tileDigDesignation.length; ++i)
                    switch (object.tileDigDesignation[i]) {
                    default:
                    case "NO_DIG":
                    case 0:
                        message.tileDigDesignation[i] = 0;
                        break;
                    case "DEFAULT_DIG":
                    case 1:
                        message.tileDigDesignation[i] = 1;
                        break;
                    case "UP_DOWN_STAIR_DIG":
                    case 2:
                        message.tileDigDesignation[i] = 2;
                        break;
                    case "CHANNEL_DIG":
                    case 3:
                        message.tileDigDesignation[i] = 3;
                        break;
                    case "RAMP_DIG":
                    case 4:
                        message.tileDigDesignation[i] = 4;
                        break;
                    case "DOWN_STAIR_DIG":
                    case 5:
                        message.tileDigDesignation[i] = 5;
                        break;
                    case "UP_STAIR_DIG":
                    case 6:
                        message.tileDigDesignation[i] = 6;
                        break;
                    }
            }
            if (object.spatterPile) {
                if (!Array.isArray(object.spatterPile))
                    throw TypeError(".RemoteFortressReader.MapBlock.spatterPile: array expected");
                message.spatterPile = [];
                for (var i = 0; i < object.spatterPile.length; ++i) {
                    if (typeof object.spatterPile[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.spatterPile: object expected");
                    message.spatterPile[i] = $root.RemoteFortressReader.SpatterPile.fromObject(object.spatterPile[i]);
                }
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".RemoteFortressReader.MapBlock.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.items: object expected");
                    message.items[i] = $root.RemoteFortressReader.Item.fromObject(object.items[i]);
                }
            }
            if (object.tileDigDesignationMarker) {
                if (!Array.isArray(object.tileDigDesignationMarker))
                    throw TypeError(".RemoteFortressReader.MapBlock.tileDigDesignationMarker: array expected");
                message.tileDigDesignationMarker = [];
                for (var i = 0; i < object.tileDigDesignationMarker.length; ++i)
                    message.tileDigDesignationMarker[i] = Boolean(object.tileDigDesignationMarker[i]);
            }
            if (object.tileDigDesignationAuto) {
                if (!Array.isArray(object.tileDigDesignationAuto))
                    throw TypeError(".RemoteFortressReader.MapBlock.tileDigDesignationAuto: array expected");
                message.tileDigDesignationAuto = [];
                for (var i = 0; i < object.tileDigDesignationAuto.length; ++i)
                    message.tileDigDesignationAuto[i] = Boolean(object.tileDigDesignationAuto[i]);
            }
            if (object.grassPercent) {
                if (!Array.isArray(object.grassPercent))
                    throw TypeError(".RemoteFortressReader.MapBlock.grassPercent: array expected");
                message.grassPercent = [];
                for (var i = 0; i < object.grassPercent.length; ++i)
                    message.grassPercent[i] = object.grassPercent[i] | 0;
            }
            if (object.flows) {
                if (!Array.isArray(object.flows))
                    throw TypeError(".RemoteFortressReader.MapBlock.flows: array expected");
                message.flows = [];
                for (var i = 0; i < object.flows.length; ++i) {
                    if (typeof object.flows[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MapBlock.flows: object expected");
                    message.flows[i] = $root.RemoteFortressReader.FlowInfo.fromObject(object.flows[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MapBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MapBlock
         * @static
         * @param {RemoteFortressReader.MapBlock} message MapBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapBlock.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.tiles = [];
                object.materials = [];
                object.layerMaterials = [];
                object.veinMaterials = [];
                object.baseMaterials = [];
                object.magma = [];
                object.water = [];
                object.hidden = [];
                object.light = [];
                object.subterranean = [];
                object.outside = [];
                object.aquifer = [];
                object.waterStagnant = [];
                object.waterSalt = [];
                object.constructionItems = [];
                object.buildings = [];
                object.treePercent = [];
                object.treeX = [];
                object.treeY = [];
                object.treeZ = [];
                object.tileDigDesignation = [];
                object.spatterPile = [];
                object.items = [];
                object.tileDigDesignationMarker = [];
                object.tileDigDesignationAuto = [];
                object.grassPercent = [];
                object.flows = [];
            }
            if (options.defaults) {
                object.mapX = 0;
                object.mapY = 0;
                object.mapZ = 0;
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.mapZ != null && message.hasOwnProperty("mapZ"))
                object.mapZ = message.mapZ;
            if (message.tiles && message.tiles.length) {
                object.tiles = [];
                for (var j = 0; j < message.tiles.length; ++j)
                    object.tiles[j] = message.tiles[j];
            }
            if (message.materials && message.materials.length) {
                object.materials = [];
                for (var j = 0; j < message.materials.length; ++j)
                    object.materials[j] = $root.RemoteFortressReader.MatPair.toObject(message.materials[j], options);
            }
            if (message.layerMaterials && message.layerMaterials.length) {
                object.layerMaterials = [];
                for (var j = 0; j < message.layerMaterials.length; ++j)
                    object.layerMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.layerMaterials[j], options);
            }
            if (message.veinMaterials && message.veinMaterials.length) {
                object.veinMaterials = [];
                for (var j = 0; j < message.veinMaterials.length; ++j)
                    object.veinMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.veinMaterials[j], options);
            }
            if (message.baseMaterials && message.baseMaterials.length) {
                object.baseMaterials = [];
                for (var j = 0; j < message.baseMaterials.length; ++j)
                    object.baseMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.baseMaterials[j], options);
            }
            if (message.magma && message.magma.length) {
                object.magma = [];
                for (var j = 0; j < message.magma.length; ++j)
                    object.magma[j] = message.magma[j];
            }
            if (message.water && message.water.length) {
                object.water = [];
                for (var j = 0; j < message.water.length; ++j)
                    object.water[j] = message.water[j];
            }
            if (message.hidden && message.hidden.length) {
                object.hidden = [];
                for (var j = 0; j < message.hidden.length; ++j)
                    object.hidden[j] = message.hidden[j];
            }
            if (message.light && message.light.length) {
                object.light = [];
                for (var j = 0; j < message.light.length; ++j)
                    object.light[j] = message.light[j];
            }
            if (message.subterranean && message.subterranean.length) {
                object.subterranean = [];
                for (var j = 0; j < message.subterranean.length; ++j)
                    object.subterranean[j] = message.subterranean[j];
            }
            if (message.outside && message.outside.length) {
                object.outside = [];
                for (var j = 0; j < message.outside.length; ++j)
                    object.outside[j] = message.outside[j];
            }
            if (message.aquifer && message.aquifer.length) {
                object.aquifer = [];
                for (var j = 0; j < message.aquifer.length; ++j)
                    object.aquifer[j] = message.aquifer[j];
            }
            if (message.waterStagnant && message.waterStagnant.length) {
                object.waterStagnant = [];
                for (var j = 0; j < message.waterStagnant.length; ++j)
                    object.waterStagnant[j] = message.waterStagnant[j];
            }
            if (message.waterSalt && message.waterSalt.length) {
                object.waterSalt = [];
                for (var j = 0; j < message.waterSalt.length; ++j)
                    object.waterSalt[j] = message.waterSalt[j];
            }
            if (message.constructionItems && message.constructionItems.length) {
                object.constructionItems = [];
                for (var j = 0; j < message.constructionItems.length; ++j)
                    object.constructionItems[j] = $root.RemoteFortressReader.MatPair.toObject(message.constructionItems[j], options);
            }
            if (message.buildings && message.buildings.length) {
                object.buildings = [];
                for (var j = 0; j < message.buildings.length; ++j)
                    object.buildings[j] = $root.RemoteFortressReader.BuildingInstance.toObject(message.buildings[j], options);
            }
            if (message.treePercent && message.treePercent.length) {
                object.treePercent = [];
                for (var j = 0; j < message.treePercent.length; ++j)
                    object.treePercent[j] = message.treePercent[j];
            }
            if (message.treeX && message.treeX.length) {
                object.treeX = [];
                for (var j = 0; j < message.treeX.length; ++j)
                    object.treeX[j] = message.treeX[j];
            }
            if (message.treeY && message.treeY.length) {
                object.treeY = [];
                for (var j = 0; j < message.treeY.length; ++j)
                    object.treeY[j] = message.treeY[j];
            }
            if (message.treeZ && message.treeZ.length) {
                object.treeZ = [];
                for (var j = 0; j < message.treeZ.length; ++j)
                    object.treeZ[j] = message.treeZ[j];
            }
            if (message.tileDigDesignation && message.tileDigDesignation.length) {
                object.tileDigDesignation = [];
                for (var j = 0; j < message.tileDigDesignation.length; ++j)
                    object.tileDigDesignation[j] = options.enums === String ? $root.RemoteFortressReader.TileDigDesignation[message.tileDigDesignation[j]] : message.tileDigDesignation[j];
            }
            if (message.spatterPile && message.spatterPile.length) {
                object.spatterPile = [];
                for (var j = 0; j < message.spatterPile.length; ++j)
                    object.spatterPile[j] = $root.RemoteFortressReader.SpatterPile.toObject(message.spatterPile[j], options);
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.RemoteFortressReader.Item.toObject(message.items[j], options);
            }
            if (message.tileDigDesignationMarker && message.tileDigDesignationMarker.length) {
                object.tileDigDesignationMarker = [];
                for (var j = 0; j < message.tileDigDesignationMarker.length; ++j)
                    object.tileDigDesignationMarker[j] = message.tileDigDesignationMarker[j];
            }
            if (message.tileDigDesignationAuto && message.tileDigDesignationAuto.length) {
                object.tileDigDesignationAuto = [];
                for (var j = 0; j < message.tileDigDesignationAuto.length; ++j)
                    object.tileDigDesignationAuto[j] = message.tileDigDesignationAuto[j];
            }
            if (message.grassPercent && message.grassPercent.length) {
                object.grassPercent = [];
                for (var j = 0; j < message.grassPercent.length; ++j)
                    object.grassPercent[j] = message.grassPercent[j];
            }
            if (message.flows && message.flows.length) {
                object.flows = [];
                for (var j = 0; j < message.flows.length; ++j)
                    object.flows[j] = $root.RemoteFortressReader.FlowInfo.toObject(message.flows[j], options);
            }
            return object;
        };

        /**
         * Converts this MapBlock to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MapBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapBlock.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapBlock;
    })();

    RemoteFortressReader.MatPair = (function() {

        /**
         * Properties of a MatPair.
         * @memberof RemoteFortressReader
         * @interface IMatPair
         * @property {number} matType MatPair matType
         * @property {number} matIndex MatPair matIndex
         */

        /**
         * Constructs a new MatPair.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MatPair.
         * @implements IMatPair
         * @constructor
         * @param {RemoteFortressReader.IMatPair=} [properties] Properties to set
         */
        function MatPair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatPair matType.
         * @member {number} matType
         * @memberof RemoteFortressReader.MatPair
         * @instance
         */
        MatPair.prototype.matType = 0;

        /**
         * MatPair matIndex.
         * @member {number} matIndex
         * @memberof RemoteFortressReader.MatPair
         * @instance
         */
        MatPair.prototype.matIndex = 0;

        /**
         * Creates a new MatPair instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.IMatPair=} [properties] Properties to set
         * @returns {RemoteFortressReader.MatPair} MatPair instance
         */
        MatPair.create = function create(properties) {
            return new MatPair(properties);
        };

        /**
         * Encodes the specified MatPair message. Does not implicitly {@link RemoteFortressReader.MatPair.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.IMatPair} message MatPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatPair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.matType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.matIndex);
            return writer;
        };

        /**
         * Encodes the specified MatPair message, length delimited. Does not implicitly {@link RemoteFortressReader.MatPair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.IMatPair} message MatPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatPair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatPair message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MatPair} MatPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatPair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MatPair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.matType = reader.int32();
                    break;
                case 2:
                    message.matIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("matType"))
                throw $util.ProtocolError("missing required 'matType'", { instance: message });
            if (!message.hasOwnProperty("matIndex"))
                throw $util.ProtocolError("missing required 'matIndex'", { instance: message });
            return message;
        };

        /**
         * Decodes a MatPair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MatPair} MatPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatPair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatPair message.
         * @function verify
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatPair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.matType))
                return "matType: integer expected";
            if (!$util.isInteger(message.matIndex))
                return "matIndex: integer expected";
            return null;
        };

        /**
         * Creates a MatPair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MatPair} MatPair
         */
        MatPair.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MatPair)
                return object;
            var message = new $root.RemoteFortressReader.MatPair();
            if (object.matType != null)
                message.matType = object.matType | 0;
            if (object.matIndex != null)
                message.matIndex = object.matIndex | 0;
            return message;
        };

        /**
         * Creates a plain object from a MatPair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MatPair
         * @static
         * @param {RemoteFortressReader.MatPair} message MatPair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MatPair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.matType = 0;
                object.matIndex = 0;
            }
            if (message.matType != null && message.hasOwnProperty("matType"))
                object.matType = message.matType;
            if (message.matIndex != null && message.hasOwnProperty("matIndex"))
                object.matIndex = message.matIndex;
            return object;
        };

        /**
         * Converts this MatPair to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MatPair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MatPair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MatPair;
    })();

    RemoteFortressReader.ColorDefinition = (function() {

        /**
         * Properties of a ColorDefinition.
         * @memberof RemoteFortressReader
         * @interface IColorDefinition
         * @property {number} red ColorDefinition red
         * @property {number} green ColorDefinition green
         * @property {number} blue ColorDefinition blue
         */

        /**
         * Constructs a new ColorDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ColorDefinition.
         * @implements IColorDefinition
         * @constructor
         * @param {RemoteFortressReader.IColorDefinition=} [properties] Properties to set
         */
        function ColorDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorDefinition red.
         * @member {number} red
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.red = 0;

        /**
         * ColorDefinition green.
         * @member {number} green
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.green = 0;

        /**
         * ColorDefinition blue.
         * @member {number} blue
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.blue = 0;

        /**
         * Creates a new ColorDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.IColorDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition instance
         */
        ColorDefinition.create = function create(properties) {
            return new ColorDefinition(properties);
        };

        /**
         * Encodes the specified ColorDefinition message. Does not implicitly {@link RemoteFortressReader.ColorDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.red);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.green);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blue);
            return writer;
        };

        /**
         * Encodes the specified ColorDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.ColorDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ColorDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.red = reader.int32();
                    break;
                case 2:
                    message.green = reader.int32();
                    break;
                case 3:
                    message.blue = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("red"))
                throw $util.ProtocolError("missing required 'red'", { instance: message });
            if (!message.hasOwnProperty("green"))
                throw $util.ProtocolError("missing required 'green'", { instance: message });
            if (!message.hasOwnProperty("blue"))
                throw $util.ProtocolError("missing required 'blue'", { instance: message });
            return message;
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.red))
                return "red: integer expected";
            if (!$util.isInteger(message.green))
                return "green: integer expected";
            if (!$util.isInteger(message.blue))
                return "blue: integer expected";
            return null;
        };

        /**
         * Creates a ColorDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ColorDefinition} ColorDefinition
         */
        ColorDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ColorDefinition)
                return object;
            var message = new $root.RemoteFortressReader.ColorDefinition();
            if (object.red != null)
                message.red = object.red | 0;
            if (object.green != null)
                message.green = object.green | 0;
            if (object.blue != null)
                message.blue = object.blue | 0;
            return message;
        };

        /**
         * Creates a plain object from a ColorDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ColorDefinition
         * @static
         * @param {RemoteFortressReader.ColorDefinition} message ColorDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.red = 0;
                object.green = 0;
                object.blue = 0;
            }
            if (message.red != null && message.hasOwnProperty("red"))
                object.red = message.red;
            if (message.green != null && message.hasOwnProperty("green"))
                object.green = message.green;
            if (message.blue != null && message.hasOwnProperty("blue"))
                object.blue = message.blue;
            return object;
        };

        /**
         * Converts this ColorDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ColorDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ColorDefinition;
    })();

    RemoteFortressReader.MaterialDefinition = (function() {

        /**
         * Properties of a MaterialDefinition.
         * @memberof RemoteFortressReader
         * @interface IMaterialDefinition
         * @property {RemoteFortressReader.IMatPair} matPair MaterialDefinition matPair
         * @property {string|null} [id] MaterialDefinition id
         * @property {string|null} [name] MaterialDefinition name
         * @property {RemoteFortressReader.IColorDefinition|null} [stateColor] MaterialDefinition stateColor
         * @property {ItemdefInstrument.IInstrumentDef|null} [instrument] MaterialDefinition instrument
         */

        /**
         * Constructs a new MaterialDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MaterialDefinition.
         * @implements IMaterialDefinition
         * @constructor
         * @param {RemoteFortressReader.IMaterialDefinition=} [properties] Properties to set
         */
        function MaterialDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaterialDefinition matPair.
         * @member {RemoteFortressReader.IMatPair} matPair
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.matPair = null;

        /**
         * MaterialDefinition id.
         * @member {string} id
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.id = "";

        /**
         * MaterialDefinition name.
         * @member {string} name
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.name = "";

        /**
         * MaterialDefinition stateColor.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} stateColor
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.stateColor = null;

        /**
         * MaterialDefinition instrument.
         * @member {ItemdefInstrument.IInstrumentDef|null|undefined} instrument
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         */
        MaterialDefinition.prototype.instrument = null;

        /**
         * Creates a new MaterialDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.IMaterialDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition instance
         */
        MaterialDefinition.create = function create(properties) {
            return new MaterialDefinition(properties);
        };

        /**
         * Encodes the specified MaterialDefinition message. Does not implicitly {@link RemoteFortressReader.MaterialDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.IMaterialDefinition} message MaterialDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.RemoteFortressReader.MatPair.encode(message.matPair, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.stateColor != null && Object.hasOwnProperty.call(message, "stateColor"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.stateColor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.instrument != null && Object.hasOwnProperty.call(message, "instrument"))
                $root.ItemdefInstrument.InstrumentDef.encode(message.instrument, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MaterialDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.MaterialDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.IMaterialDefinition} message MaterialDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaterialDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MaterialDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.matPair = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.stateColor = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.instrument = $root.ItemdefInstrument.InstrumentDef.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("matPair"))
                throw $util.ProtocolError("missing required 'matPair'", { instance: message });
            return message;
        };

        /**
         * Decodes a MaterialDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaterialDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaterialDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.RemoteFortressReader.MatPair.verify(message.matPair);
                if (error)
                    return "matPair." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.stateColor != null && message.hasOwnProperty("stateColor")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.stateColor);
                if (error)
                    return "stateColor." + error;
            }
            if (message.instrument != null && message.hasOwnProperty("instrument")) {
                var error = $root.ItemdefInstrument.InstrumentDef.verify(message.instrument);
                if (error)
                    return "instrument." + error;
            }
            return null;
        };

        /**
         * Creates a MaterialDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MaterialDefinition} MaterialDefinition
         */
        MaterialDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MaterialDefinition)
                return object;
            var message = new $root.RemoteFortressReader.MaterialDefinition();
            if (object.matPair != null) {
                if (typeof object.matPair !== "object")
                    throw TypeError(".RemoteFortressReader.MaterialDefinition.matPair: object expected");
                message.matPair = $root.RemoteFortressReader.MatPair.fromObject(object.matPair);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.stateColor != null) {
                if (typeof object.stateColor !== "object")
                    throw TypeError(".RemoteFortressReader.MaterialDefinition.stateColor: object expected");
                message.stateColor = $root.RemoteFortressReader.ColorDefinition.fromObject(object.stateColor);
            }
            if (object.instrument != null) {
                if (typeof object.instrument !== "object")
                    throw TypeError(".RemoteFortressReader.MaterialDefinition.instrument: object expected");
                message.instrument = $root.ItemdefInstrument.InstrumentDef.fromObject(object.instrument);
            }
            return message;
        };

        /**
         * Creates a plain object from a MaterialDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MaterialDefinition
         * @static
         * @param {RemoteFortressReader.MaterialDefinition} message MaterialDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaterialDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.matPair = null;
                object.id = "";
                object.name = "";
                object.stateColor = null;
                object.instrument = null;
            }
            if (message.matPair != null && message.hasOwnProperty("matPair"))
                object.matPair = $root.RemoteFortressReader.MatPair.toObject(message.matPair, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.stateColor != null && message.hasOwnProperty("stateColor"))
                object.stateColor = $root.RemoteFortressReader.ColorDefinition.toObject(message.stateColor, options);
            if (message.instrument != null && message.hasOwnProperty("instrument"))
                object.instrument = $root.ItemdefInstrument.InstrumentDef.toObject(message.instrument, options);
            return object;
        };

        /**
         * Converts this MaterialDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MaterialDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaterialDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MaterialDefinition;
    })();

    RemoteFortressReader.BuildingType = (function() {

        /**
         * Properties of a BuildingType.
         * @memberof RemoteFortressReader
         * @interface IBuildingType
         * @property {number} buildingType BuildingType buildingType
         * @property {number} buildingSubtype BuildingType buildingSubtype
         * @property {number} buildingCustom BuildingType buildingCustom
         */

        /**
         * Constructs a new BuildingType.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingType.
         * @implements IBuildingType
         * @constructor
         * @param {RemoteFortressReader.IBuildingType=} [properties] Properties to set
         */
        function BuildingType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingType buildingType.
         * @member {number} buildingType
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         */
        BuildingType.prototype.buildingType = 0;

        /**
         * BuildingType buildingSubtype.
         * @member {number} buildingSubtype
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         */
        BuildingType.prototype.buildingSubtype = 0;

        /**
         * BuildingType buildingCustom.
         * @member {number} buildingCustom
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         */
        BuildingType.prototype.buildingCustom = 0;

        /**
         * Creates a new BuildingType instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.IBuildingType=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingType} BuildingType instance
         */
        BuildingType.create = function create(properties) {
            return new BuildingType(properties);
        };

        /**
         * Encodes the specified BuildingType message. Does not implicitly {@link RemoteFortressReader.BuildingType.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.IBuildingType} message BuildingType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buildingType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buildingSubtype);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.buildingCustom);
            return writer;
        };

        /**
         * Encodes the specified BuildingType message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.IBuildingType} message BuildingType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingType message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingType} BuildingType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buildingType = reader.int32();
                    break;
                case 2:
                    message.buildingSubtype = reader.int32();
                    break;
                case 3:
                    message.buildingCustom = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("buildingType"))
                throw $util.ProtocolError("missing required 'buildingType'", { instance: message });
            if (!message.hasOwnProperty("buildingSubtype"))
                throw $util.ProtocolError("missing required 'buildingSubtype'", { instance: message });
            if (!message.hasOwnProperty("buildingCustom"))
                throw $util.ProtocolError("missing required 'buildingCustom'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingType} BuildingType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingType message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.buildingType))
                return "buildingType: integer expected";
            if (!$util.isInteger(message.buildingSubtype))
                return "buildingSubtype: integer expected";
            if (!$util.isInteger(message.buildingCustom))
                return "buildingCustom: integer expected";
            return null;
        };

        /**
         * Creates a BuildingType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingType} BuildingType
         */
        BuildingType.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingType)
                return object;
            var message = new $root.RemoteFortressReader.BuildingType();
            if (object.buildingType != null)
                message.buildingType = object.buildingType | 0;
            if (object.buildingSubtype != null)
                message.buildingSubtype = object.buildingSubtype | 0;
            if (object.buildingCustom != null)
                message.buildingCustom = object.buildingCustom | 0;
            return message;
        };

        /**
         * Creates a plain object from a BuildingType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingType
         * @static
         * @param {RemoteFortressReader.BuildingType} message BuildingType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buildingType = 0;
                object.buildingSubtype = 0;
                object.buildingCustom = 0;
            }
            if (message.buildingType != null && message.hasOwnProperty("buildingType"))
                object.buildingType = message.buildingType;
            if (message.buildingSubtype != null && message.hasOwnProperty("buildingSubtype"))
                object.buildingSubtype = message.buildingSubtype;
            if (message.buildingCustom != null && message.hasOwnProperty("buildingCustom"))
                object.buildingCustom = message.buildingCustom;
            return object;
        };

        /**
         * Converts this BuildingType to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingType;
    })();

    RemoteFortressReader.BuildingDefinition = (function() {

        /**
         * Properties of a BuildingDefinition.
         * @memberof RemoteFortressReader
         * @interface IBuildingDefinition
         * @property {RemoteFortressReader.IBuildingType} buildingType BuildingDefinition buildingType
         * @property {string|null} [id] BuildingDefinition id
         * @property {string|null} [name] BuildingDefinition name
         */

        /**
         * Constructs a new BuildingDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingDefinition.
         * @implements IBuildingDefinition
         * @constructor
         * @param {RemoteFortressReader.IBuildingDefinition=} [properties] Properties to set
         */
        function BuildingDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingDefinition buildingType.
         * @member {RemoteFortressReader.IBuildingType} buildingType
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         */
        BuildingDefinition.prototype.buildingType = null;

        /**
         * BuildingDefinition id.
         * @member {string} id
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         */
        BuildingDefinition.prototype.id = "";

        /**
         * BuildingDefinition name.
         * @member {string} name
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         */
        BuildingDefinition.prototype.name = "";

        /**
         * Creates a new BuildingDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.IBuildingDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition instance
         */
        BuildingDefinition.create = function create(properties) {
            return new BuildingDefinition(properties);
        };

        /**
         * Encodes the specified BuildingDefinition message. Does not implicitly {@link RemoteFortressReader.BuildingDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.IBuildingDefinition} message BuildingDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.RemoteFortressReader.BuildingType.encode(message.buildingType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified BuildingDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.IBuildingDefinition} message BuildingDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buildingType = $root.RemoteFortressReader.BuildingType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("buildingType"))
                throw $util.ProtocolError("missing required 'buildingType'", { instance: message });
            return message;
        };

        /**
         * Decodes a BuildingDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.RemoteFortressReader.BuildingType.verify(message.buildingType);
                if (error)
                    return "buildingType." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a BuildingDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingDefinition} BuildingDefinition
         */
        BuildingDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingDefinition)
                return object;
            var message = new $root.RemoteFortressReader.BuildingDefinition();
            if (object.buildingType != null) {
                if (typeof object.buildingType !== "object")
                    throw TypeError(".RemoteFortressReader.BuildingDefinition.buildingType: object expected");
                message.buildingType = $root.RemoteFortressReader.BuildingType.fromObject(object.buildingType);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a BuildingDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingDefinition
         * @static
         * @param {RemoteFortressReader.BuildingDefinition} message BuildingDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buildingType = null;
                object.id = "";
                object.name = "";
            }
            if (message.buildingType != null && message.hasOwnProperty("buildingType"))
                object.buildingType = $root.RemoteFortressReader.BuildingType.toObject(message.buildingType, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this BuildingDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingDefinition;
    })();

    RemoteFortressReader.BuildingList = (function() {

        /**
         * Properties of a BuildingList.
         * @memberof RemoteFortressReader
         * @interface IBuildingList
         * @property {Array.<RemoteFortressReader.IBuildingDefinition>|null} [buildingList] BuildingList buildingList
         */

        /**
         * Constructs a new BuildingList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BuildingList.
         * @implements IBuildingList
         * @constructor
         * @param {RemoteFortressReader.IBuildingList=} [properties] Properties to set
         */
        function BuildingList(properties) {
            this.buildingList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingList buildingList.
         * @member {Array.<RemoteFortressReader.IBuildingDefinition>} buildingList
         * @memberof RemoteFortressReader.BuildingList
         * @instance
         */
        BuildingList.prototype.buildingList = $util.emptyArray;

        /**
         * Creates a new BuildingList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.IBuildingList=} [properties] Properties to set
         * @returns {RemoteFortressReader.BuildingList} BuildingList instance
         */
        BuildingList.create = function create(properties) {
            return new BuildingList(properties);
        };

        /**
         * Encodes the specified BuildingList message. Does not implicitly {@link RemoteFortressReader.BuildingList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.IBuildingList} message BuildingList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buildingList != null && message.buildingList.length)
                for (var i = 0; i < message.buildingList.length; ++i)
                    $root.RemoteFortressReader.BuildingDefinition.encode(message.buildingList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BuildingList message, length delimited. Does not implicitly {@link RemoteFortressReader.BuildingList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.IBuildingList} message BuildingList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BuildingList} BuildingList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BuildingList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.buildingList && message.buildingList.length))
                        message.buildingList = [];
                    message.buildingList.push($root.RemoteFortressReader.BuildingDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuildingList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BuildingList} BuildingList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingList message.
         * @function verify
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buildingList != null && message.hasOwnProperty("buildingList")) {
                if (!Array.isArray(message.buildingList))
                    return "buildingList: array expected";
                for (var i = 0; i < message.buildingList.length; ++i) {
                    var error = $root.RemoteFortressReader.BuildingDefinition.verify(message.buildingList[i]);
                    if (error)
                        return "buildingList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BuildingList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BuildingList} BuildingList
         */
        BuildingList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BuildingList)
                return object;
            var message = new $root.RemoteFortressReader.BuildingList();
            if (object.buildingList) {
                if (!Array.isArray(object.buildingList))
                    throw TypeError(".RemoteFortressReader.BuildingList.buildingList: array expected");
                message.buildingList = [];
                for (var i = 0; i < object.buildingList.length; ++i) {
                    if (typeof object.buildingList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BuildingList.buildingList: object expected");
                    message.buildingList[i] = $root.RemoteFortressReader.BuildingDefinition.fromObject(object.buildingList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BuildingList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BuildingList
         * @static
         * @param {RemoteFortressReader.BuildingList} message BuildingList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buildingList = [];
            if (message.buildingList && message.buildingList.length) {
                object.buildingList = [];
                for (var j = 0; j < message.buildingList.length; ++j)
                    object.buildingList[j] = $root.RemoteFortressReader.BuildingDefinition.toObject(message.buildingList[j], options);
            }
            return object;
        };

        /**
         * Converts this BuildingList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BuildingList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuildingList;
    })();

    RemoteFortressReader.MaterialList = (function() {

        /**
         * Properties of a MaterialList.
         * @memberof RemoteFortressReader
         * @interface IMaterialList
         * @property {Array.<RemoteFortressReader.IMaterialDefinition>|null} [materialList] MaterialList materialList
         */

        /**
         * Constructs a new MaterialList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MaterialList.
         * @implements IMaterialList
         * @constructor
         * @param {RemoteFortressReader.IMaterialList=} [properties] Properties to set
         */
        function MaterialList(properties) {
            this.materialList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaterialList materialList.
         * @member {Array.<RemoteFortressReader.IMaterialDefinition>} materialList
         * @memberof RemoteFortressReader.MaterialList
         * @instance
         */
        MaterialList.prototype.materialList = $util.emptyArray;

        /**
         * Creates a new MaterialList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.IMaterialList=} [properties] Properties to set
         * @returns {RemoteFortressReader.MaterialList} MaterialList instance
         */
        MaterialList.create = function create(properties) {
            return new MaterialList(properties);
        };

        /**
         * Encodes the specified MaterialList message. Does not implicitly {@link RemoteFortressReader.MaterialList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.IMaterialList} message MaterialList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.materialList != null && message.materialList.length)
                for (var i = 0; i < message.materialList.length; ++i)
                    $root.RemoteFortressReader.MaterialDefinition.encode(message.materialList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MaterialList message, length delimited. Does not implicitly {@link RemoteFortressReader.MaterialList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.IMaterialList} message MaterialList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterialList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaterialList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MaterialList} MaterialList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MaterialList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.materialList && message.materialList.length))
                        message.materialList = [];
                    message.materialList.push($root.RemoteFortressReader.MaterialDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MaterialList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MaterialList} MaterialList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterialList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaterialList message.
         * @function verify
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaterialList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.materialList != null && message.hasOwnProperty("materialList")) {
                if (!Array.isArray(message.materialList))
                    return "materialList: array expected";
                for (var i = 0; i < message.materialList.length; ++i) {
                    var error = $root.RemoteFortressReader.MaterialDefinition.verify(message.materialList[i]);
                    if (error)
                        return "materialList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MaterialList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MaterialList} MaterialList
         */
        MaterialList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MaterialList)
                return object;
            var message = new $root.RemoteFortressReader.MaterialList();
            if (object.materialList) {
                if (!Array.isArray(object.materialList))
                    throw TypeError(".RemoteFortressReader.MaterialList.materialList: array expected");
                message.materialList = [];
                for (var i = 0; i < object.materialList.length; ++i) {
                    if (typeof object.materialList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.MaterialList.materialList: object expected");
                    message.materialList[i] = $root.RemoteFortressReader.MaterialDefinition.fromObject(object.materialList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MaterialList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MaterialList
         * @static
         * @param {RemoteFortressReader.MaterialList} message MaterialList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaterialList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.materialList = [];
            if (message.materialList && message.materialList.length) {
                object.materialList = [];
                for (var j = 0; j < message.materialList.length; ++j)
                    object.materialList[j] = $root.RemoteFortressReader.MaterialDefinition.toObject(message.materialList[j], options);
            }
            return object;
        };

        /**
         * Converts this MaterialList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MaterialList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaterialList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MaterialList;
    })();

    RemoteFortressReader.Hair = (function() {

        /**
         * Properties of a Hair.
         * @memberof RemoteFortressReader
         * @interface IHair
         * @property {number|null} [length] Hair length
         * @property {RemoteFortressReader.HairStyle|null} [style] Hair style
         */

        /**
         * Constructs a new Hair.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Hair.
         * @implements IHair
         * @constructor
         * @param {RemoteFortressReader.IHair=} [properties] Properties to set
         */
        function Hair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hair length.
         * @member {number} length
         * @memberof RemoteFortressReader.Hair
         * @instance
         */
        Hair.prototype.length = 0;

        /**
         * Hair style.
         * @member {RemoteFortressReader.HairStyle} style
         * @memberof RemoteFortressReader.Hair
         * @instance
         */
        Hair.prototype.style = -1;

        /**
         * Creates a new Hair instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.IHair=} [properties] Properties to set
         * @returns {RemoteFortressReader.Hair} Hair instance
         */
        Hair.create = function create(properties) {
            return new Hair(properties);
        };

        /**
         * Encodes the specified Hair message. Does not implicitly {@link RemoteFortressReader.Hair.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.IHair} message Hair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.length);
            if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.style);
            return writer;
        };

        /**
         * Encodes the specified Hair message, length delimited. Does not implicitly {@link RemoteFortressReader.Hair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.IHair} message Hair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hair message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Hair} Hair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Hair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.length = reader.int32();
                    break;
                case 2:
                    message.style = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Hair} Hair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hair message.
         * @function verify
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length"))
                if (!$util.isInteger(message.length))
                    return "length: integer expected";
            if (message.style != null && message.hasOwnProperty("style"))
                switch (message.style) {
                default:
                    return "style: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a Hair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Hair} Hair
         */
        Hair.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Hair)
                return object;
            var message = new $root.RemoteFortressReader.Hair();
            if (object.length != null)
                message.length = object.length | 0;
            switch (object.style) {
            case "UNKEMPT":
            case -1:
                message.style = -1;
                break;
            case "NEATLY_COMBED":
            case 0:
                message.style = 0;
                break;
            case "BRAIDED":
            case 1:
                message.style = 1;
                break;
            case "DOUBLE_BRAID":
            case 2:
                message.style = 2;
                break;
            case "PONY_TAILS":
            case 3:
                message.style = 3;
                break;
            case "CLEAN_SHAVEN":
            case 4:
                message.style = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Hair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Hair
         * @static
         * @param {RemoteFortressReader.Hair} message Hair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.length = 0;
                object.style = options.enums === String ? "UNKEMPT" : -1;
            }
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = message.length;
            if (message.style != null && message.hasOwnProperty("style"))
                object.style = options.enums === String ? $root.RemoteFortressReader.HairStyle[message.style] : message.style;
            return object;
        };

        /**
         * Converts this Hair to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Hair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Hair;
    })();

    RemoteFortressReader.BodySizeInfo = (function() {

        /**
         * Properties of a BodySizeInfo.
         * @memberof RemoteFortressReader
         * @interface IBodySizeInfo
         * @property {number|null} [sizeCur] BodySizeInfo sizeCur
         * @property {number|null} [sizeBase] BodySizeInfo sizeBase
         * @property {number|null} [areaCur] BodySizeInfo areaCur
         * @property {number|null} [areaBase] BodySizeInfo areaBase
         * @property {number|null} [lengthCur] BodySizeInfo lengthCur
         * @property {number|null} [lengthBase] BodySizeInfo lengthBase
         */

        /**
         * Constructs a new BodySizeInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BodySizeInfo.
         * @implements IBodySizeInfo
         * @constructor
         * @param {RemoteFortressReader.IBodySizeInfo=} [properties] Properties to set
         */
        function BodySizeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BodySizeInfo sizeCur.
         * @member {number} sizeCur
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.sizeCur = 0;

        /**
         * BodySizeInfo sizeBase.
         * @member {number} sizeBase
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.sizeBase = 0;

        /**
         * BodySizeInfo areaCur.
         * @member {number} areaCur
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.areaCur = 0;

        /**
         * BodySizeInfo areaBase.
         * @member {number} areaBase
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.areaBase = 0;

        /**
         * BodySizeInfo lengthCur.
         * @member {number} lengthCur
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.lengthCur = 0;

        /**
         * BodySizeInfo lengthBase.
         * @member {number} lengthBase
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         */
        BodySizeInfo.prototype.lengthBase = 0;

        /**
         * Creates a new BodySizeInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.IBodySizeInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo instance
         */
        BodySizeInfo.create = function create(properties) {
            return new BodySizeInfo(properties);
        };

        /**
         * Encodes the specified BodySizeInfo message. Does not implicitly {@link RemoteFortressReader.BodySizeInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.IBodySizeInfo} message BodySizeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodySizeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sizeCur != null && Object.hasOwnProperty.call(message, "sizeCur"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sizeCur);
            if (message.sizeBase != null && Object.hasOwnProperty.call(message, "sizeBase"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sizeBase);
            if (message.areaCur != null && Object.hasOwnProperty.call(message, "areaCur"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.areaCur);
            if (message.areaBase != null && Object.hasOwnProperty.call(message, "areaBase"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.areaBase);
            if (message.lengthCur != null && Object.hasOwnProperty.call(message, "lengthCur"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lengthCur);
            if (message.lengthBase != null && Object.hasOwnProperty.call(message, "lengthBase"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lengthBase);
            return writer;
        };

        /**
         * Encodes the specified BodySizeInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.BodySizeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.IBodySizeInfo} message BodySizeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodySizeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BodySizeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodySizeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BodySizeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sizeCur = reader.int32();
                    break;
                case 2:
                    message.sizeBase = reader.int32();
                    break;
                case 3:
                    message.areaCur = reader.int32();
                    break;
                case 4:
                    message.areaBase = reader.int32();
                    break;
                case 5:
                    message.lengthCur = reader.int32();
                    break;
                case 6:
                    message.lengthBase = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BodySizeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodySizeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BodySizeInfo message.
         * @function verify
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BodySizeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sizeCur != null && message.hasOwnProperty("sizeCur"))
                if (!$util.isInteger(message.sizeCur))
                    return "sizeCur: integer expected";
            if (message.sizeBase != null && message.hasOwnProperty("sizeBase"))
                if (!$util.isInteger(message.sizeBase))
                    return "sizeBase: integer expected";
            if (message.areaCur != null && message.hasOwnProperty("areaCur"))
                if (!$util.isInteger(message.areaCur))
                    return "areaCur: integer expected";
            if (message.areaBase != null && message.hasOwnProperty("areaBase"))
                if (!$util.isInteger(message.areaBase))
                    return "areaBase: integer expected";
            if (message.lengthCur != null && message.hasOwnProperty("lengthCur"))
                if (!$util.isInteger(message.lengthCur))
                    return "lengthCur: integer expected";
            if (message.lengthBase != null && message.hasOwnProperty("lengthBase"))
                if (!$util.isInteger(message.lengthBase))
                    return "lengthBase: integer expected";
            return null;
        };

        /**
         * Creates a BodySizeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BodySizeInfo} BodySizeInfo
         */
        BodySizeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BodySizeInfo)
                return object;
            var message = new $root.RemoteFortressReader.BodySizeInfo();
            if (object.sizeCur != null)
                message.sizeCur = object.sizeCur | 0;
            if (object.sizeBase != null)
                message.sizeBase = object.sizeBase | 0;
            if (object.areaCur != null)
                message.areaCur = object.areaCur | 0;
            if (object.areaBase != null)
                message.areaBase = object.areaBase | 0;
            if (object.lengthCur != null)
                message.lengthCur = object.lengthCur | 0;
            if (object.lengthBase != null)
                message.lengthBase = object.lengthBase | 0;
            return message;
        };

        /**
         * Creates a plain object from a BodySizeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BodySizeInfo
         * @static
         * @param {RemoteFortressReader.BodySizeInfo} message BodySizeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BodySizeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sizeCur = 0;
                object.sizeBase = 0;
                object.areaCur = 0;
                object.areaBase = 0;
                object.lengthCur = 0;
                object.lengthBase = 0;
            }
            if (message.sizeCur != null && message.hasOwnProperty("sizeCur"))
                object.sizeCur = message.sizeCur;
            if (message.sizeBase != null && message.hasOwnProperty("sizeBase"))
                object.sizeBase = message.sizeBase;
            if (message.areaCur != null && message.hasOwnProperty("areaCur"))
                object.areaCur = message.areaCur;
            if (message.areaBase != null && message.hasOwnProperty("areaBase"))
                object.areaBase = message.areaBase;
            if (message.lengthCur != null && message.hasOwnProperty("lengthCur"))
                object.lengthCur = message.lengthCur;
            if (message.lengthBase != null && message.hasOwnProperty("lengthBase"))
                object.lengthBase = message.lengthBase;
            return object;
        };

        /**
         * Converts this BodySizeInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BodySizeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BodySizeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BodySizeInfo;
    })();

    RemoteFortressReader.UnitAppearance = (function() {

        /**
         * Properties of an UnitAppearance.
         * @memberof RemoteFortressReader
         * @interface IUnitAppearance
         * @property {Array.<number>|null} [bodyModifiers] UnitAppearance bodyModifiers
         * @property {Array.<number>|null} [bpModifiers] UnitAppearance bpModifiers
         * @property {number|null} [sizeModifier] UnitAppearance sizeModifier
         * @property {Array.<number>|null} [colors] UnitAppearance colors
         * @property {RemoteFortressReader.IHair|null} [hair] UnitAppearance hair
         * @property {RemoteFortressReader.IHair|null} [beard] UnitAppearance beard
         * @property {RemoteFortressReader.IHair|null} [moustache] UnitAppearance moustache
         * @property {RemoteFortressReader.IHair|null} [sideburns] UnitAppearance sideburns
         */

        /**
         * Constructs a new UnitAppearance.
         * @memberof RemoteFortressReader
         * @classdesc Represents an UnitAppearance.
         * @implements IUnitAppearance
         * @constructor
         * @param {RemoteFortressReader.IUnitAppearance=} [properties] Properties to set
         */
        function UnitAppearance(properties) {
            this.bodyModifiers = [];
            this.bpModifiers = [];
            this.colors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitAppearance bodyModifiers.
         * @member {Array.<number>} bodyModifiers
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.bodyModifiers = $util.emptyArray;

        /**
         * UnitAppearance bpModifiers.
         * @member {Array.<number>} bpModifiers
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.bpModifiers = $util.emptyArray;

        /**
         * UnitAppearance sizeModifier.
         * @member {number} sizeModifier
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.sizeModifier = 0;

        /**
         * UnitAppearance colors.
         * @member {Array.<number>} colors
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.colors = $util.emptyArray;

        /**
         * UnitAppearance hair.
         * @member {RemoteFortressReader.IHair|null|undefined} hair
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.hair = null;

        /**
         * UnitAppearance beard.
         * @member {RemoteFortressReader.IHair|null|undefined} beard
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.beard = null;

        /**
         * UnitAppearance moustache.
         * @member {RemoteFortressReader.IHair|null|undefined} moustache
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.moustache = null;

        /**
         * UnitAppearance sideburns.
         * @member {RemoteFortressReader.IHair|null|undefined} sideburns
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         */
        UnitAppearance.prototype.sideburns = null;

        /**
         * Creates a new UnitAppearance instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.IUnitAppearance=} [properties] Properties to set
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance instance
         */
        UnitAppearance.create = function create(properties) {
            return new UnitAppearance(properties);
        };

        /**
         * Encodes the specified UnitAppearance message. Does not implicitly {@link RemoteFortressReader.UnitAppearance.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.IUnitAppearance} message UnitAppearance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitAppearance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bodyModifiers != null && message.bodyModifiers.length)
                for (var i = 0; i < message.bodyModifiers.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bodyModifiers[i]);
            if (message.bpModifiers != null && message.bpModifiers.length)
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bpModifiers[i]);
            if (message.sizeModifier != null && Object.hasOwnProperty.call(message, "sizeModifier"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sizeModifier);
            if (message.colors != null && message.colors.length)
                for (var i = 0; i < message.colors.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.colors[i]);
            if (message.hair != null && Object.hasOwnProperty.call(message, "hair"))
                $root.RemoteFortressReader.Hair.encode(message.hair, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.beard != null && Object.hasOwnProperty.call(message, "beard"))
                $root.RemoteFortressReader.Hair.encode(message.beard, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.moustache != null && Object.hasOwnProperty.call(message, "moustache"))
                $root.RemoteFortressReader.Hair.encode(message.moustache, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.sideburns != null && Object.hasOwnProperty.call(message, "sideburns"))
                $root.RemoteFortressReader.Hair.encode(message.sideburns, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnitAppearance message, length delimited. Does not implicitly {@link RemoteFortressReader.UnitAppearance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.IUnitAppearance} message UnitAppearance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitAppearance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitAppearance message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitAppearance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.UnitAppearance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.bodyModifiers && message.bodyModifiers.length))
                        message.bodyModifiers = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bodyModifiers.push(reader.int32());
                    } else
                        message.bodyModifiers.push(reader.int32());
                    break;
                case 2:
                    if (!(message.bpModifiers && message.bpModifiers.length))
                        message.bpModifiers = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bpModifiers.push(reader.int32());
                    } else
                        message.bpModifiers.push(reader.int32());
                    break;
                case 3:
                    message.sizeModifier = reader.int32();
                    break;
                case 4:
                    if (!(message.colors && message.colors.length))
                        message.colors = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.colors.push(reader.int32());
                    } else
                        message.colors.push(reader.int32());
                    break;
                case 5:
                    message.hair = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.beard = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.moustache = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.sideburns = $root.RemoteFortressReader.Hair.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnitAppearance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitAppearance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitAppearance message.
         * @function verify
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitAppearance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bodyModifiers != null && message.hasOwnProperty("bodyModifiers")) {
                if (!Array.isArray(message.bodyModifiers))
                    return "bodyModifiers: array expected";
                for (var i = 0; i < message.bodyModifiers.length; ++i)
                    if (!$util.isInteger(message.bodyModifiers[i]))
                        return "bodyModifiers: integer[] expected";
            }
            if (message.bpModifiers != null && message.hasOwnProperty("bpModifiers")) {
                if (!Array.isArray(message.bpModifiers))
                    return "bpModifiers: array expected";
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    if (!$util.isInteger(message.bpModifiers[i]))
                        return "bpModifiers: integer[] expected";
            }
            if (message.sizeModifier != null && message.hasOwnProperty("sizeModifier"))
                if (!$util.isInteger(message.sizeModifier))
                    return "sizeModifier: integer expected";
            if (message.colors != null && message.hasOwnProperty("colors")) {
                if (!Array.isArray(message.colors))
                    return "colors: array expected";
                for (var i = 0; i < message.colors.length; ++i)
                    if (!$util.isInteger(message.colors[i]))
                        return "colors: integer[] expected";
            }
            if (message.hair != null && message.hasOwnProperty("hair")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.hair);
                if (error)
                    return "hair." + error;
            }
            if (message.beard != null && message.hasOwnProperty("beard")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.beard);
                if (error)
                    return "beard." + error;
            }
            if (message.moustache != null && message.hasOwnProperty("moustache")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.moustache);
                if (error)
                    return "moustache." + error;
            }
            if (message.sideburns != null && message.hasOwnProperty("sideburns")) {
                var error = $root.RemoteFortressReader.Hair.verify(message.sideburns);
                if (error)
                    return "sideburns." + error;
            }
            return null;
        };

        /**
         * Creates an UnitAppearance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.UnitAppearance} UnitAppearance
         */
        UnitAppearance.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.UnitAppearance)
                return object;
            var message = new $root.RemoteFortressReader.UnitAppearance();
            if (object.bodyModifiers) {
                if (!Array.isArray(object.bodyModifiers))
                    throw TypeError(".RemoteFortressReader.UnitAppearance.bodyModifiers: array expected");
                message.bodyModifiers = [];
                for (var i = 0; i < object.bodyModifiers.length; ++i)
                    message.bodyModifiers[i] = object.bodyModifiers[i] | 0;
            }
            if (object.bpModifiers) {
                if (!Array.isArray(object.bpModifiers))
                    throw TypeError(".RemoteFortressReader.UnitAppearance.bpModifiers: array expected");
                message.bpModifiers = [];
                for (var i = 0; i < object.bpModifiers.length; ++i)
                    message.bpModifiers[i] = object.bpModifiers[i] | 0;
            }
            if (object.sizeModifier != null)
                message.sizeModifier = object.sizeModifier | 0;
            if (object.colors) {
                if (!Array.isArray(object.colors))
                    throw TypeError(".RemoteFortressReader.UnitAppearance.colors: array expected");
                message.colors = [];
                for (var i = 0; i < object.colors.length; ++i)
                    message.colors[i] = object.colors[i] | 0;
            }
            if (object.hair != null) {
                if (typeof object.hair !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.hair: object expected");
                message.hair = $root.RemoteFortressReader.Hair.fromObject(object.hair);
            }
            if (object.beard != null) {
                if (typeof object.beard !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.beard: object expected");
                message.beard = $root.RemoteFortressReader.Hair.fromObject(object.beard);
            }
            if (object.moustache != null) {
                if (typeof object.moustache !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.moustache: object expected");
                message.moustache = $root.RemoteFortressReader.Hair.fromObject(object.moustache);
            }
            if (object.sideburns != null) {
                if (typeof object.sideburns !== "object")
                    throw TypeError(".RemoteFortressReader.UnitAppearance.sideburns: object expected");
                message.sideburns = $root.RemoteFortressReader.Hair.fromObject(object.sideburns);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnitAppearance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.UnitAppearance
         * @static
         * @param {RemoteFortressReader.UnitAppearance} message UnitAppearance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitAppearance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.bodyModifiers = [];
                object.bpModifiers = [];
                object.colors = [];
            }
            if (options.defaults) {
                object.sizeModifier = 0;
                object.hair = null;
                object.beard = null;
                object.moustache = null;
                object.sideburns = null;
            }
            if (message.bodyModifiers && message.bodyModifiers.length) {
                object.bodyModifiers = [];
                for (var j = 0; j < message.bodyModifiers.length; ++j)
                    object.bodyModifiers[j] = message.bodyModifiers[j];
            }
            if (message.bpModifiers && message.bpModifiers.length) {
                object.bpModifiers = [];
                for (var j = 0; j < message.bpModifiers.length; ++j)
                    object.bpModifiers[j] = message.bpModifiers[j];
            }
            if (message.sizeModifier != null && message.hasOwnProperty("sizeModifier"))
                object.sizeModifier = message.sizeModifier;
            if (message.colors && message.colors.length) {
                object.colors = [];
                for (var j = 0; j < message.colors.length; ++j)
                    object.colors[j] = message.colors[j];
            }
            if (message.hair != null && message.hasOwnProperty("hair"))
                object.hair = $root.RemoteFortressReader.Hair.toObject(message.hair, options);
            if (message.beard != null && message.hasOwnProperty("beard"))
                object.beard = $root.RemoteFortressReader.Hair.toObject(message.beard, options);
            if (message.moustache != null && message.hasOwnProperty("moustache"))
                object.moustache = $root.RemoteFortressReader.Hair.toObject(message.moustache, options);
            if (message.sideburns != null && message.hasOwnProperty("sideburns"))
                object.sideburns = $root.RemoteFortressReader.Hair.toObject(message.sideburns, options);
            return object;
        };

        /**
         * Converts this UnitAppearance to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.UnitAppearance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitAppearance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitAppearance;
    })();

    RemoteFortressReader.InventoryItem = (function() {

        /**
         * Properties of an InventoryItem.
         * @memberof RemoteFortressReader
         * @interface IInventoryItem
         * @property {RemoteFortressReader.InventoryMode|null} [mode] InventoryItem mode
         * @property {RemoteFortressReader.IItem|null} [item] InventoryItem item
         */

        /**
         * Constructs a new InventoryItem.
         * @memberof RemoteFortressReader
         * @classdesc Represents an InventoryItem.
         * @implements IInventoryItem
         * @constructor
         * @param {RemoteFortressReader.IInventoryItem=} [properties] Properties to set
         */
        function InventoryItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InventoryItem mode.
         * @member {RemoteFortressReader.InventoryMode} mode
         * @memberof RemoteFortressReader.InventoryItem
         * @instance
         */
        InventoryItem.prototype.mode = 0;

        /**
         * InventoryItem item.
         * @member {RemoteFortressReader.IItem|null|undefined} item
         * @memberof RemoteFortressReader.InventoryItem
         * @instance
         */
        InventoryItem.prototype.item = null;

        /**
         * Creates a new InventoryItem instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.IInventoryItem=} [properties] Properties to set
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem instance
         */
        InventoryItem.create = function create(properties) {
            return new InventoryItem(properties);
        };

        /**
         * Encodes the specified InventoryItem message. Does not implicitly {@link RemoteFortressReader.InventoryItem.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.IInventoryItem} message InventoryItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InventoryItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.RemoteFortressReader.Item.encode(message.item, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InventoryItem message, length delimited. Does not implicitly {@link RemoteFortressReader.InventoryItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.IInventoryItem} message InventoryItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InventoryItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InventoryItem message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InventoryItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.InventoryItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                case 2:
                    message.item = $root.RemoteFortressReader.Item.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InventoryItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InventoryItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InventoryItem message.
         * @function verify
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InventoryItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                default:
                    return "mode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.Item.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates an InventoryItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.InventoryItem} InventoryItem
         */
        InventoryItem.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.InventoryItem)
                return object;
            var message = new $root.RemoteFortressReader.InventoryItem();
            switch (object.mode) {
            case "Hauled":
            case 0:
                message.mode = 0;
                break;
            case "Weapon":
            case 1:
                message.mode = 1;
                break;
            case "Worn":
            case 2:
                message.mode = 2;
                break;
            case "Piercing":
            case 3:
                message.mode = 3;
                break;
            case "Flask":
            case 4:
                message.mode = 4;
                break;
            case "WrappedAround":
            case 5:
                message.mode = 5;
                break;
            case "StuckIn":
            case 6:
                message.mode = 6;
                break;
            case "InMouth":
            case 7:
                message.mode = 7;
                break;
            case "Pet":
            case 8:
                message.mode = 8;
                break;
            case "SewnInto":
            case 9:
                message.mode = 9;
                break;
            case "Strapped":
            case 10:
                message.mode = 10;
                break;
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.InventoryItem.item: object expected");
                message.item = $root.RemoteFortressReader.Item.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from an InventoryItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.InventoryItem
         * @static
         * @param {RemoteFortressReader.InventoryItem} message InventoryItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InventoryItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mode = options.enums === String ? "Hauled" : 0;
                object.item = null;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.RemoteFortressReader.InventoryMode[message.mode] : message.mode;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.Item.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this InventoryItem to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.InventoryItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InventoryItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InventoryItem;
    })();

    RemoteFortressReader.UnitDefinition = (function() {

        /**
         * Properties of an UnitDefinition.
         * @memberof RemoteFortressReader
         * @interface IUnitDefinition
         * @property {number} id UnitDefinition id
         * @property {boolean|null} [isValid] UnitDefinition isValid
         * @property {number|null} [posX] UnitDefinition posX
         * @property {number|null} [posY] UnitDefinition posY
         * @property {number|null} [posZ] UnitDefinition posZ
         * @property {RemoteFortressReader.IMatPair|null} [race] UnitDefinition race
         * @property {RemoteFortressReader.IColorDefinition|null} [professionColor] UnitDefinition professionColor
         * @property {number|null} [flags1] UnitDefinition flags1
         * @property {number|null} [flags2] UnitDefinition flags2
         * @property {number|null} [flags3] UnitDefinition flags3
         * @property {boolean|null} [isSoldier] UnitDefinition isSoldier
         * @property {RemoteFortressReader.IBodySizeInfo|null} [sizeInfo] UnitDefinition sizeInfo
         * @property {string|null} [name] UnitDefinition name
         * @property {number|null} [bloodMax] UnitDefinition bloodMax
         * @property {number|null} [bloodCount] UnitDefinition bloodCount
         * @property {RemoteFortressReader.IUnitAppearance|null} [appearance] UnitDefinition appearance
         * @property {number|null} [professionId] UnitDefinition professionId
         * @property {Array.<string>|null} [noblePositions] UnitDefinition noblePositions
         * @property {number|null} [riderId] UnitDefinition riderId
         * @property {Array.<RemoteFortressReader.IInventoryItem>|null} [inventory] UnitDefinition inventory
         * @property {number|null} [subposX] UnitDefinition subposX
         * @property {number|null} [subposY] UnitDefinition subposY
         * @property {number|null} [subposZ] UnitDefinition subposZ
         */

        /**
         * Constructs a new UnitDefinition.
         * @memberof RemoteFortressReader
         * @classdesc Represents an UnitDefinition.
         * @implements IUnitDefinition
         * @constructor
         * @param {RemoteFortressReader.IUnitDefinition=} [properties] Properties to set
         */
        function UnitDefinition(properties) {
            this.noblePositions = [];
            this.inventory = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitDefinition id.
         * @member {number} id
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.id = 0;

        /**
         * UnitDefinition isValid.
         * @member {boolean} isValid
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.isValid = false;

        /**
         * UnitDefinition posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.posX = 0;

        /**
         * UnitDefinition posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.posY = 0;

        /**
         * UnitDefinition posZ.
         * @member {number} posZ
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.posZ = 0;

        /**
         * UnitDefinition race.
         * @member {RemoteFortressReader.IMatPair|null|undefined} race
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.race = null;

        /**
         * UnitDefinition professionColor.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} professionColor
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.professionColor = null;

        /**
         * UnitDefinition flags1.
         * @member {number} flags1
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.flags1 = 0;

        /**
         * UnitDefinition flags2.
         * @member {number} flags2
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.flags2 = 0;

        /**
         * UnitDefinition flags3.
         * @member {number} flags3
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.flags3 = 0;

        /**
         * UnitDefinition isSoldier.
         * @member {boolean} isSoldier
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.isSoldier = false;

        /**
         * UnitDefinition sizeInfo.
         * @member {RemoteFortressReader.IBodySizeInfo|null|undefined} sizeInfo
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.sizeInfo = null;

        /**
         * UnitDefinition name.
         * @member {string} name
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.name = "";

        /**
         * UnitDefinition bloodMax.
         * @member {number} bloodMax
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.bloodMax = 0;

        /**
         * UnitDefinition bloodCount.
         * @member {number} bloodCount
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.bloodCount = 0;

        /**
         * UnitDefinition appearance.
         * @member {RemoteFortressReader.IUnitAppearance|null|undefined} appearance
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.appearance = null;

        /**
         * UnitDefinition professionId.
         * @member {number} professionId
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.professionId = 0;

        /**
         * UnitDefinition noblePositions.
         * @member {Array.<string>} noblePositions
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.noblePositions = $util.emptyArray;

        /**
         * UnitDefinition riderId.
         * @member {number} riderId
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.riderId = 0;

        /**
         * UnitDefinition inventory.
         * @member {Array.<RemoteFortressReader.IInventoryItem>} inventory
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.inventory = $util.emptyArray;

        /**
         * UnitDefinition subposX.
         * @member {number} subposX
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.subposX = 0;

        /**
         * UnitDefinition subposY.
         * @member {number} subposY
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.subposY = 0;

        /**
         * UnitDefinition subposZ.
         * @member {number} subposZ
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         */
        UnitDefinition.prototype.subposZ = 0;

        /**
         * Creates a new UnitDefinition instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.IUnitDefinition=} [properties] Properties to set
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition instance
         */
        UnitDefinition.create = function create(properties) {
            return new UnitDefinition(properties);
        };

        /**
         * Encodes the specified UnitDefinition message. Does not implicitly {@link RemoteFortressReader.UnitDefinition.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.IUnitDefinition} message UnitDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.isValid != null && Object.hasOwnProperty.call(message, "isValid"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isValid);
            if (message.posX != null && Object.hasOwnProperty.call(message, "posX"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posX);
            if (message.posY != null && Object.hasOwnProperty.call(message, "posY"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.posY);
            if (message.posZ != null && Object.hasOwnProperty.call(message, "posZ"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.posZ);
            if (message.race != null && Object.hasOwnProperty.call(message, "race"))
                $root.RemoteFortressReader.MatPair.encode(message.race, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.professionColor != null && Object.hasOwnProperty.call(message, "professionColor"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.professionColor, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.flags1 != null && Object.hasOwnProperty.call(message, "flags1"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags1);
            if (message.flags2 != null && Object.hasOwnProperty.call(message, "flags2"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags2);
            if (message.flags3 != null && Object.hasOwnProperty.call(message, "flags3"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.flags3);
            if (message.isSoldier != null && Object.hasOwnProperty.call(message, "isSoldier"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isSoldier);
            if (message.sizeInfo != null && Object.hasOwnProperty.call(message, "sizeInfo"))
                $root.RemoteFortressReader.BodySizeInfo.encode(message.sizeInfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.name);
            if (message.bloodMax != null && Object.hasOwnProperty.call(message, "bloodMax"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.bloodMax);
            if (message.bloodCount != null && Object.hasOwnProperty.call(message, "bloodCount"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.bloodCount);
            if (message.appearance != null && Object.hasOwnProperty.call(message, "appearance"))
                $root.RemoteFortressReader.UnitAppearance.encode(message.appearance, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.professionId != null && Object.hasOwnProperty.call(message, "professionId"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.professionId);
            if (message.noblePositions != null && message.noblePositions.length)
                for (var i = 0; i < message.noblePositions.length; ++i)
                    writer.uint32(/* id 18, wireType 2 =*/146).string(message.noblePositions[i]);
            if (message.riderId != null && Object.hasOwnProperty.call(message, "riderId"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.riderId);
            if (message.inventory != null && message.inventory.length)
                for (var i = 0; i < message.inventory.length; ++i)
                    $root.RemoteFortressReader.InventoryItem.encode(message.inventory[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.subposX != null && Object.hasOwnProperty.call(message, "subposX"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.subposX);
            if (message.subposY != null && Object.hasOwnProperty.call(message, "subposY"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.subposY);
            if (message.subposZ != null && Object.hasOwnProperty.call(message, "subposZ"))
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.subposZ);
            return writer;
        };

        /**
         * Encodes the specified UnitDefinition message, length delimited. Does not implicitly {@link RemoteFortressReader.UnitDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.IUnitDefinition} message UnitDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.UnitDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.isValid = reader.bool();
                    break;
                case 3:
                    message.posX = reader.int32();
                    break;
                case 4:
                    message.posY = reader.int32();
                    break;
                case 5:
                    message.posZ = reader.int32();
                    break;
                case 6:
                    message.race = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.professionColor = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.flags1 = reader.uint32();
                    break;
                case 9:
                    message.flags2 = reader.uint32();
                    break;
                case 10:
                    message.flags3 = reader.uint32();
                    break;
                case 11:
                    message.isSoldier = reader.bool();
                    break;
                case 12:
                    message.sizeInfo = $root.RemoteFortressReader.BodySizeInfo.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.name = reader.string();
                    break;
                case 14:
                    message.bloodMax = reader.int32();
                    break;
                case 15:
                    message.bloodCount = reader.int32();
                    break;
                case 16:
                    message.appearance = $root.RemoteFortressReader.UnitAppearance.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.professionId = reader.int32();
                    break;
                case 18:
                    if (!(message.noblePositions && message.noblePositions.length))
                        message.noblePositions = [];
                    message.noblePositions.push(reader.string());
                    break;
                case 19:
                    message.riderId = reader.int32();
                    break;
                case 20:
                    if (!(message.inventory && message.inventory.length))
                        message.inventory = [];
                    message.inventory.push($root.RemoteFortressReader.InventoryItem.decode(reader, reader.uint32()));
                    break;
                case 21:
                    message.subposX = reader.float();
                    break;
                case 22:
                    message.subposY = reader.float();
                    break;
                case 23:
                    message.subposZ = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes an UnitDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitDefinition message.
         * @function verify
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                if (typeof message.isValid !== "boolean")
                    return "isValid: boolean expected";
            if (message.posX != null && message.hasOwnProperty("posX"))
                if (!$util.isInteger(message.posX))
                    return "posX: integer expected";
            if (message.posY != null && message.hasOwnProperty("posY"))
                if (!$util.isInteger(message.posY))
                    return "posY: integer expected";
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                if (!$util.isInteger(message.posZ))
                    return "posZ: integer expected";
            if (message.race != null && message.hasOwnProperty("race")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.race);
                if (error)
                    return "race." + error;
            }
            if (message.professionColor != null && message.hasOwnProperty("professionColor")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.professionColor);
                if (error)
                    return "professionColor." + error;
            }
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                if (!$util.isInteger(message.flags1))
                    return "flags1: integer expected";
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                if (!$util.isInteger(message.flags2))
                    return "flags2: integer expected";
            if (message.flags3 != null && message.hasOwnProperty("flags3"))
                if (!$util.isInteger(message.flags3))
                    return "flags3: integer expected";
            if (message.isSoldier != null && message.hasOwnProperty("isSoldier"))
                if (typeof message.isSoldier !== "boolean")
                    return "isSoldier: boolean expected";
            if (message.sizeInfo != null && message.hasOwnProperty("sizeInfo")) {
                var error = $root.RemoteFortressReader.BodySizeInfo.verify(message.sizeInfo);
                if (error)
                    return "sizeInfo." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.bloodMax != null && message.hasOwnProperty("bloodMax"))
                if (!$util.isInteger(message.bloodMax))
                    return "bloodMax: integer expected";
            if (message.bloodCount != null && message.hasOwnProperty("bloodCount"))
                if (!$util.isInteger(message.bloodCount))
                    return "bloodCount: integer expected";
            if (message.appearance != null && message.hasOwnProperty("appearance")) {
                var error = $root.RemoteFortressReader.UnitAppearance.verify(message.appearance);
                if (error)
                    return "appearance." + error;
            }
            if (message.professionId != null && message.hasOwnProperty("professionId"))
                if (!$util.isInteger(message.professionId))
                    return "professionId: integer expected";
            if (message.noblePositions != null && message.hasOwnProperty("noblePositions")) {
                if (!Array.isArray(message.noblePositions))
                    return "noblePositions: array expected";
                for (var i = 0; i < message.noblePositions.length; ++i)
                    if (!$util.isString(message.noblePositions[i]))
                        return "noblePositions: string[] expected";
            }
            if (message.riderId != null && message.hasOwnProperty("riderId"))
                if (!$util.isInteger(message.riderId))
                    return "riderId: integer expected";
            if (message.inventory != null && message.hasOwnProperty("inventory")) {
                if (!Array.isArray(message.inventory))
                    return "inventory: array expected";
                for (var i = 0; i < message.inventory.length; ++i) {
                    var error = $root.RemoteFortressReader.InventoryItem.verify(message.inventory[i]);
                    if (error)
                        return "inventory." + error;
                }
            }
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                if (typeof message.subposX !== "number")
                    return "subposX: number expected";
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                if (typeof message.subposY !== "number")
                    return "subposY: number expected";
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                if (typeof message.subposZ !== "number")
                    return "subposZ: number expected";
            return null;
        };

        /**
         * Creates an UnitDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.UnitDefinition} UnitDefinition
         */
        UnitDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.UnitDefinition)
                return object;
            var message = new $root.RemoteFortressReader.UnitDefinition();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.isValid != null)
                message.isValid = Boolean(object.isValid);
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.posZ != null)
                message.posZ = object.posZ | 0;
            if (object.race != null) {
                if (typeof object.race !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.race: object expected");
                message.race = $root.RemoteFortressReader.MatPair.fromObject(object.race);
            }
            if (object.professionColor != null) {
                if (typeof object.professionColor !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.professionColor: object expected");
                message.professionColor = $root.RemoteFortressReader.ColorDefinition.fromObject(object.professionColor);
            }
            if (object.flags1 != null)
                message.flags1 = object.flags1 >>> 0;
            if (object.flags2 != null)
                message.flags2 = object.flags2 >>> 0;
            if (object.flags3 != null)
                message.flags3 = object.flags3 >>> 0;
            if (object.isSoldier != null)
                message.isSoldier = Boolean(object.isSoldier);
            if (object.sizeInfo != null) {
                if (typeof object.sizeInfo !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.sizeInfo: object expected");
                message.sizeInfo = $root.RemoteFortressReader.BodySizeInfo.fromObject(object.sizeInfo);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.bloodMax != null)
                message.bloodMax = object.bloodMax | 0;
            if (object.bloodCount != null)
                message.bloodCount = object.bloodCount | 0;
            if (object.appearance != null) {
                if (typeof object.appearance !== "object")
                    throw TypeError(".RemoteFortressReader.UnitDefinition.appearance: object expected");
                message.appearance = $root.RemoteFortressReader.UnitAppearance.fromObject(object.appearance);
            }
            if (object.professionId != null)
                message.professionId = object.professionId | 0;
            if (object.noblePositions) {
                if (!Array.isArray(object.noblePositions))
                    throw TypeError(".RemoteFortressReader.UnitDefinition.noblePositions: array expected");
                message.noblePositions = [];
                for (var i = 0; i < object.noblePositions.length; ++i)
                    message.noblePositions[i] = String(object.noblePositions[i]);
            }
            if (object.riderId != null)
                message.riderId = object.riderId | 0;
            if (object.inventory) {
                if (!Array.isArray(object.inventory))
                    throw TypeError(".RemoteFortressReader.UnitDefinition.inventory: array expected");
                message.inventory = [];
                for (var i = 0; i < object.inventory.length; ++i) {
                    if (typeof object.inventory[i] !== "object")
                        throw TypeError(".RemoteFortressReader.UnitDefinition.inventory: object expected");
                    message.inventory[i] = $root.RemoteFortressReader.InventoryItem.fromObject(object.inventory[i]);
                }
            }
            if (object.subposX != null)
                message.subposX = Number(object.subposX);
            if (object.subposY != null)
                message.subposY = Number(object.subposY);
            if (object.subposZ != null)
                message.subposZ = Number(object.subposZ);
            return message;
        };

        /**
         * Creates a plain object from an UnitDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.UnitDefinition
         * @static
         * @param {RemoteFortressReader.UnitDefinition} message UnitDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.noblePositions = [];
                object.inventory = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.isValid = false;
                object.posX = 0;
                object.posY = 0;
                object.posZ = 0;
                object.race = null;
                object.professionColor = null;
                object.flags1 = 0;
                object.flags2 = 0;
                object.flags3 = 0;
                object.isSoldier = false;
                object.sizeInfo = null;
                object.name = "";
                object.bloodMax = 0;
                object.bloodCount = 0;
                object.appearance = null;
                object.professionId = 0;
                object.riderId = 0;
                object.subposX = 0;
                object.subposY = 0;
                object.subposZ = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                object.isValid = message.isValid;
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                object.posZ = message.posZ;
            if (message.race != null && message.hasOwnProperty("race"))
                object.race = $root.RemoteFortressReader.MatPair.toObject(message.race, options);
            if (message.professionColor != null && message.hasOwnProperty("professionColor"))
                object.professionColor = $root.RemoteFortressReader.ColorDefinition.toObject(message.professionColor, options);
            if (message.flags1 != null && message.hasOwnProperty("flags1"))
                object.flags1 = message.flags1;
            if (message.flags2 != null && message.hasOwnProperty("flags2"))
                object.flags2 = message.flags2;
            if (message.flags3 != null && message.hasOwnProperty("flags3"))
                object.flags3 = message.flags3;
            if (message.isSoldier != null && message.hasOwnProperty("isSoldier"))
                object.isSoldier = message.isSoldier;
            if (message.sizeInfo != null && message.hasOwnProperty("sizeInfo"))
                object.sizeInfo = $root.RemoteFortressReader.BodySizeInfo.toObject(message.sizeInfo, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.bloodMax != null && message.hasOwnProperty("bloodMax"))
                object.bloodMax = message.bloodMax;
            if (message.bloodCount != null && message.hasOwnProperty("bloodCount"))
                object.bloodCount = message.bloodCount;
            if (message.appearance != null && message.hasOwnProperty("appearance"))
                object.appearance = $root.RemoteFortressReader.UnitAppearance.toObject(message.appearance, options);
            if (message.professionId != null && message.hasOwnProperty("professionId"))
                object.professionId = message.professionId;
            if (message.noblePositions && message.noblePositions.length) {
                object.noblePositions = [];
                for (var j = 0; j < message.noblePositions.length; ++j)
                    object.noblePositions[j] = message.noblePositions[j];
            }
            if (message.riderId != null && message.hasOwnProperty("riderId"))
                object.riderId = message.riderId;
            if (message.inventory && message.inventory.length) {
                object.inventory = [];
                for (var j = 0; j < message.inventory.length; ++j)
                    object.inventory[j] = $root.RemoteFortressReader.InventoryItem.toObject(message.inventory[j], options);
            }
            if (message.subposX != null && message.hasOwnProperty("subposX"))
                object.subposX = options.json && !isFinite(message.subposX) ? String(message.subposX) : message.subposX;
            if (message.subposY != null && message.hasOwnProperty("subposY"))
                object.subposY = options.json && !isFinite(message.subposY) ? String(message.subposY) : message.subposY;
            if (message.subposZ != null && message.hasOwnProperty("subposZ"))
                object.subposZ = options.json && !isFinite(message.subposZ) ? String(message.subposZ) : message.subposZ;
            return object;
        };

        /**
         * Converts this UnitDefinition to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.UnitDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitDefinition;
    })();

    RemoteFortressReader.UnitList = (function() {

        /**
         * Properties of an UnitList.
         * @memberof RemoteFortressReader
         * @interface IUnitList
         * @property {Array.<RemoteFortressReader.IUnitDefinition>|null} [creatureList] UnitList creatureList
         */

        /**
         * Constructs a new UnitList.
         * @memberof RemoteFortressReader
         * @classdesc Represents an UnitList.
         * @implements IUnitList
         * @constructor
         * @param {RemoteFortressReader.IUnitList=} [properties] Properties to set
         */
        function UnitList(properties) {
            this.creatureList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnitList creatureList.
         * @member {Array.<RemoteFortressReader.IUnitDefinition>} creatureList
         * @memberof RemoteFortressReader.UnitList
         * @instance
         */
        UnitList.prototype.creatureList = $util.emptyArray;

        /**
         * Creates a new UnitList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.IUnitList=} [properties] Properties to set
         * @returns {RemoteFortressReader.UnitList} UnitList instance
         */
        UnitList.create = function create(properties) {
            return new UnitList(properties);
        };

        /**
         * Encodes the specified UnitList message. Does not implicitly {@link RemoteFortressReader.UnitList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.IUnitList} message UnitList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creatureList != null && message.creatureList.length)
                for (var i = 0; i < message.creatureList.length; ++i)
                    $root.RemoteFortressReader.UnitDefinition.encode(message.creatureList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnitList message, length delimited. Does not implicitly {@link RemoteFortressReader.UnitList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.IUnitList} message UnitList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnitList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.UnitList} UnitList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.UnitList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.creatureList && message.creatureList.length))
                        message.creatureList = [];
                    message.creatureList.push($root.RemoteFortressReader.UnitDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnitList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.UnitList} UnitList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnitList message.
         * @function verify
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creatureList != null && message.hasOwnProperty("creatureList")) {
                if (!Array.isArray(message.creatureList))
                    return "creatureList: array expected";
                for (var i = 0; i < message.creatureList.length; ++i) {
                    var error = $root.RemoteFortressReader.UnitDefinition.verify(message.creatureList[i]);
                    if (error)
                        return "creatureList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UnitList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.UnitList} UnitList
         */
        UnitList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.UnitList)
                return object;
            var message = new $root.RemoteFortressReader.UnitList();
            if (object.creatureList) {
                if (!Array.isArray(object.creatureList))
                    throw TypeError(".RemoteFortressReader.UnitList.creatureList: array expected");
                message.creatureList = [];
                for (var i = 0; i < object.creatureList.length; ++i) {
                    if (typeof object.creatureList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.UnitList.creatureList: object expected");
                    message.creatureList[i] = $root.RemoteFortressReader.UnitDefinition.fromObject(object.creatureList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UnitList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.UnitList
         * @static
         * @param {RemoteFortressReader.UnitList} message UnitList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.creatureList = [];
            if (message.creatureList && message.creatureList.length) {
                object.creatureList = [];
                for (var j = 0; j < message.creatureList.length; ++j)
                    object.creatureList[j] = $root.RemoteFortressReader.UnitDefinition.toObject(message.creatureList[j], options);
            }
            return object;
        };

        /**
         * Converts this UnitList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.UnitList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnitList;
    })();

    RemoteFortressReader.BlockRequest = (function() {

        /**
         * Properties of a BlockRequest.
         * @memberof RemoteFortressReader
         * @interface IBlockRequest
         * @property {number|null} [blocksNeeded] BlockRequest blocksNeeded
         * @property {number|null} [minX] BlockRequest minX
         * @property {number|null} [maxX] BlockRequest maxX
         * @property {number|null} [minY] BlockRequest minY
         * @property {number|null} [maxY] BlockRequest maxY
         * @property {number|null} [minZ] BlockRequest minZ
         * @property {number|null} [maxZ] BlockRequest maxZ
         */

        /**
         * Constructs a new BlockRequest.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BlockRequest.
         * @implements IBlockRequest
         * @constructor
         * @param {RemoteFortressReader.IBlockRequest=} [properties] Properties to set
         */
        function BlockRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockRequest blocksNeeded.
         * @member {number} blocksNeeded
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.blocksNeeded = 0;

        /**
         * BlockRequest minX.
         * @member {number} minX
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.minX = 0;

        /**
         * BlockRequest maxX.
         * @member {number} maxX
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.maxX = 0;

        /**
         * BlockRequest minY.
         * @member {number} minY
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.minY = 0;

        /**
         * BlockRequest maxY.
         * @member {number} maxY
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.maxY = 0;

        /**
         * BlockRequest minZ.
         * @member {number} minZ
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.minZ = 0;

        /**
         * BlockRequest maxZ.
         * @member {number} maxZ
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         */
        BlockRequest.prototype.maxZ = 0;

        /**
         * Creates a new BlockRequest instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.IBlockRequest=} [properties] Properties to set
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest instance
         */
        BlockRequest.create = function create(properties) {
            return new BlockRequest(properties);
        };

        /**
         * Encodes the specified BlockRequest message. Does not implicitly {@link RemoteFortressReader.BlockRequest.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.IBlockRequest} message BlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blocksNeeded != null && Object.hasOwnProperty.call(message, "blocksNeeded"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.blocksNeeded);
            if (message.minX != null && Object.hasOwnProperty.call(message, "minX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minX);
            if (message.maxX != null && Object.hasOwnProperty.call(message, "maxX"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxX);
            if (message.minY != null && Object.hasOwnProperty.call(message, "minY"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minY);
            if (message.maxY != null && Object.hasOwnProperty.call(message, "maxY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxY);
            if (message.minZ != null && Object.hasOwnProperty.call(message, "minZ"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minZ);
            if (message.maxZ != null && Object.hasOwnProperty.call(message, "maxZ"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxZ);
            return writer;
        };

        /**
         * Encodes the specified BlockRequest message, length delimited. Does not implicitly {@link RemoteFortressReader.BlockRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.IBlockRequest} message BlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockRequest message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BlockRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blocksNeeded = reader.int32();
                    break;
                case 2:
                    message.minX = reader.int32();
                    break;
                case 3:
                    message.maxX = reader.int32();
                    break;
                case 4:
                    message.minY = reader.int32();
                    break;
                case 5:
                    message.maxY = reader.int32();
                    break;
                case 6:
                    message.minZ = reader.int32();
                    break;
                case 7:
                    message.maxZ = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockRequest message.
         * @function verify
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blocksNeeded != null && message.hasOwnProperty("blocksNeeded"))
                if (!$util.isInteger(message.blocksNeeded))
                    return "blocksNeeded: integer expected";
            if (message.minX != null && message.hasOwnProperty("minX"))
                if (!$util.isInteger(message.minX))
                    return "minX: integer expected";
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                if (!$util.isInteger(message.maxX))
                    return "maxX: integer expected";
            if (message.minY != null && message.hasOwnProperty("minY"))
                if (!$util.isInteger(message.minY))
                    return "minY: integer expected";
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                if (!$util.isInteger(message.maxY))
                    return "maxY: integer expected";
            if (message.minZ != null && message.hasOwnProperty("minZ"))
                if (!$util.isInteger(message.minZ))
                    return "minZ: integer expected";
            if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                if (!$util.isInteger(message.maxZ))
                    return "maxZ: integer expected";
            return null;
        };

        /**
         * Creates a BlockRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BlockRequest} BlockRequest
         */
        BlockRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BlockRequest)
                return object;
            var message = new $root.RemoteFortressReader.BlockRequest();
            if (object.blocksNeeded != null)
                message.blocksNeeded = object.blocksNeeded | 0;
            if (object.minX != null)
                message.minX = object.minX | 0;
            if (object.maxX != null)
                message.maxX = object.maxX | 0;
            if (object.minY != null)
                message.minY = object.minY | 0;
            if (object.maxY != null)
                message.maxY = object.maxY | 0;
            if (object.minZ != null)
                message.minZ = object.minZ | 0;
            if (object.maxZ != null)
                message.maxZ = object.maxZ | 0;
            return message;
        };

        /**
         * Creates a plain object from a BlockRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BlockRequest
         * @static
         * @param {RemoteFortressReader.BlockRequest} message BlockRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.blocksNeeded = 0;
                object.minX = 0;
                object.maxX = 0;
                object.minY = 0;
                object.maxY = 0;
                object.minZ = 0;
                object.maxZ = 0;
            }
            if (message.blocksNeeded != null && message.hasOwnProperty("blocksNeeded"))
                object.blocksNeeded = message.blocksNeeded;
            if (message.minX != null && message.hasOwnProperty("minX"))
                object.minX = message.minX;
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                object.maxX = message.maxX;
            if (message.minY != null && message.hasOwnProperty("minY"))
                object.minY = message.minY;
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                object.maxY = message.maxY;
            if (message.minZ != null && message.hasOwnProperty("minZ"))
                object.minZ = message.minZ;
            if (message.maxZ != null && message.hasOwnProperty("maxZ"))
                object.maxZ = message.maxZ;
            return object;
        };

        /**
         * Converts this BlockRequest to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BlockRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockRequest;
    })();

    RemoteFortressReader.BlockList = (function() {

        /**
         * Properties of a BlockList.
         * @memberof RemoteFortressReader
         * @interface IBlockList
         * @property {Array.<RemoteFortressReader.IMapBlock>|null} [mapBlocks] BlockList mapBlocks
         * @property {number|null} [mapX] BlockList mapX
         * @property {number|null} [mapY] BlockList mapY
         * @property {Array.<RemoteFortressReader.IEngraving>|null} [engravings] BlockList engravings
         * @property {Array.<RemoteFortressReader.IWave>|null} [oceanWaves] BlockList oceanWaves
         */

        /**
         * Constructs a new BlockList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BlockList.
         * @implements IBlockList
         * @constructor
         * @param {RemoteFortressReader.IBlockList=} [properties] Properties to set
         */
        function BlockList(properties) {
            this.mapBlocks = [];
            this.engravings = [];
            this.oceanWaves = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockList mapBlocks.
         * @member {Array.<RemoteFortressReader.IMapBlock>} mapBlocks
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.mapBlocks = $util.emptyArray;

        /**
         * BlockList mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.mapX = 0;

        /**
         * BlockList mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.mapY = 0;

        /**
         * BlockList engravings.
         * @member {Array.<RemoteFortressReader.IEngraving>} engravings
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.engravings = $util.emptyArray;

        /**
         * BlockList oceanWaves.
         * @member {Array.<RemoteFortressReader.IWave>} oceanWaves
         * @memberof RemoteFortressReader.BlockList
         * @instance
         */
        BlockList.prototype.oceanWaves = $util.emptyArray;

        /**
         * Creates a new BlockList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.IBlockList=} [properties] Properties to set
         * @returns {RemoteFortressReader.BlockList} BlockList instance
         */
        BlockList.create = function create(properties) {
            return new BlockList(properties);
        };

        /**
         * Encodes the specified BlockList message. Does not implicitly {@link RemoteFortressReader.BlockList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.IBlockList} message BlockList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapBlocks != null && message.mapBlocks.length)
                for (var i = 0; i < message.mapBlocks.length; ++i)
                    $root.RemoteFortressReader.MapBlock.encode(message.mapBlocks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mapX != null && Object.hasOwnProperty.call(message, "mapX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapX);
            if (message.mapY != null && Object.hasOwnProperty.call(message, "mapY"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mapY);
            if (message.engravings != null && message.engravings.length)
                for (var i = 0; i < message.engravings.length; ++i)
                    $root.RemoteFortressReader.Engraving.encode(message.engravings[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.oceanWaves != null && message.oceanWaves.length)
                for (var i = 0; i < message.oceanWaves.length; ++i)
                    $root.RemoteFortressReader.Wave.encode(message.oceanWaves[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BlockList message, length delimited. Does not implicitly {@link RemoteFortressReader.BlockList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.IBlockList} message BlockList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BlockList} BlockList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BlockList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mapBlocks && message.mapBlocks.length))
                        message.mapBlocks = [];
                    message.mapBlocks.push($root.RemoteFortressReader.MapBlock.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.mapX = reader.int32();
                    break;
                case 3:
                    message.mapY = reader.int32();
                    break;
                case 4:
                    if (!(message.engravings && message.engravings.length))
                        message.engravings = [];
                    message.engravings.push($root.RemoteFortressReader.Engraving.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.oceanWaves && message.oceanWaves.length))
                        message.oceanWaves = [];
                    message.oceanWaves.push($root.RemoteFortressReader.Wave.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BlockList} BlockList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockList message.
         * @function verify
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapBlocks != null && message.hasOwnProperty("mapBlocks")) {
                if (!Array.isArray(message.mapBlocks))
                    return "mapBlocks: array expected";
                for (var i = 0; i < message.mapBlocks.length; ++i) {
                    var error = $root.RemoteFortressReader.MapBlock.verify(message.mapBlocks[i]);
                    if (error)
                        return "mapBlocks." + error;
                }
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                if (!$util.isInteger(message.mapX))
                    return "mapX: integer expected";
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                if (!$util.isInteger(message.mapY))
                    return "mapY: integer expected";
            if (message.engravings != null && message.hasOwnProperty("engravings")) {
                if (!Array.isArray(message.engravings))
                    return "engravings: array expected";
                for (var i = 0; i < message.engravings.length; ++i) {
                    var error = $root.RemoteFortressReader.Engraving.verify(message.engravings[i]);
                    if (error)
                        return "engravings." + error;
                }
            }
            if (message.oceanWaves != null && message.hasOwnProperty("oceanWaves")) {
                if (!Array.isArray(message.oceanWaves))
                    return "oceanWaves: array expected";
                for (var i = 0; i < message.oceanWaves.length; ++i) {
                    var error = $root.RemoteFortressReader.Wave.verify(message.oceanWaves[i]);
                    if (error)
                        return "oceanWaves." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BlockList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BlockList} BlockList
         */
        BlockList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BlockList)
                return object;
            var message = new $root.RemoteFortressReader.BlockList();
            if (object.mapBlocks) {
                if (!Array.isArray(object.mapBlocks))
                    throw TypeError(".RemoteFortressReader.BlockList.mapBlocks: array expected");
                message.mapBlocks = [];
                for (var i = 0; i < object.mapBlocks.length; ++i) {
                    if (typeof object.mapBlocks[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BlockList.mapBlocks: object expected");
                    message.mapBlocks[i] = $root.RemoteFortressReader.MapBlock.fromObject(object.mapBlocks[i]);
                }
            }
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.engravings) {
                if (!Array.isArray(object.engravings))
                    throw TypeError(".RemoteFortressReader.BlockList.engravings: array expected");
                message.engravings = [];
                for (var i = 0; i < object.engravings.length; ++i) {
                    if (typeof object.engravings[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BlockList.engravings: object expected");
                    message.engravings[i] = $root.RemoteFortressReader.Engraving.fromObject(object.engravings[i]);
                }
            }
            if (object.oceanWaves) {
                if (!Array.isArray(object.oceanWaves))
                    throw TypeError(".RemoteFortressReader.BlockList.oceanWaves: array expected");
                message.oceanWaves = [];
                for (var i = 0; i < object.oceanWaves.length; ++i) {
                    if (typeof object.oceanWaves[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BlockList.oceanWaves: object expected");
                    message.oceanWaves[i] = $root.RemoteFortressReader.Wave.fromObject(object.oceanWaves[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BlockList
         * @static
         * @param {RemoteFortressReader.BlockList} message BlockList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.mapBlocks = [];
                object.engravings = [];
                object.oceanWaves = [];
            }
            if (options.defaults) {
                object.mapX = 0;
                object.mapY = 0;
            }
            if (message.mapBlocks && message.mapBlocks.length) {
                object.mapBlocks = [];
                for (var j = 0; j < message.mapBlocks.length; ++j)
                    object.mapBlocks[j] = $root.RemoteFortressReader.MapBlock.toObject(message.mapBlocks[j], options);
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.engravings && message.engravings.length) {
                object.engravings = [];
                for (var j = 0; j < message.engravings.length; ++j)
                    object.engravings[j] = $root.RemoteFortressReader.Engraving.toObject(message.engravings[j], options);
            }
            if (message.oceanWaves && message.oceanWaves.length) {
                object.oceanWaves = [];
                for (var j = 0; j < message.oceanWaves.length; ++j)
                    object.oceanWaves[j] = $root.RemoteFortressReader.Wave.toObject(message.oceanWaves[j], options);
            }
            return object;
        };

        /**
         * Converts this BlockList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BlockList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockList;
    })();

    RemoteFortressReader.PlantDef = (function() {

        /**
         * Properties of a PlantDef.
         * @memberof RemoteFortressReader
         * @interface IPlantDef
         * @property {number} posX PlantDef posX
         * @property {number} posY PlantDef posY
         * @property {number} posZ PlantDef posZ
         * @property {number} index PlantDef index
         */

        /**
         * Constructs a new PlantDef.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantDef.
         * @implements IPlantDef
         * @constructor
         * @param {RemoteFortressReader.IPlantDef=} [properties] Properties to set
         */
        function PlantDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantDef posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.posX = 0;

        /**
         * PlantDef posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.posY = 0;

        /**
         * PlantDef posZ.
         * @member {number} posZ
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.posZ = 0;

        /**
         * PlantDef index.
         * @member {number} index
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         */
        PlantDef.prototype.index = 0;

        /**
         * Creates a new PlantDef instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.IPlantDef=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantDef} PlantDef instance
         */
        PlantDef.create = function create(properties) {
            return new PlantDef(properties);
        };

        /**
         * Encodes the specified PlantDef message. Does not implicitly {@link RemoteFortressReader.PlantDef.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.IPlantDef} message PlantDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.posX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posY);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posZ);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified PlantDef message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.IPlantDef} message PlantDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantDef message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantDef} PlantDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.posX = reader.int32();
                    break;
                case 2:
                    message.posY = reader.int32();
                    break;
                case 3:
                    message.posZ = reader.int32();
                    break;
                case 4:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("posX"))
                throw $util.ProtocolError("missing required 'posX'", { instance: message });
            if (!message.hasOwnProperty("posY"))
                throw $util.ProtocolError("missing required 'posY'", { instance: message });
            if (!message.hasOwnProperty("posZ"))
                throw $util.ProtocolError("missing required 'posZ'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };

        /**
         * Decodes a PlantDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantDef} PlantDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantDef message.
         * @function verify
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.posX))
                return "posX: integer expected";
            if (!$util.isInteger(message.posY))
                return "posY: integer expected";
            if (!$util.isInteger(message.posZ))
                return "posZ: integer expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            return null;
        };

        /**
         * Creates a PlantDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantDef} PlantDef
         */
        PlantDef.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantDef)
                return object;
            var message = new $root.RemoteFortressReader.PlantDef();
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.posZ != null)
                message.posZ = object.posZ | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlantDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantDef
         * @static
         * @param {RemoteFortressReader.PlantDef} message PlantDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.posX = 0;
                object.posY = 0;
                object.posZ = 0;
                object.index = 0;
            }
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                object.posZ = message.posZ;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this PlantDef to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantDef;
    })();

    RemoteFortressReader.PlantList = (function() {

        /**
         * Properties of a PlantList.
         * @memberof RemoteFortressReader
         * @interface IPlantList
         * @property {Array.<RemoteFortressReader.IPlantDef>|null} [plantList] PlantList plantList
         */

        /**
         * Constructs a new PlantList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantList.
         * @implements IPlantList
         * @constructor
         * @param {RemoteFortressReader.IPlantList=} [properties] Properties to set
         */
        function PlantList(properties) {
            this.plantList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantList plantList.
         * @member {Array.<RemoteFortressReader.IPlantDef>} plantList
         * @memberof RemoteFortressReader.PlantList
         * @instance
         */
        PlantList.prototype.plantList = $util.emptyArray;

        /**
         * Creates a new PlantList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.IPlantList=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantList} PlantList instance
         */
        PlantList.create = function create(properties) {
            return new PlantList(properties);
        };

        /**
         * Encodes the specified PlantList message. Does not implicitly {@link RemoteFortressReader.PlantList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.IPlantList} message PlantList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.plantList != null && message.plantList.length)
                for (var i = 0; i < message.plantList.length; ++i)
                    $root.RemoteFortressReader.PlantDef.encode(message.plantList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlantList message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.IPlantList} message PlantList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantList} PlantList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.plantList && message.plantList.length))
                        message.plantList = [];
                    message.plantList.push($root.RemoteFortressReader.PlantDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlantList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantList} PlantList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantList message.
         * @function verify
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.plantList != null && message.hasOwnProperty("plantList")) {
                if (!Array.isArray(message.plantList))
                    return "plantList: array expected";
                for (var i = 0; i < message.plantList.length; ++i) {
                    var error = $root.RemoteFortressReader.PlantDef.verify(message.plantList[i]);
                    if (error)
                        return "plantList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PlantList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantList} PlantList
         */
        PlantList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantList)
                return object;
            var message = new $root.RemoteFortressReader.PlantList();
            if (object.plantList) {
                if (!Array.isArray(object.plantList))
                    throw TypeError(".RemoteFortressReader.PlantList.plantList: array expected");
                message.plantList = [];
                for (var i = 0; i < object.plantList.length; ++i) {
                    if (typeof object.plantList[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PlantList.plantList: object expected");
                    message.plantList[i] = $root.RemoteFortressReader.PlantDef.fromObject(object.plantList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PlantList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantList
         * @static
         * @param {RemoteFortressReader.PlantList} message PlantList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plantList = [];
            if (message.plantList && message.plantList.length) {
                object.plantList = [];
                for (var j = 0; j < message.plantList.length; ++j)
                    object.plantList[j] = $root.RemoteFortressReader.PlantDef.toObject(message.plantList[j], options);
            }
            return object;
        };

        /**
         * Converts this PlantList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantList;
    })();

    RemoteFortressReader.ViewInfo = (function() {

        /**
         * Properties of a ViewInfo.
         * @memberof RemoteFortressReader
         * @interface IViewInfo
         * @property {number|null} [viewPosX] ViewInfo viewPosX
         * @property {number|null} [viewPosY] ViewInfo viewPosY
         * @property {number|null} [viewPosZ] ViewInfo viewPosZ
         * @property {number|null} [viewSizeX] ViewInfo viewSizeX
         * @property {number|null} [viewSizeY] ViewInfo viewSizeY
         * @property {number|null} [cursorPosX] ViewInfo cursorPosX
         * @property {number|null} [cursorPosY] ViewInfo cursorPosY
         * @property {number|null} [cursorPosZ] ViewInfo cursorPosZ
         * @property {number|null} [followUnitId] ViewInfo followUnitId
         * @property {number|null} [followItemId] ViewInfo followItemId
         */

        /**
         * Constructs a new ViewInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ViewInfo.
         * @implements IViewInfo
         * @constructor
         * @param {RemoteFortressReader.IViewInfo=} [properties] Properties to set
         */
        function ViewInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ViewInfo viewPosX.
         * @member {number} viewPosX
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewPosX = 0;

        /**
         * ViewInfo viewPosY.
         * @member {number} viewPosY
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewPosY = 0;

        /**
         * ViewInfo viewPosZ.
         * @member {number} viewPosZ
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewPosZ = 0;

        /**
         * ViewInfo viewSizeX.
         * @member {number} viewSizeX
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewSizeX = 0;

        /**
         * ViewInfo viewSizeY.
         * @member {number} viewSizeY
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.viewSizeY = 0;

        /**
         * ViewInfo cursorPosX.
         * @member {number} cursorPosX
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.cursorPosX = 0;

        /**
         * ViewInfo cursorPosY.
         * @member {number} cursorPosY
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.cursorPosY = 0;

        /**
         * ViewInfo cursorPosZ.
         * @member {number} cursorPosZ
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.cursorPosZ = 0;

        /**
         * ViewInfo followUnitId.
         * @member {number} followUnitId
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.followUnitId = -1;

        /**
         * ViewInfo followItemId.
         * @member {number} followItemId
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         */
        ViewInfo.prototype.followItemId = -1;

        /**
         * Creates a new ViewInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.IViewInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo instance
         */
        ViewInfo.create = function create(properties) {
            return new ViewInfo(properties);
        };

        /**
         * Encodes the specified ViewInfo message. Does not implicitly {@link RemoteFortressReader.ViewInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.IViewInfo} message ViewInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ViewInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.viewPosX != null && Object.hasOwnProperty.call(message, "viewPosX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.viewPosX);
            if (message.viewPosY != null && Object.hasOwnProperty.call(message, "viewPosY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.viewPosY);
            if (message.viewPosZ != null && Object.hasOwnProperty.call(message, "viewPosZ"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.viewPosZ);
            if (message.viewSizeX != null && Object.hasOwnProperty.call(message, "viewSizeX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.viewSizeX);
            if (message.viewSizeY != null && Object.hasOwnProperty.call(message, "viewSizeY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.viewSizeY);
            if (message.cursorPosX != null && Object.hasOwnProperty.call(message, "cursorPosX"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cursorPosX);
            if (message.cursorPosY != null && Object.hasOwnProperty.call(message, "cursorPosY"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.cursorPosY);
            if (message.cursorPosZ != null && Object.hasOwnProperty.call(message, "cursorPosZ"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.cursorPosZ);
            if (message.followUnitId != null && Object.hasOwnProperty.call(message, "followUnitId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.followUnitId);
            if (message.followItemId != null && Object.hasOwnProperty.call(message, "followItemId"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.followItemId);
            return writer;
        };

        /**
         * Encodes the specified ViewInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.ViewInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.IViewInfo} message ViewInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ViewInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ViewInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ViewInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ViewInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.viewPosX = reader.int32();
                    break;
                case 2:
                    message.viewPosY = reader.int32();
                    break;
                case 3:
                    message.viewPosZ = reader.int32();
                    break;
                case 4:
                    message.viewSizeX = reader.int32();
                    break;
                case 5:
                    message.viewSizeY = reader.int32();
                    break;
                case 6:
                    message.cursorPosX = reader.int32();
                    break;
                case 7:
                    message.cursorPosY = reader.int32();
                    break;
                case 8:
                    message.cursorPosZ = reader.int32();
                    break;
                case 9:
                    message.followUnitId = reader.int32();
                    break;
                case 10:
                    message.followItemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ViewInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ViewInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ViewInfo message.
         * @function verify
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ViewInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.viewPosX != null && message.hasOwnProperty("viewPosX"))
                if (!$util.isInteger(message.viewPosX))
                    return "viewPosX: integer expected";
            if (message.viewPosY != null && message.hasOwnProperty("viewPosY"))
                if (!$util.isInteger(message.viewPosY))
                    return "viewPosY: integer expected";
            if (message.viewPosZ != null && message.hasOwnProperty("viewPosZ"))
                if (!$util.isInteger(message.viewPosZ))
                    return "viewPosZ: integer expected";
            if (message.viewSizeX != null && message.hasOwnProperty("viewSizeX"))
                if (!$util.isInteger(message.viewSizeX))
                    return "viewSizeX: integer expected";
            if (message.viewSizeY != null && message.hasOwnProperty("viewSizeY"))
                if (!$util.isInteger(message.viewSizeY))
                    return "viewSizeY: integer expected";
            if (message.cursorPosX != null && message.hasOwnProperty("cursorPosX"))
                if (!$util.isInteger(message.cursorPosX))
                    return "cursorPosX: integer expected";
            if (message.cursorPosY != null && message.hasOwnProperty("cursorPosY"))
                if (!$util.isInteger(message.cursorPosY))
                    return "cursorPosY: integer expected";
            if (message.cursorPosZ != null && message.hasOwnProperty("cursorPosZ"))
                if (!$util.isInteger(message.cursorPosZ))
                    return "cursorPosZ: integer expected";
            if (message.followUnitId != null && message.hasOwnProperty("followUnitId"))
                if (!$util.isInteger(message.followUnitId))
                    return "followUnitId: integer expected";
            if (message.followItemId != null && message.hasOwnProperty("followItemId"))
                if (!$util.isInteger(message.followItemId))
                    return "followItemId: integer expected";
            return null;
        };

        /**
         * Creates a ViewInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ViewInfo} ViewInfo
         */
        ViewInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ViewInfo)
                return object;
            var message = new $root.RemoteFortressReader.ViewInfo();
            if (object.viewPosX != null)
                message.viewPosX = object.viewPosX | 0;
            if (object.viewPosY != null)
                message.viewPosY = object.viewPosY | 0;
            if (object.viewPosZ != null)
                message.viewPosZ = object.viewPosZ | 0;
            if (object.viewSizeX != null)
                message.viewSizeX = object.viewSizeX | 0;
            if (object.viewSizeY != null)
                message.viewSizeY = object.viewSizeY | 0;
            if (object.cursorPosX != null)
                message.cursorPosX = object.cursorPosX | 0;
            if (object.cursorPosY != null)
                message.cursorPosY = object.cursorPosY | 0;
            if (object.cursorPosZ != null)
                message.cursorPosZ = object.cursorPosZ | 0;
            if (object.followUnitId != null)
                message.followUnitId = object.followUnitId | 0;
            if (object.followItemId != null)
                message.followItemId = object.followItemId | 0;
            return message;
        };

        /**
         * Creates a plain object from a ViewInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ViewInfo
         * @static
         * @param {RemoteFortressReader.ViewInfo} message ViewInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ViewInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.viewPosX = 0;
                object.viewPosY = 0;
                object.viewPosZ = 0;
                object.viewSizeX = 0;
                object.viewSizeY = 0;
                object.cursorPosX = 0;
                object.cursorPosY = 0;
                object.cursorPosZ = 0;
                object.followUnitId = -1;
                object.followItemId = -1;
            }
            if (message.viewPosX != null && message.hasOwnProperty("viewPosX"))
                object.viewPosX = message.viewPosX;
            if (message.viewPosY != null && message.hasOwnProperty("viewPosY"))
                object.viewPosY = message.viewPosY;
            if (message.viewPosZ != null && message.hasOwnProperty("viewPosZ"))
                object.viewPosZ = message.viewPosZ;
            if (message.viewSizeX != null && message.hasOwnProperty("viewSizeX"))
                object.viewSizeX = message.viewSizeX;
            if (message.viewSizeY != null && message.hasOwnProperty("viewSizeY"))
                object.viewSizeY = message.viewSizeY;
            if (message.cursorPosX != null && message.hasOwnProperty("cursorPosX"))
                object.cursorPosX = message.cursorPosX;
            if (message.cursorPosY != null && message.hasOwnProperty("cursorPosY"))
                object.cursorPosY = message.cursorPosY;
            if (message.cursorPosZ != null && message.hasOwnProperty("cursorPosZ"))
                object.cursorPosZ = message.cursorPosZ;
            if (message.followUnitId != null && message.hasOwnProperty("followUnitId"))
                object.followUnitId = message.followUnitId;
            if (message.followItemId != null && message.hasOwnProperty("followItemId"))
                object.followItemId = message.followItemId;
            return object;
        };

        /**
         * Converts this ViewInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ViewInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ViewInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ViewInfo;
    })();

    RemoteFortressReader.MapInfo = (function() {

        /**
         * Properties of a MapInfo.
         * @memberof RemoteFortressReader
         * @interface IMapInfo
         * @property {number|null} [blockSizeX] MapInfo blockSizeX
         * @property {number|null} [blockSizeY] MapInfo blockSizeY
         * @property {number|null} [blockSizeZ] MapInfo blockSizeZ
         * @property {number|null} [blockPosX] MapInfo blockPosX
         * @property {number|null} [blockPosY] MapInfo blockPosY
         * @property {number|null} [blockPosZ] MapInfo blockPosZ
         * @property {string|null} [worldName] MapInfo worldName
         * @property {string|null} [worldNameEnglish] MapInfo worldNameEnglish
         * @property {string|null} [saveName] MapInfo saveName
         */

        /**
         * Constructs a new MapInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a MapInfo.
         * @implements IMapInfo
         * @constructor
         * @param {RemoteFortressReader.IMapInfo=} [properties] Properties to set
         */
        function MapInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapInfo blockSizeX.
         * @member {number} blockSizeX
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockSizeX = 0;

        /**
         * MapInfo blockSizeY.
         * @member {number} blockSizeY
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockSizeY = 0;

        /**
         * MapInfo blockSizeZ.
         * @member {number} blockSizeZ
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockSizeZ = 0;

        /**
         * MapInfo blockPosX.
         * @member {number} blockPosX
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockPosX = 0;

        /**
         * MapInfo blockPosY.
         * @member {number} blockPosY
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockPosY = 0;

        /**
         * MapInfo blockPosZ.
         * @member {number} blockPosZ
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.blockPosZ = 0;

        /**
         * MapInfo worldName.
         * @member {string} worldName
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.worldName = "";

        /**
         * MapInfo worldNameEnglish.
         * @member {string} worldNameEnglish
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.worldNameEnglish = "";

        /**
         * MapInfo saveName.
         * @member {string} saveName
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         */
        MapInfo.prototype.saveName = "";

        /**
         * Creates a new MapInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.IMapInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.MapInfo} MapInfo instance
         */
        MapInfo.create = function create(properties) {
            return new MapInfo(properties);
        };

        /**
         * Encodes the specified MapInfo message. Does not implicitly {@link RemoteFortressReader.MapInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.IMapInfo} message MapInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSizeX != null && Object.hasOwnProperty.call(message, "blockSizeX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.blockSizeX);
            if (message.blockSizeY != null && Object.hasOwnProperty.call(message, "blockSizeY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.blockSizeY);
            if (message.blockSizeZ != null && Object.hasOwnProperty.call(message, "blockSizeZ"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blockSizeZ);
            if (message.blockPosX != null && Object.hasOwnProperty.call(message, "blockPosX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.blockPosX);
            if (message.blockPosY != null && Object.hasOwnProperty.call(message, "blockPosY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blockPosY);
            if (message.blockPosZ != null && Object.hasOwnProperty.call(message, "blockPosZ"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.blockPosZ);
            if (message.worldName != null && Object.hasOwnProperty.call(message, "worldName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.worldName);
            if (message.worldNameEnglish != null && Object.hasOwnProperty.call(message, "worldNameEnglish"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.worldNameEnglish);
            if (message.saveName != null && Object.hasOwnProperty.call(message, "saveName"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.saveName);
            return writer;
        };

        /**
         * Encodes the specified MapInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.MapInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.IMapInfo} message MapInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.MapInfo} MapInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.MapInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSizeX = reader.int32();
                    break;
                case 2:
                    message.blockSizeY = reader.int32();
                    break;
                case 3:
                    message.blockSizeZ = reader.int32();
                    break;
                case 4:
                    message.blockPosX = reader.int32();
                    break;
                case 5:
                    message.blockPosY = reader.int32();
                    break;
                case 6:
                    message.blockPosZ = reader.int32();
                    break;
                case 7:
                    message.worldName = reader.string();
                    break;
                case 8:
                    message.worldNameEnglish = reader.string();
                    break;
                case 9:
                    message.saveName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.MapInfo} MapInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapInfo message.
         * @function verify
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSizeX != null && message.hasOwnProperty("blockSizeX"))
                if (!$util.isInteger(message.blockSizeX))
                    return "blockSizeX: integer expected";
            if (message.blockSizeY != null && message.hasOwnProperty("blockSizeY"))
                if (!$util.isInteger(message.blockSizeY))
                    return "blockSizeY: integer expected";
            if (message.blockSizeZ != null && message.hasOwnProperty("blockSizeZ"))
                if (!$util.isInteger(message.blockSizeZ))
                    return "blockSizeZ: integer expected";
            if (message.blockPosX != null && message.hasOwnProperty("blockPosX"))
                if (!$util.isInteger(message.blockPosX))
                    return "blockPosX: integer expected";
            if (message.blockPosY != null && message.hasOwnProperty("blockPosY"))
                if (!$util.isInteger(message.blockPosY))
                    return "blockPosY: integer expected";
            if (message.blockPosZ != null && message.hasOwnProperty("blockPosZ"))
                if (!$util.isInteger(message.blockPosZ))
                    return "blockPosZ: integer expected";
            if (message.worldName != null && message.hasOwnProperty("worldName"))
                if (!$util.isString(message.worldName))
                    return "worldName: string expected";
            if (message.worldNameEnglish != null && message.hasOwnProperty("worldNameEnglish"))
                if (!$util.isString(message.worldNameEnglish))
                    return "worldNameEnglish: string expected";
            if (message.saveName != null && message.hasOwnProperty("saveName"))
                if (!$util.isString(message.saveName))
                    return "saveName: string expected";
            return null;
        };

        /**
         * Creates a MapInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.MapInfo} MapInfo
         */
        MapInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.MapInfo)
                return object;
            var message = new $root.RemoteFortressReader.MapInfo();
            if (object.blockSizeX != null)
                message.blockSizeX = object.blockSizeX | 0;
            if (object.blockSizeY != null)
                message.blockSizeY = object.blockSizeY | 0;
            if (object.blockSizeZ != null)
                message.blockSizeZ = object.blockSizeZ | 0;
            if (object.blockPosX != null)
                message.blockPosX = object.blockPosX | 0;
            if (object.blockPosY != null)
                message.blockPosY = object.blockPosY | 0;
            if (object.blockPosZ != null)
                message.blockPosZ = object.blockPosZ | 0;
            if (object.worldName != null)
                message.worldName = String(object.worldName);
            if (object.worldNameEnglish != null)
                message.worldNameEnglish = String(object.worldNameEnglish);
            if (object.saveName != null)
                message.saveName = String(object.saveName);
            return message;
        };

        /**
         * Creates a plain object from a MapInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.MapInfo
         * @static
         * @param {RemoteFortressReader.MapInfo} message MapInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.blockSizeX = 0;
                object.blockSizeY = 0;
                object.blockSizeZ = 0;
                object.blockPosX = 0;
                object.blockPosY = 0;
                object.blockPosZ = 0;
                object.worldName = "";
                object.worldNameEnglish = "";
                object.saveName = "";
            }
            if (message.blockSizeX != null && message.hasOwnProperty("blockSizeX"))
                object.blockSizeX = message.blockSizeX;
            if (message.blockSizeY != null && message.hasOwnProperty("blockSizeY"))
                object.blockSizeY = message.blockSizeY;
            if (message.blockSizeZ != null && message.hasOwnProperty("blockSizeZ"))
                object.blockSizeZ = message.blockSizeZ;
            if (message.blockPosX != null && message.hasOwnProperty("blockPosX"))
                object.blockPosX = message.blockPosX;
            if (message.blockPosY != null && message.hasOwnProperty("blockPosY"))
                object.blockPosY = message.blockPosY;
            if (message.blockPosZ != null && message.hasOwnProperty("blockPosZ"))
                object.blockPosZ = message.blockPosZ;
            if (message.worldName != null && message.hasOwnProperty("worldName"))
                object.worldName = message.worldName;
            if (message.worldNameEnglish != null && message.hasOwnProperty("worldNameEnglish"))
                object.worldNameEnglish = message.worldNameEnglish;
            if (message.saveName != null && message.hasOwnProperty("saveName"))
                object.saveName = message.saveName;
            return object;
        };

        /**
         * Converts this MapInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.MapInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapInfo;
    })();

    /**
     * FrontType enum.
     * @name RemoteFortressReader.FrontType
     * @enum {string}
     * @property {number} FRONT_NONE=0 FRONT_NONE value
     * @property {number} FRONT_WARM=1 FRONT_WARM value
     * @property {number} FRONT_COLD=2 FRONT_COLD value
     * @property {number} FRONT_OCCLUDED=3 FRONT_OCCLUDED value
     */
    RemoteFortressReader.FrontType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FRONT_NONE"] = 0;
        values[valuesById[1] = "FRONT_WARM"] = 1;
        values[valuesById[2] = "FRONT_COLD"] = 2;
        values[valuesById[3] = "FRONT_OCCLUDED"] = 3;
        return values;
    })();

    /**
     * CumulusType enum.
     * @name RemoteFortressReader.CumulusType
     * @enum {string}
     * @property {number} CUMULUS_NONE=0 CUMULUS_NONE value
     * @property {number} CUMULUS_MEDIUM=1 CUMULUS_MEDIUM value
     * @property {number} CUMULUS_MULTI=2 CUMULUS_MULTI value
     * @property {number} CUMULUS_NIMBUS=3 CUMULUS_NIMBUS value
     */
    RemoteFortressReader.CumulusType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CUMULUS_NONE"] = 0;
        values[valuesById[1] = "CUMULUS_MEDIUM"] = 1;
        values[valuesById[2] = "CUMULUS_MULTI"] = 2;
        values[valuesById[3] = "CUMULUS_NIMBUS"] = 3;
        return values;
    })();

    /**
     * StratusType enum.
     * @name RemoteFortressReader.StratusType
     * @enum {string}
     * @property {number} STRATUS_NONE=0 STRATUS_NONE value
     * @property {number} STRATUS_ALTO=1 STRATUS_ALTO value
     * @property {number} STRATUS_PROPER=2 STRATUS_PROPER value
     * @property {number} STRATUS_NIMBUS=3 STRATUS_NIMBUS value
     */
    RemoteFortressReader.StratusType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "STRATUS_NONE"] = 0;
        values[valuesById[1] = "STRATUS_ALTO"] = 1;
        values[valuesById[2] = "STRATUS_PROPER"] = 2;
        values[valuesById[3] = "STRATUS_NIMBUS"] = 3;
        return values;
    })();

    /**
     * FogType enum.
     * @name RemoteFortressReader.FogType
     * @enum {string}
     * @property {number} FOG_NONE=0 FOG_NONE value
     * @property {number} FOG_MIST=1 FOG_MIST value
     * @property {number} FOG_NORMAL=2 FOG_NORMAL value
     * @property {number} F0G_THICK=3 F0G_THICK value
     */
    RemoteFortressReader.FogType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FOG_NONE"] = 0;
        values[valuesById[1] = "FOG_MIST"] = 1;
        values[valuesById[2] = "FOG_NORMAL"] = 2;
        values[valuesById[3] = "F0G_THICK"] = 3;
        return values;
    })();

    RemoteFortressReader.Cloud = (function() {

        /**
         * Properties of a Cloud.
         * @memberof RemoteFortressReader
         * @interface ICloud
         * @property {RemoteFortressReader.FrontType|null} [front] Cloud front
         * @property {RemoteFortressReader.CumulusType|null} [cumulus] Cloud cumulus
         * @property {boolean|null} [cirrus] Cloud cirrus
         * @property {RemoteFortressReader.StratusType|null} [stratus] Cloud stratus
         * @property {RemoteFortressReader.FogType|null} [fog] Cloud fog
         */

        /**
         * Constructs a new Cloud.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Cloud.
         * @implements ICloud
         * @constructor
         * @param {RemoteFortressReader.ICloud=} [properties] Properties to set
         */
        function Cloud(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Cloud front.
         * @member {RemoteFortressReader.FrontType} front
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.front = 0;

        /**
         * Cloud cumulus.
         * @member {RemoteFortressReader.CumulusType} cumulus
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.cumulus = 0;

        /**
         * Cloud cirrus.
         * @member {boolean} cirrus
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.cirrus = false;

        /**
         * Cloud stratus.
         * @member {RemoteFortressReader.StratusType} stratus
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.stratus = 0;

        /**
         * Cloud fog.
         * @member {RemoteFortressReader.FogType} fog
         * @memberof RemoteFortressReader.Cloud
         * @instance
         */
        Cloud.prototype.fog = 0;

        /**
         * Creates a new Cloud instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.ICloud=} [properties] Properties to set
         * @returns {RemoteFortressReader.Cloud} Cloud instance
         */
        Cloud.create = function create(properties) {
            return new Cloud(properties);
        };

        /**
         * Encodes the specified Cloud message. Does not implicitly {@link RemoteFortressReader.Cloud.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.ICloud} message Cloud message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cloud.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.front != null && Object.hasOwnProperty.call(message, "front"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.front);
            if (message.cumulus != null && Object.hasOwnProperty.call(message, "cumulus"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cumulus);
            if (message.cirrus != null && Object.hasOwnProperty.call(message, "cirrus"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.cirrus);
            if (message.stratus != null && Object.hasOwnProperty.call(message, "stratus"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.stratus);
            if (message.fog != null && Object.hasOwnProperty.call(message, "fog"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.fog);
            return writer;
        };

        /**
         * Encodes the specified Cloud message, length delimited. Does not implicitly {@link RemoteFortressReader.Cloud.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.ICloud} message Cloud message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cloud.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Cloud message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Cloud} Cloud
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cloud.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Cloud();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.front = reader.int32();
                    break;
                case 2:
                    message.cumulus = reader.int32();
                    break;
                case 3:
                    message.cirrus = reader.bool();
                    break;
                case 4:
                    message.stratus = reader.int32();
                    break;
                case 5:
                    message.fog = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Cloud message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Cloud} Cloud
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cloud.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Cloud message.
         * @function verify
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Cloud.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.front != null && message.hasOwnProperty("front"))
                switch (message.front) {
                default:
                    return "front: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.cumulus != null && message.hasOwnProperty("cumulus"))
                switch (message.cumulus) {
                default:
                    return "cumulus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.cirrus != null && message.hasOwnProperty("cirrus"))
                if (typeof message.cirrus !== "boolean")
                    return "cirrus: boolean expected";
            if (message.stratus != null && message.hasOwnProperty("stratus"))
                switch (message.stratus) {
                default:
                    return "stratus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.fog != null && message.hasOwnProperty("fog"))
                switch (message.fog) {
                default:
                    return "fog: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Cloud message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Cloud} Cloud
         */
        Cloud.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Cloud)
                return object;
            var message = new $root.RemoteFortressReader.Cloud();
            switch (object.front) {
            case "FRONT_NONE":
            case 0:
                message.front = 0;
                break;
            case "FRONT_WARM":
            case 1:
                message.front = 1;
                break;
            case "FRONT_COLD":
            case 2:
                message.front = 2;
                break;
            case "FRONT_OCCLUDED":
            case 3:
                message.front = 3;
                break;
            }
            switch (object.cumulus) {
            case "CUMULUS_NONE":
            case 0:
                message.cumulus = 0;
                break;
            case "CUMULUS_MEDIUM":
            case 1:
                message.cumulus = 1;
                break;
            case "CUMULUS_MULTI":
            case 2:
                message.cumulus = 2;
                break;
            case "CUMULUS_NIMBUS":
            case 3:
                message.cumulus = 3;
                break;
            }
            if (object.cirrus != null)
                message.cirrus = Boolean(object.cirrus);
            switch (object.stratus) {
            case "STRATUS_NONE":
            case 0:
                message.stratus = 0;
                break;
            case "STRATUS_ALTO":
            case 1:
                message.stratus = 1;
                break;
            case "STRATUS_PROPER":
            case 2:
                message.stratus = 2;
                break;
            case "STRATUS_NIMBUS":
            case 3:
                message.stratus = 3;
                break;
            }
            switch (object.fog) {
            case "FOG_NONE":
            case 0:
                message.fog = 0;
                break;
            case "FOG_MIST":
            case 1:
                message.fog = 1;
                break;
            case "FOG_NORMAL":
            case 2:
                message.fog = 2;
                break;
            case "F0G_THICK":
            case 3:
                message.fog = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Cloud message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Cloud
         * @static
         * @param {RemoteFortressReader.Cloud} message Cloud
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Cloud.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.front = options.enums === String ? "FRONT_NONE" : 0;
                object.cumulus = options.enums === String ? "CUMULUS_NONE" : 0;
                object.cirrus = false;
                object.stratus = options.enums === String ? "STRATUS_NONE" : 0;
                object.fog = options.enums === String ? "FOG_NONE" : 0;
            }
            if (message.front != null && message.hasOwnProperty("front"))
                object.front = options.enums === String ? $root.RemoteFortressReader.FrontType[message.front] : message.front;
            if (message.cumulus != null && message.hasOwnProperty("cumulus"))
                object.cumulus = options.enums === String ? $root.RemoteFortressReader.CumulusType[message.cumulus] : message.cumulus;
            if (message.cirrus != null && message.hasOwnProperty("cirrus"))
                object.cirrus = message.cirrus;
            if (message.stratus != null && message.hasOwnProperty("stratus"))
                object.stratus = options.enums === String ? $root.RemoteFortressReader.StratusType[message.stratus] : message.stratus;
            if (message.fog != null && message.hasOwnProperty("fog"))
                object.fog = options.enums === String ? $root.RemoteFortressReader.FogType[message.fog] : message.fog;
            return object;
        };

        /**
         * Converts this Cloud to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Cloud
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Cloud.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Cloud;
    })();

    RemoteFortressReader.WorldMap = (function() {

        /**
         * Properties of a WorldMap.
         * @memberof RemoteFortressReader
         * @interface IWorldMap
         * @property {number} worldWidth WorldMap worldWidth
         * @property {number} worldHeight WorldMap worldHeight
         * @property {string|null} [name] WorldMap name
         * @property {string|null} [nameEnglish] WorldMap nameEnglish
         * @property {Array.<number>|null} [elevation] WorldMap elevation
         * @property {Array.<number>|null} [rainfall] WorldMap rainfall
         * @property {Array.<number>|null} [vegetation] WorldMap vegetation
         * @property {Array.<number>|null} [temperature] WorldMap temperature
         * @property {Array.<number>|null} [evilness] WorldMap evilness
         * @property {Array.<number>|null} [drainage] WorldMap drainage
         * @property {Array.<number>|null} [volcanism] WorldMap volcanism
         * @property {Array.<number>|null} [savagery] WorldMap savagery
         * @property {Array.<RemoteFortressReader.ICloud>|null} [clouds] WorldMap clouds
         * @property {Array.<number>|null} [salinity] WorldMap salinity
         * @property {number|null} [mapX] WorldMap mapX
         * @property {number|null} [mapY] WorldMap mapY
         * @property {number|null} [centerX] WorldMap centerX
         * @property {number|null} [centerY] WorldMap centerY
         * @property {number|null} [centerZ] WorldMap centerZ
         * @property {number|null} [curYear] WorldMap curYear
         * @property {number|null} [curYearTick] WorldMap curYearTick
         * @property {RemoteFortressReader.WorldPoles|null} [worldPoles] WorldMap worldPoles
         * @property {Array.<RemoteFortressReader.IRiverTile>|null} [riverTiles] WorldMap riverTiles
         * @property {Array.<number>|null} [waterElevation] WorldMap waterElevation
         * @property {Array.<RemoteFortressReader.IRegionTile>|null} [regionTiles] WorldMap regionTiles
         */

        /**
         * Constructs a new WorldMap.
         * @memberof RemoteFortressReader
         * @classdesc Represents a WorldMap.
         * @implements IWorldMap
         * @constructor
         * @param {RemoteFortressReader.IWorldMap=} [properties] Properties to set
         */
        function WorldMap(properties) {
            this.elevation = [];
            this.rainfall = [];
            this.vegetation = [];
            this.temperature = [];
            this.evilness = [];
            this.drainage = [];
            this.volcanism = [];
            this.savagery = [];
            this.clouds = [];
            this.salinity = [];
            this.riverTiles = [];
            this.waterElevation = [];
            this.regionTiles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WorldMap worldWidth.
         * @member {number} worldWidth
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.worldWidth = 0;

        /**
         * WorldMap worldHeight.
         * @member {number} worldHeight
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.worldHeight = 0;

        /**
         * WorldMap name.
         * @member {string} name
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.name = "";

        /**
         * WorldMap nameEnglish.
         * @member {string} nameEnglish
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.nameEnglish = "";

        /**
         * WorldMap elevation.
         * @member {Array.<number>} elevation
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.elevation = $util.emptyArray;

        /**
         * WorldMap rainfall.
         * @member {Array.<number>} rainfall
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.rainfall = $util.emptyArray;

        /**
         * WorldMap vegetation.
         * @member {Array.<number>} vegetation
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.vegetation = $util.emptyArray;

        /**
         * WorldMap temperature.
         * @member {Array.<number>} temperature
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.temperature = $util.emptyArray;

        /**
         * WorldMap evilness.
         * @member {Array.<number>} evilness
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.evilness = $util.emptyArray;

        /**
         * WorldMap drainage.
         * @member {Array.<number>} drainage
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.drainage = $util.emptyArray;

        /**
         * WorldMap volcanism.
         * @member {Array.<number>} volcanism
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.volcanism = $util.emptyArray;

        /**
         * WorldMap savagery.
         * @member {Array.<number>} savagery
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.savagery = $util.emptyArray;

        /**
         * WorldMap clouds.
         * @member {Array.<RemoteFortressReader.ICloud>} clouds
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.clouds = $util.emptyArray;

        /**
         * WorldMap salinity.
         * @member {Array.<number>} salinity
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.salinity = $util.emptyArray;

        /**
         * WorldMap mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.mapX = 0;

        /**
         * WorldMap mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.mapY = 0;

        /**
         * WorldMap centerX.
         * @member {number} centerX
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.centerX = 0;

        /**
         * WorldMap centerY.
         * @member {number} centerY
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.centerY = 0;

        /**
         * WorldMap centerZ.
         * @member {number} centerZ
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.centerZ = 0;

        /**
         * WorldMap curYear.
         * @member {number} curYear
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.curYear = 0;

        /**
         * WorldMap curYearTick.
         * @member {number} curYearTick
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.curYearTick = 0;

        /**
         * WorldMap worldPoles.
         * @member {RemoteFortressReader.WorldPoles} worldPoles
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.worldPoles = 0;

        /**
         * WorldMap riverTiles.
         * @member {Array.<RemoteFortressReader.IRiverTile>} riverTiles
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.riverTiles = $util.emptyArray;

        /**
         * WorldMap waterElevation.
         * @member {Array.<number>} waterElevation
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.waterElevation = $util.emptyArray;

        /**
         * WorldMap regionTiles.
         * @member {Array.<RemoteFortressReader.IRegionTile>} regionTiles
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         */
        WorldMap.prototype.regionTiles = $util.emptyArray;

        /**
         * Creates a new WorldMap instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.IWorldMap=} [properties] Properties to set
         * @returns {RemoteFortressReader.WorldMap} WorldMap instance
         */
        WorldMap.create = function create(properties) {
            return new WorldMap(properties);
        };

        /**
         * Encodes the specified WorldMap message. Does not implicitly {@link RemoteFortressReader.WorldMap.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.IWorldMap} message WorldMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.worldWidth);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.worldHeight);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.nameEnglish != null && Object.hasOwnProperty.call(message, "nameEnglish"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nameEnglish);
            if (message.elevation != null && message.elevation.length)
                for (var i = 0; i < message.elevation.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.elevation[i]);
            if (message.rainfall != null && message.rainfall.length)
                for (var i = 0; i < message.rainfall.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rainfall[i]);
            if (message.vegetation != null && message.vegetation.length)
                for (var i = 0; i < message.vegetation.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.vegetation[i]);
            if (message.temperature != null && message.temperature.length)
                for (var i = 0; i < message.temperature.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.temperature[i]);
            if (message.evilness != null && message.evilness.length)
                for (var i = 0; i < message.evilness.length; ++i)
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.evilness[i]);
            if (message.drainage != null && message.drainage.length)
                for (var i = 0; i < message.drainage.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.drainage[i]);
            if (message.volcanism != null && message.volcanism.length)
                for (var i = 0; i < message.volcanism.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.volcanism[i]);
            if (message.savagery != null && message.savagery.length)
                for (var i = 0; i < message.savagery.length; ++i)
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.savagery[i]);
            if (message.clouds != null && message.clouds.length)
                for (var i = 0; i < message.clouds.length; ++i)
                    $root.RemoteFortressReader.Cloud.encode(message.clouds[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.salinity != null && message.salinity.length)
                for (var i = 0; i < message.salinity.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.salinity[i]);
            if (message.mapX != null && Object.hasOwnProperty.call(message, "mapX"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.mapX);
            if (message.mapY != null && Object.hasOwnProperty.call(message, "mapY"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.mapY);
            if (message.centerX != null && Object.hasOwnProperty.call(message, "centerX"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.centerX);
            if (message.centerY != null && Object.hasOwnProperty.call(message, "centerY"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.centerY);
            if (message.centerZ != null && Object.hasOwnProperty.call(message, "centerZ"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.centerZ);
            if (message.curYear != null && Object.hasOwnProperty.call(message, "curYear"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.curYear);
            if (message.curYearTick != null && Object.hasOwnProperty.call(message, "curYearTick"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.curYearTick);
            if (message.worldPoles != null && Object.hasOwnProperty.call(message, "worldPoles"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.worldPoles);
            if (message.riverTiles != null && message.riverTiles.length)
                for (var i = 0; i < message.riverTiles.length; ++i)
                    $root.RemoteFortressReader.RiverTile.encode(message.riverTiles[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.waterElevation != null && message.waterElevation.length)
                for (var i = 0; i < message.waterElevation.length; ++i)
                    writer.uint32(/* id 24, wireType 0 =*/192).int32(message.waterElevation[i]);
            if (message.regionTiles != null && message.regionTiles.length)
                for (var i = 0; i < message.regionTiles.length; ++i)
                    $root.RemoteFortressReader.RegionTile.encode(message.regionTiles[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WorldMap message, length delimited. Does not implicitly {@link RemoteFortressReader.WorldMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.IWorldMap} message WorldMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WorldMap message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.WorldMap} WorldMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.WorldMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldWidth = reader.int32();
                    break;
                case 2:
                    message.worldHeight = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.nameEnglish = reader.string();
                    break;
                case 5:
                    if (!(message.elevation && message.elevation.length))
                        message.elevation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.elevation.push(reader.int32());
                    } else
                        message.elevation.push(reader.int32());
                    break;
                case 6:
                    if (!(message.rainfall && message.rainfall.length))
                        message.rainfall = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rainfall.push(reader.int32());
                    } else
                        message.rainfall.push(reader.int32());
                    break;
                case 7:
                    if (!(message.vegetation && message.vegetation.length))
                        message.vegetation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.vegetation.push(reader.int32());
                    } else
                        message.vegetation.push(reader.int32());
                    break;
                case 8:
                    if (!(message.temperature && message.temperature.length))
                        message.temperature = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.temperature.push(reader.int32());
                    } else
                        message.temperature.push(reader.int32());
                    break;
                case 9:
                    if (!(message.evilness && message.evilness.length))
                        message.evilness = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.evilness.push(reader.int32());
                    } else
                        message.evilness.push(reader.int32());
                    break;
                case 10:
                    if (!(message.drainage && message.drainage.length))
                        message.drainage = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.drainage.push(reader.int32());
                    } else
                        message.drainage.push(reader.int32());
                    break;
                case 11:
                    if (!(message.volcanism && message.volcanism.length))
                        message.volcanism = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.volcanism.push(reader.int32());
                    } else
                        message.volcanism.push(reader.int32());
                    break;
                case 12:
                    if (!(message.savagery && message.savagery.length))
                        message.savagery = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.savagery.push(reader.int32());
                    } else
                        message.savagery.push(reader.int32());
                    break;
                case 13:
                    if (!(message.clouds && message.clouds.length))
                        message.clouds = [];
                    message.clouds.push($root.RemoteFortressReader.Cloud.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.salinity && message.salinity.length))
                        message.salinity = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.salinity.push(reader.int32());
                    } else
                        message.salinity.push(reader.int32());
                    break;
                case 15:
                    message.mapX = reader.int32();
                    break;
                case 16:
                    message.mapY = reader.int32();
                    break;
                case 17:
                    message.centerX = reader.int32();
                    break;
                case 18:
                    message.centerY = reader.int32();
                    break;
                case 19:
                    message.centerZ = reader.int32();
                    break;
                case 20:
                    message.curYear = reader.int32();
                    break;
                case 21:
                    message.curYearTick = reader.int32();
                    break;
                case 22:
                    message.worldPoles = reader.int32();
                    break;
                case 23:
                    if (!(message.riverTiles && message.riverTiles.length))
                        message.riverTiles = [];
                    message.riverTiles.push($root.RemoteFortressReader.RiverTile.decode(reader, reader.uint32()));
                    break;
                case 24:
                    if (!(message.waterElevation && message.waterElevation.length))
                        message.waterElevation = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waterElevation.push(reader.int32());
                    } else
                        message.waterElevation.push(reader.int32());
                    break;
                case 25:
                    if (!(message.regionTiles && message.regionTiles.length))
                        message.regionTiles = [];
                    message.regionTiles.push($root.RemoteFortressReader.RegionTile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("worldWidth"))
                throw $util.ProtocolError("missing required 'worldWidth'", { instance: message });
            if (!message.hasOwnProperty("worldHeight"))
                throw $util.ProtocolError("missing required 'worldHeight'", { instance: message });
            return message;
        };

        /**
         * Decodes a WorldMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.WorldMap} WorldMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WorldMap message.
         * @function verify
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WorldMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.worldWidth))
                return "worldWidth: integer expected";
            if (!$util.isInteger(message.worldHeight))
                return "worldHeight: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                if (!$util.isString(message.nameEnglish))
                    return "nameEnglish: string expected";
            if (message.elevation != null && message.hasOwnProperty("elevation")) {
                if (!Array.isArray(message.elevation))
                    return "elevation: array expected";
                for (var i = 0; i < message.elevation.length; ++i)
                    if (!$util.isInteger(message.elevation[i]))
                        return "elevation: integer[] expected";
            }
            if (message.rainfall != null && message.hasOwnProperty("rainfall")) {
                if (!Array.isArray(message.rainfall))
                    return "rainfall: array expected";
                for (var i = 0; i < message.rainfall.length; ++i)
                    if (!$util.isInteger(message.rainfall[i]))
                        return "rainfall: integer[] expected";
            }
            if (message.vegetation != null && message.hasOwnProperty("vegetation")) {
                if (!Array.isArray(message.vegetation))
                    return "vegetation: array expected";
                for (var i = 0; i < message.vegetation.length; ++i)
                    if (!$util.isInteger(message.vegetation[i]))
                        return "vegetation: integer[] expected";
            }
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                if (!Array.isArray(message.temperature))
                    return "temperature: array expected";
                for (var i = 0; i < message.temperature.length; ++i)
                    if (!$util.isInteger(message.temperature[i]))
                        return "temperature: integer[] expected";
            }
            if (message.evilness != null && message.hasOwnProperty("evilness")) {
                if (!Array.isArray(message.evilness))
                    return "evilness: array expected";
                for (var i = 0; i < message.evilness.length; ++i)
                    if (!$util.isInteger(message.evilness[i]))
                        return "evilness: integer[] expected";
            }
            if (message.drainage != null && message.hasOwnProperty("drainage")) {
                if (!Array.isArray(message.drainage))
                    return "drainage: array expected";
                for (var i = 0; i < message.drainage.length; ++i)
                    if (!$util.isInteger(message.drainage[i]))
                        return "drainage: integer[] expected";
            }
            if (message.volcanism != null && message.hasOwnProperty("volcanism")) {
                if (!Array.isArray(message.volcanism))
                    return "volcanism: array expected";
                for (var i = 0; i < message.volcanism.length; ++i)
                    if (!$util.isInteger(message.volcanism[i]))
                        return "volcanism: integer[] expected";
            }
            if (message.savagery != null && message.hasOwnProperty("savagery")) {
                if (!Array.isArray(message.savagery))
                    return "savagery: array expected";
                for (var i = 0; i < message.savagery.length; ++i)
                    if (!$util.isInteger(message.savagery[i]))
                        return "savagery: integer[] expected";
            }
            if (message.clouds != null && message.hasOwnProperty("clouds")) {
                if (!Array.isArray(message.clouds))
                    return "clouds: array expected";
                for (var i = 0; i < message.clouds.length; ++i) {
                    var error = $root.RemoteFortressReader.Cloud.verify(message.clouds[i]);
                    if (error)
                        return "clouds." + error;
                }
            }
            if (message.salinity != null && message.hasOwnProperty("salinity")) {
                if (!Array.isArray(message.salinity))
                    return "salinity: array expected";
                for (var i = 0; i < message.salinity.length; ++i)
                    if (!$util.isInteger(message.salinity[i]))
                        return "salinity: integer[] expected";
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                if (!$util.isInteger(message.mapX))
                    return "mapX: integer expected";
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                if (!$util.isInteger(message.mapY))
                    return "mapY: integer expected";
            if (message.centerX != null && message.hasOwnProperty("centerX"))
                if (!$util.isInteger(message.centerX))
                    return "centerX: integer expected";
            if (message.centerY != null && message.hasOwnProperty("centerY"))
                if (!$util.isInteger(message.centerY))
                    return "centerY: integer expected";
            if (message.centerZ != null && message.hasOwnProperty("centerZ"))
                if (!$util.isInteger(message.centerZ))
                    return "centerZ: integer expected";
            if (message.curYear != null && message.hasOwnProperty("curYear"))
                if (!$util.isInteger(message.curYear))
                    return "curYear: integer expected";
            if (message.curYearTick != null && message.hasOwnProperty("curYearTick"))
                if (!$util.isInteger(message.curYearTick))
                    return "curYearTick: integer expected";
            if (message.worldPoles != null && message.hasOwnProperty("worldPoles"))
                switch (message.worldPoles) {
                default:
                    return "worldPoles: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.riverTiles != null && message.hasOwnProperty("riverTiles")) {
                if (!Array.isArray(message.riverTiles))
                    return "riverTiles: array expected";
                for (var i = 0; i < message.riverTiles.length; ++i) {
                    var error = $root.RemoteFortressReader.RiverTile.verify(message.riverTiles[i]);
                    if (error)
                        return "riverTiles." + error;
                }
            }
            if (message.waterElevation != null && message.hasOwnProperty("waterElevation")) {
                if (!Array.isArray(message.waterElevation))
                    return "waterElevation: array expected";
                for (var i = 0; i < message.waterElevation.length; ++i)
                    if (!$util.isInteger(message.waterElevation[i]))
                        return "waterElevation: integer[] expected";
            }
            if (message.regionTiles != null && message.hasOwnProperty("regionTiles")) {
                if (!Array.isArray(message.regionTiles))
                    return "regionTiles: array expected";
                for (var i = 0; i < message.regionTiles.length; ++i) {
                    var error = $root.RemoteFortressReader.RegionTile.verify(message.regionTiles[i]);
                    if (error)
                        return "regionTiles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WorldMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.WorldMap} WorldMap
         */
        WorldMap.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.WorldMap)
                return object;
            var message = new $root.RemoteFortressReader.WorldMap();
            if (object.worldWidth != null)
                message.worldWidth = object.worldWidth | 0;
            if (object.worldHeight != null)
                message.worldHeight = object.worldHeight | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.nameEnglish != null)
                message.nameEnglish = String(object.nameEnglish);
            if (object.elevation) {
                if (!Array.isArray(object.elevation))
                    throw TypeError(".RemoteFortressReader.WorldMap.elevation: array expected");
                message.elevation = [];
                for (var i = 0; i < object.elevation.length; ++i)
                    message.elevation[i] = object.elevation[i] | 0;
            }
            if (object.rainfall) {
                if (!Array.isArray(object.rainfall))
                    throw TypeError(".RemoteFortressReader.WorldMap.rainfall: array expected");
                message.rainfall = [];
                for (var i = 0; i < object.rainfall.length; ++i)
                    message.rainfall[i] = object.rainfall[i] | 0;
            }
            if (object.vegetation) {
                if (!Array.isArray(object.vegetation))
                    throw TypeError(".RemoteFortressReader.WorldMap.vegetation: array expected");
                message.vegetation = [];
                for (var i = 0; i < object.vegetation.length; ++i)
                    message.vegetation[i] = object.vegetation[i] | 0;
            }
            if (object.temperature) {
                if (!Array.isArray(object.temperature))
                    throw TypeError(".RemoteFortressReader.WorldMap.temperature: array expected");
                message.temperature = [];
                for (var i = 0; i < object.temperature.length; ++i)
                    message.temperature[i] = object.temperature[i] | 0;
            }
            if (object.evilness) {
                if (!Array.isArray(object.evilness))
                    throw TypeError(".RemoteFortressReader.WorldMap.evilness: array expected");
                message.evilness = [];
                for (var i = 0; i < object.evilness.length; ++i)
                    message.evilness[i] = object.evilness[i] | 0;
            }
            if (object.drainage) {
                if (!Array.isArray(object.drainage))
                    throw TypeError(".RemoteFortressReader.WorldMap.drainage: array expected");
                message.drainage = [];
                for (var i = 0; i < object.drainage.length; ++i)
                    message.drainage[i] = object.drainage[i] | 0;
            }
            if (object.volcanism) {
                if (!Array.isArray(object.volcanism))
                    throw TypeError(".RemoteFortressReader.WorldMap.volcanism: array expected");
                message.volcanism = [];
                for (var i = 0; i < object.volcanism.length; ++i)
                    message.volcanism[i] = object.volcanism[i] | 0;
            }
            if (object.savagery) {
                if (!Array.isArray(object.savagery))
                    throw TypeError(".RemoteFortressReader.WorldMap.savagery: array expected");
                message.savagery = [];
                for (var i = 0; i < object.savagery.length; ++i)
                    message.savagery[i] = object.savagery[i] | 0;
            }
            if (object.clouds) {
                if (!Array.isArray(object.clouds))
                    throw TypeError(".RemoteFortressReader.WorldMap.clouds: array expected");
                message.clouds = [];
                for (var i = 0; i < object.clouds.length; ++i) {
                    if (typeof object.clouds[i] !== "object")
                        throw TypeError(".RemoteFortressReader.WorldMap.clouds: object expected");
                    message.clouds[i] = $root.RemoteFortressReader.Cloud.fromObject(object.clouds[i]);
                }
            }
            if (object.salinity) {
                if (!Array.isArray(object.salinity))
                    throw TypeError(".RemoteFortressReader.WorldMap.salinity: array expected");
                message.salinity = [];
                for (var i = 0; i < object.salinity.length; ++i)
                    message.salinity[i] = object.salinity[i] | 0;
            }
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.centerX != null)
                message.centerX = object.centerX | 0;
            if (object.centerY != null)
                message.centerY = object.centerY | 0;
            if (object.centerZ != null)
                message.centerZ = object.centerZ | 0;
            if (object.curYear != null)
                message.curYear = object.curYear | 0;
            if (object.curYearTick != null)
                message.curYearTick = object.curYearTick | 0;
            switch (object.worldPoles) {
            case "NO_POLES":
            case 0:
                message.worldPoles = 0;
                break;
            case "NORTH_POLE":
            case 1:
                message.worldPoles = 1;
                break;
            case "SOUTH_POLE":
            case 2:
                message.worldPoles = 2;
                break;
            case "BOTH_POLES":
            case 3:
                message.worldPoles = 3;
                break;
            }
            if (object.riverTiles) {
                if (!Array.isArray(object.riverTiles))
                    throw TypeError(".RemoteFortressReader.WorldMap.riverTiles: array expected");
                message.riverTiles = [];
                for (var i = 0; i < object.riverTiles.length; ++i) {
                    if (typeof object.riverTiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.WorldMap.riverTiles: object expected");
                    message.riverTiles[i] = $root.RemoteFortressReader.RiverTile.fromObject(object.riverTiles[i]);
                }
            }
            if (object.waterElevation) {
                if (!Array.isArray(object.waterElevation))
                    throw TypeError(".RemoteFortressReader.WorldMap.waterElevation: array expected");
                message.waterElevation = [];
                for (var i = 0; i < object.waterElevation.length; ++i)
                    message.waterElevation[i] = object.waterElevation[i] | 0;
            }
            if (object.regionTiles) {
                if (!Array.isArray(object.regionTiles))
                    throw TypeError(".RemoteFortressReader.WorldMap.regionTiles: array expected");
                message.regionTiles = [];
                for (var i = 0; i < object.regionTiles.length; ++i) {
                    if (typeof object.regionTiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.WorldMap.regionTiles: object expected");
                    message.regionTiles[i] = $root.RemoteFortressReader.RegionTile.fromObject(object.regionTiles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WorldMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.WorldMap
         * @static
         * @param {RemoteFortressReader.WorldMap} message WorldMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WorldMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.elevation = [];
                object.rainfall = [];
                object.vegetation = [];
                object.temperature = [];
                object.evilness = [];
                object.drainage = [];
                object.volcanism = [];
                object.savagery = [];
                object.clouds = [];
                object.salinity = [];
                object.riverTiles = [];
                object.waterElevation = [];
                object.regionTiles = [];
            }
            if (options.defaults) {
                object.worldWidth = 0;
                object.worldHeight = 0;
                object.name = "";
                object.nameEnglish = "";
                object.mapX = 0;
                object.mapY = 0;
                object.centerX = 0;
                object.centerY = 0;
                object.centerZ = 0;
                object.curYear = 0;
                object.curYearTick = 0;
                object.worldPoles = options.enums === String ? "NO_POLES" : 0;
            }
            if (message.worldWidth != null && message.hasOwnProperty("worldWidth"))
                object.worldWidth = message.worldWidth;
            if (message.worldHeight != null && message.hasOwnProperty("worldHeight"))
                object.worldHeight = message.worldHeight;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                object.nameEnglish = message.nameEnglish;
            if (message.elevation && message.elevation.length) {
                object.elevation = [];
                for (var j = 0; j < message.elevation.length; ++j)
                    object.elevation[j] = message.elevation[j];
            }
            if (message.rainfall && message.rainfall.length) {
                object.rainfall = [];
                for (var j = 0; j < message.rainfall.length; ++j)
                    object.rainfall[j] = message.rainfall[j];
            }
            if (message.vegetation && message.vegetation.length) {
                object.vegetation = [];
                for (var j = 0; j < message.vegetation.length; ++j)
                    object.vegetation[j] = message.vegetation[j];
            }
            if (message.temperature && message.temperature.length) {
                object.temperature = [];
                for (var j = 0; j < message.temperature.length; ++j)
                    object.temperature[j] = message.temperature[j];
            }
            if (message.evilness && message.evilness.length) {
                object.evilness = [];
                for (var j = 0; j < message.evilness.length; ++j)
                    object.evilness[j] = message.evilness[j];
            }
            if (message.drainage && message.drainage.length) {
                object.drainage = [];
                for (var j = 0; j < message.drainage.length; ++j)
                    object.drainage[j] = message.drainage[j];
            }
            if (message.volcanism && message.volcanism.length) {
                object.volcanism = [];
                for (var j = 0; j < message.volcanism.length; ++j)
                    object.volcanism[j] = message.volcanism[j];
            }
            if (message.savagery && message.savagery.length) {
                object.savagery = [];
                for (var j = 0; j < message.savagery.length; ++j)
                    object.savagery[j] = message.savagery[j];
            }
            if (message.clouds && message.clouds.length) {
                object.clouds = [];
                for (var j = 0; j < message.clouds.length; ++j)
                    object.clouds[j] = $root.RemoteFortressReader.Cloud.toObject(message.clouds[j], options);
            }
            if (message.salinity && message.salinity.length) {
                object.salinity = [];
                for (var j = 0; j < message.salinity.length; ++j)
                    object.salinity[j] = message.salinity[j];
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.centerX != null && message.hasOwnProperty("centerX"))
                object.centerX = message.centerX;
            if (message.centerY != null && message.hasOwnProperty("centerY"))
                object.centerY = message.centerY;
            if (message.centerZ != null && message.hasOwnProperty("centerZ"))
                object.centerZ = message.centerZ;
            if (message.curYear != null && message.hasOwnProperty("curYear"))
                object.curYear = message.curYear;
            if (message.curYearTick != null && message.hasOwnProperty("curYearTick"))
                object.curYearTick = message.curYearTick;
            if (message.worldPoles != null && message.hasOwnProperty("worldPoles"))
                object.worldPoles = options.enums === String ? $root.RemoteFortressReader.WorldPoles[message.worldPoles] : message.worldPoles;
            if (message.riverTiles && message.riverTiles.length) {
                object.riverTiles = [];
                for (var j = 0; j < message.riverTiles.length; ++j)
                    object.riverTiles[j] = $root.RemoteFortressReader.RiverTile.toObject(message.riverTiles[j], options);
            }
            if (message.waterElevation && message.waterElevation.length) {
                object.waterElevation = [];
                for (var j = 0; j < message.waterElevation.length; ++j)
                    object.waterElevation[j] = message.waterElevation[j];
            }
            if (message.regionTiles && message.regionTiles.length) {
                object.regionTiles = [];
                for (var j = 0; j < message.regionTiles.length; ++j)
                    object.regionTiles[j] = $root.RemoteFortressReader.RegionTile.toObject(message.regionTiles[j], options);
            }
            return object;
        };

        /**
         * Converts this WorldMap to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.WorldMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WorldMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WorldMap;
    })();

    /**
     * SiteRealizationBuildingType enum.
     * @name RemoteFortressReader.SiteRealizationBuildingType
     * @enum {string}
     * @property {number} cottage_plot=0 cottage_plot value
     * @property {number} castle_wall=1 castle_wall value
     * @property {number} castle_tower=2 castle_tower value
     * @property {number} castle_courtyard=3 castle_courtyard value
     * @property {number} house=4 house value
     * @property {number} temple=5 temple value
     * @property {number} tomb=6 tomb value
     * @property {number} shop_house=7 shop_house value
     * @property {number} warehouse=8 warehouse value
     * @property {number} market_square=9 market_square value
     * @property {number} pasture=10 pasture value
     * @property {number} waste=11 waste value
     * @property {number} courtyard=12 courtyard value
     * @property {number} well=13 well value
     * @property {number} vault=14 vault value
     * @property {number} great_tower=15 great_tower value
     * @property {number} trenches=16 trenches value
     * @property {number} tree_house=17 tree_house value
     * @property {number} hillock_house=18 hillock_house value
     * @property {number} mead_hall=19 mead_hall value
     * @property {number} fortress_entrance=20 fortress_entrance value
     * @property {number} library=21 library value
     * @property {number} tavern=22 tavern value
     */
    RemoteFortressReader.SiteRealizationBuildingType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "cottage_plot"] = 0;
        values[valuesById[1] = "castle_wall"] = 1;
        values[valuesById[2] = "castle_tower"] = 2;
        values[valuesById[3] = "castle_courtyard"] = 3;
        values[valuesById[4] = "house"] = 4;
        values[valuesById[5] = "temple"] = 5;
        values[valuesById[6] = "tomb"] = 6;
        values[valuesById[7] = "shop_house"] = 7;
        values[valuesById[8] = "warehouse"] = 8;
        values[valuesById[9] = "market_square"] = 9;
        values[valuesById[10] = "pasture"] = 10;
        values[valuesById[11] = "waste"] = 11;
        values[valuesById[12] = "courtyard"] = 12;
        values[valuesById[13] = "well"] = 13;
        values[valuesById[14] = "vault"] = 14;
        values[valuesById[15] = "great_tower"] = 15;
        values[valuesById[16] = "trenches"] = 16;
        values[valuesById[17] = "tree_house"] = 17;
        values[valuesById[18] = "hillock_house"] = 18;
        values[valuesById[19] = "mead_hall"] = 19;
        values[valuesById[20] = "fortress_entrance"] = 20;
        values[valuesById[21] = "library"] = 21;
        values[valuesById[22] = "tavern"] = 22;
        return values;
    })();

    RemoteFortressReader.SiteRealizationBuildingWall = (function() {

        /**
         * Properties of a SiteRealizationBuildingWall.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuildingWall
         * @property {number|null} [startX] SiteRealizationBuildingWall startX
         * @property {number|null} [startY] SiteRealizationBuildingWall startY
         * @property {number|null} [startZ] SiteRealizationBuildingWall startZ
         * @property {number|null} [endX] SiteRealizationBuildingWall endX
         * @property {number|null} [endY] SiteRealizationBuildingWall endY
         * @property {number|null} [endZ] SiteRealizationBuildingWall endZ
         */

        /**
         * Constructs a new SiteRealizationBuildingWall.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuildingWall.
         * @implements ISiteRealizationBuildingWall
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall=} [properties] Properties to set
         */
        function SiteRealizationBuildingWall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuildingWall startX.
         * @member {number} startX
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.startX = 0;

        /**
         * SiteRealizationBuildingWall startY.
         * @member {number} startY
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.startY = 0;

        /**
         * SiteRealizationBuildingWall startZ.
         * @member {number} startZ
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.startZ = 0;

        /**
         * SiteRealizationBuildingWall endX.
         * @member {number} endX
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.endX = 0;

        /**
         * SiteRealizationBuildingWall endY.
         * @member {number} endY
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.endY = 0;

        /**
         * SiteRealizationBuildingWall endZ.
         * @member {number} endZ
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         */
        SiteRealizationBuildingWall.prototype.endZ = 0;

        /**
         * Creates a new SiteRealizationBuildingWall instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall instance
         */
        SiteRealizationBuildingWall.create = function create(properties) {
            return new SiteRealizationBuildingWall(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuildingWall message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingWall.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall} message SiteRealizationBuildingWall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingWall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startX != null && Object.hasOwnProperty.call(message, "startX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.startX);
            if (message.startY != null && Object.hasOwnProperty.call(message, "startY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.startY);
            if (message.startZ != null && Object.hasOwnProperty.call(message, "startZ"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.startZ);
            if (message.endX != null && Object.hasOwnProperty.call(message, "endX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.endX);
            if (message.endY != null && Object.hasOwnProperty.call(message, "endY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.endY);
            if (message.endZ != null && Object.hasOwnProperty.call(message, "endZ"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.endZ);
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuildingWall message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingWall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingWall} message SiteRealizationBuildingWall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingWall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuildingWall message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingWall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuildingWall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startX = reader.int32();
                    break;
                case 2:
                    message.startY = reader.int32();
                    break;
                case 3:
                    message.startZ = reader.int32();
                    break;
                case 4:
                    message.endX = reader.int32();
                    break;
                case 5:
                    message.endY = reader.int32();
                    break;
                case 6:
                    message.endZ = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuildingWall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingWall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuildingWall message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuildingWall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startX != null && message.hasOwnProperty("startX"))
                if (!$util.isInteger(message.startX))
                    return "startX: integer expected";
            if (message.startY != null && message.hasOwnProperty("startY"))
                if (!$util.isInteger(message.startY))
                    return "startY: integer expected";
            if (message.startZ != null && message.hasOwnProperty("startZ"))
                if (!$util.isInteger(message.startZ))
                    return "startZ: integer expected";
            if (message.endX != null && message.hasOwnProperty("endX"))
                if (!$util.isInteger(message.endX))
                    return "endX: integer expected";
            if (message.endY != null && message.hasOwnProperty("endY"))
                if (!$util.isInteger(message.endY))
                    return "endY: integer expected";
            if (message.endZ != null && message.hasOwnProperty("endZ"))
                if (!$util.isInteger(message.endZ))
                    return "endZ: integer expected";
            return null;
        };

        /**
         * Creates a SiteRealizationBuildingWall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuildingWall} SiteRealizationBuildingWall
         */
        SiteRealizationBuildingWall.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuildingWall)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuildingWall();
            if (object.startX != null)
                message.startX = object.startX | 0;
            if (object.startY != null)
                message.startY = object.startY | 0;
            if (object.startZ != null)
                message.startZ = object.startZ | 0;
            if (object.endX != null)
                message.endX = object.endX | 0;
            if (object.endY != null)
                message.endY = object.endY | 0;
            if (object.endZ != null)
                message.endZ = object.endZ | 0;
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuildingWall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuildingWall} message SiteRealizationBuildingWall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuildingWall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.startX = 0;
                object.startY = 0;
                object.startZ = 0;
                object.endX = 0;
                object.endY = 0;
                object.endZ = 0;
            }
            if (message.startX != null && message.hasOwnProperty("startX"))
                object.startX = message.startX;
            if (message.startY != null && message.hasOwnProperty("startY"))
                object.startY = message.startY;
            if (message.startZ != null && message.hasOwnProperty("startZ"))
                object.startZ = message.startZ;
            if (message.endX != null && message.hasOwnProperty("endX"))
                object.endX = message.endX;
            if (message.endY != null && message.hasOwnProperty("endY"))
                object.endY = message.endY;
            if (message.endZ != null && message.hasOwnProperty("endZ"))
                object.endZ = message.endZ;
            return object;
        };

        /**
         * Converts this SiteRealizationBuildingWall to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuildingWall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuildingWall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuildingWall;
    })();

    RemoteFortressReader.SiteRealizationBuildingTower = (function() {

        /**
         * Properties of a SiteRealizationBuildingTower.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuildingTower
         * @property {number|null} [roofZ] SiteRealizationBuildingTower roofZ
         * @property {boolean|null} [round] SiteRealizationBuildingTower round
         * @property {boolean|null} [goblin] SiteRealizationBuildingTower goblin
         */

        /**
         * Constructs a new SiteRealizationBuildingTower.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuildingTower.
         * @implements ISiteRealizationBuildingTower
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower=} [properties] Properties to set
         */
        function SiteRealizationBuildingTower(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuildingTower roofZ.
         * @member {number} roofZ
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         */
        SiteRealizationBuildingTower.prototype.roofZ = 0;

        /**
         * SiteRealizationBuildingTower round.
         * @member {boolean} round
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         */
        SiteRealizationBuildingTower.prototype.round = false;

        /**
         * SiteRealizationBuildingTower goblin.
         * @member {boolean} goblin
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         */
        SiteRealizationBuildingTower.prototype.goblin = false;

        /**
         * Creates a new SiteRealizationBuildingTower instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower instance
         */
        SiteRealizationBuildingTower.create = function create(properties) {
            return new SiteRealizationBuildingTower(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuildingTower message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTower.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower} message SiteRealizationBuildingTower message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTower.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roofZ != null && Object.hasOwnProperty.call(message, "roofZ"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roofZ);
            if (message.round != null && Object.hasOwnProperty.call(message, "round"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.round);
            if (message.goblin != null && Object.hasOwnProperty.call(message, "goblin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.goblin);
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuildingTower message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTower.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTower} message SiteRealizationBuildingTower message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTower.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuildingTower message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTower.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuildingTower();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roofZ = reader.int32();
                    break;
                case 2:
                    message.round = reader.bool();
                    break;
                case 3:
                    message.goblin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuildingTower message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTower.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuildingTower message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuildingTower.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roofZ != null && message.hasOwnProperty("roofZ"))
                if (!$util.isInteger(message.roofZ))
                    return "roofZ: integer expected";
            if (message.round != null && message.hasOwnProperty("round"))
                if (typeof message.round !== "boolean")
                    return "round: boolean expected";
            if (message.goblin != null && message.hasOwnProperty("goblin"))
                if (typeof message.goblin !== "boolean")
                    return "goblin: boolean expected";
            return null;
        };

        /**
         * Creates a SiteRealizationBuildingTower message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuildingTower} SiteRealizationBuildingTower
         */
        SiteRealizationBuildingTower.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuildingTower)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuildingTower();
            if (object.roofZ != null)
                message.roofZ = object.roofZ | 0;
            if (object.round != null)
                message.round = Boolean(object.round);
            if (object.goblin != null)
                message.goblin = Boolean(object.goblin);
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuildingTower message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuildingTower} message SiteRealizationBuildingTower
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuildingTower.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roofZ = 0;
                object.round = false;
                object.goblin = false;
            }
            if (message.roofZ != null && message.hasOwnProperty("roofZ"))
                object.roofZ = message.roofZ;
            if (message.round != null && message.hasOwnProperty("round"))
                object.round = message.round;
            if (message.goblin != null && message.hasOwnProperty("goblin"))
                object.goblin = message.goblin;
            return object;
        };

        /**
         * Converts this SiteRealizationBuildingTower to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuildingTower
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuildingTower.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuildingTower;
    })();

    RemoteFortressReader.TrenchSpoke = (function() {

        /**
         * Properties of a TrenchSpoke.
         * @memberof RemoteFortressReader
         * @interface ITrenchSpoke
         * @property {number|null} [moundStart] TrenchSpoke moundStart
         * @property {number|null} [trenchStart] TrenchSpoke trenchStart
         * @property {number|null} [trenchEnd] TrenchSpoke trenchEnd
         * @property {number|null} [moundEnd] TrenchSpoke moundEnd
         */

        /**
         * Constructs a new TrenchSpoke.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TrenchSpoke.
         * @implements ITrenchSpoke
         * @constructor
         * @param {RemoteFortressReader.ITrenchSpoke=} [properties] Properties to set
         */
        function TrenchSpoke(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrenchSpoke moundStart.
         * @member {number} moundStart
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.moundStart = 0;

        /**
         * TrenchSpoke trenchStart.
         * @member {number} trenchStart
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.trenchStart = 0;

        /**
         * TrenchSpoke trenchEnd.
         * @member {number} trenchEnd
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.trenchEnd = 0;

        /**
         * TrenchSpoke moundEnd.
         * @member {number} moundEnd
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         */
        TrenchSpoke.prototype.moundEnd = 0;

        /**
         * Creates a new TrenchSpoke instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.ITrenchSpoke=} [properties] Properties to set
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke instance
         */
        TrenchSpoke.create = function create(properties) {
            return new TrenchSpoke(properties);
        };

        /**
         * Encodes the specified TrenchSpoke message. Does not implicitly {@link RemoteFortressReader.TrenchSpoke.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.ITrenchSpoke} message TrenchSpoke message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrenchSpoke.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.moundStart != null && Object.hasOwnProperty.call(message, "moundStart"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.moundStart);
            if (message.trenchStart != null && Object.hasOwnProperty.call(message, "trenchStart"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trenchStart);
            if (message.trenchEnd != null && Object.hasOwnProperty.call(message, "trenchEnd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trenchEnd);
            if (message.moundEnd != null && Object.hasOwnProperty.call(message, "moundEnd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.moundEnd);
            return writer;
        };

        /**
         * Encodes the specified TrenchSpoke message, length delimited. Does not implicitly {@link RemoteFortressReader.TrenchSpoke.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.ITrenchSpoke} message TrenchSpoke message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrenchSpoke.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrenchSpoke message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrenchSpoke.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TrenchSpoke();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.moundStart = reader.int32();
                    break;
                case 2:
                    message.trenchStart = reader.int32();
                    break;
                case 3:
                    message.trenchEnd = reader.int32();
                    break;
                case 4:
                    message.moundEnd = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrenchSpoke message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrenchSpoke.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrenchSpoke message.
         * @function verify
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrenchSpoke.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.moundStart != null && message.hasOwnProperty("moundStart"))
                if (!$util.isInteger(message.moundStart))
                    return "moundStart: integer expected";
            if (message.trenchStart != null && message.hasOwnProperty("trenchStart"))
                if (!$util.isInteger(message.trenchStart))
                    return "trenchStart: integer expected";
            if (message.trenchEnd != null && message.hasOwnProperty("trenchEnd"))
                if (!$util.isInteger(message.trenchEnd))
                    return "trenchEnd: integer expected";
            if (message.moundEnd != null && message.hasOwnProperty("moundEnd"))
                if (!$util.isInteger(message.moundEnd))
                    return "moundEnd: integer expected";
            return null;
        };

        /**
         * Creates a TrenchSpoke message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TrenchSpoke} TrenchSpoke
         */
        TrenchSpoke.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TrenchSpoke)
                return object;
            var message = new $root.RemoteFortressReader.TrenchSpoke();
            if (object.moundStart != null)
                message.moundStart = object.moundStart | 0;
            if (object.trenchStart != null)
                message.trenchStart = object.trenchStart | 0;
            if (object.trenchEnd != null)
                message.trenchEnd = object.trenchEnd | 0;
            if (object.moundEnd != null)
                message.moundEnd = object.moundEnd | 0;
            return message;
        };

        /**
         * Creates a plain object from a TrenchSpoke message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TrenchSpoke
         * @static
         * @param {RemoteFortressReader.TrenchSpoke} message TrenchSpoke
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrenchSpoke.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.moundStart = 0;
                object.trenchStart = 0;
                object.trenchEnd = 0;
                object.moundEnd = 0;
            }
            if (message.moundStart != null && message.hasOwnProperty("moundStart"))
                object.moundStart = message.moundStart;
            if (message.trenchStart != null && message.hasOwnProperty("trenchStart"))
                object.trenchStart = message.trenchStart;
            if (message.trenchEnd != null && message.hasOwnProperty("trenchEnd"))
                object.trenchEnd = message.trenchEnd;
            if (message.moundEnd != null && message.hasOwnProperty("moundEnd"))
                object.moundEnd = message.moundEnd;
            return object;
        };

        /**
         * Converts this TrenchSpoke to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TrenchSpoke
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrenchSpoke.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrenchSpoke;
    })();

    RemoteFortressReader.SiteRealizationBuildingTrenches = (function() {

        /**
         * Properties of a SiteRealizationBuildingTrenches.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuildingTrenches
         * @property {Array.<RemoteFortressReader.ITrenchSpoke>|null} [spokes] SiteRealizationBuildingTrenches spokes
         */

        /**
         * Constructs a new SiteRealizationBuildingTrenches.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuildingTrenches.
         * @implements ISiteRealizationBuildingTrenches
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches=} [properties] Properties to set
         */
        function SiteRealizationBuildingTrenches(properties) {
            this.spokes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuildingTrenches spokes.
         * @member {Array.<RemoteFortressReader.ITrenchSpoke>} spokes
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @instance
         */
        SiteRealizationBuildingTrenches.prototype.spokes = $util.emptyArray;

        /**
         * Creates a new SiteRealizationBuildingTrenches instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches instance
         */
        SiteRealizationBuildingTrenches.create = function create(properties) {
            return new SiteRealizationBuildingTrenches(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuildingTrenches message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTrenches.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches} message SiteRealizationBuildingTrenches message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTrenches.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spokes != null && message.spokes.length)
                for (var i = 0; i < message.spokes.length; ++i)
                    $root.RemoteFortressReader.TrenchSpoke.encode(message.spokes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuildingTrenches message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuildingTrenches.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuildingTrenches} message SiteRealizationBuildingTrenches message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuildingTrenches.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuildingTrenches message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTrenches.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuildingTrenches();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.spokes && message.spokes.length))
                        message.spokes = [];
                    message.spokes.push($root.RemoteFortressReader.TrenchSpoke.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuildingTrenches message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuildingTrenches.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuildingTrenches message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuildingTrenches.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spokes != null && message.hasOwnProperty("spokes")) {
                if (!Array.isArray(message.spokes))
                    return "spokes: array expected";
                for (var i = 0; i < message.spokes.length; ++i) {
                    var error = $root.RemoteFortressReader.TrenchSpoke.verify(message.spokes[i]);
                    if (error)
                        return "spokes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SiteRealizationBuildingTrenches message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuildingTrenches} SiteRealizationBuildingTrenches
         */
        SiteRealizationBuildingTrenches.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuildingTrenches)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuildingTrenches();
            if (object.spokes) {
                if (!Array.isArray(object.spokes))
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuildingTrenches.spokes: array expected");
                message.spokes = [];
                for (var i = 0; i < object.spokes.length; ++i) {
                    if (typeof object.spokes[i] !== "object")
                        throw TypeError(".RemoteFortressReader.SiteRealizationBuildingTrenches.spokes: object expected");
                    message.spokes[i] = $root.RemoteFortressReader.TrenchSpoke.fromObject(object.spokes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuildingTrenches message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuildingTrenches} message SiteRealizationBuildingTrenches
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuildingTrenches.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.spokes = [];
            if (message.spokes && message.spokes.length) {
                object.spokes = [];
                for (var j = 0; j < message.spokes.length; ++j)
                    object.spokes[j] = $root.RemoteFortressReader.TrenchSpoke.toObject(message.spokes[j], options);
            }
            return object;
        };

        /**
         * Converts this SiteRealizationBuildingTrenches to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuildingTrenches
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuildingTrenches.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuildingTrenches;
    })();

    RemoteFortressReader.SiteRealizationBuilding = (function() {

        /**
         * Properties of a SiteRealizationBuilding.
         * @memberof RemoteFortressReader
         * @interface ISiteRealizationBuilding
         * @property {number|null} [id] SiteRealizationBuilding id
         * @property {RemoteFortressReader.SiteRealizationBuildingType|null} [type] SiteRealizationBuilding type
         * @property {number|null} [minX] SiteRealizationBuilding minX
         * @property {number|null} [minY] SiteRealizationBuilding minY
         * @property {number|null} [maxX] SiteRealizationBuilding maxX
         * @property {number|null} [maxY] SiteRealizationBuilding maxY
         * @property {RemoteFortressReader.IMatPair|null} [material] SiteRealizationBuilding material
         * @property {RemoteFortressReader.ISiteRealizationBuildingWall|null} [wallInfo] SiteRealizationBuilding wallInfo
         * @property {RemoteFortressReader.ISiteRealizationBuildingTower|null} [towerInfo] SiteRealizationBuilding towerInfo
         * @property {RemoteFortressReader.ISiteRealizationBuildingTrenches|null} [trenchInfo] SiteRealizationBuilding trenchInfo
         */

        /**
         * Constructs a new SiteRealizationBuilding.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SiteRealizationBuilding.
         * @implements ISiteRealizationBuilding
         * @constructor
         * @param {RemoteFortressReader.ISiteRealizationBuilding=} [properties] Properties to set
         */
        function SiteRealizationBuilding(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SiteRealizationBuilding id.
         * @member {number} id
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.id = 0;

        /**
         * SiteRealizationBuilding type.
         * @member {RemoteFortressReader.SiteRealizationBuildingType} type
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.type = 0;

        /**
         * SiteRealizationBuilding minX.
         * @member {number} minX
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.minX = 0;

        /**
         * SiteRealizationBuilding minY.
         * @member {number} minY
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.minY = 0;

        /**
         * SiteRealizationBuilding maxX.
         * @member {number} maxX
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.maxX = 0;

        /**
         * SiteRealizationBuilding maxY.
         * @member {number} maxY
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.maxY = 0;

        /**
         * SiteRealizationBuilding material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.material = null;

        /**
         * SiteRealizationBuilding wallInfo.
         * @member {RemoteFortressReader.ISiteRealizationBuildingWall|null|undefined} wallInfo
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.wallInfo = null;

        /**
         * SiteRealizationBuilding towerInfo.
         * @member {RemoteFortressReader.ISiteRealizationBuildingTower|null|undefined} towerInfo
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.towerInfo = null;

        /**
         * SiteRealizationBuilding trenchInfo.
         * @member {RemoteFortressReader.ISiteRealizationBuildingTrenches|null|undefined} trenchInfo
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         */
        SiteRealizationBuilding.prototype.trenchInfo = null;

        /**
         * Creates a new SiteRealizationBuilding instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuilding=} [properties] Properties to set
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding instance
         */
        SiteRealizationBuilding.create = function create(properties) {
            return new SiteRealizationBuilding(properties);
        };

        /**
         * Encodes the specified SiteRealizationBuilding message. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuilding.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuilding} message SiteRealizationBuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuilding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.minX != null && Object.hasOwnProperty.call(message, "minX"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minX);
            if (message.minY != null && Object.hasOwnProperty.call(message, "minY"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minY);
            if (message.maxX != null && Object.hasOwnProperty.call(message, "maxX"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxX);
            if (message.maxY != null && Object.hasOwnProperty.call(message, "maxY"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxY);
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.wallInfo != null && Object.hasOwnProperty.call(message, "wallInfo"))
                $root.RemoteFortressReader.SiteRealizationBuildingWall.encode(message.wallInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.towerInfo != null && Object.hasOwnProperty.call(message, "towerInfo"))
                $root.RemoteFortressReader.SiteRealizationBuildingTower.encode(message.towerInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.trenchInfo != null && Object.hasOwnProperty.call(message, "trenchInfo"))
                $root.RemoteFortressReader.SiteRealizationBuildingTrenches.encode(message.trenchInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SiteRealizationBuilding message, length delimited. Does not implicitly {@link RemoteFortressReader.SiteRealizationBuilding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.ISiteRealizationBuilding} message SiteRealizationBuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SiteRealizationBuilding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SiteRealizationBuilding message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuilding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SiteRealizationBuilding();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.minX = reader.int32();
                    break;
                case 4:
                    message.minY = reader.int32();
                    break;
                case 5:
                    message.maxX = reader.int32();
                    break;
                case 6:
                    message.maxY = reader.int32();
                    break;
                case 7:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.wallInfo = $root.RemoteFortressReader.SiteRealizationBuildingWall.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.towerInfo = $root.RemoteFortressReader.SiteRealizationBuildingTower.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.trenchInfo = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SiteRealizationBuilding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SiteRealizationBuilding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SiteRealizationBuilding message.
         * @function verify
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SiteRealizationBuilding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                    break;
                }
            if (message.minX != null && message.hasOwnProperty("minX"))
                if (!$util.isInteger(message.minX))
                    return "minX: integer expected";
            if (message.minY != null && message.hasOwnProperty("minY"))
                if (!$util.isInteger(message.minY))
                    return "minY: integer expected";
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                if (!$util.isInteger(message.maxX))
                    return "maxX: integer expected";
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                if (!$util.isInteger(message.maxY))
                    return "maxY: integer expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.wallInfo != null && message.hasOwnProperty("wallInfo")) {
                var error = $root.RemoteFortressReader.SiteRealizationBuildingWall.verify(message.wallInfo);
                if (error)
                    return "wallInfo." + error;
            }
            if (message.towerInfo != null && message.hasOwnProperty("towerInfo")) {
                var error = $root.RemoteFortressReader.SiteRealizationBuildingTower.verify(message.towerInfo);
                if (error)
                    return "towerInfo." + error;
            }
            if (message.trenchInfo != null && message.hasOwnProperty("trenchInfo")) {
                var error = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.verify(message.trenchInfo);
                if (error)
                    return "trenchInfo." + error;
            }
            return null;
        };

        /**
         * Creates a SiteRealizationBuilding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SiteRealizationBuilding} SiteRealizationBuilding
         */
        SiteRealizationBuilding.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SiteRealizationBuilding)
                return object;
            var message = new $root.RemoteFortressReader.SiteRealizationBuilding();
            if (object.id != null)
                message.id = object.id | 0;
            switch (object.type) {
            case "cottage_plot":
            case 0:
                message.type = 0;
                break;
            case "castle_wall":
            case 1:
                message.type = 1;
                break;
            case "castle_tower":
            case 2:
                message.type = 2;
                break;
            case "castle_courtyard":
            case 3:
                message.type = 3;
                break;
            case "house":
            case 4:
                message.type = 4;
                break;
            case "temple":
            case 5:
                message.type = 5;
                break;
            case "tomb":
            case 6:
                message.type = 6;
                break;
            case "shop_house":
            case 7:
                message.type = 7;
                break;
            case "warehouse":
            case 8:
                message.type = 8;
                break;
            case "market_square":
            case 9:
                message.type = 9;
                break;
            case "pasture":
            case 10:
                message.type = 10;
                break;
            case "waste":
            case 11:
                message.type = 11;
                break;
            case "courtyard":
            case 12:
                message.type = 12;
                break;
            case "well":
            case 13:
                message.type = 13;
                break;
            case "vault":
            case 14:
                message.type = 14;
                break;
            case "great_tower":
            case 15:
                message.type = 15;
                break;
            case "trenches":
            case 16:
                message.type = 16;
                break;
            case "tree_house":
            case 17:
                message.type = 17;
                break;
            case "hillock_house":
            case 18:
                message.type = 18;
                break;
            case "mead_hall":
            case 19:
                message.type = 19;
                break;
            case "fortress_entrance":
            case 20:
                message.type = 20;
                break;
            case "library":
            case 21:
                message.type = 21;
                break;
            case "tavern":
            case 22:
                message.type = 22;
                break;
            }
            if (object.minX != null)
                message.minX = object.minX | 0;
            if (object.minY != null)
                message.minY = object.minY | 0;
            if (object.maxX != null)
                message.maxX = object.maxX | 0;
            if (object.maxY != null)
                message.maxY = object.maxY | 0;
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.wallInfo != null) {
                if (typeof object.wallInfo !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.wallInfo: object expected");
                message.wallInfo = $root.RemoteFortressReader.SiteRealizationBuildingWall.fromObject(object.wallInfo);
            }
            if (object.towerInfo != null) {
                if (typeof object.towerInfo !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.towerInfo: object expected");
                message.towerInfo = $root.RemoteFortressReader.SiteRealizationBuildingTower.fromObject(object.towerInfo);
            }
            if (object.trenchInfo != null) {
                if (typeof object.trenchInfo !== "object")
                    throw TypeError(".RemoteFortressReader.SiteRealizationBuilding.trenchInfo: object expected");
                message.trenchInfo = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.fromObject(object.trenchInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a SiteRealizationBuilding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @static
         * @param {RemoteFortressReader.SiteRealizationBuilding} message SiteRealizationBuilding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SiteRealizationBuilding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.type = options.enums === String ? "cottage_plot" : 0;
                object.minX = 0;
                object.minY = 0;
                object.maxX = 0;
                object.maxY = 0;
                object.material = null;
                object.wallInfo = null;
                object.towerInfo = null;
                object.trenchInfo = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.SiteRealizationBuildingType[message.type] : message.type;
            if (message.minX != null && message.hasOwnProperty("minX"))
                object.minX = message.minX;
            if (message.minY != null && message.hasOwnProperty("minY"))
                object.minY = message.minY;
            if (message.maxX != null && message.hasOwnProperty("maxX"))
                object.maxX = message.maxX;
            if (message.maxY != null && message.hasOwnProperty("maxY"))
                object.maxY = message.maxY;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.wallInfo != null && message.hasOwnProperty("wallInfo"))
                object.wallInfo = $root.RemoteFortressReader.SiteRealizationBuildingWall.toObject(message.wallInfo, options);
            if (message.towerInfo != null && message.hasOwnProperty("towerInfo"))
                object.towerInfo = $root.RemoteFortressReader.SiteRealizationBuildingTower.toObject(message.towerInfo, options);
            if (message.trenchInfo != null && message.hasOwnProperty("trenchInfo"))
                object.trenchInfo = $root.RemoteFortressReader.SiteRealizationBuildingTrenches.toObject(message.trenchInfo, options);
            return object;
        };

        /**
         * Converts this SiteRealizationBuilding to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SiteRealizationBuilding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SiteRealizationBuilding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SiteRealizationBuilding;
    })();

    RemoteFortressReader.RegionTile = (function() {

        /**
         * Properties of a RegionTile.
         * @memberof RemoteFortressReader
         * @interface IRegionTile
         * @property {number|null} [elevation] RegionTile elevation
         * @property {number|null} [rainfall] RegionTile rainfall
         * @property {number|null} [vegetation] RegionTile vegetation
         * @property {number|null} [temperature] RegionTile temperature
         * @property {number|null} [evilness] RegionTile evilness
         * @property {number|null} [drainage] RegionTile drainage
         * @property {number|null} [volcanism] RegionTile volcanism
         * @property {number|null} [savagery] RegionTile savagery
         * @property {number|null} [salinity] RegionTile salinity
         * @property {RemoteFortressReader.IRiverTile|null} [riverTiles] RegionTile riverTiles
         * @property {number|null} [waterElevation] RegionTile waterElevation
         * @property {RemoteFortressReader.IMatPair|null} [surfaceMaterial] RegionTile surfaceMaterial
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [plantMaterials] RegionTile plantMaterials
         * @property {Array.<RemoteFortressReader.ISiteRealizationBuilding>|null} [buildings] RegionTile buildings
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [stoneMaterials] RegionTile stoneMaterials
         * @property {Array.<RemoteFortressReader.IMatPair>|null} [treeMaterials] RegionTile treeMaterials
         * @property {number|null} [snow] RegionTile snow
         */

        /**
         * Constructs a new RegionTile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RegionTile.
         * @implements IRegionTile
         * @constructor
         * @param {RemoteFortressReader.IRegionTile=} [properties] Properties to set
         */
        function RegionTile(properties) {
            this.plantMaterials = [];
            this.buildings = [];
            this.stoneMaterials = [];
            this.treeMaterials = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegionTile elevation.
         * @member {number} elevation
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.elevation = 0;

        /**
         * RegionTile rainfall.
         * @member {number} rainfall
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.rainfall = 0;

        /**
         * RegionTile vegetation.
         * @member {number} vegetation
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.vegetation = 0;

        /**
         * RegionTile temperature.
         * @member {number} temperature
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.temperature = 0;

        /**
         * RegionTile evilness.
         * @member {number} evilness
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.evilness = 0;

        /**
         * RegionTile drainage.
         * @member {number} drainage
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.drainage = 0;

        /**
         * RegionTile volcanism.
         * @member {number} volcanism
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.volcanism = 0;

        /**
         * RegionTile savagery.
         * @member {number} savagery
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.savagery = 0;

        /**
         * RegionTile salinity.
         * @member {number} salinity
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.salinity = 0;

        /**
         * RegionTile riverTiles.
         * @member {RemoteFortressReader.IRiverTile|null|undefined} riverTiles
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.riverTiles = null;

        /**
         * RegionTile waterElevation.
         * @member {number} waterElevation
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.waterElevation = 0;

        /**
         * RegionTile surfaceMaterial.
         * @member {RemoteFortressReader.IMatPair|null|undefined} surfaceMaterial
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.surfaceMaterial = null;

        /**
         * RegionTile plantMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} plantMaterials
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.plantMaterials = $util.emptyArray;

        /**
         * RegionTile buildings.
         * @member {Array.<RemoteFortressReader.ISiteRealizationBuilding>} buildings
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.buildings = $util.emptyArray;

        /**
         * RegionTile stoneMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} stoneMaterials
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.stoneMaterials = $util.emptyArray;

        /**
         * RegionTile treeMaterials.
         * @member {Array.<RemoteFortressReader.IMatPair>} treeMaterials
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.treeMaterials = $util.emptyArray;

        /**
         * RegionTile snow.
         * @member {number} snow
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         */
        RegionTile.prototype.snow = 0;

        /**
         * Creates a new RegionTile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.IRegionTile=} [properties] Properties to set
         * @returns {RemoteFortressReader.RegionTile} RegionTile instance
         */
        RegionTile.create = function create(properties) {
            return new RegionTile(properties);
        };

        /**
         * Encodes the specified RegionTile message. Does not implicitly {@link RemoteFortressReader.RegionTile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.IRegionTile} message RegionTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elevation != null && Object.hasOwnProperty.call(message, "elevation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elevation);
            if (message.rainfall != null && Object.hasOwnProperty.call(message, "rainfall"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rainfall);
            if (message.vegetation != null && Object.hasOwnProperty.call(message, "vegetation"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.vegetation);
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.temperature);
            if (message.evilness != null && Object.hasOwnProperty.call(message, "evilness"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.evilness);
            if (message.drainage != null && Object.hasOwnProperty.call(message, "drainage"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.drainage);
            if (message.volcanism != null && Object.hasOwnProperty.call(message, "volcanism"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.volcanism);
            if (message.savagery != null && Object.hasOwnProperty.call(message, "savagery"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.savagery);
            if (message.salinity != null && Object.hasOwnProperty.call(message, "salinity"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.salinity);
            if (message.riverTiles != null && Object.hasOwnProperty.call(message, "riverTiles"))
                $root.RemoteFortressReader.RiverTile.encode(message.riverTiles, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.waterElevation != null && Object.hasOwnProperty.call(message, "waterElevation"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.waterElevation);
            if (message.surfaceMaterial != null && Object.hasOwnProperty.call(message, "surfaceMaterial"))
                $root.RemoteFortressReader.MatPair.encode(message.surfaceMaterial, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.plantMaterials != null && message.plantMaterials.length)
                for (var i = 0; i < message.plantMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.plantMaterials[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.buildings != null && message.buildings.length)
                for (var i = 0; i < message.buildings.length; ++i)
                    $root.RemoteFortressReader.SiteRealizationBuilding.encode(message.buildings[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.stoneMaterials != null && message.stoneMaterials.length)
                for (var i = 0; i < message.stoneMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.stoneMaterials[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.treeMaterials != null && message.treeMaterials.length)
                for (var i = 0; i < message.treeMaterials.length; ++i)
                    $root.RemoteFortressReader.MatPair.encode(message.treeMaterials[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.snow != null && Object.hasOwnProperty.call(message, "snow"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.snow);
            return writer;
        };

        /**
         * Encodes the specified RegionTile message, length delimited. Does not implicitly {@link RemoteFortressReader.RegionTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.IRegionTile} message RegionTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegionTile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RegionTile} RegionTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RegionTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.elevation = reader.int32();
                    break;
                case 2:
                    message.rainfall = reader.int32();
                    break;
                case 3:
                    message.vegetation = reader.int32();
                    break;
                case 4:
                    message.temperature = reader.int32();
                    break;
                case 5:
                    message.evilness = reader.int32();
                    break;
                case 6:
                    message.drainage = reader.int32();
                    break;
                case 7:
                    message.volcanism = reader.int32();
                    break;
                case 8:
                    message.savagery = reader.int32();
                    break;
                case 9:
                    message.salinity = reader.int32();
                    break;
                case 10:
                    message.riverTiles = $root.RemoteFortressReader.RiverTile.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.waterElevation = reader.int32();
                    break;
                case 12:
                    message.surfaceMaterial = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 13:
                    if (!(message.plantMaterials && message.plantMaterials.length))
                        message.plantMaterials = [];
                    message.plantMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.buildings && message.buildings.length))
                        message.buildings = [];
                    message.buildings.push($root.RemoteFortressReader.SiteRealizationBuilding.decode(reader, reader.uint32()));
                    break;
                case 15:
                    if (!(message.stoneMaterials && message.stoneMaterials.length))
                        message.stoneMaterials = [];
                    message.stoneMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 16:
                    if (!(message.treeMaterials && message.treeMaterials.length))
                        message.treeMaterials = [];
                    message.treeMaterials.push($root.RemoteFortressReader.MatPair.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.snow = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegionTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RegionTile} RegionTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegionTile message.
         * @function verify
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegionTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                if (!$util.isInteger(message.elevation))
                    return "elevation: integer expected";
            if (message.rainfall != null && message.hasOwnProperty("rainfall"))
                if (!$util.isInteger(message.rainfall))
                    return "rainfall: integer expected";
            if (message.vegetation != null && message.hasOwnProperty("vegetation"))
                if (!$util.isInteger(message.vegetation))
                    return "vegetation: integer expected";
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                if (!$util.isInteger(message.temperature))
                    return "temperature: integer expected";
            if (message.evilness != null && message.hasOwnProperty("evilness"))
                if (!$util.isInteger(message.evilness))
                    return "evilness: integer expected";
            if (message.drainage != null && message.hasOwnProperty("drainage"))
                if (!$util.isInteger(message.drainage))
                    return "drainage: integer expected";
            if (message.volcanism != null && message.hasOwnProperty("volcanism"))
                if (!$util.isInteger(message.volcanism))
                    return "volcanism: integer expected";
            if (message.savagery != null && message.hasOwnProperty("savagery"))
                if (!$util.isInteger(message.savagery))
                    return "savagery: integer expected";
            if (message.salinity != null && message.hasOwnProperty("salinity"))
                if (!$util.isInteger(message.salinity))
                    return "salinity: integer expected";
            if (message.riverTiles != null && message.hasOwnProperty("riverTiles")) {
                var error = $root.RemoteFortressReader.RiverTile.verify(message.riverTiles);
                if (error)
                    return "riverTiles." + error;
            }
            if (message.waterElevation != null && message.hasOwnProperty("waterElevation"))
                if (!$util.isInteger(message.waterElevation))
                    return "waterElevation: integer expected";
            if (message.surfaceMaterial != null && message.hasOwnProperty("surfaceMaterial")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.surfaceMaterial);
                if (error)
                    return "surfaceMaterial." + error;
            }
            if (message.plantMaterials != null && message.hasOwnProperty("plantMaterials")) {
                if (!Array.isArray(message.plantMaterials))
                    return "plantMaterials: array expected";
                for (var i = 0; i < message.plantMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.plantMaterials[i]);
                    if (error)
                        return "plantMaterials." + error;
                }
            }
            if (message.buildings != null && message.hasOwnProperty("buildings")) {
                if (!Array.isArray(message.buildings))
                    return "buildings: array expected";
                for (var i = 0; i < message.buildings.length; ++i) {
                    var error = $root.RemoteFortressReader.SiteRealizationBuilding.verify(message.buildings[i]);
                    if (error)
                        return "buildings." + error;
                }
            }
            if (message.stoneMaterials != null && message.hasOwnProperty("stoneMaterials")) {
                if (!Array.isArray(message.stoneMaterials))
                    return "stoneMaterials: array expected";
                for (var i = 0; i < message.stoneMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.stoneMaterials[i]);
                    if (error)
                        return "stoneMaterials." + error;
                }
            }
            if (message.treeMaterials != null && message.hasOwnProperty("treeMaterials")) {
                if (!Array.isArray(message.treeMaterials))
                    return "treeMaterials: array expected";
                for (var i = 0; i < message.treeMaterials.length; ++i) {
                    var error = $root.RemoteFortressReader.MatPair.verify(message.treeMaterials[i]);
                    if (error)
                        return "treeMaterials." + error;
                }
            }
            if (message.snow != null && message.hasOwnProperty("snow"))
                if (!$util.isInteger(message.snow))
                    return "snow: integer expected";
            return null;
        };

        /**
         * Creates a RegionTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RegionTile} RegionTile
         */
        RegionTile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RegionTile)
                return object;
            var message = new $root.RemoteFortressReader.RegionTile();
            if (object.elevation != null)
                message.elevation = object.elevation | 0;
            if (object.rainfall != null)
                message.rainfall = object.rainfall | 0;
            if (object.vegetation != null)
                message.vegetation = object.vegetation | 0;
            if (object.temperature != null)
                message.temperature = object.temperature | 0;
            if (object.evilness != null)
                message.evilness = object.evilness | 0;
            if (object.drainage != null)
                message.drainage = object.drainage | 0;
            if (object.volcanism != null)
                message.volcanism = object.volcanism | 0;
            if (object.savagery != null)
                message.savagery = object.savagery | 0;
            if (object.salinity != null)
                message.salinity = object.salinity | 0;
            if (object.riverTiles != null) {
                if (typeof object.riverTiles !== "object")
                    throw TypeError(".RemoteFortressReader.RegionTile.riverTiles: object expected");
                message.riverTiles = $root.RemoteFortressReader.RiverTile.fromObject(object.riverTiles);
            }
            if (object.waterElevation != null)
                message.waterElevation = object.waterElevation | 0;
            if (object.surfaceMaterial != null) {
                if (typeof object.surfaceMaterial !== "object")
                    throw TypeError(".RemoteFortressReader.RegionTile.surfaceMaterial: object expected");
                message.surfaceMaterial = $root.RemoteFortressReader.MatPair.fromObject(object.surfaceMaterial);
            }
            if (object.plantMaterials) {
                if (!Array.isArray(object.plantMaterials))
                    throw TypeError(".RemoteFortressReader.RegionTile.plantMaterials: array expected");
                message.plantMaterials = [];
                for (var i = 0; i < object.plantMaterials.length; ++i) {
                    if (typeof object.plantMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.plantMaterials: object expected");
                    message.plantMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.plantMaterials[i]);
                }
            }
            if (object.buildings) {
                if (!Array.isArray(object.buildings))
                    throw TypeError(".RemoteFortressReader.RegionTile.buildings: array expected");
                message.buildings = [];
                for (var i = 0; i < object.buildings.length; ++i) {
                    if (typeof object.buildings[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.buildings: object expected");
                    message.buildings[i] = $root.RemoteFortressReader.SiteRealizationBuilding.fromObject(object.buildings[i]);
                }
            }
            if (object.stoneMaterials) {
                if (!Array.isArray(object.stoneMaterials))
                    throw TypeError(".RemoteFortressReader.RegionTile.stoneMaterials: array expected");
                message.stoneMaterials = [];
                for (var i = 0; i < object.stoneMaterials.length; ++i) {
                    if (typeof object.stoneMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.stoneMaterials: object expected");
                    message.stoneMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.stoneMaterials[i]);
                }
            }
            if (object.treeMaterials) {
                if (!Array.isArray(object.treeMaterials))
                    throw TypeError(".RemoteFortressReader.RegionTile.treeMaterials: array expected");
                message.treeMaterials = [];
                for (var i = 0; i < object.treeMaterials.length; ++i) {
                    if (typeof object.treeMaterials[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionTile.treeMaterials: object expected");
                    message.treeMaterials[i] = $root.RemoteFortressReader.MatPair.fromObject(object.treeMaterials[i]);
                }
            }
            if (object.snow != null)
                message.snow = object.snow | 0;
            return message;
        };

        /**
         * Creates a plain object from a RegionTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RegionTile
         * @static
         * @param {RemoteFortressReader.RegionTile} message RegionTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegionTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.plantMaterials = [];
                object.buildings = [];
                object.stoneMaterials = [];
                object.treeMaterials = [];
            }
            if (options.defaults) {
                object.elevation = 0;
                object.rainfall = 0;
                object.vegetation = 0;
                object.temperature = 0;
                object.evilness = 0;
                object.drainage = 0;
                object.volcanism = 0;
                object.savagery = 0;
                object.salinity = 0;
                object.riverTiles = null;
                object.waterElevation = 0;
                object.surfaceMaterial = null;
                object.snow = 0;
            }
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                object.elevation = message.elevation;
            if (message.rainfall != null && message.hasOwnProperty("rainfall"))
                object.rainfall = message.rainfall;
            if (message.vegetation != null && message.hasOwnProperty("vegetation"))
                object.vegetation = message.vegetation;
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                object.temperature = message.temperature;
            if (message.evilness != null && message.hasOwnProperty("evilness"))
                object.evilness = message.evilness;
            if (message.drainage != null && message.hasOwnProperty("drainage"))
                object.drainage = message.drainage;
            if (message.volcanism != null && message.hasOwnProperty("volcanism"))
                object.volcanism = message.volcanism;
            if (message.savagery != null && message.hasOwnProperty("savagery"))
                object.savagery = message.savagery;
            if (message.salinity != null && message.hasOwnProperty("salinity"))
                object.salinity = message.salinity;
            if (message.riverTiles != null && message.hasOwnProperty("riverTiles"))
                object.riverTiles = $root.RemoteFortressReader.RiverTile.toObject(message.riverTiles, options);
            if (message.waterElevation != null && message.hasOwnProperty("waterElevation"))
                object.waterElevation = message.waterElevation;
            if (message.surfaceMaterial != null && message.hasOwnProperty("surfaceMaterial"))
                object.surfaceMaterial = $root.RemoteFortressReader.MatPair.toObject(message.surfaceMaterial, options);
            if (message.plantMaterials && message.plantMaterials.length) {
                object.plantMaterials = [];
                for (var j = 0; j < message.plantMaterials.length; ++j)
                    object.plantMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.plantMaterials[j], options);
            }
            if (message.buildings && message.buildings.length) {
                object.buildings = [];
                for (var j = 0; j < message.buildings.length; ++j)
                    object.buildings[j] = $root.RemoteFortressReader.SiteRealizationBuilding.toObject(message.buildings[j], options);
            }
            if (message.stoneMaterials && message.stoneMaterials.length) {
                object.stoneMaterials = [];
                for (var j = 0; j < message.stoneMaterials.length; ++j)
                    object.stoneMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.stoneMaterials[j], options);
            }
            if (message.treeMaterials && message.treeMaterials.length) {
                object.treeMaterials = [];
                for (var j = 0; j < message.treeMaterials.length; ++j)
                    object.treeMaterials[j] = $root.RemoteFortressReader.MatPair.toObject(message.treeMaterials[j], options);
            }
            if (message.snow != null && message.hasOwnProperty("snow"))
                object.snow = message.snow;
            return object;
        };

        /**
         * Converts this RegionTile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RegionTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegionTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegionTile;
    })();

    RemoteFortressReader.RegionMap = (function() {

        /**
         * Properties of a RegionMap.
         * @memberof RemoteFortressReader
         * @interface IRegionMap
         * @property {number|null} [mapX] RegionMap mapX
         * @property {number|null} [mapY] RegionMap mapY
         * @property {string|null} [name] RegionMap name
         * @property {string|null} [nameEnglish] RegionMap nameEnglish
         * @property {Array.<RemoteFortressReader.IRegionTile>|null} [tiles] RegionMap tiles
         */

        /**
         * Constructs a new RegionMap.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RegionMap.
         * @implements IRegionMap
         * @constructor
         * @param {RemoteFortressReader.IRegionMap=} [properties] Properties to set
         */
        function RegionMap(properties) {
            this.tiles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegionMap mapX.
         * @member {number} mapX
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.mapX = 0;

        /**
         * RegionMap mapY.
         * @member {number} mapY
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.mapY = 0;

        /**
         * RegionMap name.
         * @member {string} name
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.name = "";

        /**
         * RegionMap nameEnglish.
         * @member {string} nameEnglish
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.nameEnglish = "";

        /**
         * RegionMap tiles.
         * @member {Array.<RemoteFortressReader.IRegionTile>} tiles
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         */
        RegionMap.prototype.tiles = $util.emptyArray;

        /**
         * Creates a new RegionMap instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.IRegionMap=} [properties] Properties to set
         * @returns {RemoteFortressReader.RegionMap} RegionMap instance
         */
        RegionMap.create = function create(properties) {
            return new RegionMap(properties);
        };

        /**
         * Encodes the specified RegionMap message. Does not implicitly {@link RemoteFortressReader.RegionMap.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.IRegionMap} message RegionMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapX != null && Object.hasOwnProperty.call(message, "mapX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mapX);
            if (message.mapY != null && Object.hasOwnProperty.call(message, "mapY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mapY);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.nameEnglish != null && Object.hasOwnProperty.call(message, "nameEnglish"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nameEnglish);
            if (message.tiles != null && message.tiles.length)
                for (var i = 0; i < message.tiles.length; ++i)
                    $root.RemoteFortressReader.RegionTile.encode(message.tiles[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegionMap message, length delimited. Does not implicitly {@link RemoteFortressReader.RegionMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.IRegionMap} message RegionMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegionMap message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RegionMap} RegionMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RegionMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mapX = reader.int32();
                    break;
                case 2:
                    message.mapY = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.nameEnglish = reader.string();
                    break;
                case 5:
                    if (!(message.tiles && message.tiles.length))
                        message.tiles = [];
                    message.tiles.push($root.RemoteFortressReader.RegionTile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegionMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RegionMap} RegionMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegionMap message.
         * @function verify
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegionMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                if (!$util.isInteger(message.mapX))
                    return "mapX: integer expected";
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                if (!$util.isInteger(message.mapY))
                    return "mapY: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                if (!$util.isString(message.nameEnglish))
                    return "nameEnglish: string expected";
            if (message.tiles != null && message.hasOwnProperty("tiles")) {
                if (!Array.isArray(message.tiles))
                    return "tiles: array expected";
                for (var i = 0; i < message.tiles.length; ++i) {
                    var error = $root.RemoteFortressReader.RegionTile.verify(message.tiles[i]);
                    if (error)
                        return "tiles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegionMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RegionMap} RegionMap
         */
        RegionMap.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RegionMap)
                return object;
            var message = new $root.RemoteFortressReader.RegionMap();
            if (object.mapX != null)
                message.mapX = object.mapX | 0;
            if (object.mapY != null)
                message.mapY = object.mapY | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.nameEnglish != null)
                message.nameEnglish = String(object.nameEnglish);
            if (object.tiles) {
                if (!Array.isArray(object.tiles))
                    throw TypeError(".RemoteFortressReader.RegionMap.tiles: array expected");
                message.tiles = [];
                for (var i = 0; i < object.tiles.length; ++i) {
                    if (typeof object.tiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionMap.tiles: object expected");
                    message.tiles[i] = $root.RemoteFortressReader.RegionTile.fromObject(object.tiles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RegionMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RegionMap
         * @static
         * @param {RemoteFortressReader.RegionMap} message RegionMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegionMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tiles = [];
            if (options.defaults) {
                object.mapX = 0;
                object.mapY = 0;
                object.name = "";
                object.nameEnglish = "";
            }
            if (message.mapX != null && message.hasOwnProperty("mapX"))
                object.mapX = message.mapX;
            if (message.mapY != null && message.hasOwnProperty("mapY"))
                object.mapY = message.mapY;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.nameEnglish != null && message.hasOwnProperty("nameEnglish"))
                object.nameEnglish = message.nameEnglish;
            if (message.tiles && message.tiles.length) {
                object.tiles = [];
                for (var j = 0; j < message.tiles.length; ++j)
                    object.tiles[j] = $root.RemoteFortressReader.RegionTile.toObject(message.tiles[j], options);
            }
            return object;
        };

        /**
         * Converts this RegionMap to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RegionMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegionMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegionMap;
    })();

    RemoteFortressReader.RegionMaps = (function() {

        /**
         * Properties of a RegionMaps.
         * @memberof RemoteFortressReader
         * @interface IRegionMaps
         * @property {Array.<RemoteFortressReader.IWorldMap>|null} [worldMaps] RegionMaps worldMaps
         * @property {Array.<RemoteFortressReader.IRegionMap>|null} [regionMaps] RegionMaps regionMaps
         */

        /**
         * Constructs a new RegionMaps.
         * @memberof RemoteFortressReader
         * @classdesc Represents a RegionMaps.
         * @implements IRegionMaps
         * @constructor
         * @param {RemoteFortressReader.IRegionMaps=} [properties] Properties to set
         */
        function RegionMaps(properties) {
            this.worldMaps = [];
            this.regionMaps = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegionMaps worldMaps.
         * @member {Array.<RemoteFortressReader.IWorldMap>} worldMaps
         * @memberof RemoteFortressReader.RegionMaps
         * @instance
         */
        RegionMaps.prototype.worldMaps = $util.emptyArray;

        /**
         * RegionMaps regionMaps.
         * @member {Array.<RemoteFortressReader.IRegionMap>} regionMaps
         * @memberof RemoteFortressReader.RegionMaps
         * @instance
         */
        RegionMaps.prototype.regionMaps = $util.emptyArray;

        /**
         * Creates a new RegionMaps instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.IRegionMaps=} [properties] Properties to set
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps instance
         */
        RegionMaps.create = function create(properties) {
            return new RegionMaps(properties);
        };

        /**
         * Encodes the specified RegionMaps message. Does not implicitly {@link RemoteFortressReader.RegionMaps.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.IRegionMaps} message RegionMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMaps.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldMaps != null && message.worldMaps.length)
                for (var i = 0; i < message.worldMaps.length; ++i)
                    $root.RemoteFortressReader.WorldMap.encode(message.worldMaps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.regionMaps != null && message.regionMaps.length)
                for (var i = 0; i < message.regionMaps.length; ++i)
                    $root.RemoteFortressReader.RegionMap.encode(message.regionMaps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegionMaps message, length delimited. Does not implicitly {@link RemoteFortressReader.RegionMaps.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.IRegionMaps} message RegionMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegionMaps.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegionMaps message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMaps.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.RegionMaps();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.worldMaps && message.worldMaps.length))
                        message.worldMaps = [];
                    message.worldMaps.push($root.RemoteFortressReader.WorldMap.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.regionMaps && message.regionMaps.length))
                        message.regionMaps = [];
                    message.regionMaps.push($root.RemoteFortressReader.RegionMap.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegionMaps message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegionMaps.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegionMaps message.
         * @function verify
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegionMaps.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldMaps != null && message.hasOwnProperty("worldMaps")) {
                if (!Array.isArray(message.worldMaps))
                    return "worldMaps: array expected";
                for (var i = 0; i < message.worldMaps.length; ++i) {
                    var error = $root.RemoteFortressReader.WorldMap.verify(message.worldMaps[i]);
                    if (error)
                        return "worldMaps." + error;
                }
            }
            if (message.regionMaps != null && message.hasOwnProperty("regionMaps")) {
                if (!Array.isArray(message.regionMaps))
                    return "regionMaps: array expected";
                for (var i = 0; i < message.regionMaps.length; ++i) {
                    var error = $root.RemoteFortressReader.RegionMap.verify(message.regionMaps[i]);
                    if (error)
                        return "regionMaps." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegionMaps message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.RegionMaps} RegionMaps
         */
        RegionMaps.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.RegionMaps)
                return object;
            var message = new $root.RemoteFortressReader.RegionMaps();
            if (object.worldMaps) {
                if (!Array.isArray(object.worldMaps))
                    throw TypeError(".RemoteFortressReader.RegionMaps.worldMaps: array expected");
                message.worldMaps = [];
                for (var i = 0; i < object.worldMaps.length; ++i) {
                    if (typeof object.worldMaps[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionMaps.worldMaps: object expected");
                    message.worldMaps[i] = $root.RemoteFortressReader.WorldMap.fromObject(object.worldMaps[i]);
                }
            }
            if (object.regionMaps) {
                if (!Array.isArray(object.regionMaps))
                    throw TypeError(".RemoteFortressReader.RegionMaps.regionMaps: array expected");
                message.regionMaps = [];
                for (var i = 0; i < object.regionMaps.length; ++i) {
                    if (typeof object.regionMaps[i] !== "object")
                        throw TypeError(".RemoteFortressReader.RegionMaps.regionMaps: object expected");
                    message.regionMaps[i] = $root.RemoteFortressReader.RegionMap.fromObject(object.regionMaps[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RegionMaps message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.RegionMaps
         * @static
         * @param {RemoteFortressReader.RegionMaps} message RegionMaps
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegionMaps.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.worldMaps = [];
                object.regionMaps = [];
            }
            if (message.worldMaps && message.worldMaps.length) {
                object.worldMaps = [];
                for (var j = 0; j < message.worldMaps.length; ++j)
                    object.worldMaps[j] = $root.RemoteFortressReader.WorldMap.toObject(message.worldMaps[j], options);
            }
            if (message.regionMaps && message.regionMaps.length) {
                object.regionMaps = [];
                for (var j = 0; j < message.regionMaps.length; ++j)
                    object.regionMaps[j] = $root.RemoteFortressReader.RegionMap.toObject(message.regionMaps[j], options);
            }
            return object;
        };

        /**
         * Converts this RegionMaps to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.RegionMaps
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegionMaps.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegionMaps;
    })();

    /**
     * PatternType enum.
     * @name RemoteFortressReader.PatternType
     * @enum {string}
     * @property {number} MONOTONE=0 MONOTONE value
     * @property {number} STRIPES=1 STRIPES value
     * @property {number} IRIS_EYE=2 IRIS_EYE value
     * @property {number} SPOTS=3 SPOTS value
     * @property {number} PUPIL_EYE=4 PUPIL_EYE value
     * @property {number} MOTTLED=5 MOTTLED value
     */
    RemoteFortressReader.PatternType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MONOTONE"] = 0;
        values[valuesById[1] = "STRIPES"] = 1;
        values[valuesById[2] = "IRIS_EYE"] = 2;
        values[valuesById[3] = "SPOTS"] = 3;
        values[valuesById[4] = "PUPIL_EYE"] = 4;
        values[valuesById[5] = "MOTTLED"] = 5;
        return values;
    })();

    RemoteFortressReader.PatternDescriptor = (function() {

        /**
         * Properties of a PatternDescriptor.
         * @memberof RemoteFortressReader
         * @interface IPatternDescriptor
         * @property {string|null} [id] PatternDescriptor id
         * @property {Array.<RemoteFortressReader.IColorDefinition>|null} [colors] PatternDescriptor colors
         * @property {RemoteFortressReader.PatternType|null} [pattern] PatternDescriptor pattern
         */

        /**
         * Constructs a new PatternDescriptor.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PatternDescriptor.
         * @implements IPatternDescriptor
         * @constructor
         * @param {RemoteFortressReader.IPatternDescriptor=} [properties] Properties to set
         */
        function PatternDescriptor(properties) {
            this.colors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PatternDescriptor id.
         * @member {string} id
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         */
        PatternDescriptor.prototype.id = "";

        /**
         * PatternDescriptor colors.
         * @member {Array.<RemoteFortressReader.IColorDefinition>} colors
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         */
        PatternDescriptor.prototype.colors = $util.emptyArray;

        /**
         * PatternDescriptor pattern.
         * @member {RemoteFortressReader.PatternType} pattern
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         */
        PatternDescriptor.prototype.pattern = 0;

        /**
         * Creates a new PatternDescriptor instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.IPatternDescriptor=} [properties] Properties to set
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor instance
         */
        PatternDescriptor.create = function create(properties) {
            return new PatternDescriptor(properties);
        };

        /**
         * Encodes the specified PatternDescriptor message. Does not implicitly {@link RemoteFortressReader.PatternDescriptor.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.IPatternDescriptor} message PatternDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatternDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.colors != null && message.colors.length)
                for (var i = 0; i < message.colors.length; ++i)
                    $root.RemoteFortressReader.ColorDefinition.encode(message.colors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.pattern != null && Object.hasOwnProperty.call(message, "pattern"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pattern);
            return writer;
        };

        /**
         * Encodes the specified PatternDescriptor message, length delimited. Does not implicitly {@link RemoteFortressReader.PatternDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.IPatternDescriptor} message PatternDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatternDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PatternDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatternDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PatternDescriptor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    if (!(message.colors && message.colors.length))
                        message.colors = [];
                    message.colors.push($root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pattern = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PatternDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatternDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PatternDescriptor message.
         * @function verify
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PatternDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.colors != null && message.hasOwnProperty("colors")) {
                if (!Array.isArray(message.colors))
                    return "colors: array expected";
                for (var i = 0; i < message.colors.length; ++i) {
                    var error = $root.RemoteFortressReader.ColorDefinition.verify(message.colors[i]);
                    if (error)
                        return "colors." + error;
                }
            }
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                switch (message.pattern) {
                default:
                    return "pattern: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a PatternDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PatternDescriptor} PatternDescriptor
         */
        PatternDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PatternDescriptor)
                return object;
            var message = new $root.RemoteFortressReader.PatternDescriptor();
            if (object.id != null)
                message.id = String(object.id);
            if (object.colors) {
                if (!Array.isArray(object.colors))
                    throw TypeError(".RemoteFortressReader.PatternDescriptor.colors: array expected");
                message.colors = [];
                for (var i = 0; i < object.colors.length; ++i) {
                    if (typeof object.colors[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PatternDescriptor.colors: object expected");
                    message.colors[i] = $root.RemoteFortressReader.ColorDefinition.fromObject(object.colors[i]);
                }
            }
            switch (object.pattern) {
            case "MONOTONE":
            case 0:
                message.pattern = 0;
                break;
            case "STRIPES":
            case 1:
                message.pattern = 1;
                break;
            case "IRIS_EYE":
            case 2:
                message.pattern = 2;
                break;
            case "SPOTS":
            case 3:
                message.pattern = 3;
                break;
            case "PUPIL_EYE":
            case 4:
                message.pattern = 4;
                break;
            case "MOTTLED":
            case 5:
                message.pattern = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PatternDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PatternDescriptor
         * @static
         * @param {RemoteFortressReader.PatternDescriptor} message PatternDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PatternDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.colors = [];
            if (options.defaults) {
                object.id = "";
                object.pattern = options.enums === String ? "MONOTONE" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.colors && message.colors.length) {
                object.colors = [];
                for (var j = 0; j < message.colors.length; ++j)
                    object.colors[j] = $root.RemoteFortressReader.ColorDefinition.toObject(message.colors[j], options);
            }
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = options.enums === String ? $root.RemoteFortressReader.PatternType[message.pattern] : message.pattern;
            return object;
        };

        /**
         * Converts this PatternDescriptor to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PatternDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PatternDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PatternDescriptor;
    })();

    RemoteFortressReader.ColorModifierRaw = (function() {

        /**
         * Properties of a ColorModifierRaw.
         * @memberof RemoteFortressReader
         * @interface IColorModifierRaw
         * @property {Array.<RemoteFortressReader.IPatternDescriptor>|null} [patterns] ColorModifierRaw patterns
         * @property {Array.<number>|null} [bodyPartId] ColorModifierRaw bodyPartId
         * @property {Array.<number>|null} [tissueLayerId] ColorModifierRaw tissueLayerId
         * @property {number|null} [startDate] ColorModifierRaw startDate
         * @property {number|null} [endDate] ColorModifierRaw endDate
         * @property {string|null} [part] ColorModifierRaw part
         */

        /**
         * Constructs a new ColorModifierRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ColorModifierRaw.
         * @implements IColorModifierRaw
         * @constructor
         * @param {RemoteFortressReader.IColorModifierRaw=} [properties] Properties to set
         */
        function ColorModifierRaw(properties) {
            this.patterns = [];
            this.bodyPartId = [];
            this.tissueLayerId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorModifierRaw patterns.
         * @member {Array.<RemoteFortressReader.IPatternDescriptor>} patterns
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.patterns = $util.emptyArray;

        /**
         * ColorModifierRaw bodyPartId.
         * @member {Array.<number>} bodyPartId
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.bodyPartId = $util.emptyArray;

        /**
         * ColorModifierRaw tissueLayerId.
         * @member {Array.<number>} tissueLayerId
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.tissueLayerId = $util.emptyArray;

        /**
         * ColorModifierRaw startDate.
         * @member {number} startDate
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.startDate = 0;

        /**
         * ColorModifierRaw endDate.
         * @member {number} endDate
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.endDate = 0;

        /**
         * ColorModifierRaw part.
         * @member {string} part
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         */
        ColorModifierRaw.prototype.part = "";

        /**
         * Creates a new ColorModifierRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.IColorModifierRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw instance
         */
        ColorModifierRaw.create = function create(properties) {
            return new ColorModifierRaw(properties);
        };

        /**
         * Encodes the specified ColorModifierRaw message. Does not implicitly {@link RemoteFortressReader.ColorModifierRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.IColorModifierRaw} message ColorModifierRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorModifierRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.patterns != null && message.patterns.length)
                for (var i = 0; i < message.patterns.length; ++i)
                    $root.RemoteFortressReader.PatternDescriptor.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.bodyPartId != null && message.bodyPartId.length)
                for (var i = 0; i < message.bodyPartId.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bodyPartId[i]);
            if (message.tissueLayerId != null && message.tissueLayerId.length)
                for (var i = 0; i < message.tissueLayerId.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tissueLayerId[i]);
            if (message.startDate != null && Object.hasOwnProperty.call(message, "startDate"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.startDate);
            if (message.endDate != null && Object.hasOwnProperty.call(message, "endDate"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.endDate);
            if (message.part != null && Object.hasOwnProperty.call(message, "part"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.part);
            return writer;
        };

        /**
         * Encodes the specified ColorModifierRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.ColorModifierRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.IColorModifierRaw} message ColorModifierRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorModifierRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorModifierRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorModifierRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ColorModifierRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.patterns && message.patterns.length))
                        message.patterns = [];
                    message.patterns.push($root.RemoteFortressReader.PatternDescriptor.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.bodyPartId && message.bodyPartId.length))
                        message.bodyPartId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bodyPartId.push(reader.int32());
                    } else
                        message.bodyPartId.push(reader.int32());
                    break;
                case 3:
                    if (!(message.tissueLayerId && message.tissueLayerId.length))
                        message.tissueLayerId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tissueLayerId.push(reader.int32());
                    } else
                        message.tissueLayerId.push(reader.int32());
                    break;
                case 4:
                    message.startDate = reader.int32();
                    break;
                case 5:
                    message.endDate = reader.int32();
                    break;
                case 6:
                    message.part = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorModifierRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorModifierRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorModifierRaw message.
         * @function verify
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorModifierRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.patterns != null && message.hasOwnProperty("patterns")) {
                if (!Array.isArray(message.patterns))
                    return "patterns: array expected";
                for (var i = 0; i < message.patterns.length; ++i) {
                    var error = $root.RemoteFortressReader.PatternDescriptor.verify(message.patterns[i]);
                    if (error)
                        return "patterns." + error;
                }
            }
            if (message.bodyPartId != null && message.hasOwnProperty("bodyPartId")) {
                if (!Array.isArray(message.bodyPartId))
                    return "bodyPartId: array expected";
                for (var i = 0; i < message.bodyPartId.length; ++i)
                    if (!$util.isInteger(message.bodyPartId[i]))
                        return "bodyPartId: integer[] expected";
            }
            if (message.tissueLayerId != null && message.hasOwnProperty("tissueLayerId")) {
                if (!Array.isArray(message.tissueLayerId))
                    return "tissueLayerId: array expected";
                for (var i = 0; i < message.tissueLayerId.length; ++i)
                    if (!$util.isInteger(message.tissueLayerId[i]))
                        return "tissueLayerId: integer[] expected";
            }
            if (message.startDate != null && message.hasOwnProperty("startDate"))
                if (!$util.isInteger(message.startDate))
                    return "startDate: integer expected";
            if (message.endDate != null && message.hasOwnProperty("endDate"))
                if (!$util.isInteger(message.endDate))
                    return "endDate: integer expected";
            if (message.part != null && message.hasOwnProperty("part"))
                if (!$util.isString(message.part))
                    return "part: string expected";
            return null;
        };

        /**
         * Creates a ColorModifierRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ColorModifierRaw} ColorModifierRaw
         */
        ColorModifierRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ColorModifierRaw)
                return object;
            var message = new $root.RemoteFortressReader.ColorModifierRaw();
            if (object.patterns) {
                if (!Array.isArray(object.patterns))
                    throw TypeError(".RemoteFortressReader.ColorModifierRaw.patterns: array expected");
                message.patterns = [];
                for (var i = 0; i < object.patterns.length; ++i) {
                    if (typeof object.patterns[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ColorModifierRaw.patterns: object expected");
                    message.patterns[i] = $root.RemoteFortressReader.PatternDescriptor.fromObject(object.patterns[i]);
                }
            }
            if (object.bodyPartId) {
                if (!Array.isArray(object.bodyPartId))
                    throw TypeError(".RemoteFortressReader.ColorModifierRaw.bodyPartId: array expected");
                message.bodyPartId = [];
                for (var i = 0; i < object.bodyPartId.length; ++i)
                    message.bodyPartId[i] = object.bodyPartId[i] | 0;
            }
            if (object.tissueLayerId) {
                if (!Array.isArray(object.tissueLayerId))
                    throw TypeError(".RemoteFortressReader.ColorModifierRaw.tissueLayerId: array expected");
                message.tissueLayerId = [];
                for (var i = 0; i < object.tissueLayerId.length; ++i)
                    message.tissueLayerId[i] = object.tissueLayerId[i] | 0;
            }
            if (object.startDate != null)
                message.startDate = object.startDate | 0;
            if (object.endDate != null)
                message.endDate = object.endDate | 0;
            if (object.part != null)
                message.part = String(object.part);
            return message;
        };

        /**
         * Creates a plain object from a ColorModifierRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @static
         * @param {RemoteFortressReader.ColorModifierRaw} message ColorModifierRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorModifierRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.patterns = [];
                object.bodyPartId = [];
                object.tissueLayerId = [];
            }
            if (options.defaults) {
                object.startDate = 0;
                object.endDate = 0;
                object.part = "";
            }
            if (message.patterns && message.patterns.length) {
                object.patterns = [];
                for (var j = 0; j < message.patterns.length; ++j)
                    object.patterns[j] = $root.RemoteFortressReader.PatternDescriptor.toObject(message.patterns[j], options);
            }
            if (message.bodyPartId && message.bodyPartId.length) {
                object.bodyPartId = [];
                for (var j = 0; j < message.bodyPartId.length; ++j)
                    object.bodyPartId[j] = message.bodyPartId[j];
            }
            if (message.tissueLayerId && message.tissueLayerId.length) {
                object.tissueLayerId = [];
                for (var j = 0; j < message.tissueLayerId.length; ++j)
                    object.tissueLayerId[j] = message.tissueLayerId[j];
            }
            if (message.startDate != null && message.hasOwnProperty("startDate"))
                object.startDate = message.startDate;
            if (message.endDate != null && message.hasOwnProperty("endDate"))
                object.endDate = message.endDate;
            if (message.part != null && message.hasOwnProperty("part"))
                object.part = message.part;
            return object;
        };

        /**
         * Converts this ColorModifierRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ColorModifierRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorModifierRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ColorModifierRaw;
    })();

    RemoteFortressReader.BodyPartLayerRaw = (function() {

        /**
         * Properties of a BodyPartLayerRaw.
         * @memberof RemoteFortressReader
         * @interface IBodyPartLayerRaw
         * @property {string|null} [layerName] BodyPartLayerRaw layerName
         * @property {number|null} [tissueId] BodyPartLayerRaw tissueId
         * @property {number|null} [layerDepth] BodyPartLayerRaw layerDepth
         * @property {Array.<number>|null} [bpModifiers] BodyPartLayerRaw bpModifiers
         */

        /**
         * Constructs a new BodyPartLayerRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BodyPartLayerRaw.
         * @implements IBodyPartLayerRaw
         * @constructor
         * @param {RemoteFortressReader.IBodyPartLayerRaw=} [properties] Properties to set
         */
        function BodyPartLayerRaw(properties) {
            this.bpModifiers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BodyPartLayerRaw layerName.
         * @member {string} layerName
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.layerName = "";

        /**
         * BodyPartLayerRaw tissueId.
         * @member {number} tissueId
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.tissueId = 0;

        /**
         * BodyPartLayerRaw layerDepth.
         * @member {number} layerDepth
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.layerDepth = 0;

        /**
         * BodyPartLayerRaw bpModifiers.
         * @member {Array.<number>} bpModifiers
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         */
        BodyPartLayerRaw.prototype.bpModifiers = $util.emptyArray;

        /**
         * Creates a new BodyPartLayerRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartLayerRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw instance
         */
        BodyPartLayerRaw.create = function create(properties) {
            return new BodyPartLayerRaw(properties);
        };

        /**
         * Encodes the specified BodyPartLayerRaw message. Does not implicitly {@link RemoteFortressReader.BodyPartLayerRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartLayerRaw} message BodyPartLayerRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartLayerRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.layerName != null && Object.hasOwnProperty.call(message, "layerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.layerName);
            if (message.tissueId != null && Object.hasOwnProperty.call(message, "tissueId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tissueId);
            if (message.layerDepth != null && Object.hasOwnProperty.call(message, "layerDepth"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.layerDepth);
            if (message.bpModifiers != null && message.bpModifiers.length)
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bpModifiers[i]);
            return writer;
        };

        /**
         * Encodes the specified BodyPartLayerRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.BodyPartLayerRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartLayerRaw} message BodyPartLayerRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartLayerRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BodyPartLayerRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartLayerRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BodyPartLayerRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.layerName = reader.string();
                    break;
                case 2:
                    message.tissueId = reader.int32();
                    break;
                case 3:
                    message.layerDepth = reader.int32();
                    break;
                case 4:
                    if (!(message.bpModifiers && message.bpModifiers.length))
                        message.bpModifiers = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bpModifiers.push(reader.int32());
                    } else
                        message.bpModifiers.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BodyPartLayerRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartLayerRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BodyPartLayerRaw message.
         * @function verify
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BodyPartLayerRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.layerName != null && message.hasOwnProperty("layerName"))
                if (!$util.isString(message.layerName))
                    return "layerName: string expected";
            if (message.tissueId != null && message.hasOwnProperty("tissueId"))
                if (!$util.isInteger(message.tissueId))
                    return "tissueId: integer expected";
            if (message.layerDepth != null && message.hasOwnProperty("layerDepth"))
                if (!$util.isInteger(message.layerDepth))
                    return "layerDepth: integer expected";
            if (message.bpModifiers != null && message.hasOwnProperty("bpModifiers")) {
                if (!Array.isArray(message.bpModifiers))
                    return "bpModifiers: array expected";
                for (var i = 0; i < message.bpModifiers.length; ++i)
                    if (!$util.isInteger(message.bpModifiers[i]))
                        return "bpModifiers: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BodyPartLayerRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BodyPartLayerRaw} BodyPartLayerRaw
         */
        BodyPartLayerRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BodyPartLayerRaw)
                return object;
            var message = new $root.RemoteFortressReader.BodyPartLayerRaw();
            if (object.layerName != null)
                message.layerName = String(object.layerName);
            if (object.tissueId != null)
                message.tissueId = object.tissueId | 0;
            if (object.layerDepth != null)
                message.layerDepth = object.layerDepth | 0;
            if (object.bpModifiers) {
                if (!Array.isArray(object.bpModifiers))
                    throw TypeError(".RemoteFortressReader.BodyPartLayerRaw.bpModifiers: array expected");
                message.bpModifiers = [];
                for (var i = 0; i < object.bpModifiers.length; ++i)
                    message.bpModifiers[i] = object.bpModifiers[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BodyPartLayerRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @static
         * @param {RemoteFortressReader.BodyPartLayerRaw} message BodyPartLayerRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BodyPartLayerRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bpModifiers = [];
            if (options.defaults) {
                object.layerName = "";
                object.tissueId = 0;
                object.layerDepth = 0;
            }
            if (message.layerName != null && message.hasOwnProperty("layerName"))
                object.layerName = message.layerName;
            if (message.tissueId != null && message.hasOwnProperty("tissueId"))
                object.tissueId = message.tissueId;
            if (message.layerDepth != null && message.hasOwnProperty("layerDepth"))
                object.layerDepth = message.layerDepth;
            if (message.bpModifiers && message.bpModifiers.length) {
                object.bpModifiers = [];
                for (var j = 0; j < message.bpModifiers.length; ++j)
                    object.bpModifiers[j] = message.bpModifiers[j];
            }
            return object;
        };

        /**
         * Converts this BodyPartLayerRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BodyPartLayerRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BodyPartLayerRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BodyPartLayerRaw;
    })();

    RemoteFortressReader.BodyPartRaw = (function() {

        /**
         * Properties of a BodyPartRaw.
         * @memberof RemoteFortressReader
         * @interface IBodyPartRaw
         * @property {string|null} [token] BodyPartRaw token
         * @property {string|null} [category] BodyPartRaw category
         * @property {number|null} [parent] BodyPartRaw parent
         * @property {Array.<boolean>|null} [flags] BodyPartRaw flags
         * @property {Array.<RemoteFortressReader.IBodyPartLayerRaw>|null} [layers] BodyPartRaw layers
         * @property {number|null} [relsize] BodyPartRaw relsize
         */

        /**
         * Constructs a new BodyPartRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BodyPartRaw.
         * @implements IBodyPartRaw
         * @constructor
         * @param {RemoteFortressReader.IBodyPartRaw=} [properties] Properties to set
         */
        function BodyPartRaw(properties) {
            this.flags = [];
            this.layers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BodyPartRaw token.
         * @member {string} token
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.token = "";

        /**
         * BodyPartRaw category.
         * @member {string} category
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.category = "";

        /**
         * BodyPartRaw parent.
         * @member {number} parent
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.parent = 0;

        /**
         * BodyPartRaw flags.
         * @member {Array.<boolean>} flags
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.flags = $util.emptyArray;

        /**
         * BodyPartRaw layers.
         * @member {Array.<RemoteFortressReader.IBodyPartLayerRaw>} layers
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.layers = $util.emptyArray;

        /**
         * BodyPartRaw relsize.
         * @member {number} relsize
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         */
        BodyPartRaw.prototype.relsize = 0;

        /**
         * Creates a new BodyPartRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw instance
         */
        BodyPartRaw.create = function create(properties) {
            return new BodyPartRaw(properties);
        };

        /**
         * Encodes the specified BodyPartRaw message. Does not implicitly {@link RemoteFortressReader.BodyPartRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartRaw} message BodyPartRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.category);
            if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.parent);
            if (message.flags != null && message.flags.length)
                for (var i = 0; i < message.flags.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.flags[i]);
            if (message.layers != null && message.layers.length)
                for (var i = 0; i < message.layers.length; ++i)
                    $root.RemoteFortressReader.BodyPartLayerRaw.encode(message.layers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.relsize != null && Object.hasOwnProperty.call(message, "relsize"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.relsize);
            return writer;
        };

        /**
         * Encodes the specified BodyPartRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.BodyPartRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.IBodyPartRaw} message BodyPartRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyPartRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BodyPartRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BodyPartRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                case 2:
                    message.category = reader.string();
                    break;
                case 3:
                    message.parent = reader.int32();
                    break;
                case 4:
                    if (!(message.flags && message.flags.length))
                        message.flags = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.flags.push(reader.bool());
                    } else
                        message.flags.push(reader.bool());
                    break;
                case 5:
                    if (!(message.layers && message.layers.length))
                        message.layers = [];
                    message.layers.push($root.RemoteFortressReader.BodyPartLayerRaw.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.relsize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BodyPartRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyPartRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BodyPartRaw message.
         * @function verify
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BodyPartRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.category != null && message.hasOwnProperty("category"))
                if (!$util.isString(message.category))
                    return "category: string expected";
            if (message.parent != null && message.hasOwnProperty("parent"))
                if (!$util.isInteger(message.parent))
                    return "parent: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (var i = 0; i < message.flags.length; ++i)
                    if (typeof message.flags[i] !== "boolean")
                        return "flags: boolean[] expected";
            }
            if (message.layers != null && message.hasOwnProperty("layers")) {
                if (!Array.isArray(message.layers))
                    return "layers: array expected";
                for (var i = 0; i < message.layers.length; ++i) {
                    var error = $root.RemoteFortressReader.BodyPartLayerRaw.verify(message.layers[i]);
                    if (error)
                        return "layers." + error;
                }
            }
            if (message.relsize != null && message.hasOwnProperty("relsize"))
                if (!$util.isInteger(message.relsize))
                    return "relsize: integer expected";
            return null;
        };

        /**
         * Creates a BodyPartRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BodyPartRaw} BodyPartRaw
         */
        BodyPartRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BodyPartRaw)
                return object;
            var message = new $root.RemoteFortressReader.BodyPartRaw();
            if (object.token != null)
                message.token = String(object.token);
            if (object.category != null)
                message.category = String(object.category);
            if (object.parent != null)
                message.parent = object.parent | 0;
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".RemoteFortressReader.BodyPartRaw.flags: array expected");
                message.flags = [];
                for (var i = 0; i < object.flags.length; ++i)
                    message.flags[i] = Boolean(object.flags[i]);
            }
            if (object.layers) {
                if (!Array.isArray(object.layers))
                    throw TypeError(".RemoteFortressReader.BodyPartRaw.layers: array expected");
                message.layers = [];
                for (var i = 0; i < object.layers.length; ++i) {
                    if (typeof object.layers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.BodyPartRaw.layers: object expected");
                    message.layers[i] = $root.RemoteFortressReader.BodyPartLayerRaw.fromObject(object.layers[i]);
                }
            }
            if (object.relsize != null)
                message.relsize = object.relsize | 0;
            return message;
        };

        /**
         * Creates a plain object from a BodyPartRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BodyPartRaw
         * @static
         * @param {RemoteFortressReader.BodyPartRaw} message BodyPartRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BodyPartRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.flags = [];
                object.layers = [];
            }
            if (options.defaults) {
                object.token = "";
                object.category = "";
                object.parent = 0;
                object.relsize = 0;
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.category != null && message.hasOwnProperty("category"))
                object.category = message.category;
            if (message.parent != null && message.hasOwnProperty("parent"))
                object.parent = message.parent;
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (var j = 0; j < message.flags.length; ++j)
                    object.flags[j] = message.flags[j];
            }
            if (message.layers && message.layers.length) {
                object.layers = [];
                for (var j = 0; j < message.layers.length; ++j)
                    object.layers[j] = $root.RemoteFortressReader.BodyPartLayerRaw.toObject(message.layers[j], options);
            }
            if (message.relsize != null && message.hasOwnProperty("relsize"))
                object.relsize = message.relsize;
            return object;
        };

        /**
         * Converts this BodyPartRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BodyPartRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BodyPartRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BodyPartRaw;
    })();

    RemoteFortressReader.BpAppearanceModifier = (function() {

        /**
         * Properties of a BpAppearanceModifier.
         * @memberof RemoteFortressReader
         * @interface IBpAppearanceModifier
         * @property {string|null} [type] BpAppearanceModifier type
         * @property {number|null} [modMin] BpAppearanceModifier modMin
         * @property {number|null} [modMax] BpAppearanceModifier modMax
         */

        /**
         * Constructs a new BpAppearanceModifier.
         * @memberof RemoteFortressReader
         * @classdesc Represents a BpAppearanceModifier.
         * @implements IBpAppearanceModifier
         * @constructor
         * @param {RemoteFortressReader.IBpAppearanceModifier=} [properties] Properties to set
         */
        function BpAppearanceModifier(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BpAppearanceModifier type.
         * @member {string} type
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         */
        BpAppearanceModifier.prototype.type = "";

        /**
         * BpAppearanceModifier modMin.
         * @member {number} modMin
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         */
        BpAppearanceModifier.prototype.modMin = 0;

        /**
         * BpAppearanceModifier modMax.
         * @member {number} modMax
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         */
        BpAppearanceModifier.prototype.modMax = 0;

        /**
         * Creates a new BpAppearanceModifier instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.IBpAppearanceModifier=} [properties] Properties to set
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier instance
         */
        BpAppearanceModifier.create = function create(properties) {
            return new BpAppearanceModifier(properties);
        };

        /**
         * Encodes the specified BpAppearanceModifier message. Does not implicitly {@link RemoteFortressReader.BpAppearanceModifier.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.IBpAppearanceModifier} message BpAppearanceModifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BpAppearanceModifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.modMin != null && Object.hasOwnProperty.call(message, "modMin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.modMin);
            if (message.modMax != null && Object.hasOwnProperty.call(message, "modMax"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.modMax);
            return writer;
        };

        /**
         * Encodes the specified BpAppearanceModifier message, length delimited. Does not implicitly {@link RemoteFortressReader.BpAppearanceModifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.IBpAppearanceModifier} message BpAppearanceModifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BpAppearanceModifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BpAppearanceModifier message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BpAppearanceModifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.BpAppearanceModifier();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.modMin = reader.int32();
                    break;
                case 3:
                    message.modMax = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BpAppearanceModifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BpAppearanceModifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BpAppearanceModifier message.
         * @function verify
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BpAppearanceModifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.modMin != null && message.hasOwnProperty("modMin"))
                if (!$util.isInteger(message.modMin))
                    return "modMin: integer expected";
            if (message.modMax != null && message.hasOwnProperty("modMax"))
                if (!$util.isInteger(message.modMax))
                    return "modMax: integer expected";
            return null;
        };

        /**
         * Creates a BpAppearanceModifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.BpAppearanceModifier} BpAppearanceModifier
         */
        BpAppearanceModifier.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.BpAppearanceModifier)
                return object;
            var message = new $root.RemoteFortressReader.BpAppearanceModifier();
            if (object.type != null)
                message.type = String(object.type);
            if (object.modMin != null)
                message.modMin = object.modMin | 0;
            if (object.modMax != null)
                message.modMax = object.modMax | 0;
            return message;
        };

        /**
         * Creates a plain object from a BpAppearanceModifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @static
         * @param {RemoteFortressReader.BpAppearanceModifier} message BpAppearanceModifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BpAppearanceModifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                object.modMin = 0;
                object.modMax = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.modMin != null && message.hasOwnProperty("modMin"))
                object.modMin = message.modMin;
            if (message.modMax != null && message.hasOwnProperty("modMax"))
                object.modMax = message.modMax;
            return object;
        };

        /**
         * Converts this BpAppearanceModifier to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.BpAppearanceModifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BpAppearanceModifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BpAppearanceModifier;
    })();

    RemoteFortressReader.TissueRaw = (function() {

        /**
         * Properties of a TissueRaw.
         * @memberof RemoteFortressReader
         * @interface ITissueRaw
         * @property {string|null} [id] TissueRaw id
         * @property {string|null} [name] TissueRaw name
         * @property {RemoteFortressReader.IMatPair|null} [material] TissueRaw material
         * @property {string|null} [subordinateToTissue] TissueRaw subordinateToTissue
         */

        /**
         * Constructs a new TissueRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TissueRaw.
         * @implements ITissueRaw
         * @constructor
         * @param {RemoteFortressReader.ITissueRaw=} [properties] Properties to set
         */
        function TissueRaw(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TissueRaw id.
         * @member {string} id
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.id = "";

        /**
         * TissueRaw name.
         * @member {string} name
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.name = "";

        /**
         * TissueRaw material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.material = null;

        /**
         * TissueRaw subordinateToTissue.
         * @member {string} subordinateToTissue
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         */
        TissueRaw.prototype.subordinateToTissue = "";

        /**
         * Creates a new TissueRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.ITissueRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw instance
         */
        TissueRaw.create = function create(properties) {
            return new TissueRaw(properties);
        };

        /**
         * Encodes the specified TissueRaw message. Does not implicitly {@link RemoteFortressReader.TissueRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.ITissueRaw} message TissueRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TissueRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.subordinateToTissue != null && Object.hasOwnProperty.call(message, "subordinateToTissue"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.subordinateToTissue);
            return writer;
        };

        /**
         * Encodes the specified TissueRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.TissueRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.ITissueRaw} message TissueRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TissueRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TissueRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TissueRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TissueRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.subordinateToTissue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TissueRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TissueRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TissueRaw message.
         * @function verify
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TissueRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.subordinateToTissue != null && message.hasOwnProperty("subordinateToTissue"))
                if (!$util.isString(message.subordinateToTissue))
                    return "subordinateToTissue: string expected";
            return null;
        };

        /**
         * Creates a TissueRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TissueRaw} TissueRaw
         */
        TissueRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TissueRaw)
                return object;
            var message = new $root.RemoteFortressReader.TissueRaw();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.TissueRaw.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.subordinateToTissue != null)
                message.subordinateToTissue = String(object.subordinateToTissue);
            return message;
        };

        /**
         * Creates a plain object from a TissueRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TissueRaw
         * @static
         * @param {RemoteFortressReader.TissueRaw} message TissueRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TissueRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.material = null;
                object.subordinateToTissue = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.subordinateToTissue != null && message.hasOwnProperty("subordinateToTissue"))
                object.subordinateToTissue = message.subordinateToTissue;
            return object;
        };

        /**
         * Converts this TissueRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TissueRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TissueRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TissueRaw;
    })();

    RemoteFortressReader.CasteRaw = (function() {

        /**
         * Properties of a CasteRaw.
         * @memberof RemoteFortressReader
         * @interface ICasteRaw
         * @property {number|null} [index] CasteRaw index
         * @property {string|null} [casteId] CasteRaw casteId
         * @property {Array.<string>|null} [casteName] CasteRaw casteName
         * @property {Array.<string>|null} [babyName] CasteRaw babyName
         * @property {Array.<string>|null} [childName] CasteRaw childName
         * @property {number|null} [gender] CasteRaw gender
         * @property {Array.<RemoteFortressReader.IBodyPartRaw>|null} [bodyParts] CasteRaw bodyParts
         * @property {number|null} [totalRelsize] CasteRaw totalRelsize
         * @property {Array.<RemoteFortressReader.IBpAppearanceModifier>|null} [modifiers] CasteRaw modifiers
         * @property {Array.<number>|null} [modifierIdx] CasteRaw modifierIdx
         * @property {Array.<number>|null} [partIdx] CasteRaw partIdx
         * @property {Array.<number>|null} [layerIdx] CasteRaw layerIdx
         * @property {Array.<RemoteFortressReader.IBpAppearanceModifier>|null} [bodyAppearanceModifiers] CasteRaw bodyAppearanceModifiers
         * @property {Array.<RemoteFortressReader.IColorModifierRaw>|null} [colorModifiers] CasteRaw colorModifiers
         * @property {string|null} [description] CasteRaw description
         * @property {number|null} [adultSize] CasteRaw adultSize
         */

        /**
         * Constructs a new CasteRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a CasteRaw.
         * @implements ICasteRaw
         * @constructor
         * @param {RemoteFortressReader.ICasteRaw=} [properties] Properties to set
         */
        function CasteRaw(properties) {
            this.casteName = [];
            this.babyName = [];
            this.childName = [];
            this.bodyParts = [];
            this.modifiers = [];
            this.modifierIdx = [];
            this.partIdx = [];
            this.layerIdx = [];
            this.bodyAppearanceModifiers = [];
            this.colorModifiers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CasteRaw index.
         * @member {number} index
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.index = 0;

        /**
         * CasteRaw casteId.
         * @member {string} casteId
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.casteId = "";

        /**
         * CasteRaw casteName.
         * @member {Array.<string>} casteName
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.casteName = $util.emptyArray;

        /**
         * CasteRaw babyName.
         * @member {Array.<string>} babyName
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.babyName = $util.emptyArray;

        /**
         * CasteRaw childName.
         * @member {Array.<string>} childName
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.childName = $util.emptyArray;

        /**
         * CasteRaw gender.
         * @member {number} gender
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.gender = 0;

        /**
         * CasteRaw bodyParts.
         * @member {Array.<RemoteFortressReader.IBodyPartRaw>} bodyParts
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.bodyParts = $util.emptyArray;

        /**
         * CasteRaw totalRelsize.
         * @member {number} totalRelsize
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.totalRelsize = 0;

        /**
         * CasteRaw modifiers.
         * @member {Array.<RemoteFortressReader.IBpAppearanceModifier>} modifiers
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.modifiers = $util.emptyArray;

        /**
         * CasteRaw modifierIdx.
         * @member {Array.<number>} modifierIdx
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.modifierIdx = $util.emptyArray;

        /**
         * CasteRaw partIdx.
         * @member {Array.<number>} partIdx
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.partIdx = $util.emptyArray;

        /**
         * CasteRaw layerIdx.
         * @member {Array.<number>} layerIdx
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.layerIdx = $util.emptyArray;

        /**
         * CasteRaw bodyAppearanceModifiers.
         * @member {Array.<RemoteFortressReader.IBpAppearanceModifier>} bodyAppearanceModifiers
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.bodyAppearanceModifiers = $util.emptyArray;

        /**
         * CasteRaw colorModifiers.
         * @member {Array.<RemoteFortressReader.IColorModifierRaw>} colorModifiers
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.colorModifiers = $util.emptyArray;

        /**
         * CasteRaw description.
         * @member {string} description
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.description = "";

        /**
         * CasteRaw adultSize.
         * @member {number} adultSize
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         */
        CasteRaw.prototype.adultSize = 0;

        /**
         * Creates a new CasteRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.ICasteRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw instance
         */
        CasteRaw.create = function create(properties) {
            return new CasteRaw(properties);
        };

        /**
         * Encodes the specified CasteRaw message. Does not implicitly {@link RemoteFortressReader.CasteRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.ICasteRaw} message CasteRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CasteRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.casteId != null && Object.hasOwnProperty.call(message, "casteId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.casteId);
            if (message.casteName != null && message.casteName.length)
                for (var i = 0; i < message.casteName.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.casteName[i]);
            if (message.babyName != null && message.babyName.length)
                for (var i = 0; i < message.babyName.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.babyName[i]);
            if (message.childName != null && message.childName.length)
                for (var i = 0; i < message.childName.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.childName[i]);
            if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.gender);
            if (message.bodyParts != null && message.bodyParts.length)
                for (var i = 0; i < message.bodyParts.length; ++i)
                    $root.RemoteFortressReader.BodyPartRaw.encode(message.bodyParts[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.totalRelsize != null && Object.hasOwnProperty.call(message, "totalRelsize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.totalRelsize);
            if (message.modifiers != null && message.modifiers.length)
                for (var i = 0; i < message.modifiers.length; ++i)
                    $root.RemoteFortressReader.BpAppearanceModifier.encode(message.modifiers[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.modifierIdx != null && message.modifierIdx.length)
                for (var i = 0; i < message.modifierIdx.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.modifierIdx[i]);
            if (message.partIdx != null && message.partIdx.length)
                for (var i = 0; i < message.partIdx.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.partIdx[i]);
            if (message.layerIdx != null && message.layerIdx.length)
                for (var i = 0; i < message.layerIdx.length; ++i)
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.layerIdx[i]);
            if (message.bodyAppearanceModifiers != null && message.bodyAppearanceModifiers.length)
                for (var i = 0; i < message.bodyAppearanceModifiers.length; ++i)
                    $root.RemoteFortressReader.BpAppearanceModifier.encode(message.bodyAppearanceModifiers[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.colorModifiers != null && message.colorModifiers.length)
                for (var i = 0; i < message.colorModifiers.length; ++i)
                    $root.RemoteFortressReader.ColorModifierRaw.encode(message.colorModifiers[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.description);
            if (message.adultSize != null && Object.hasOwnProperty.call(message, "adultSize"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.adultSize);
            return writer;
        };

        /**
         * Encodes the specified CasteRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.CasteRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.ICasteRaw} message CasteRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CasteRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CasteRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CasteRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.CasteRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.casteId = reader.string();
                    break;
                case 3:
                    if (!(message.casteName && message.casteName.length))
                        message.casteName = [];
                    message.casteName.push(reader.string());
                    break;
                case 4:
                    if (!(message.babyName && message.babyName.length))
                        message.babyName = [];
                    message.babyName.push(reader.string());
                    break;
                case 5:
                    if (!(message.childName && message.childName.length))
                        message.childName = [];
                    message.childName.push(reader.string());
                    break;
                case 6:
                    message.gender = reader.int32();
                    break;
                case 7:
                    if (!(message.bodyParts && message.bodyParts.length))
                        message.bodyParts = [];
                    message.bodyParts.push($root.RemoteFortressReader.BodyPartRaw.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.totalRelsize = reader.int32();
                    break;
                case 9:
                    if (!(message.modifiers && message.modifiers.length))
                        message.modifiers = [];
                    message.modifiers.push($root.RemoteFortressReader.BpAppearanceModifier.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.modifierIdx && message.modifierIdx.length))
                        message.modifierIdx = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.modifierIdx.push(reader.int32());
                    } else
                        message.modifierIdx.push(reader.int32());
                    break;
                case 11:
                    if (!(message.partIdx && message.partIdx.length))
                        message.partIdx = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.partIdx.push(reader.int32());
                    } else
                        message.partIdx.push(reader.int32());
                    break;
                case 12:
                    if (!(message.layerIdx && message.layerIdx.length))
                        message.layerIdx = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.layerIdx.push(reader.int32());
                    } else
                        message.layerIdx.push(reader.int32());
                    break;
                case 13:
                    if (!(message.bodyAppearanceModifiers && message.bodyAppearanceModifiers.length))
                        message.bodyAppearanceModifiers = [];
                    message.bodyAppearanceModifiers.push($root.RemoteFortressReader.BpAppearanceModifier.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.colorModifiers && message.colorModifiers.length))
                        message.colorModifiers = [];
                    message.colorModifiers.push($root.RemoteFortressReader.ColorModifierRaw.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.description = reader.string();
                    break;
                case 16:
                    message.adultSize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CasteRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CasteRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CasteRaw message.
         * @function verify
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CasteRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.casteId != null && message.hasOwnProperty("casteId"))
                if (!$util.isString(message.casteId))
                    return "casteId: string expected";
            if (message.casteName != null && message.hasOwnProperty("casteName")) {
                if (!Array.isArray(message.casteName))
                    return "casteName: array expected";
                for (var i = 0; i < message.casteName.length; ++i)
                    if (!$util.isString(message.casteName[i]))
                        return "casteName: string[] expected";
            }
            if (message.babyName != null && message.hasOwnProperty("babyName")) {
                if (!Array.isArray(message.babyName))
                    return "babyName: array expected";
                for (var i = 0; i < message.babyName.length; ++i)
                    if (!$util.isString(message.babyName[i]))
                        return "babyName: string[] expected";
            }
            if (message.childName != null && message.hasOwnProperty("childName")) {
                if (!Array.isArray(message.childName))
                    return "childName: array expected";
                for (var i = 0; i < message.childName.length; ++i)
                    if (!$util.isString(message.childName[i]))
                        return "childName: string[] expected";
            }
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            if (message.bodyParts != null && message.hasOwnProperty("bodyParts")) {
                if (!Array.isArray(message.bodyParts))
                    return "bodyParts: array expected";
                for (var i = 0; i < message.bodyParts.length; ++i) {
                    var error = $root.RemoteFortressReader.BodyPartRaw.verify(message.bodyParts[i]);
                    if (error)
                        return "bodyParts." + error;
                }
            }
            if (message.totalRelsize != null && message.hasOwnProperty("totalRelsize"))
                if (!$util.isInteger(message.totalRelsize))
                    return "totalRelsize: integer expected";
            if (message.modifiers != null && message.hasOwnProperty("modifiers")) {
                if (!Array.isArray(message.modifiers))
                    return "modifiers: array expected";
                for (var i = 0; i < message.modifiers.length; ++i) {
                    var error = $root.RemoteFortressReader.BpAppearanceModifier.verify(message.modifiers[i]);
                    if (error)
                        return "modifiers." + error;
                }
            }
            if (message.modifierIdx != null && message.hasOwnProperty("modifierIdx")) {
                if (!Array.isArray(message.modifierIdx))
                    return "modifierIdx: array expected";
                for (var i = 0; i < message.modifierIdx.length; ++i)
                    if (!$util.isInteger(message.modifierIdx[i]))
                        return "modifierIdx: integer[] expected";
            }
            if (message.partIdx != null && message.hasOwnProperty("partIdx")) {
                if (!Array.isArray(message.partIdx))
                    return "partIdx: array expected";
                for (var i = 0; i < message.partIdx.length; ++i)
                    if (!$util.isInteger(message.partIdx[i]))
                        return "partIdx: integer[] expected";
            }
            if (message.layerIdx != null && message.hasOwnProperty("layerIdx")) {
                if (!Array.isArray(message.layerIdx))
                    return "layerIdx: array expected";
                for (var i = 0; i < message.layerIdx.length; ++i)
                    if (!$util.isInteger(message.layerIdx[i]))
                        return "layerIdx: integer[] expected";
            }
            if (message.bodyAppearanceModifiers != null && message.hasOwnProperty("bodyAppearanceModifiers")) {
                if (!Array.isArray(message.bodyAppearanceModifiers))
                    return "bodyAppearanceModifiers: array expected";
                for (var i = 0; i < message.bodyAppearanceModifiers.length; ++i) {
                    var error = $root.RemoteFortressReader.BpAppearanceModifier.verify(message.bodyAppearanceModifiers[i]);
                    if (error)
                        return "bodyAppearanceModifiers." + error;
                }
            }
            if (message.colorModifiers != null && message.hasOwnProperty("colorModifiers")) {
                if (!Array.isArray(message.colorModifiers))
                    return "colorModifiers: array expected";
                for (var i = 0; i < message.colorModifiers.length; ++i) {
                    var error = $root.RemoteFortressReader.ColorModifierRaw.verify(message.colorModifiers[i]);
                    if (error)
                        return "colorModifiers." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.adultSize != null && message.hasOwnProperty("adultSize"))
                if (!$util.isInteger(message.adultSize))
                    return "adultSize: integer expected";
            return null;
        };

        /**
         * Creates a CasteRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.CasteRaw} CasteRaw
         */
        CasteRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.CasteRaw)
                return object;
            var message = new $root.RemoteFortressReader.CasteRaw();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.casteId != null)
                message.casteId = String(object.casteId);
            if (object.casteName) {
                if (!Array.isArray(object.casteName))
                    throw TypeError(".RemoteFortressReader.CasteRaw.casteName: array expected");
                message.casteName = [];
                for (var i = 0; i < object.casteName.length; ++i)
                    message.casteName[i] = String(object.casteName[i]);
            }
            if (object.babyName) {
                if (!Array.isArray(object.babyName))
                    throw TypeError(".RemoteFortressReader.CasteRaw.babyName: array expected");
                message.babyName = [];
                for (var i = 0; i < object.babyName.length; ++i)
                    message.babyName[i] = String(object.babyName[i]);
            }
            if (object.childName) {
                if (!Array.isArray(object.childName))
                    throw TypeError(".RemoteFortressReader.CasteRaw.childName: array expected");
                message.childName = [];
                for (var i = 0; i < object.childName.length; ++i)
                    message.childName[i] = String(object.childName[i]);
            }
            if (object.gender != null)
                message.gender = object.gender | 0;
            if (object.bodyParts) {
                if (!Array.isArray(object.bodyParts))
                    throw TypeError(".RemoteFortressReader.CasteRaw.bodyParts: array expected");
                message.bodyParts = [];
                for (var i = 0; i < object.bodyParts.length; ++i) {
                    if (typeof object.bodyParts[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.bodyParts: object expected");
                    message.bodyParts[i] = $root.RemoteFortressReader.BodyPartRaw.fromObject(object.bodyParts[i]);
                }
            }
            if (object.totalRelsize != null)
                message.totalRelsize = object.totalRelsize | 0;
            if (object.modifiers) {
                if (!Array.isArray(object.modifiers))
                    throw TypeError(".RemoteFortressReader.CasteRaw.modifiers: array expected");
                message.modifiers = [];
                for (var i = 0; i < object.modifiers.length; ++i) {
                    if (typeof object.modifiers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.modifiers: object expected");
                    message.modifiers[i] = $root.RemoteFortressReader.BpAppearanceModifier.fromObject(object.modifiers[i]);
                }
            }
            if (object.modifierIdx) {
                if (!Array.isArray(object.modifierIdx))
                    throw TypeError(".RemoteFortressReader.CasteRaw.modifierIdx: array expected");
                message.modifierIdx = [];
                for (var i = 0; i < object.modifierIdx.length; ++i)
                    message.modifierIdx[i] = object.modifierIdx[i] | 0;
            }
            if (object.partIdx) {
                if (!Array.isArray(object.partIdx))
                    throw TypeError(".RemoteFortressReader.CasteRaw.partIdx: array expected");
                message.partIdx = [];
                for (var i = 0; i < object.partIdx.length; ++i)
                    message.partIdx[i] = object.partIdx[i] | 0;
            }
            if (object.layerIdx) {
                if (!Array.isArray(object.layerIdx))
                    throw TypeError(".RemoteFortressReader.CasteRaw.layerIdx: array expected");
                message.layerIdx = [];
                for (var i = 0; i < object.layerIdx.length; ++i)
                    message.layerIdx[i] = object.layerIdx[i] | 0;
            }
            if (object.bodyAppearanceModifiers) {
                if (!Array.isArray(object.bodyAppearanceModifiers))
                    throw TypeError(".RemoteFortressReader.CasteRaw.bodyAppearanceModifiers: array expected");
                message.bodyAppearanceModifiers = [];
                for (var i = 0; i < object.bodyAppearanceModifiers.length; ++i) {
                    if (typeof object.bodyAppearanceModifiers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.bodyAppearanceModifiers: object expected");
                    message.bodyAppearanceModifiers[i] = $root.RemoteFortressReader.BpAppearanceModifier.fromObject(object.bodyAppearanceModifiers[i]);
                }
            }
            if (object.colorModifiers) {
                if (!Array.isArray(object.colorModifiers))
                    throw TypeError(".RemoteFortressReader.CasteRaw.colorModifiers: array expected");
                message.colorModifiers = [];
                for (var i = 0; i < object.colorModifiers.length; ++i) {
                    if (typeof object.colorModifiers[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CasteRaw.colorModifiers: object expected");
                    message.colorModifiers[i] = $root.RemoteFortressReader.ColorModifierRaw.fromObject(object.colorModifiers[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.adultSize != null)
                message.adultSize = object.adultSize | 0;
            return message;
        };

        /**
         * Creates a plain object from a CasteRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.CasteRaw
         * @static
         * @param {RemoteFortressReader.CasteRaw} message CasteRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CasteRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.casteName = [];
                object.babyName = [];
                object.childName = [];
                object.bodyParts = [];
                object.modifiers = [];
                object.modifierIdx = [];
                object.partIdx = [];
                object.layerIdx = [];
                object.bodyAppearanceModifiers = [];
                object.colorModifiers = [];
            }
            if (options.defaults) {
                object.index = 0;
                object.casteId = "";
                object.gender = 0;
                object.totalRelsize = 0;
                object.description = "";
                object.adultSize = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.casteId != null && message.hasOwnProperty("casteId"))
                object.casteId = message.casteId;
            if (message.casteName && message.casteName.length) {
                object.casteName = [];
                for (var j = 0; j < message.casteName.length; ++j)
                    object.casteName[j] = message.casteName[j];
            }
            if (message.babyName && message.babyName.length) {
                object.babyName = [];
                for (var j = 0; j < message.babyName.length; ++j)
                    object.babyName[j] = message.babyName[j];
            }
            if (message.childName && message.childName.length) {
                object.childName = [];
                for (var j = 0; j < message.childName.length; ++j)
                    object.childName[j] = message.childName[j];
            }
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.bodyParts && message.bodyParts.length) {
                object.bodyParts = [];
                for (var j = 0; j < message.bodyParts.length; ++j)
                    object.bodyParts[j] = $root.RemoteFortressReader.BodyPartRaw.toObject(message.bodyParts[j], options);
            }
            if (message.totalRelsize != null && message.hasOwnProperty("totalRelsize"))
                object.totalRelsize = message.totalRelsize;
            if (message.modifiers && message.modifiers.length) {
                object.modifiers = [];
                for (var j = 0; j < message.modifiers.length; ++j)
                    object.modifiers[j] = $root.RemoteFortressReader.BpAppearanceModifier.toObject(message.modifiers[j], options);
            }
            if (message.modifierIdx && message.modifierIdx.length) {
                object.modifierIdx = [];
                for (var j = 0; j < message.modifierIdx.length; ++j)
                    object.modifierIdx[j] = message.modifierIdx[j];
            }
            if (message.partIdx && message.partIdx.length) {
                object.partIdx = [];
                for (var j = 0; j < message.partIdx.length; ++j)
                    object.partIdx[j] = message.partIdx[j];
            }
            if (message.layerIdx && message.layerIdx.length) {
                object.layerIdx = [];
                for (var j = 0; j < message.layerIdx.length; ++j)
                    object.layerIdx[j] = message.layerIdx[j];
            }
            if (message.bodyAppearanceModifiers && message.bodyAppearanceModifiers.length) {
                object.bodyAppearanceModifiers = [];
                for (var j = 0; j < message.bodyAppearanceModifiers.length; ++j)
                    object.bodyAppearanceModifiers[j] = $root.RemoteFortressReader.BpAppearanceModifier.toObject(message.bodyAppearanceModifiers[j], options);
            }
            if (message.colorModifiers && message.colorModifiers.length) {
                object.colorModifiers = [];
                for (var j = 0; j < message.colorModifiers.length; ++j)
                    object.colorModifiers[j] = $root.RemoteFortressReader.ColorModifierRaw.toObject(message.colorModifiers[j], options);
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.adultSize != null && message.hasOwnProperty("adultSize"))
                object.adultSize = message.adultSize;
            return object;
        };

        /**
         * Converts this CasteRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.CasteRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CasteRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CasteRaw;
    })();

    RemoteFortressReader.CreatureRaw = (function() {

        /**
         * Properties of a CreatureRaw.
         * @memberof RemoteFortressReader
         * @interface ICreatureRaw
         * @property {number|null} [index] CreatureRaw index
         * @property {string|null} [creatureId] CreatureRaw creatureId
         * @property {Array.<string>|null} [name] CreatureRaw name
         * @property {Array.<string>|null} [generalBabyName] CreatureRaw generalBabyName
         * @property {Array.<string>|null} [generalChildName] CreatureRaw generalChildName
         * @property {number|null} [creatureTile] CreatureRaw creatureTile
         * @property {number|null} [creatureSoldierTile] CreatureRaw creatureSoldierTile
         * @property {RemoteFortressReader.IColorDefinition|null} [color] CreatureRaw color
         * @property {number|null} [adultsize] CreatureRaw adultsize
         * @property {Array.<RemoteFortressReader.ICasteRaw>|null} [caste] CreatureRaw caste
         * @property {Array.<RemoteFortressReader.ITissueRaw>|null} [tissues] CreatureRaw tissues
         */

        /**
         * Constructs a new CreatureRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a CreatureRaw.
         * @implements ICreatureRaw
         * @constructor
         * @param {RemoteFortressReader.ICreatureRaw=} [properties] Properties to set
         */
        function CreatureRaw(properties) {
            this.name = [];
            this.generalBabyName = [];
            this.generalChildName = [];
            this.caste = [];
            this.tissues = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatureRaw index.
         * @member {number} index
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.index = 0;

        /**
         * CreatureRaw creatureId.
         * @member {string} creatureId
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.creatureId = "";

        /**
         * CreatureRaw name.
         * @member {Array.<string>} name
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.name = $util.emptyArray;

        /**
         * CreatureRaw generalBabyName.
         * @member {Array.<string>} generalBabyName
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.generalBabyName = $util.emptyArray;

        /**
         * CreatureRaw generalChildName.
         * @member {Array.<string>} generalChildName
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.generalChildName = $util.emptyArray;

        /**
         * CreatureRaw creatureTile.
         * @member {number} creatureTile
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.creatureTile = 0;

        /**
         * CreatureRaw creatureSoldierTile.
         * @member {number} creatureSoldierTile
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.creatureSoldierTile = 0;

        /**
         * CreatureRaw color.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} color
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.color = null;

        /**
         * CreatureRaw adultsize.
         * @member {number} adultsize
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.adultsize = 0;

        /**
         * CreatureRaw caste.
         * @member {Array.<RemoteFortressReader.ICasteRaw>} caste
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.caste = $util.emptyArray;

        /**
         * CreatureRaw tissues.
         * @member {Array.<RemoteFortressReader.ITissueRaw>} tissues
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         */
        CreatureRaw.prototype.tissues = $util.emptyArray;

        /**
         * Creates a new CreatureRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.ICreatureRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw instance
         */
        CreatureRaw.create = function create(properties) {
            return new CreatureRaw(properties);
        };

        /**
         * Encodes the specified CreatureRaw message. Does not implicitly {@link RemoteFortressReader.CreatureRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.ICreatureRaw} message CreatureRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.creatureId != null && Object.hasOwnProperty.call(message, "creatureId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.creatureId);
            if (message.name != null && message.name.length)
                for (var i = 0; i < message.name.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name[i]);
            if (message.generalBabyName != null && message.generalBabyName.length)
                for (var i = 0; i < message.generalBabyName.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.generalBabyName[i]);
            if (message.generalChildName != null && message.generalChildName.length)
                for (var i = 0; i < message.generalChildName.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.generalChildName[i]);
            if (message.creatureTile != null && Object.hasOwnProperty.call(message, "creatureTile"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.creatureTile);
            if (message.creatureSoldierTile != null && Object.hasOwnProperty.call(message, "creatureSoldierTile"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.creatureSoldierTile);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.color, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.adultsize != null && Object.hasOwnProperty.call(message, "adultsize"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.adultsize);
            if (message.caste != null && message.caste.length)
                for (var i = 0; i < message.caste.length; ++i)
                    $root.RemoteFortressReader.CasteRaw.encode(message.caste[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.tissues != null && message.tissues.length)
                for (var i = 0; i < message.tissues.length; ++i)
                    $root.RemoteFortressReader.TissueRaw.encode(message.tissues[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreatureRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.CreatureRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.ICreatureRaw} message CreatureRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatureRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.CreatureRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.creatureId = reader.string();
                    break;
                case 3:
                    if (!(message.name && message.name.length))
                        message.name = [];
                    message.name.push(reader.string());
                    break;
                case 4:
                    if (!(message.generalBabyName && message.generalBabyName.length))
                        message.generalBabyName = [];
                    message.generalBabyName.push(reader.string());
                    break;
                case 5:
                    if (!(message.generalChildName && message.generalChildName.length))
                        message.generalChildName = [];
                    message.generalChildName.push(reader.string());
                    break;
                case 6:
                    message.creatureTile = reader.int32();
                    break;
                case 7:
                    message.creatureSoldierTile = reader.int32();
                    break;
                case 8:
                    message.color = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.adultsize = reader.int32();
                    break;
                case 10:
                    if (!(message.caste && message.caste.length))
                        message.caste = [];
                    message.caste.push($root.RemoteFortressReader.CasteRaw.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.tissues && message.tissues.length))
                        message.tissues = [];
                    message.tissues.push($root.RemoteFortressReader.TissueRaw.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatureRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatureRaw message.
         * @function verify
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatureRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.creatureId != null && message.hasOwnProperty("creatureId"))
                if (!$util.isString(message.creatureId))
                    return "creatureId: string expected";
            if (message.name != null && message.hasOwnProperty("name")) {
                if (!Array.isArray(message.name))
                    return "name: array expected";
                for (var i = 0; i < message.name.length; ++i)
                    if (!$util.isString(message.name[i]))
                        return "name: string[] expected";
            }
            if (message.generalBabyName != null && message.hasOwnProperty("generalBabyName")) {
                if (!Array.isArray(message.generalBabyName))
                    return "generalBabyName: array expected";
                for (var i = 0; i < message.generalBabyName.length; ++i)
                    if (!$util.isString(message.generalBabyName[i]))
                        return "generalBabyName: string[] expected";
            }
            if (message.generalChildName != null && message.hasOwnProperty("generalChildName")) {
                if (!Array.isArray(message.generalChildName))
                    return "generalChildName: array expected";
                for (var i = 0; i < message.generalChildName.length; ++i)
                    if (!$util.isString(message.generalChildName[i]))
                        return "generalChildName: string[] expected";
            }
            if (message.creatureTile != null && message.hasOwnProperty("creatureTile"))
                if (!$util.isInteger(message.creatureTile))
                    return "creatureTile: integer expected";
            if (message.creatureSoldierTile != null && message.hasOwnProperty("creatureSoldierTile"))
                if (!$util.isInteger(message.creatureSoldierTile))
                    return "creatureSoldierTile: integer expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.adultsize != null && message.hasOwnProperty("adultsize"))
                if (!$util.isInteger(message.adultsize))
                    return "adultsize: integer expected";
            if (message.caste != null && message.hasOwnProperty("caste")) {
                if (!Array.isArray(message.caste))
                    return "caste: array expected";
                for (var i = 0; i < message.caste.length; ++i) {
                    var error = $root.RemoteFortressReader.CasteRaw.verify(message.caste[i]);
                    if (error)
                        return "caste." + error;
                }
            }
            if (message.tissues != null && message.hasOwnProperty("tissues")) {
                if (!Array.isArray(message.tissues))
                    return "tissues: array expected";
                for (var i = 0; i < message.tissues.length; ++i) {
                    var error = $root.RemoteFortressReader.TissueRaw.verify(message.tissues[i]);
                    if (error)
                        return "tissues." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreatureRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.CreatureRaw} CreatureRaw
         */
        CreatureRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.CreatureRaw)
                return object;
            var message = new $root.RemoteFortressReader.CreatureRaw();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.creatureId != null)
                message.creatureId = String(object.creatureId);
            if (object.name) {
                if (!Array.isArray(object.name))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.name: array expected");
                message.name = [];
                for (var i = 0; i < object.name.length; ++i)
                    message.name[i] = String(object.name[i]);
            }
            if (object.generalBabyName) {
                if (!Array.isArray(object.generalBabyName))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.generalBabyName: array expected");
                message.generalBabyName = [];
                for (var i = 0; i < object.generalBabyName.length; ++i)
                    message.generalBabyName[i] = String(object.generalBabyName[i]);
            }
            if (object.generalChildName) {
                if (!Array.isArray(object.generalChildName))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.generalChildName: array expected");
                message.generalChildName = [];
                for (var i = 0; i < object.generalChildName.length; ++i)
                    message.generalChildName[i] = String(object.generalChildName[i]);
            }
            if (object.creatureTile != null)
                message.creatureTile = object.creatureTile | 0;
            if (object.creatureSoldierTile != null)
                message.creatureSoldierTile = object.creatureSoldierTile | 0;
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".RemoteFortressReader.CreatureRaw.color: object expected");
                message.color = $root.RemoteFortressReader.ColorDefinition.fromObject(object.color);
            }
            if (object.adultsize != null)
                message.adultsize = object.adultsize | 0;
            if (object.caste) {
                if (!Array.isArray(object.caste))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.caste: array expected");
                message.caste = [];
                for (var i = 0; i < object.caste.length; ++i) {
                    if (typeof object.caste[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CreatureRaw.caste: object expected");
                    message.caste[i] = $root.RemoteFortressReader.CasteRaw.fromObject(object.caste[i]);
                }
            }
            if (object.tissues) {
                if (!Array.isArray(object.tissues))
                    throw TypeError(".RemoteFortressReader.CreatureRaw.tissues: array expected");
                message.tissues = [];
                for (var i = 0; i < object.tissues.length; ++i) {
                    if (typeof object.tissues[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CreatureRaw.tissues: object expected");
                    message.tissues[i] = $root.RemoteFortressReader.TissueRaw.fromObject(object.tissues[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreatureRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.CreatureRaw
         * @static
         * @param {RemoteFortressReader.CreatureRaw} message CreatureRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatureRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.name = [];
                object.generalBabyName = [];
                object.generalChildName = [];
                object.caste = [];
                object.tissues = [];
            }
            if (options.defaults) {
                object.index = 0;
                object.creatureId = "";
                object.creatureTile = 0;
                object.creatureSoldierTile = 0;
                object.color = null;
                object.adultsize = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.creatureId != null && message.hasOwnProperty("creatureId"))
                object.creatureId = message.creatureId;
            if (message.name && message.name.length) {
                object.name = [];
                for (var j = 0; j < message.name.length; ++j)
                    object.name[j] = message.name[j];
            }
            if (message.generalBabyName && message.generalBabyName.length) {
                object.generalBabyName = [];
                for (var j = 0; j < message.generalBabyName.length; ++j)
                    object.generalBabyName[j] = message.generalBabyName[j];
            }
            if (message.generalChildName && message.generalChildName.length) {
                object.generalChildName = [];
                for (var j = 0; j < message.generalChildName.length; ++j)
                    object.generalChildName[j] = message.generalChildName[j];
            }
            if (message.creatureTile != null && message.hasOwnProperty("creatureTile"))
                object.creatureTile = message.creatureTile;
            if (message.creatureSoldierTile != null && message.hasOwnProperty("creatureSoldierTile"))
                object.creatureSoldierTile = message.creatureSoldierTile;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.RemoteFortressReader.ColorDefinition.toObject(message.color, options);
            if (message.adultsize != null && message.hasOwnProperty("adultsize"))
                object.adultsize = message.adultsize;
            if (message.caste && message.caste.length) {
                object.caste = [];
                for (var j = 0; j < message.caste.length; ++j)
                    object.caste[j] = $root.RemoteFortressReader.CasteRaw.toObject(message.caste[j], options);
            }
            if (message.tissues && message.tissues.length) {
                object.tissues = [];
                for (var j = 0; j < message.tissues.length; ++j)
                    object.tissues[j] = $root.RemoteFortressReader.TissueRaw.toObject(message.tissues[j], options);
            }
            return object;
        };

        /**
         * Converts this CreatureRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.CreatureRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatureRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatureRaw;
    })();

    RemoteFortressReader.CreatureRawList = (function() {

        /**
         * Properties of a CreatureRawList.
         * @memberof RemoteFortressReader
         * @interface ICreatureRawList
         * @property {Array.<RemoteFortressReader.ICreatureRaw>|null} [creatureRaws] CreatureRawList creatureRaws
         */

        /**
         * Constructs a new CreatureRawList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a CreatureRawList.
         * @implements ICreatureRawList
         * @constructor
         * @param {RemoteFortressReader.ICreatureRawList=} [properties] Properties to set
         */
        function CreatureRawList(properties) {
            this.creatureRaws = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatureRawList creatureRaws.
         * @member {Array.<RemoteFortressReader.ICreatureRaw>} creatureRaws
         * @memberof RemoteFortressReader.CreatureRawList
         * @instance
         */
        CreatureRawList.prototype.creatureRaws = $util.emptyArray;

        /**
         * Creates a new CreatureRawList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.ICreatureRawList=} [properties] Properties to set
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList instance
         */
        CreatureRawList.create = function create(properties) {
            return new CreatureRawList(properties);
        };

        /**
         * Encodes the specified CreatureRawList message. Does not implicitly {@link RemoteFortressReader.CreatureRawList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.ICreatureRawList} message CreatureRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRawList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creatureRaws != null && message.creatureRaws.length)
                for (var i = 0; i < message.creatureRaws.length; ++i)
                    $root.RemoteFortressReader.CreatureRaw.encode(message.creatureRaws[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreatureRawList message, length delimited. Does not implicitly {@link RemoteFortressReader.CreatureRawList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.ICreatureRawList} message CreatureRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatureRawList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatureRawList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRawList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.CreatureRawList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.creatureRaws && message.creatureRaws.length))
                        message.creatureRaws = [];
                    message.creatureRaws.push($root.RemoteFortressReader.CreatureRaw.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatureRawList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatureRawList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatureRawList message.
         * @function verify
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatureRawList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creatureRaws != null && message.hasOwnProperty("creatureRaws")) {
                if (!Array.isArray(message.creatureRaws))
                    return "creatureRaws: array expected";
                for (var i = 0; i < message.creatureRaws.length; ++i) {
                    var error = $root.RemoteFortressReader.CreatureRaw.verify(message.creatureRaws[i]);
                    if (error)
                        return "creatureRaws." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreatureRawList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.CreatureRawList} CreatureRawList
         */
        CreatureRawList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.CreatureRawList)
                return object;
            var message = new $root.RemoteFortressReader.CreatureRawList();
            if (object.creatureRaws) {
                if (!Array.isArray(object.creatureRaws))
                    throw TypeError(".RemoteFortressReader.CreatureRawList.creatureRaws: array expected");
                message.creatureRaws = [];
                for (var i = 0; i < object.creatureRaws.length; ++i) {
                    if (typeof object.creatureRaws[i] !== "object")
                        throw TypeError(".RemoteFortressReader.CreatureRawList.creatureRaws: object expected");
                    message.creatureRaws[i] = $root.RemoteFortressReader.CreatureRaw.fromObject(object.creatureRaws[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreatureRawList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.CreatureRawList
         * @static
         * @param {RemoteFortressReader.CreatureRawList} message CreatureRawList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatureRawList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.creatureRaws = [];
            if (message.creatureRaws && message.creatureRaws.length) {
                object.creatureRaws = [];
                for (var j = 0; j < message.creatureRaws.length; ++j)
                    object.creatureRaws[j] = $root.RemoteFortressReader.CreatureRaw.toObject(message.creatureRaws[j], options);
            }
            return object;
        };

        /**
         * Converts this CreatureRawList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.CreatureRawList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatureRawList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatureRawList;
    })();

    RemoteFortressReader.Army = (function() {

        /**
         * Properties of an Army.
         * @memberof RemoteFortressReader
         * @interface IArmy
         * @property {number|null} [id] Army id
         * @property {number|null} [posX] Army posX
         * @property {number|null} [posY] Army posY
         * @property {number|null} [posZ] Army posZ
         * @property {RemoteFortressReader.IUnitDefinition|null} [leader] Army leader
         * @property {Array.<RemoteFortressReader.IUnitDefinition>|null} [members] Army members
         * @property {number|null} [flags] Army flags
         */

        /**
         * Constructs a new Army.
         * @memberof RemoteFortressReader
         * @classdesc Represents an Army.
         * @implements IArmy
         * @constructor
         * @param {RemoteFortressReader.IArmy=} [properties] Properties to set
         */
        function Army(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Army id.
         * @member {number} id
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.id = 0;

        /**
         * Army posX.
         * @member {number} posX
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.posX = 0;

        /**
         * Army posY.
         * @member {number} posY
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.posY = 0;

        /**
         * Army posZ.
         * @member {number} posZ
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.posZ = 0;

        /**
         * Army leader.
         * @member {RemoteFortressReader.IUnitDefinition|null|undefined} leader
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.leader = null;

        /**
         * Army members.
         * @member {Array.<RemoteFortressReader.IUnitDefinition>} members
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.members = $util.emptyArray;

        /**
         * Army flags.
         * @member {number} flags
         * @memberof RemoteFortressReader.Army
         * @instance
         */
        Army.prototype.flags = 0;

        /**
         * Creates a new Army instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.IArmy=} [properties] Properties to set
         * @returns {RemoteFortressReader.Army} Army instance
         */
        Army.create = function create(properties) {
            return new Army(properties);
        };

        /**
         * Encodes the specified Army message. Does not implicitly {@link RemoteFortressReader.Army.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.IArmy} message Army message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Army.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.posX != null && Object.hasOwnProperty.call(message, "posX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.posX);
            if (message.posY != null && Object.hasOwnProperty.call(message, "posY"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.posY);
            if (message.posZ != null && Object.hasOwnProperty.call(message, "posZ"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.posZ);
            if (message.leader != null && Object.hasOwnProperty.call(message, "leader"))
                $root.RemoteFortressReader.UnitDefinition.encode(message.leader, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.RemoteFortressReader.UnitDefinition.encode(message.members[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.flags);
            return writer;
        };

        /**
         * Encodes the specified Army message, length delimited. Does not implicitly {@link RemoteFortressReader.Army.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.IArmy} message Army message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Army.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Army message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Army} Army
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Army.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Army();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.posX = reader.int32();
                    break;
                case 3:
                    message.posY = reader.int32();
                    break;
                case 4:
                    message.posZ = reader.int32();
                    break;
                case 5:
                    message.leader = $root.RemoteFortressReader.UnitDefinition.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.RemoteFortressReader.UnitDefinition.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Army message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Army} Army
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Army.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Army message.
         * @function verify
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Army.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.posX != null && message.hasOwnProperty("posX"))
                if (!$util.isInteger(message.posX))
                    return "posX: integer expected";
            if (message.posY != null && message.hasOwnProperty("posY"))
                if (!$util.isInteger(message.posY))
                    return "posY: integer expected";
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                if (!$util.isInteger(message.posZ))
                    return "posZ: integer expected";
            if (message.leader != null && message.hasOwnProperty("leader")) {
                var error = $root.RemoteFortressReader.UnitDefinition.verify(message.leader);
                if (error)
                    return "leader." + error;
            }
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.RemoteFortressReader.UnitDefinition.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };

        /**
         * Creates an Army message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Army} Army
         */
        Army.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Army)
                return object;
            var message = new $root.RemoteFortressReader.Army();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.posX != null)
                message.posX = object.posX | 0;
            if (object.posY != null)
                message.posY = object.posY | 0;
            if (object.posZ != null)
                message.posZ = object.posZ | 0;
            if (object.leader != null) {
                if (typeof object.leader !== "object")
                    throw TypeError(".RemoteFortressReader.Army.leader: object expected");
                message.leader = $root.RemoteFortressReader.UnitDefinition.fromObject(object.leader);
            }
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".RemoteFortressReader.Army.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Army.members: object expected");
                    message.members[i] = $root.RemoteFortressReader.UnitDefinition.fromObject(object.members[i]);
                }
            }
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Army message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Army
         * @static
         * @param {RemoteFortressReader.Army} message Army
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Army.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (options.defaults) {
                object.id = 0;
                object.posX = 0;
                object.posY = 0;
                object.posZ = 0;
                object.leader = null;
                object.flags = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.posX != null && message.hasOwnProperty("posX"))
                object.posX = message.posX;
            if (message.posY != null && message.hasOwnProperty("posY"))
                object.posY = message.posY;
            if (message.posZ != null && message.hasOwnProperty("posZ"))
                object.posZ = message.posZ;
            if (message.leader != null && message.hasOwnProperty("leader"))
                object.leader = $root.RemoteFortressReader.UnitDefinition.toObject(message.leader, options);
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.RemoteFortressReader.UnitDefinition.toObject(message.members[j], options);
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };

        /**
         * Converts this Army to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Army
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Army.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Army;
    })();

    RemoteFortressReader.ArmyList = (function() {

        /**
         * Properties of an ArmyList.
         * @memberof RemoteFortressReader
         * @interface IArmyList
         * @property {Array.<RemoteFortressReader.IArmy>|null} [armies] ArmyList armies
         */

        /**
         * Constructs a new ArmyList.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArmyList.
         * @implements IArmyList
         * @constructor
         * @param {RemoteFortressReader.IArmyList=} [properties] Properties to set
         */
        function ArmyList(properties) {
            this.armies = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArmyList armies.
         * @member {Array.<RemoteFortressReader.IArmy>} armies
         * @memberof RemoteFortressReader.ArmyList
         * @instance
         */
        ArmyList.prototype.armies = $util.emptyArray;

        /**
         * Creates a new ArmyList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.IArmyList=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArmyList} ArmyList instance
         */
        ArmyList.create = function create(properties) {
            return new ArmyList(properties);
        };

        /**
         * Encodes the specified ArmyList message. Does not implicitly {@link RemoteFortressReader.ArmyList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.IArmyList} message ArmyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArmyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.armies != null && message.armies.length)
                for (var i = 0; i < message.armies.length; ++i)
                    $root.RemoteFortressReader.Army.encode(message.armies[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArmyList message, length delimited. Does not implicitly {@link RemoteFortressReader.ArmyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.IArmyList} message ArmyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArmyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArmyList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArmyList} ArmyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArmyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArmyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.armies && message.armies.length))
                        message.armies = [];
                    message.armies.push($root.RemoteFortressReader.Army.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArmyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArmyList} ArmyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArmyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArmyList message.
         * @function verify
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArmyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.armies != null && message.hasOwnProperty("armies")) {
                if (!Array.isArray(message.armies))
                    return "armies: array expected";
                for (var i = 0; i < message.armies.length; ++i) {
                    var error = $root.RemoteFortressReader.Army.verify(message.armies[i]);
                    if (error)
                        return "armies." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArmyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArmyList} ArmyList
         */
        ArmyList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArmyList)
                return object;
            var message = new $root.RemoteFortressReader.ArmyList();
            if (object.armies) {
                if (!Array.isArray(object.armies))
                    throw TypeError(".RemoteFortressReader.ArmyList.armies: array expected");
                message.armies = [];
                for (var i = 0; i < object.armies.length; ++i) {
                    if (typeof object.armies[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ArmyList.armies: object expected");
                    message.armies[i] = $root.RemoteFortressReader.Army.fromObject(object.armies[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArmyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArmyList
         * @static
         * @param {RemoteFortressReader.ArmyList} message ArmyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArmyList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.armies = [];
            if (message.armies && message.armies.length) {
                object.armies = [];
                for (var j = 0; j < message.armies.length; ++j)
                    object.armies[j] = $root.RemoteFortressReader.Army.toObject(message.armies[j], options);
            }
            return object;
        };

        /**
         * Converts this ArmyList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArmyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArmyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArmyList;
    })();

    RemoteFortressReader.GrowthPrint = (function() {

        /**
         * Properties of a GrowthPrint.
         * @memberof RemoteFortressReader
         * @interface IGrowthPrint
         * @property {number|null} [priority] GrowthPrint priority
         * @property {number|null} [color] GrowthPrint color
         * @property {number|null} [timingStart] GrowthPrint timingStart
         * @property {number|null} [timingEnd] GrowthPrint timingEnd
         * @property {number|null} [tile] GrowthPrint tile
         */

        /**
         * Constructs a new GrowthPrint.
         * @memberof RemoteFortressReader
         * @classdesc Represents a GrowthPrint.
         * @implements IGrowthPrint
         * @constructor
         * @param {RemoteFortressReader.IGrowthPrint=} [properties] Properties to set
         */
        function GrowthPrint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GrowthPrint priority.
         * @member {number} priority
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.priority = 0;

        /**
         * GrowthPrint color.
         * @member {number} color
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.color = 0;

        /**
         * GrowthPrint timingStart.
         * @member {number} timingStart
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.timingStart = 0;

        /**
         * GrowthPrint timingEnd.
         * @member {number} timingEnd
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.timingEnd = 0;

        /**
         * GrowthPrint tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         */
        GrowthPrint.prototype.tile = 0;

        /**
         * Creates a new GrowthPrint instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.IGrowthPrint=} [properties] Properties to set
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint instance
         */
        GrowthPrint.create = function create(properties) {
            return new GrowthPrint(properties);
        };

        /**
         * Encodes the specified GrowthPrint message. Does not implicitly {@link RemoteFortressReader.GrowthPrint.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.IGrowthPrint} message GrowthPrint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowthPrint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.priority);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
            if (message.timingStart != null && Object.hasOwnProperty.call(message, "timingStart"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.timingStart);
            if (message.timingEnd != null && Object.hasOwnProperty.call(message, "timingEnd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timingEnd);
            if (message.tile != null && Object.hasOwnProperty.call(message, "tile"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.tile);
            return writer;
        };

        /**
         * Encodes the specified GrowthPrint message, length delimited. Does not implicitly {@link RemoteFortressReader.GrowthPrint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.IGrowthPrint} message GrowthPrint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrowthPrint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GrowthPrint message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowthPrint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.GrowthPrint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.priority = reader.int32();
                    break;
                case 2:
                    message.color = reader.int32();
                    break;
                case 3:
                    message.timingStart = reader.int32();
                    break;
                case 4:
                    message.timingEnd = reader.int32();
                    break;
                case 5:
                    message.tile = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GrowthPrint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrowthPrint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GrowthPrint message.
         * @function verify
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GrowthPrint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                if (!$util.isInteger(message.timingStart))
                    return "timingStart: integer expected";
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                if (!$util.isInteger(message.timingEnd))
                    return "timingEnd: integer expected";
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            return null;
        };

        /**
         * Creates a GrowthPrint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.GrowthPrint} GrowthPrint
         */
        GrowthPrint.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.GrowthPrint)
                return object;
            var message = new $root.RemoteFortressReader.GrowthPrint();
            if (object.priority != null)
                message.priority = object.priority | 0;
            if (object.color != null)
                message.color = object.color | 0;
            if (object.timingStart != null)
                message.timingStart = object.timingStart | 0;
            if (object.timingEnd != null)
                message.timingEnd = object.timingEnd | 0;
            if (object.tile != null)
                message.tile = object.tile | 0;
            return message;
        };

        /**
         * Creates a plain object from a GrowthPrint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.GrowthPrint
         * @static
         * @param {RemoteFortressReader.GrowthPrint} message GrowthPrint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GrowthPrint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.priority = 0;
                object.color = 0;
                object.timingStart = 0;
                object.timingEnd = 0;
                object.tile = 0;
            }
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                object.timingStart = message.timingStart;
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                object.timingEnd = message.timingEnd;
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            return object;
        };

        /**
         * Converts this GrowthPrint to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.GrowthPrint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GrowthPrint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GrowthPrint;
    })();

    RemoteFortressReader.TreeGrowth = (function() {

        /**
         * Properties of a TreeGrowth.
         * @memberof RemoteFortressReader
         * @interface ITreeGrowth
         * @property {number|null} [index] TreeGrowth index
         * @property {string|null} [id] TreeGrowth id
         * @property {string|null} [name] TreeGrowth name
         * @property {RemoteFortressReader.IMatPair|null} [mat] TreeGrowth mat
         * @property {Array.<RemoteFortressReader.IGrowthPrint>|null} [prints] TreeGrowth prints
         * @property {number|null} [timingStart] TreeGrowth timingStart
         * @property {number|null} [timingEnd] TreeGrowth timingEnd
         * @property {boolean|null} [twigs] TreeGrowth twigs
         * @property {boolean|null} [lightBranches] TreeGrowth lightBranches
         * @property {boolean|null} [heavyBranches] TreeGrowth heavyBranches
         * @property {boolean|null} [trunk] TreeGrowth trunk
         * @property {boolean|null} [roots] TreeGrowth roots
         * @property {boolean|null} [cap] TreeGrowth cap
         * @property {boolean|null} [sapling] TreeGrowth sapling
         * @property {number|null} [trunkHeightStart] TreeGrowth trunkHeightStart
         * @property {number|null} [trunkHeightEnd] TreeGrowth trunkHeightEnd
         */

        /**
         * Constructs a new TreeGrowth.
         * @memberof RemoteFortressReader
         * @classdesc Represents a TreeGrowth.
         * @implements ITreeGrowth
         * @constructor
         * @param {RemoteFortressReader.ITreeGrowth=} [properties] Properties to set
         */
        function TreeGrowth(properties) {
            this.prints = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreeGrowth index.
         * @member {number} index
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.index = 0;

        /**
         * TreeGrowth id.
         * @member {string} id
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.id = "";

        /**
         * TreeGrowth name.
         * @member {string} name
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.name = "";

        /**
         * TreeGrowth mat.
         * @member {RemoteFortressReader.IMatPair|null|undefined} mat
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.mat = null;

        /**
         * TreeGrowth prints.
         * @member {Array.<RemoteFortressReader.IGrowthPrint>} prints
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.prints = $util.emptyArray;

        /**
         * TreeGrowth timingStart.
         * @member {number} timingStart
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.timingStart = 0;

        /**
         * TreeGrowth timingEnd.
         * @member {number} timingEnd
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.timingEnd = 0;

        /**
         * TreeGrowth twigs.
         * @member {boolean} twigs
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.twigs = false;

        /**
         * TreeGrowth lightBranches.
         * @member {boolean} lightBranches
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.lightBranches = false;

        /**
         * TreeGrowth heavyBranches.
         * @member {boolean} heavyBranches
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.heavyBranches = false;

        /**
         * TreeGrowth trunk.
         * @member {boolean} trunk
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.trunk = false;

        /**
         * TreeGrowth roots.
         * @member {boolean} roots
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.roots = false;

        /**
         * TreeGrowth cap.
         * @member {boolean} cap
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.cap = false;

        /**
         * TreeGrowth sapling.
         * @member {boolean} sapling
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.sapling = false;

        /**
         * TreeGrowth trunkHeightStart.
         * @member {number} trunkHeightStart
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.trunkHeightStart = 0;

        /**
         * TreeGrowth trunkHeightEnd.
         * @member {number} trunkHeightEnd
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         */
        TreeGrowth.prototype.trunkHeightEnd = 0;

        /**
         * Creates a new TreeGrowth instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.ITreeGrowth=} [properties] Properties to set
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth instance
         */
        TreeGrowth.create = function create(properties) {
            return new TreeGrowth(properties);
        };

        /**
         * Encodes the specified TreeGrowth message. Does not implicitly {@link RemoteFortressReader.TreeGrowth.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.ITreeGrowth} message TreeGrowth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreeGrowth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.mat != null && Object.hasOwnProperty.call(message, "mat"))
                $root.RemoteFortressReader.MatPair.encode(message.mat, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.prints != null && message.prints.length)
                for (var i = 0; i < message.prints.length; ++i)
                    $root.RemoteFortressReader.GrowthPrint.encode(message.prints[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timingStart != null && Object.hasOwnProperty.call(message, "timingStart"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timingStart);
            if (message.timingEnd != null && Object.hasOwnProperty.call(message, "timingEnd"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timingEnd);
            if (message.twigs != null && Object.hasOwnProperty.call(message, "twigs"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.twigs);
            if (message.lightBranches != null && Object.hasOwnProperty.call(message, "lightBranches"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.lightBranches);
            if (message.heavyBranches != null && Object.hasOwnProperty.call(message, "heavyBranches"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.heavyBranches);
            if (message.trunk != null && Object.hasOwnProperty.call(message, "trunk"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.trunk);
            if (message.roots != null && Object.hasOwnProperty.call(message, "roots"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.roots);
            if (message.cap != null && Object.hasOwnProperty.call(message, "cap"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.cap);
            if (message.sapling != null && Object.hasOwnProperty.call(message, "sapling"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.sapling);
            if (message.trunkHeightStart != null && Object.hasOwnProperty.call(message, "trunkHeightStart"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.trunkHeightStart);
            if (message.trunkHeightEnd != null && Object.hasOwnProperty.call(message, "trunkHeightEnd"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.trunkHeightEnd);
            return writer;
        };

        /**
         * Encodes the specified TreeGrowth message, length delimited. Does not implicitly {@link RemoteFortressReader.TreeGrowth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.ITreeGrowth} message TreeGrowth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreeGrowth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreeGrowth message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreeGrowth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.TreeGrowth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.mat = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.prints && message.prints.length))
                        message.prints = [];
                    message.prints.push($root.RemoteFortressReader.GrowthPrint.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timingStart = reader.int32();
                    break;
                case 7:
                    message.timingEnd = reader.int32();
                    break;
                case 8:
                    message.twigs = reader.bool();
                    break;
                case 9:
                    message.lightBranches = reader.bool();
                    break;
                case 10:
                    message.heavyBranches = reader.bool();
                    break;
                case 11:
                    message.trunk = reader.bool();
                    break;
                case 12:
                    message.roots = reader.bool();
                    break;
                case 13:
                    message.cap = reader.bool();
                    break;
                case 14:
                    message.sapling = reader.bool();
                    break;
                case 15:
                    message.trunkHeightStart = reader.int32();
                    break;
                case 16:
                    message.trunkHeightEnd = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreeGrowth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreeGrowth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreeGrowth message.
         * @function verify
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreeGrowth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.mat != null && message.hasOwnProperty("mat")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.mat);
                if (error)
                    return "mat." + error;
            }
            if (message.prints != null && message.hasOwnProperty("prints")) {
                if (!Array.isArray(message.prints))
                    return "prints: array expected";
                for (var i = 0; i < message.prints.length; ++i) {
                    var error = $root.RemoteFortressReader.GrowthPrint.verify(message.prints[i]);
                    if (error)
                        return "prints." + error;
                }
            }
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                if (!$util.isInteger(message.timingStart))
                    return "timingStart: integer expected";
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                if (!$util.isInteger(message.timingEnd))
                    return "timingEnd: integer expected";
            if (message.twigs != null && message.hasOwnProperty("twigs"))
                if (typeof message.twigs !== "boolean")
                    return "twigs: boolean expected";
            if (message.lightBranches != null && message.hasOwnProperty("lightBranches"))
                if (typeof message.lightBranches !== "boolean")
                    return "lightBranches: boolean expected";
            if (message.heavyBranches != null && message.hasOwnProperty("heavyBranches"))
                if (typeof message.heavyBranches !== "boolean")
                    return "heavyBranches: boolean expected";
            if (message.trunk != null && message.hasOwnProperty("trunk"))
                if (typeof message.trunk !== "boolean")
                    return "trunk: boolean expected";
            if (message.roots != null && message.hasOwnProperty("roots"))
                if (typeof message.roots !== "boolean")
                    return "roots: boolean expected";
            if (message.cap != null && message.hasOwnProperty("cap"))
                if (typeof message.cap !== "boolean")
                    return "cap: boolean expected";
            if (message.sapling != null && message.hasOwnProperty("sapling"))
                if (typeof message.sapling !== "boolean")
                    return "sapling: boolean expected";
            if (message.trunkHeightStart != null && message.hasOwnProperty("trunkHeightStart"))
                if (!$util.isInteger(message.trunkHeightStart))
                    return "trunkHeightStart: integer expected";
            if (message.trunkHeightEnd != null && message.hasOwnProperty("trunkHeightEnd"))
                if (!$util.isInteger(message.trunkHeightEnd))
                    return "trunkHeightEnd: integer expected";
            return null;
        };

        /**
         * Creates a TreeGrowth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.TreeGrowth} TreeGrowth
         */
        TreeGrowth.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.TreeGrowth)
                return object;
            var message = new $root.RemoteFortressReader.TreeGrowth();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.mat != null) {
                if (typeof object.mat !== "object")
                    throw TypeError(".RemoteFortressReader.TreeGrowth.mat: object expected");
                message.mat = $root.RemoteFortressReader.MatPair.fromObject(object.mat);
            }
            if (object.prints) {
                if (!Array.isArray(object.prints))
                    throw TypeError(".RemoteFortressReader.TreeGrowth.prints: array expected");
                message.prints = [];
                for (var i = 0; i < object.prints.length; ++i) {
                    if (typeof object.prints[i] !== "object")
                        throw TypeError(".RemoteFortressReader.TreeGrowth.prints: object expected");
                    message.prints[i] = $root.RemoteFortressReader.GrowthPrint.fromObject(object.prints[i]);
                }
            }
            if (object.timingStart != null)
                message.timingStart = object.timingStart | 0;
            if (object.timingEnd != null)
                message.timingEnd = object.timingEnd | 0;
            if (object.twigs != null)
                message.twigs = Boolean(object.twigs);
            if (object.lightBranches != null)
                message.lightBranches = Boolean(object.lightBranches);
            if (object.heavyBranches != null)
                message.heavyBranches = Boolean(object.heavyBranches);
            if (object.trunk != null)
                message.trunk = Boolean(object.trunk);
            if (object.roots != null)
                message.roots = Boolean(object.roots);
            if (object.cap != null)
                message.cap = Boolean(object.cap);
            if (object.sapling != null)
                message.sapling = Boolean(object.sapling);
            if (object.trunkHeightStart != null)
                message.trunkHeightStart = object.trunkHeightStart | 0;
            if (object.trunkHeightEnd != null)
                message.trunkHeightEnd = object.trunkHeightEnd | 0;
            return message;
        };

        /**
         * Creates a plain object from a TreeGrowth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.TreeGrowth
         * @static
         * @param {RemoteFortressReader.TreeGrowth} message TreeGrowth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TreeGrowth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.prints = [];
            if (options.defaults) {
                object.index = 0;
                object.id = "";
                object.name = "";
                object.mat = null;
                object.timingStart = 0;
                object.timingEnd = 0;
                object.twigs = false;
                object.lightBranches = false;
                object.heavyBranches = false;
                object.trunk = false;
                object.roots = false;
                object.cap = false;
                object.sapling = false;
                object.trunkHeightStart = 0;
                object.trunkHeightEnd = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.mat != null && message.hasOwnProperty("mat"))
                object.mat = $root.RemoteFortressReader.MatPair.toObject(message.mat, options);
            if (message.prints && message.prints.length) {
                object.prints = [];
                for (var j = 0; j < message.prints.length; ++j)
                    object.prints[j] = $root.RemoteFortressReader.GrowthPrint.toObject(message.prints[j], options);
            }
            if (message.timingStart != null && message.hasOwnProperty("timingStart"))
                object.timingStart = message.timingStart;
            if (message.timingEnd != null && message.hasOwnProperty("timingEnd"))
                object.timingEnd = message.timingEnd;
            if (message.twigs != null && message.hasOwnProperty("twigs"))
                object.twigs = message.twigs;
            if (message.lightBranches != null && message.hasOwnProperty("lightBranches"))
                object.lightBranches = message.lightBranches;
            if (message.heavyBranches != null && message.hasOwnProperty("heavyBranches"))
                object.heavyBranches = message.heavyBranches;
            if (message.trunk != null && message.hasOwnProperty("trunk"))
                object.trunk = message.trunk;
            if (message.roots != null && message.hasOwnProperty("roots"))
                object.roots = message.roots;
            if (message.cap != null && message.hasOwnProperty("cap"))
                object.cap = message.cap;
            if (message.sapling != null && message.hasOwnProperty("sapling"))
                object.sapling = message.sapling;
            if (message.trunkHeightStart != null && message.hasOwnProperty("trunkHeightStart"))
                object.trunkHeightStart = message.trunkHeightStart;
            if (message.trunkHeightEnd != null && message.hasOwnProperty("trunkHeightEnd"))
                object.trunkHeightEnd = message.trunkHeightEnd;
            return object;
        };

        /**
         * Converts this TreeGrowth to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.TreeGrowth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TreeGrowth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TreeGrowth;
    })();

    RemoteFortressReader.PlantRaw = (function() {

        /**
         * Properties of a PlantRaw.
         * @memberof RemoteFortressReader
         * @interface IPlantRaw
         * @property {number|null} [index] PlantRaw index
         * @property {string|null} [id] PlantRaw id
         * @property {string|null} [name] PlantRaw name
         * @property {Array.<RemoteFortressReader.ITreeGrowth>|null} [growths] PlantRaw growths
         * @property {number|null} [tile] PlantRaw tile
         */

        /**
         * Constructs a new PlantRaw.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantRaw.
         * @implements IPlantRaw
         * @constructor
         * @param {RemoteFortressReader.IPlantRaw=} [properties] Properties to set
         */
        function PlantRaw(properties) {
            this.growths = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantRaw index.
         * @member {number} index
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.index = 0;

        /**
         * PlantRaw id.
         * @member {string} id
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.id = "";

        /**
         * PlantRaw name.
         * @member {string} name
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.name = "";

        /**
         * PlantRaw growths.
         * @member {Array.<RemoteFortressReader.ITreeGrowth>} growths
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.growths = $util.emptyArray;

        /**
         * PlantRaw tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         */
        PlantRaw.prototype.tile = 0;

        /**
         * Creates a new PlantRaw instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.IPlantRaw=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw instance
         */
        PlantRaw.create = function create(properties) {
            return new PlantRaw(properties);
        };

        /**
         * Encodes the specified PlantRaw message. Does not implicitly {@link RemoteFortressReader.PlantRaw.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.IPlantRaw} message PlantRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.growths != null && message.growths.length)
                for (var i = 0; i < message.growths.length; ++i)
                    $root.RemoteFortressReader.TreeGrowth.encode(message.growths[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.tile != null && Object.hasOwnProperty.call(message, "tile"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.tile);
            return writer;
        };

        /**
         * Encodes the specified PlantRaw message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.IPlantRaw} message PlantRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantRaw message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    if (!(message.growths && message.growths.length))
                        message.growths = [];
                    message.growths.push($root.RemoteFortressReader.TreeGrowth.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.tile = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlantRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantRaw message.
         * @function verify
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.growths != null && message.hasOwnProperty("growths")) {
                if (!Array.isArray(message.growths))
                    return "growths: array expected";
                for (var i = 0; i < message.growths.length; ++i) {
                    var error = $root.RemoteFortressReader.TreeGrowth.verify(message.growths[i]);
                    if (error)
                        return "growths." + error;
                }
            }
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            return null;
        };

        /**
         * Creates a PlantRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantRaw} PlantRaw
         */
        PlantRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantRaw)
                return object;
            var message = new $root.RemoteFortressReader.PlantRaw();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.growths) {
                if (!Array.isArray(object.growths))
                    throw TypeError(".RemoteFortressReader.PlantRaw.growths: array expected");
                message.growths = [];
                for (var i = 0; i < object.growths.length; ++i) {
                    if (typeof object.growths[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PlantRaw.growths: object expected");
                    message.growths[i] = $root.RemoteFortressReader.TreeGrowth.fromObject(object.growths[i]);
                }
            }
            if (object.tile != null)
                message.tile = object.tile | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlantRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantRaw
         * @static
         * @param {RemoteFortressReader.PlantRaw} message PlantRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.growths = [];
            if (options.defaults) {
                object.index = 0;
                object.id = "";
                object.name = "";
                object.tile = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.growths && message.growths.length) {
                object.growths = [];
                for (var j = 0; j < message.growths.length; ++j)
                    object.growths[j] = $root.RemoteFortressReader.TreeGrowth.toObject(message.growths[j], options);
            }
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            return object;
        };

        /**
         * Converts this PlantRaw to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantRaw;
    })();

    RemoteFortressReader.PlantRawList = (function() {

        /**
         * Properties of a PlantRawList.
         * @memberof RemoteFortressReader
         * @interface IPlantRawList
         * @property {Array.<RemoteFortressReader.IPlantRaw>|null} [plantRaws] PlantRawList plantRaws
         */

        /**
         * Constructs a new PlantRawList.
         * @memberof RemoteFortressReader
         * @classdesc Represents a PlantRawList.
         * @implements IPlantRawList
         * @constructor
         * @param {RemoteFortressReader.IPlantRawList=} [properties] Properties to set
         */
        function PlantRawList(properties) {
            this.plantRaws = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlantRawList plantRaws.
         * @member {Array.<RemoteFortressReader.IPlantRaw>} plantRaws
         * @memberof RemoteFortressReader.PlantRawList
         * @instance
         */
        PlantRawList.prototype.plantRaws = $util.emptyArray;

        /**
         * Creates a new PlantRawList instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.IPlantRawList=} [properties] Properties to set
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList instance
         */
        PlantRawList.create = function create(properties) {
            return new PlantRawList(properties);
        };

        /**
         * Encodes the specified PlantRawList message. Does not implicitly {@link RemoteFortressReader.PlantRawList.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.IPlantRawList} message PlantRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRawList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.plantRaws != null && message.plantRaws.length)
                for (var i = 0; i < message.plantRaws.length; ++i)
                    $root.RemoteFortressReader.PlantRaw.encode(message.plantRaws[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlantRawList message, length delimited. Does not implicitly {@link RemoteFortressReader.PlantRawList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.IPlantRawList} message PlantRawList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlantRawList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlantRawList message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRawList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.PlantRawList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.plantRaws && message.plantRaws.length))
                        message.plantRaws = [];
                    message.plantRaws.push($root.RemoteFortressReader.PlantRaw.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlantRawList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlantRawList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlantRawList message.
         * @function verify
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlantRawList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.plantRaws != null && message.hasOwnProperty("plantRaws")) {
                if (!Array.isArray(message.plantRaws))
                    return "plantRaws: array expected";
                for (var i = 0; i < message.plantRaws.length; ++i) {
                    var error = $root.RemoteFortressReader.PlantRaw.verify(message.plantRaws[i]);
                    if (error)
                        return "plantRaws." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PlantRawList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.PlantRawList} PlantRawList
         */
        PlantRawList.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.PlantRawList)
                return object;
            var message = new $root.RemoteFortressReader.PlantRawList();
            if (object.plantRaws) {
                if (!Array.isArray(object.plantRaws))
                    throw TypeError(".RemoteFortressReader.PlantRawList.plantRaws: array expected");
                message.plantRaws = [];
                for (var i = 0; i < object.plantRaws.length; ++i) {
                    if (typeof object.plantRaws[i] !== "object")
                        throw TypeError(".RemoteFortressReader.PlantRawList.plantRaws: object expected");
                    message.plantRaws[i] = $root.RemoteFortressReader.PlantRaw.fromObject(object.plantRaws[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PlantRawList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.PlantRawList
         * @static
         * @param {RemoteFortressReader.PlantRawList} message PlantRawList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlantRawList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plantRaws = [];
            if (message.plantRaws && message.plantRaws.length) {
                object.plantRaws = [];
                for (var j = 0; j < message.plantRaws.length; ++j)
                    object.plantRaws[j] = $root.RemoteFortressReader.PlantRaw.toObject(message.plantRaws[j], options);
            }
            return object;
        };

        /**
         * Converts this PlantRawList to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.PlantRawList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlantRawList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlantRawList;
    })();

    RemoteFortressReader.ScreenTile = (function() {

        /**
         * Properties of a ScreenTile.
         * @memberof RemoteFortressReader
         * @interface IScreenTile
         * @property {number|null} [character] ScreenTile character
         * @property {number|null} [foreground] ScreenTile foreground
         * @property {number|null} [background] ScreenTile background
         */

        /**
         * Constructs a new ScreenTile.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ScreenTile.
         * @implements IScreenTile
         * @constructor
         * @param {RemoteFortressReader.IScreenTile=} [properties] Properties to set
         */
        function ScreenTile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScreenTile character.
         * @member {number} character
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         */
        ScreenTile.prototype.character = 0;

        /**
         * ScreenTile foreground.
         * @member {number} foreground
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         */
        ScreenTile.prototype.foreground = 0;

        /**
         * ScreenTile background.
         * @member {number} background
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         */
        ScreenTile.prototype.background = 0;

        /**
         * Creates a new ScreenTile instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.IScreenTile=} [properties] Properties to set
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile instance
         */
        ScreenTile.create = function create(properties) {
            return new ScreenTile(properties);
        };

        /**
         * Encodes the specified ScreenTile message. Does not implicitly {@link RemoteFortressReader.ScreenTile.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.IScreenTile} message ScreenTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.character != null && Object.hasOwnProperty.call(message, "character"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.character);
            if (message.foreground != null && Object.hasOwnProperty.call(message, "foreground"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.foreground);
            if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.background);
            return writer;
        };

        /**
         * Encodes the specified ScreenTile message, length delimited. Does not implicitly {@link RemoteFortressReader.ScreenTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.IScreenTile} message ScreenTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ScreenTile message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ScreenTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.character = reader.uint32();
                    break;
                case 2:
                    message.foreground = reader.uint32();
                    break;
                case 3:
                    message.background = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScreenTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ScreenTile message.
         * @function verify
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScreenTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.character != null && message.hasOwnProperty("character"))
                if (!$util.isInteger(message.character))
                    return "character: integer expected";
            if (message.foreground != null && message.hasOwnProperty("foreground"))
                if (!$util.isInteger(message.foreground))
                    return "foreground: integer expected";
            if (message.background != null && message.hasOwnProperty("background"))
                if (!$util.isInteger(message.background))
                    return "background: integer expected";
            return null;
        };

        /**
         * Creates a ScreenTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ScreenTile} ScreenTile
         */
        ScreenTile.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ScreenTile)
                return object;
            var message = new $root.RemoteFortressReader.ScreenTile();
            if (object.character != null)
                message.character = object.character >>> 0;
            if (object.foreground != null)
                message.foreground = object.foreground >>> 0;
            if (object.background != null)
                message.background = object.background >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ScreenTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ScreenTile
         * @static
         * @param {RemoteFortressReader.ScreenTile} message ScreenTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScreenTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.character = 0;
                object.foreground = 0;
                object.background = 0;
            }
            if (message.character != null && message.hasOwnProperty("character"))
                object.character = message.character;
            if (message.foreground != null && message.hasOwnProperty("foreground"))
                object.foreground = message.foreground;
            if (message.background != null && message.hasOwnProperty("background"))
                object.background = message.background;
            return object;
        };

        /**
         * Converts this ScreenTile to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ScreenTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScreenTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ScreenTile;
    })();

    RemoteFortressReader.ScreenCapture = (function() {

        /**
         * Properties of a ScreenCapture.
         * @memberof RemoteFortressReader
         * @interface IScreenCapture
         * @property {number|null} [width] ScreenCapture width
         * @property {number|null} [height] ScreenCapture height
         * @property {Array.<RemoteFortressReader.IScreenTile>|null} [tiles] ScreenCapture tiles
         */

        /**
         * Constructs a new ScreenCapture.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ScreenCapture.
         * @implements IScreenCapture
         * @constructor
         * @param {RemoteFortressReader.IScreenCapture=} [properties] Properties to set
         */
        function ScreenCapture(properties) {
            this.tiles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScreenCapture width.
         * @member {number} width
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         */
        ScreenCapture.prototype.width = 0;

        /**
         * ScreenCapture height.
         * @member {number} height
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         */
        ScreenCapture.prototype.height = 0;

        /**
         * ScreenCapture tiles.
         * @member {Array.<RemoteFortressReader.IScreenTile>} tiles
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         */
        ScreenCapture.prototype.tiles = $util.emptyArray;

        /**
         * Creates a new ScreenCapture instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.IScreenCapture=} [properties] Properties to set
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture instance
         */
        ScreenCapture.create = function create(properties) {
            return new ScreenCapture(properties);
        };

        /**
         * Encodes the specified ScreenCapture message. Does not implicitly {@link RemoteFortressReader.ScreenCapture.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.IScreenCapture} message ScreenCapture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenCapture.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.height);
            if (message.tiles != null && message.tiles.length)
                for (var i = 0; i < message.tiles.length; ++i)
                    $root.RemoteFortressReader.ScreenTile.encode(message.tiles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ScreenCapture message, length delimited. Does not implicitly {@link RemoteFortressReader.ScreenCapture.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.IScreenCapture} message ScreenCapture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenCapture.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ScreenCapture message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenCapture.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ScreenCapture();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.width = reader.uint32();
                    break;
                case 2:
                    message.height = reader.uint32();
                    break;
                case 3:
                    if (!(message.tiles && message.tiles.length))
                        message.tiles = [];
                    message.tiles.push($root.RemoteFortressReader.ScreenTile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScreenCapture message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenCapture.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ScreenCapture message.
         * @function verify
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScreenCapture.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.tiles != null && message.hasOwnProperty("tiles")) {
                if (!Array.isArray(message.tiles))
                    return "tiles: array expected";
                for (var i = 0; i < message.tiles.length; ++i) {
                    var error = $root.RemoteFortressReader.ScreenTile.verify(message.tiles[i]);
                    if (error)
                        return "tiles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ScreenCapture message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ScreenCapture} ScreenCapture
         */
        ScreenCapture.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ScreenCapture)
                return object;
            var message = new $root.RemoteFortressReader.ScreenCapture();
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.tiles) {
                if (!Array.isArray(object.tiles))
                    throw TypeError(".RemoteFortressReader.ScreenCapture.tiles: array expected");
                message.tiles = [];
                for (var i = 0; i < object.tiles.length; ++i) {
                    if (typeof object.tiles[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ScreenCapture.tiles: object expected");
                    message.tiles[i] = $root.RemoteFortressReader.ScreenTile.fromObject(object.tiles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ScreenCapture message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ScreenCapture
         * @static
         * @param {RemoteFortressReader.ScreenCapture} message ScreenCapture
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScreenCapture.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tiles = [];
            if (options.defaults) {
                object.width = 0;
                object.height = 0;
            }
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.tiles && message.tiles.length) {
                object.tiles = [];
                for (var j = 0; j < message.tiles.length; ++j)
                    object.tiles[j] = $root.RemoteFortressReader.ScreenTile.toObject(message.tiles[j], options);
            }
            return object;
        };

        /**
         * Converts this ScreenCapture to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ScreenCapture
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScreenCapture.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ScreenCapture;
    })();

    RemoteFortressReader.KeyboardEvent = (function() {

        /**
         * Properties of a KeyboardEvent.
         * @memberof RemoteFortressReader
         * @interface IKeyboardEvent
         * @property {number|null} [type] KeyboardEvent type
         * @property {number|null} [which] KeyboardEvent which
         * @property {number|null} [state] KeyboardEvent state
         * @property {number|null} [scancode] KeyboardEvent scancode
         * @property {number|null} [sym] KeyboardEvent sym
         * @property {number|null} [mod] KeyboardEvent mod
         * @property {number|null} [unicode] KeyboardEvent unicode
         */

        /**
         * Constructs a new KeyboardEvent.
         * @memberof RemoteFortressReader
         * @classdesc Represents a KeyboardEvent.
         * @implements IKeyboardEvent
         * @constructor
         * @param {RemoteFortressReader.IKeyboardEvent=} [properties] Properties to set
         */
        function KeyboardEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyboardEvent type.
         * @member {number} type
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.type = 0;

        /**
         * KeyboardEvent which.
         * @member {number} which
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.which = 0;

        /**
         * KeyboardEvent state.
         * @member {number} state
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.state = 0;

        /**
         * KeyboardEvent scancode.
         * @member {number} scancode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.scancode = 0;

        /**
         * KeyboardEvent sym.
         * @member {number} sym
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.sym = 0;

        /**
         * KeyboardEvent mod.
         * @member {number} mod
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.mod = 0;

        /**
         * KeyboardEvent unicode.
         * @member {number} unicode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         */
        KeyboardEvent.prototype.unicode = 0;

        /**
         * Creates a new KeyboardEvent instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.IKeyboardEvent=} [properties] Properties to set
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent instance
         */
        KeyboardEvent.create = function create(properties) {
            return new KeyboardEvent(properties);
        };

        /**
         * Encodes the specified KeyboardEvent message. Does not implicitly {@link RemoteFortressReader.KeyboardEvent.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.IKeyboardEvent} message KeyboardEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyboardEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.which != null && Object.hasOwnProperty.call(message, "which"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.which);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.state);
            if (message.scancode != null && Object.hasOwnProperty.call(message, "scancode"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.scancode);
            if (message.sym != null && Object.hasOwnProperty.call(message, "sym"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.sym);
            if (message.mod != null && Object.hasOwnProperty.call(message, "mod"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.mod);
            if (message.unicode != null && Object.hasOwnProperty.call(message, "unicode"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.unicode);
            return writer;
        };

        /**
         * Encodes the specified KeyboardEvent message, length delimited. Does not implicitly {@link RemoteFortressReader.KeyboardEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.IKeyboardEvent} message KeyboardEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyboardEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyboardEvent message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyboardEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.KeyboardEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.uint32();
                    break;
                case 2:
                    message.which = reader.uint32();
                    break;
                case 3:
                    message.state = reader.uint32();
                    break;
                case 4:
                    message.scancode = reader.uint32();
                    break;
                case 5:
                    message.sym = reader.uint32();
                    break;
                case 6:
                    message.mod = reader.uint32();
                    break;
                case 7:
                    message.unicode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyboardEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyboardEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyboardEvent message.
         * @function verify
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyboardEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.which != null && message.hasOwnProperty("which"))
                if (!$util.isInteger(message.which))
                    return "which: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.scancode != null && message.hasOwnProperty("scancode"))
                if (!$util.isInteger(message.scancode))
                    return "scancode: integer expected";
            if (message.sym != null && message.hasOwnProperty("sym"))
                if (!$util.isInteger(message.sym))
                    return "sym: integer expected";
            if (message.mod != null && message.hasOwnProperty("mod"))
                if (!$util.isInteger(message.mod))
                    return "mod: integer expected";
            if (message.unicode != null && message.hasOwnProperty("unicode"))
                if (!$util.isInteger(message.unicode))
                    return "unicode: integer expected";
            return null;
        };

        /**
         * Creates a KeyboardEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.KeyboardEvent} KeyboardEvent
         */
        KeyboardEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.KeyboardEvent)
                return object;
            var message = new $root.RemoteFortressReader.KeyboardEvent();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.which != null)
                message.which = object.which >>> 0;
            if (object.state != null)
                message.state = object.state >>> 0;
            if (object.scancode != null)
                message.scancode = object.scancode >>> 0;
            if (object.sym != null)
                message.sym = object.sym >>> 0;
            if (object.mod != null)
                message.mod = object.mod >>> 0;
            if (object.unicode != null)
                message.unicode = object.unicode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a KeyboardEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.KeyboardEvent
         * @static
         * @param {RemoteFortressReader.KeyboardEvent} message KeyboardEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyboardEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.which = 0;
                object.state = 0;
                object.scancode = 0;
                object.sym = 0;
                object.mod = 0;
                object.unicode = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.which != null && message.hasOwnProperty("which"))
                object.which = message.which;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.scancode != null && message.hasOwnProperty("scancode"))
                object.scancode = message.scancode;
            if (message.sym != null && message.hasOwnProperty("sym"))
                object.sym = message.sym;
            if (message.mod != null && message.hasOwnProperty("mod"))
                object.mod = message.mod;
            if (message.unicode != null && message.hasOwnProperty("unicode"))
                object.unicode = message.unicode;
            return object;
        };

        /**
         * Converts this KeyboardEvent to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.KeyboardEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyboardEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyboardEvent;
    })();

    RemoteFortressReader.DigCommand = (function() {

        /**
         * Properties of a DigCommand.
         * @memberof RemoteFortressReader
         * @interface IDigCommand
         * @property {RemoteFortressReader.TileDigDesignation|null} [designation] DigCommand designation
         * @property {Array.<RemoteFortressReader.ICoord>|null} [locations] DigCommand locations
         */

        /**
         * Constructs a new DigCommand.
         * @memberof RemoteFortressReader
         * @classdesc Represents a DigCommand.
         * @implements IDigCommand
         * @constructor
         * @param {RemoteFortressReader.IDigCommand=} [properties] Properties to set
         */
        function DigCommand(properties) {
            this.locations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DigCommand designation.
         * @member {RemoteFortressReader.TileDigDesignation} designation
         * @memberof RemoteFortressReader.DigCommand
         * @instance
         */
        DigCommand.prototype.designation = 0;

        /**
         * DigCommand locations.
         * @member {Array.<RemoteFortressReader.ICoord>} locations
         * @memberof RemoteFortressReader.DigCommand
         * @instance
         */
        DigCommand.prototype.locations = $util.emptyArray;

        /**
         * Creates a new DigCommand instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.IDigCommand=} [properties] Properties to set
         * @returns {RemoteFortressReader.DigCommand} DigCommand instance
         */
        DigCommand.create = function create(properties) {
            return new DigCommand(properties);
        };

        /**
         * Encodes the specified DigCommand message. Does not implicitly {@link RemoteFortressReader.DigCommand.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.IDigCommand} message DigCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DigCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.designation != null && Object.hasOwnProperty.call(message, "designation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.designation);
            if (message.locations != null && message.locations.length)
                for (var i = 0; i < message.locations.length; ++i)
                    $root.RemoteFortressReader.Coord.encode(message.locations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DigCommand message, length delimited. Does not implicitly {@link RemoteFortressReader.DigCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.IDigCommand} message DigCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DigCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DigCommand message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.DigCommand} DigCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DigCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.DigCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.designation = reader.int32();
                    break;
                case 2:
                    if (!(message.locations && message.locations.length))
                        message.locations = [];
                    message.locations.push($root.RemoteFortressReader.Coord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DigCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.DigCommand} DigCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DigCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DigCommand message.
         * @function verify
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DigCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.designation != null && message.hasOwnProperty("designation"))
                switch (message.designation) {
                default:
                    return "designation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.locations != null && message.hasOwnProperty("locations")) {
                if (!Array.isArray(message.locations))
                    return "locations: array expected";
                for (var i = 0; i < message.locations.length; ++i) {
                    var error = $root.RemoteFortressReader.Coord.verify(message.locations[i]);
                    if (error)
                        return "locations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a DigCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.DigCommand} DigCommand
         */
        DigCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.DigCommand)
                return object;
            var message = new $root.RemoteFortressReader.DigCommand();
            switch (object.designation) {
            case "NO_DIG":
            case 0:
                message.designation = 0;
                break;
            case "DEFAULT_DIG":
            case 1:
                message.designation = 1;
                break;
            case "UP_DOWN_STAIR_DIG":
            case 2:
                message.designation = 2;
                break;
            case "CHANNEL_DIG":
            case 3:
                message.designation = 3;
                break;
            case "RAMP_DIG":
            case 4:
                message.designation = 4;
                break;
            case "DOWN_STAIR_DIG":
            case 5:
                message.designation = 5;
                break;
            case "UP_STAIR_DIG":
            case 6:
                message.designation = 6;
                break;
            }
            if (object.locations) {
                if (!Array.isArray(object.locations))
                    throw TypeError(".RemoteFortressReader.DigCommand.locations: array expected");
                message.locations = [];
                for (var i = 0; i < object.locations.length; ++i) {
                    if (typeof object.locations[i] !== "object")
                        throw TypeError(".RemoteFortressReader.DigCommand.locations: object expected");
                    message.locations[i] = $root.RemoteFortressReader.Coord.fromObject(object.locations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a DigCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.DigCommand
         * @static
         * @param {RemoteFortressReader.DigCommand} message DigCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DigCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.locations = [];
            if (options.defaults)
                object.designation = options.enums === String ? "NO_DIG" : 0;
            if (message.designation != null && message.hasOwnProperty("designation"))
                object.designation = options.enums === String ? $root.RemoteFortressReader.TileDigDesignation[message.designation] : message.designation;
            if (message.locations && message.locations.length) {
                object.locations = [];
                for (var j = 0; j < message.locations.length; ++j)
                    object.locations[j] = $root.RemoteFortressReader.Coord.toObject(message.locations[j], options);
            }
            return object;
        };

        /**
         * Converts this DigCommand to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.DigCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DigCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DigCommand;
    })();

    RemoteFortressReader.SingleBool = (function() {

        /**
         * Properties of a SingleBool.
         * @memberof RemoteFortressReader
         * @interface ISingleBool
         * @property {boolean|null} [Value] SingleBool Value
         */

        /**
         * Constructs a new SingleBool.
         * @memberof RemoteFortressReader
         * @classdesc Represents a SingleBool.
         * @implements ISingleBool
         * @constructor
         * @param {RemoteFortressReader.ISingleBool=} [properties] Properties to set
         */
        function SingleBool(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SingleBool Value.
         * @member {boolean} Value
         * @memberof RemoteFortressReader.SingleBool
         * @instance
         */
        SingleBool.prototype.Value = false;

        /**
         * Creates a new SingleBool instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.ISingleBool=} [properties] Properties to set
         * @returns {RemoteFortressReader.SingleBool} SingleBool instance
         */
        SingleBool.create = function create(properties) {
            return new SingleBool(properties);
        };

        /**
         * Encodes the specified SingleBool message. Does not implicitly {@link RemoteFortressReader.SingleBool.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.ISingleBool} message SingleBool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleBool.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Value != null && Object.hasOwnProperty.call(message, "Value"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.Value);
            return writer;
        };

        /**
         * Encodes the specified SingleBool message, length delimited. Does not implicitly {@link RemoteFortressReader.SingleBool.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.ISingleBool} message SingleBool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleBool.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SingleBool message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.SingleBool} SingleBool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleBool.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.SingleBool();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SingleBool message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.SingleBool} SingleBool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleBool.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SingleBool message.
         * @function verify
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SingleBool.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Value != null && message.hasOwnProperty("Value"))
                if (typeof message.Value !== "boolean")
                    return "Value: boolean expected";
            return null;
        };

        /**
         * Creates a SingleBool message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.SingleBool} SingleBool
         */
        SingleBool.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.SingleBool)
                return object;
            var message = new $root.RemoteFortressReader.SingleBool();
            if (object.Value != null)
                message.Value = Boolean(object.Value);
            return message;
        };

        /**
         * Creates a plain object from a SingleBool message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.SingleBool
         * @static
         * @param {RemoteFortressReader.SingleBool} message SingleBool
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SingleBool.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.Value = false;
            if (message.Value != null && message.hasOwnProperty("Value"))
                object.Value = message.Value;
            return object;
        };

        /**
         * Converts this SingleBool to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.SingleBool
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SingleBool.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SingleBool;
    })();

    RemoteFortressReader.VersionInfo = (function() {

        /**
         * Properties of a VersionInfo.
         * @memberof RemoteFortressReader
         * @interface IVersionInfo
         * @property {string|null} [dwarfFortressVersion] VersionInfo dwarfFortressVersion
         * @property {string|null} [dfhackVersion] VersionInfo dfhackVersion
         * @property {string|null} [remoteFortressReaderVersion] VersionInfo remoteFortressReaderVersion
         */

        /**
         * Constructs a new VersionInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a VersionInfo.
         * @implements IVersionInfo
         * @constructor
         * @param {RemoteFortressReader.IVersionInfo=} [properties] Properties to set
         */
        function VersionInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VersionInfo dwarfFortressVersion.
         * @member {string} dwarfFortressVersion
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         */
        VersionInfo.prototype.dwarfFortressVersion = "";

        /**
         * VersionInfo dfhackVersion.
         * @member {string} dfhackVersion
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         */
        VersionInfo.prototype.dfhackVersion = "";

        /**
         * VersionInfo remoteFortressReaderVersion.
         * @member {string} remoteFortressReaderVersion
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         */
        VersionInfo.prototype.remoteFortressReaderVersion = "";

        /**
         * Creates a new VersionInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.IVersionInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo instance
         */
        VersionInfo.create = function create(properties) {
            return new VersionInfo(properties);
        };

        /**
         * Encodes the specified VersionInfo message. Does not implicitly {@link RemoteFortressReader.VersionInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.IVersionInfo} message VersionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dwarfFortressVersion != null && Object.hasOwnProperty.call(message, "dwarfFortressVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dwarfFortressVersion);
            if (message.dfhackVersion != null && Object.hasOwnProperty.call(message, "dfhackVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.dfhackVersion);
            if (message.remoteFortressReaderVersion != null && Object.hasOwnProperty.call(message, "remoteFortressReaderVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.remoteFortressReaderVersion);
            return writer;
        };

        /**
         * Encodes the specified VersionInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.VersionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.IVersionInfo} message VersionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.VersionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dwarfFortressVersion = reader.string();
                    break;
                case 2:
                    message.dfhackVersion = reader.string();
                    break;
                case 3:
                    message.remoteFortressReaderVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VersionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionInfo message.
         * @function verify
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dwarfFortressVersion != null && message.hasOwnProperty("dwarfFortressVersion"))
                if (!$util.isString(message.dwarfFortressVersion))
                    return "dwarfFortressVersion: string expected";
            if (message.dfhackVersion != null && message.hasOwnProperty("dfhackVersion"))
                if (!$util.isString(message.dfhackVersion))
                    return "dfhackVersion: string expected";
            if (message.remoteFortressReaderVersion != null && message.hasOwnProperty("remoteFortressReaderVersion"))
                if (!$util.isString(message.remoteFortressReaderVersion))
                    return "remoteFortressReaderVersion: string expected";
            return null;
        };

        /**
         * Creates a VersionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.VersionInfo} VersionInfo
         */
        VersionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.VersionInfo)
                return object;
            var message = new $root.RemoteFortressReader.VersionInfo();
            if (object.dwarfFortressVersion != null)
                message.dwarfFortressVersion = String(object.dwarfFortressVersion);
            if (object.dfhackVersion != null)
                message.dfhackVersion = String(object.dfhackVersion);
            if (object.remoteFortressReaderVersion != null)
                message.remoteFortressReaderVersion = String(object.remoteFortressReaderVersion);
            return message;
        };

        /**
         * Creates a plain object from a VersionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.VersionInfo
         * @static
         * @param {RemoteFortressReader.VersionInfo} message VersionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dwarfFortressVersion = "";
                object.dfhackVersion = "";
                object.remoteFortressReaderVersion = "";
            }
            if (message.dwarfFortressVersion != null && message.hasOwnProperty("dwarfFortressVersion"))
                object.dwarfFortressVersion = message.dwarfFortressVersion;
            if (message.dfhackVersion != null && message.hasOwnProperty("dfhackVersion"))
                object.dfhackVersion = message.dfhackVersion;
            if (message.remoteFortressReaderVersion != null && message.hasOwnProperty("remoteFortressReaderVersion"))
                object.remoteFortressReaderVersion = message.remoteFortressReaderVersion;
            return object;
        };

        /**
         * Converts this VersionInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.VersionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VersionInfo;
    })();

    RemoteFortressReader.ListRequest = (function() {

        /**
         * Properties of a ListRequest.
         * @memberof RemoteFortressReader
         * @interface IListRequest
         * @property {number|null} [listStart] ListRequest listStart
         * @property {number|null} [listEnd] ListRequest listEnd
         */

        /**
         * Constructs a new ListRequest.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ListRequest.
         * @implements IListRequest
         * @constructor
         * @param {RemoteFortressReader.IListRequest=} [properties] Properties to set
         */
        function ListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListRequest listStart.
         * @member {number} listStart
         * @memberof RemoteFortressReader.ListRequest
         * @instance
         */
        ListRequest.prototype.listStart = 0;

        /**
         * ListRequest listEnd.
         * @member {number} listEnd
         * @memberof RemoteFortressReader.ListRequest
         * @instance
         */
        ListRequest.prototype.listEnd = 0;

        /**
         * Creates a new ListRequest instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.IListRequest=} [properties] Properties to set
         * @returns {RemoteFortressReader.ListRequest} ListRequest instance
         */
        ListRequest.create = function create(properties) {
            return new ListRequest(properties);
        };

        /**
         * Encodes the specified ListRequest message. Does not implicitly {@link RemoteFortressReader.ListRequest.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.IListRequest} message ListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.listStart != null && Object.hasOwnProperty.call(message, "listStart"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.listStart);
            if (message.listEnd != null && Object.hasOwnProperty.call(message, "listEnd"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.listEnd);
            return writer;
        };

        /**
         * Encodes the specified ListRequest message, length delimited. Does not implicitly {@link RemoteFortressReader.ListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.IListRequest} message ListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ListRequest} ListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.listStart = reader.int32();
                    break;
                case 2:
                    message.listEnd = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ListRequest} ListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListRequest message.
         * @function verify
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.listStart != null && message.hasOwnProperty("listStart"))
                if (!$util.isInteger(message.listStart))
                    return "listStart: integer expected";
            if (message.listEnd != null && message.hasOwnProperty("listEnd"))
                if (!$util.isInteger(message.listEnd))
                    return "listEnd: integer expected";
            return null;
        };

        /**
         * Creates a ListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ListRequest} ListRequest
         */
        ListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ListRequest)
                return object;
            var message = new $root.RemoteFortressReader.ListRequest();
            if (object.listStart != null)
                message.listStart = object.listStart | 0;
            if (object.listEnd != null)
                message.listEnd = object.listEnd | 0;
            return message;
        };

        /**
         * Creates a plain object from a ListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ListRequest
         * @static
         * @param {RemoteFortressReader.ListRequest} message ListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.listStart = 0;
                object.listEnd = 0;
            }
            if (message.listStart != null && message.hasOwnProperty("listStart"))
                object.listStart = message.listStart;
            if (message.listEnd != null && message.hasOwnProperty("listEnd"))
                object.listEnd = message.listEnd;
            return object;
        };

        /**
         * Converts this ListRequest to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListRequest;
    })();

    RemoteFortressReader.Report = (function() {

        /**
         * Properties of a Report.
         * @memberof RemoteFortressReader
         * @interface IReport
         * @property {number|null} [type] Report type
         * @property {string|null} [text] Report text
         * @property {RemoteFortressReader.IColorDefinition|null} [color] Report color
         * @property {number|null} [duration] Report duration
         * @property {boolean|null} [continuation] Report continuation
         * @property {boolean|null} [unconscious] Report unconscious
         * @property {boolean|null} [announcement] Report announcement
         * @property {number|null} [repeatCount] Report repeatCount
         * @property {RemoteFortressReader.ICoord|null} [pos] Report pos
         * @property {number|null} [id] Report id
         * @property {number|null} [year] Report year
         * @property {number|null} [time] Report time
         */

        /**
         * Constructs a new Report.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Report.
         * @implements IReport
         * @constructor
         * @param {RemoteFortressReader.IReport=} [properties] Properties to set
         */
        function Report(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Report type.
         * @member {number} type
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.type = 0;

        /**
         * Report text.
         * @member {string} text
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.text = "";

        /**
         * Report color.
         * @member {RemoteFortressReader.IColorDefinition|null|undefined} color
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.color = null;

        /**
         * Report duration.
         * @member {number} duration
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.duration = 0;

        /**
         * Report continuation.
         * @member {boolean} continuation
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.continuation = false;

        /**
         * Report unconscious.
         * @member {boolean} unconscious
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.unconscious = false;

        /**
         * Report announcement.
         * @member {boolean} announcement
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.announcement = false;

        /**
         * Report repeatCount.
         * @member {number} repeatCount
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.repeatCount = 0;

        /**
         * Report pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.pos = null;

        /**
         * Report id.
         * @member {number} id
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.id = 0;

        /**
         * Report year.
         * @member {number} year
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.year = 0;

        /**
         * Report time.
         * @member {number} time
         * @memberof RemoteFortressReader.Report
         * @instance
         */
        Report.prototype.time = 0;

        /**
         * Creates a new Report instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.IReport=} [properties] Properties to set
         * @returns {RemoteFortressReader.Report} Report instance
         */
        Report.create = function create(properties) {
            return new Report(properties);
        };

        /**
         * Encodes the specified Report message. Does not implicitly {@link RemoteFortressReader.Report.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.IReport} message Report message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Report.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                $root.RemoteFortressReader.ColorDefinition.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.duration);
            if (message.continuation != null && Object.hasOwnProperty.call(message, "continuation"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.continuation);
            if (message.unconscious != null && Object.hasOwnProperty.call(message, "unconscious"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.unconscious);
            if (message.announcement != null && Object.hasOwnProperty.call(message, "announcement"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.announcement);
            if (message.repeatCount != null && Object.hasOwnProperty.call(message, "repeatCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.repeatCount);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.id);
            if (message.year != null && Object.hasOwnProperty.call(message, "year"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.year);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.time);
            return writer;
        };

        /**
         * Encodes the specified Report message, length delimited. Does not implicitly {@link RemoteFortressReader.Report.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.IReport} message Report message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Report.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Report message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Report} Report
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Report.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Report();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.color = $root.RemoteFortressReader.ColorDefinition.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.duration = reader.int32();
                    break;
                case 5:
                    message.continuation = reader.bool();
                    break;
                case 6:
                    message.unconscious = reader.bool();
                    break;
                case 7:
                    message.announcement = reader.bool();
                    break;
                case 8:
                    message.repeatCount = reader.int32();
                    break;
                case 9:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.id = reader.int32();
                    break;
                case 11:
                    message.year = reader.int32();
                    break;
                case 12:
                    message.time = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Report message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Report} Report
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Report.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Report message.
         * @function verify
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Report.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.RemoteFortressReader.ColorDefinition.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.continuation != null && message.hasOwnProperty("continuation"))
                if (typeof message.continuation !== "boolean")
                    return "continuation: boolean expected";
            if (message.unconscious != null && message.hasOwnProperty("unconscious"))
                if (typeof message.unconscious !== "boolean")
                    return "unconscious: boolean expected";
            if (message.announcement != null && message.hasOwnProperty("announcement"))
                if (typeof message.announcement !== "boolean")
                    return "announcement: boolean expected";
            if (message.repeatCount != null && message.hasOwnProperty("repeatCount"))
                if (!$util.isInteger(message.repeatCount))
                    return "repeatCount: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.year != null && message.hasOwnProperty("year"))
                if (!$util.isInteger(message.year))
                    return "year: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            return null;
        };

        /**
         * Creates a Report message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Report} Report
         */
        Report.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Report)
                return object;
            var message = new $root.RemoteFortressReader.Report();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".RemoteFortressReader.Report.color: object expected");
                message.color = $root.RemoteFortressReader.ColorDefinition.fromObject(object.color);
            }
            if (object.duration != null)
                message.duration = object.duration | 0;
            if (object.continuation != null)
                message.continuation = Boolean(object.continuation);
            if (object.unconscious != null)
                message.unconscious = Boolean(object.unconscious);
            if (object.announcement != null)
                message.announcement = Boolean(object.announcement);
            if (object.repeatCount != null)
                message.repeatCount = object.repeatCount | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Report.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.id != null)
                message.id = object.id | 0;
            if (object.year != null)
                message.year = object.year | 0;
            if (object.time != null)
                message.time = object.time | 0;
            return message;
        };

        /**
         * Creates a plain object from a Report message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Report
         * @static
         * @param {RemoteFortressReader.Report} message Report
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Report.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.text = "";
                object.color = null;
                object.duration = 0;
                object.continuation = false;
                object.unconscious = false;
                object.announcement = false;
                object.repeatCount = 0;
                object.pos = null;
                object.id = 0;
                object.year = 0;
                object.time = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.RemoteFortressReader.ColorDefinition.toObject(message.color, options);
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.continuation != null && message.hasOwnProperty("continuation"))
                object.continuation = message.continuation;
            if (message.unconscious != null && message.hasOwnProperty("unconscious"))
                object.unconscious = message.unconscious;
            if (message.announcement != null && message.hasOwnProperty("announcement"))
                object.announcement = message.announcement;
            if (message.repeatCount != null && message.hasOwnProperty("repeatCount"))
                object.repeatCount = message.repeatCount;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.year != null && message.hasOwnProperty("year"))
                object.year = message.year;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            return object;
        };

        /**
         * Converts this Report to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Report
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Report.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Report;
    })();

    RemoteFortressReader.Status = (function() {

        /**
         * Properties of a Status.
         * @memberof RemoteFortressReader
         * @interface IStatus
         * @property {Array.<RemoteFortressReader.IReport>|null} [reports] Status reports
         */

        /**
         * Constructs a new Status.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Status.
         * @implements IStatus
         * @constructor
         * @param {RemoteFortressReader.IStatus=} [properties] Properties to set
         */
        function Status(properties) {
            this.reports = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Status reports.
         * @member {Array.<RemoteFortressReader.IReport>} reports
         * @memberof RemoteFortressReader.Status
         * @instance
         */
        Status.prototype.reports = $util.emptyArray;

        /**
         * Creates a new Status instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.IStatus=} [properties] Properties to set
         * @returns {RemoteFortressReader.Status} Status instance
         */
        Status.create = function create(properties) {
            return new Status(properties);
        };

        /**
         * Encodes the specified Status message. Does not implicitly {@link RemoteFortressReader.Status.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reports != null && message.reports.length)
                for (var i = 0; i < message.reports.length; ++i)
                    $root.RemoteFortressReader.Report.encode(message.reports[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Status message, length delimited. Does not implicitly {@link RemoteFortressReader.Status.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Status message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Status();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.reports && message.reports.length))
                        message.reports = [];
                    message.reports.push($root.RemoteFortressReader.Report.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Status message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Status message.
         * @function verify
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Status.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reports != null && message.hasOwnProperty("reports")) {
                if (!Array.isArray(message.reports))
                    return "reports: array expected";
                for (var i = 0; i < message.reports.length; ++i) {
                    var error = $root.RemoteFortressReader.Report.verify(message.reports[i]);
                    if (error)
                        return "reports." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Status message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Status} Status
         */
        Status.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Status)
                return object;
            var message = new $root.RemoteFortressReader.Status();
            if (object.reports) {
                if (!Array.isArray(object.reports))
                    throw TypeError(".RemoteFortressReader.Status.reports: array expected");
                message.reports = [];
                for (var i = 0; i < object.reports.length; ++i) {
                    if (typeof object.reports[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Status.reports: object expected");
                    message.reports[i] = $root.RemoteFortressReader.Report.fromObject(object.reports[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Status message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Status
         * @static
         * @param {RemoteFortressReader.Status} message Status
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Status.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reports = [];
            if (message.reports && message.reports.length) {
                object.reports = [];
                for (var j = 0; j < message.reports.length; ++j)
                    object.reports[j] = $root.RemoteFortressReader.Report.toObject(message.reports[j], options);
            }
            return object;
        };

        /**
         * Converts this Status to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Status
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Status.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Status;
    })();

    RemoteFortressReader.ShapeDescriptior = (function() {

        /**
         * Properties of a ShapeDescriptior.
         * @memberof RemoteFortressReader
         * @interface IShapeDescriptior
         * @property {string|null} [id] ShapeDescriptior id
         * @property {number|null} [tile] ShapeDescriptior tile
         */

        /**
         * Constructs a new ShapeDescriptior.
         * @memberof RemoteFortressReader
         * @classdesc Represents a ShapeDescriptior.
         * @implements IShapeDescriptior
         * @constructor
         * @param {RemoteFortressReader.IShapeDescriptior=} [properties] Properties to set
         */
        function ShapeDescriptior(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShapeDescriptior id.
         * @member {string} id
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @instance
         */
        ShapeDescriptior.prototype.id = "";

        /**
         * ShapeDescriptior tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @instance
         */
        ShapeDescriptior.prototype.tile = 0;

        /**
         * Creates a new ShapeDescriptior instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.IShapeDescriptior=} [properties] Properties to set
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior instance
         */
        ShapeDescriptior.create = function create(properties) {
            return new ShapeDescriptior(properties);
        };

        /**
         * Encodes the specified ShapeDescriptior message. Does not implicitly {@link RemoteFortressReader.ShapeDescriptior.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.IShapeDescriptior} message ShapeDescriptior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShapeDescriptior.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.tile != null && Object.hasOwnProperty.call(message, "tile"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tile);
            return writer;
        };

        /**
         * Encodes the specified ShapeDescriptior message, length delimited. Does not implicitly {@link RemoteFortressReader.ShapeDescriptior.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.IShapeDescriptior} message ShapeDescriptior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShapeDescriptior.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShapeDescriptior message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShapeDescriptior.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ShapeDescriptior();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.tile = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShapeDescriptior message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShapeDescriptior.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShapeDescriptior message.
         * @function verify
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShapeDescriptior.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            return null;
        };

        /**
         * Creates a ShapeDescriptior message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ShapeDescriptior} ShapeDescriptior
         */
        ShapeDescriptior.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ShapeDescriptior)
                return object;
            var message = new $root.RemoteFortressReader.ShapeDescriptior();
            if (object.id != null)
                message.id = String(object.id);
            if (object.tile != null)
                message.tile = object.tile | 0;
            return message;
        };

        /**
         * Creates a plain object from a ShapeDescriptior message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @static
         * @param {RemoteFortressReader.ShapeDescriptior} message ShapeDescriptior
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShapeDescriptior.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.tile = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            return object;
        };

        /**
         * Converts this ShapeDescriptior to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ShapeDescriptior
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShapeDescriptior.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShapeDescriptior;
    })();

    RemoteFortressReader.Language = (function() {

        /**
         * Properties of a Language.
         * @memberof RemoteFortressReader
         * @interface ILanguage
         * @property {Array.<RemoteFortressReader.IShapeDescriptior>|null} [shapes] Language shapes
         */

        /**
         * Constructs a new Language.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Language.
         * @implements ILanguage
         * @constructor
         * @param {RemoteFortressReader.ILanguage=} [properties] Properties to set
         */
        function Language(properties) {
            this.shapes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Language shapes.
         * @member {Array.<RemoteFortressReader.IShapeDescriptior>} shapes
         * @memberof RemoteFortressReader.Language
         * @instance
         */
        Language.prototype.shapes = $util.emptyArray;

        /**
         * Creates a new Language instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.ILanguage=} [properties] Properties to set
         * @returns {RemoteFortressReader.Language} Language instance
         */
        Language.create = function create(properties) {
            return new Language(properties);
        };

        /**
         * Encodes the specified Language message. Does not implicitly {@link RemoteFortressReader.Language.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.ILanguage} message Language message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Language.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shapes != null && message.shapes.length)
                for (var i = 0; i < message.shapes.length; ++i)
                    $root.RemoteFortressReader.ShapeDescriptior.encode(message.shapes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Language message, length delimited. Does not implicitly {@link RemoteFortressReader.Language.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.ILanguage} message Language message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Language.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Language message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Language} Language
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Language.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Language();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.shapes && message.shapes.length))
                        message.shapes = [];
                    message.shapes.push($root.RemoteFortressReader.ShapeDescriptior.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Language message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Language} Language
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Language.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Language message.
         * @function verify
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Language.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shapes != null && message.hasOwnProperty("shapes")) {
                if (!Array.isArray(message.shapes))
                    return "shapes: array expected";
                for (var i = 0; i < message.shapes.length; ++i) {
                    var error = $root.RemoteFortressReader.ShapeDescriptior.verify(message.shapes[i]);
                    if (error)
                        return "shapes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Language message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Language} Language
         */
        Language.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Language)
                return object;
            var message = new $root.RemoteFortressReader.Language();
            if (object.shapes) {
                if (!Array.isArray(object.shapes))
                    throw TypeError(".RemoteFortressReader.Language.shapes: array expected");
                message.shapes = [];
                for (var i = 0; i < object.shapes.length; ++i) {
                    if (typeof object.shapes[i] !== "object")
                        throw TypeError(".RemoteFortressReader.Language.shapes: object expected");
                    message.shapes[i] = $root.RemoteFortressReader.ShapeDescriptior.fromObject(object.shapes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Language message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Language
         * @static
         * @param {RemoteFortressReader.Language} message Language
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Language.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shapes = [];
            if (message.shapes && message.shapes.length) {
                object.shapes = [];
                for (var j = 0; j < message.shapes.length; ++j)
                    object.shapes[j] = $root.RemoteFortressReader.ShapeDescriptior.toObject(message.shapes[j], options);
            }
            return object;
        };

        /**
         * Converts this Language to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Language
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Language.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Language;
    })();

    /**
     * ImprovementType enum.
     * @name RemoteFortressReader.ImprovementType
     * @enum {string}
     * @property {number} ART_IMAGE=0 ART_IMAGE value
     * @property {number} COVERED=1 COVERED value
     * @property {number} RINGS_HANGING=2 RINGS_HANGING value
     * @property {number} BANDS=3 BANDS value
     * @property {number} SPIKES=4 SPIKES value
     * @property {number} ITEMSPECIFIC=5 ITEMSPECIFIC value
     * @property {number} THREAD=6 THREAD value
     * @property {number} CLOTH=7 CLOTH value
     * @property {number} SEWN_IMAGE=8 SEWN_IMAGE value
     * @property {number} PAGES=9 PAGES value
     * @property {number} ILLUSTRATION=10 ILLUSTRATION value
     * @property {number} INSTRUMENT_PIECE=11 INSTRUMENT_PIECE value
     * @property {number} WRITING=12 WRITING value
     */
    RemoteFortressReader.ImprovementType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ART_IMAGE"] = 0;
        values[valuesById[1] = "COVERED"] = 1;
        values[valuesById[2] = "RINGS_HANGING"] = 2;
        values[valuesById[3] = "BANDS"] = 3;
        values[valuesById[4] = "SPIKES"] = 4;
        values[valuesById[5] = "ITEMSPECIFIC"] = 5;
        values[valuesById[6] = "THREAD"] = 6;
        values[valuesById[7] = "CLOTH"] = 7;
        values[valuesById[8] = "SEWN_IMAGE"] = 8;
        values[valuesById[9] = "PAGES"] = 9;
        values[valuesById[10] = "ILLUSTRATION"] = 10;
        values[valuesById[11] = "INSTRUMENT_PIECE"] = 11;
        values[valuesById[12] = "WRITING"] = 12;
        return values;
    })();

    RemoteFortressReader.ItemImprovement = (function() {

        /**
         * Properties of an ItemImprovement.
         * @memberof RemoteFortressReader
         * @interface IItemImprovement
         * @property {RemoteFortressReader.IMatPair|null} [material] ItemImprovement material
         * @property {RemoteFortressReader.ImprovementType|null} [type] ItemImprovement type
         * @property {number|null} [shape] ItemImprovement shape
         * @property {number|null} [specificType] ItemImprovement specificType
         * @property {RemoteFortressReader.IArtImage|null} [image] ItemImprovement image
         */

        /**
         * Constructs a new ItemImprovement.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ItemImprovement.
         * @implements IItemImprovement
         * @constructor
         * @param {RemoteFortressReader.IItemImprovement=} [properties] Properties to set
         */
        function ItemImprovement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemImprovement material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.material = null;

        /**
         * ItemImprovement type.
         * @member {RemoteFortressReader.ImprovementType} type
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.type = 0;

        /**
         * ItemImprovement shape.
         * @member {number} shape
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.shape = 0;

        /**
         * ItemImprovement specificType.
         * @member {number} specificType
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.specificType = 0;

        /**
         * ItemImprovement image.
         * @member {RemoteFortressReader.IArtImage|null|undefined} image
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         */
        ItemImprovement.prototype.image = null;

        /**
         * Creates a new ItemImprovement instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.IItemImprovement=} [properties] Properties to set
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement instance
         */
        ItemImprovement.create = function create(properties) {
            return new ItemImprovement(properties);
        };

        /**
         * Encodes the specified ItemImprovement message. Does not implicitly {@link RemoteFortressReader.ItemImprovement.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.IItemImprovement} message ItemImprovement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemImprovement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.shape);
            if (message.specificType != null && Object.hasOwnProperty.call(message, "specificType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.specificType);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                $root.RemoteFortressReader.ArtImage.encode(message.image, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ItemImprovement message, length delimited. Does not implicitly {@link RemoteFortressReader.ItemImprovement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.IItemImprovement} message ItemImprovement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemImprovement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemImprovement message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemImprovement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ItemImprovement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.shape = reader.int32();
                    break;
                case 4:
                    message.specificType = reader.int32();
                    break;
                case 5:
                    message.image = $root.RemoteFortressReader.ArtImage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemImprovement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemImprovement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemImprovement message.
         * @function verify
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemImprovement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.shape != null && message.hasOwnProperty("shape"))
                if (!$util.isInteger(message.shape))
                    return "shape: integer expected";
            if (message.specificType != null && message.hasOwnProperty("specificType"))
                if (!$util.isInteger(message.specificType))
                    return "specificType: integer expected";
            if (message.image != null && message.hasOwnProperty("image")) {
                var error = $root.RemoteFortressReader.ArtImage.verify(message.image);
                if (error)
                    return "image." + error;
            }
            return null;
        };

        /**
         * Creates an ItemImprovement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ItemImprovement} ItemImprovement
         */
        ItemImprovement.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ItemImprovement)
                return object;
            var message = new $root.RemoteFortressReader.ItemImprovement();
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.ItemImprovement.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            switch (object.type) {
            case "ART_IMAGE":
            case 0:
                message.type = 0;
                break;
            case "COVERED":
            case 1:
                message.type = 1;
                break;
            case "RINGS_HANGING":
            case 2:
                message.type = 2;
                break;
            case "BANDS":
            case 3:
                message.type = 3;
                break;
            case "SPIKES":
            case 4:
                message.type = 4;
                break;
            case "ITEMSPECIFIC":
            case 5:
                message.type = 5;
                break;
            case "THREAD":
            case 6:
                message.type = 6;
                break;
            case "CLOTH":
            case 7:
                message.type = 7;
                break;
            case "SEWN_IMAGE":
            case 8:
                message.type = 8;
                break;
            case "PAGES":
            case 9:
                message.type = 9;
                break;
            case "ILLUSTRATION":
            case 10:
                message.type = 10;
                break;
            case "INSTRUMENT_PIECE":
            case 11:
                message.type = 11;
                break;
            case "WRITING":
            case 12:
                message.type = 12;
                break;
            }
            if (object.shape != null)
                message.shape = object.shape | 0;
            if (object.specificType != null)
                message.specificType = object.specificType | 0;
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".RemoteFortressReader.ItemImprovement.image: object expected");
                message.image = $root.RemoteFortressReader.ArtImage.fromObject(object.image);
            }
            return message;
        };

        /**
         * Creates a plain object from an ItemImprovement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ItemImprovement
         * @static
         * @param {RemoteFortressReader.ItemImprovement} message ItemImprovement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemImprovement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.material = null;
                object.type = options.enums === String ? "ART_IMAGE" : 0;
                object.shape = 0;
                object.specificType = 0;
                object.image = null;
            }
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.ImprovementType[message.type] : message.type;
            if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = message.shape;
            if (message.specificType != null && message.hasOwnProperty("specificType"))
                object.specificType = message.specificType;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.RemoteFortressReader.ArtImage.toObject(message.image, options);
            return object;
        };

        /**
         * Converts this ItemImprovement to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ItemImprovement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemImprovement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemImprovement;
    })();

    /**
     * ArtImageElementType enum.
     * @name RemoteFortressReader.ArtImageElementType
     * @enum {string}
     * @property {number} IMAGE_CREATURE=0 IMAGE_CREATURE value
     * @property {number} IMAGE_PLANT=1 IMAGE_PLANT value
     * @property {number} IMAGE_TREE=2 IMAGE_TREE value
     * @property {number} IMAGE_SHAPE=3 IMAGE_SHAPE value
     * @property {number} IMAGE_ITEM=4 IMAGE_ITEM value
     */
    RemoteFortressReader.ArtImageElementType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IMAGE_CREATURE"] = 0;
        values[valuesById[1] = "IMAGE_PLANT"] = 1;
        values[valuesById[2] = "IMAGE_TREE"] = 2;
        values[valuesById[3] = "IMAGE_SHAPE"] = 3;
        values[valuesById[4] = "IMAGE_ITEM"] = 4;
        return values;
    })();

    RemoteFortressReader.ArtImageElement = (function() {

        /**
         * Properties of an ArtImageElement.
         * @memberof RemoteFortressReader
         * @interface IArtImageElement
         * @property {number|null} [count] ArtImageElement count
         * @property {RemoteFortressReader.ArtImageElementType|null} [type] ArtImageElement type
         * @property {RemoteFortressReader.IMatPair|null} [creatureItem] ArtImageElement creatureItem
         * @property {RemoteFortressReader.IMatPair|null} [material] ArtImageElement material
         * @property {number|null} [id] ArtImageElement id
         */

        /**
         * Constructs a new ArtImageElement.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArtImageElement.
         * @implements IArtImageElement
         * @constructor
         * @param {RemoteFortressReader.IArtImageElement=} [properties] Properties to set
         */
        function ArtImageElement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtImageElement count.
         * @member {number} count
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.count = 0;

        /**
         * ArtImageElement type.
         * @member {RemoteFortressReader.ArtImageElementType} type
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.type = 0;

        /**
         * ArtImageElement creatureItem.
         * @member {RemoteFortressReader.IMatPair|null|undefined} creatureItem
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.creatureItem = null;

        /**
         * ArtImageElement material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.material = null;

        /**
         * ArtImageElement id.
         * @member {number} id
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         */
        ArtImageElement.prototype.id = 0;

        /**
         * Creates a new ArtImageElement instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.IArtImageElement=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement instance
         */
        ArtImageElement.create = function create(properties) {
            return new ArtImageElement(properties);
        };

        /**
         * Encodes the specified ArtImageElement message. Does not implicitly {@link RemoteFortressReader.ArtImageElement.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.IArtImageElement} message ArtImageElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.creatureItem != null && Object.hasOwnProperty.call(message, "creatureItem"))
                $root.RemoteFortressReader.MatPair.encode(message.creatureItem, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified ArtImageElement message, length delimited. Does not implicitly {@link RemoteFortressReader.ArtImageElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.IArtImageElement} message ArtImageElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtImageElement message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArtImageElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.creatureItem = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtImageElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtImageElement message.
         * @function verify
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtImageElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.creatureItem != null && message.hasOwnProperty("creatureItem")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.creatureItem);
                if (error)
                    return "creatureItem." + error;
            }
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates an ArtImageElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArtImageElement} ArtImageElement
         */
        ArtImageElement.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArtImageElement)
                return object;
            var message = new $root.RemoteFortressReader.ArtImageElement();
            if (object.count != null)
                message.count = object.count | 0;
            switch (object.type) {
            case "IMAGE_CREATURE":
            case 0:
                message.type = 0;
                break;
            case "IMAGE_PLANT":
            case 1:
                message.type = 1;
                break;
            case "IMAGE_TREE":
            case 2:
                message.type = 2;
                break;
            case "IMAGE_SHAPE":
            case 3:
                message.type = 3;
                break;
            case "IMAGE_ITEM":
            case 4:
                message.type = 4;
                break;
            }
            if (object.creatureItem != null) {
                if (typeof object.creatureItem !== "object")
                    throw TypeError(".RemoteFortressReader.ArtImageElement.creatureItem: object expected");
                message.creatureItem = $root.RemoteFortressReader.MatPair.fromObject(object.creatureItem);
            }
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.ArtImageElement.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from an ArtImageElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArtImageElement
         * @static
         * @param {RemoteFortressReader.ArtImageElement} message ArtImageElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtImageElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.count = 0;
                object.type = options.enums === String ? "IMAGE_CREATURE" : 0;
                object.creatureItem = null;
                object.material = null;
                object.id = 0;
            }
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.ArtImageElementType[message.type] : message.type;
            if (message.creatureItem != null && message.hasOwnProperty("creatureItem"))
                object.creatureItem = $root.RemoteFortressReader.MatPair.toObject(message.creatureItem, options);
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ArtImageElement to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArtImageElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtImageElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtImageElement;
    })();

    /**
     * ArtImagePropertyType enum.
     * @name RemoteFortressReader.ArtImagePropertyType
     * @enum {string}
     * @property {number} TRANSITIVE_VERB=0 TRANSITIVE_VERB value
     * @property {number} INTRANSITIVE_VERB=1 INTRANSITIVE_VERB value
     */
    RemoteFortressReader.ArtImagePropertyType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TRANSITIVE_VERB"] = 0;
        values[valuesById[1] = "INTRANSITIVE_VERB"] = 1;
        return values;
    })();

    RemoteFortressReader.ArtImageProperty = (function() {

        /**
         * Properties of an ArtImageProperty.
         * @memberof RemoteFortressReader
         * @interface IArtImageProperty
         * @property {number|null} [subject] ArtImageProperty subject
         * @property {number|null} [object] ArtImageProperty object
         * @property {RemoteFortressReader.ArtImageVerb|null} [verb] ArtImageProperty verb
         * @property {RemoteFortressReader.ArtImagePropertyType|null} [type] ArtImageProperty type
         */

        /**
         * Constructs a new ArtImageProperty.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArtImageProperty.
         * @implements IArtImageProperty
         * @constructor
         * @param {RemoteFortressReader.IArtImageProperty=} [properties] Properties to set
         */
        function ArtImageProperty(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtImageProperty subject.
         * @member {number} subject
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.subject = 0;

        /**
         * ArtImageProperty object.
         * @member {number} object
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.object = 0;

        /**
         * ArtImageProperty verb.
         * @member {RemoteFortressReader.ArtImageVerb} verb
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.verb = 0;

        /**
         * ArtImageProperty type.
         * @member {RemoteFortressReader.ArtImagePropertyType} type
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         */
        ArtImageProperty.prototype.type = 0;

        /**
         * Creates a new ArtImageProperty instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.IArtImageProperty=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty instance
         */
        ArtImageProperty.create = function create(properties) {
            return new ArtImageProperty(properties);
        };

        /**
         * Encodes the specified ArtImageProperty message. Does not implicitly {@link RemoteFortressReader.ArtImageProperty.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.IArtImageProperty} message ArtImageProperty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageProperty.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subject);
            if (message.object != null && Object.hasOwnProperty.call(message, "object"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.object);
            if (message.verb != null && Object.hasOwnProperty.call(message, "verb"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.verb);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ArtImageProperty message, length delimited. Does not implicitly {@link RemoteFortressReader.ArtImageProperty.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.IArtImageProperty} message ArtImageProperty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImageProperty.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtImageProperty message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageProperty.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArtImageProperty();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subject = reader.int32();
                    break;
                case 2:
                    message.object = reader.int32();
                    break;
                case 3:
                    message.verb = reader.int32();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtImageProperty message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImageProperty.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtImageProperty message.
         * @function verify
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtImageProperty.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subject != null && message.hasOwnProperty("subject"))
                if (!$util.isInteger(message.subject))
                    return "subject: integer expected";
            if (message.object != null && message.hasOwnProperty("object"))
                if (!$util.isInteger(message.object))
                    return "object: integer expected";
            if (message.verb != null && message.hasOwnProperty("verb"))
                switch (message.verb) {
                default:
                    return "verb: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                    break;
                }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an ArtImageProperty message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArtImageProperty} ArtImageProperty
         */
        ArtImageProperty.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArtImageProperty)
                return object;
            var message = new $root.RemoteFortressReader.ArtImageProperty();
            if (object.subject != null)
                message.subject = object.subject | 0;
            if (object.object != null)
                message.object = object.object | 0;
            switch (object.verb) {
            case "VERB_WITHERING":
            case 0:
                message.verb = 0;
                break;
            case "VERB_SURROUNDEDBY":
            case 1:
                message.verb = 1;
                break;
            case "VERB_MASSACRING":
            case 2:
                message.verb = 2;
                break;
            case "VERB_FIGHTING":
            case 3:
                message.verb = 3;
                break;
            case "VERB_LABORING":
            case 4:
                message.verb = 4;
                break;
            case "VERB_GREETING":
            case 5:
                message.verb = 5;
                break;
            case "VERB_REFUSING":
            case 6:
                message.verb = 6;
                break;
            case "VERB_SPEAKING":
            case 7:
                message.verb = 7;
                break;
            case "VERB_EMBRACING":
            case 8:
                message.verb = 8;
                break;
            case "VERB_STRIKINGDOWN":
            case 9:
                message.verb = 9;
                break;
            case "VERB_MENACINGPOSE":
            case 10:
                message.verb = 10;
                break;
            case "VERB_TRAVELING":
            case 11:
                message.verb = 11;
                break;
            case "VERB_RAISING":
            case 12:
                message.verb = 12;
                break;
            case "VERB_HIDING":
            case 13:
                message.verb = 13;
                break;
            case "VERB_LOOKINGCONFUSED":
            case 14:
                message.verb = 14;
                break;
            case "VERB_LOOKINGTERRIFIED":
            case 15:
                message.verb = 15;
                break;
            case "VERB_DEVOURING":
            case 16:
                message.verb = 16;
                break;
            case "VERB_ADMIRING":
            case 17:
                message.verb = 17;
                break;
            case "VERB_BURNING":
            case 18:
                message.verb = 18;
                break;
            case "VERB_WEEPING":
            case 19:
                message.verb = 19;
                break;
            case "VERB_LOOKINGDEJECTED":
            case 20:
                message.verb = 20;
                break;
            case "VERB_CRINGING":
            case 21:
                message.verb = 21;
                break;
            case "VERB_SCREAMING":
            case 22:
                message.verb = 22;
                break;
            case "VERB_SUBMISSIVEGESTURE":
            case 23:
                message.verb = 23;
                break;
            case "VERB_FETALPOSITION":
            case 24:
                message.verb = 24;
                break;
            case "VERB_SMEAREDINTOSPIRAL":
            case 25:
                message.verb = 25;
                break;
            case "VERB_FALLING":
            case 26:
                message.verb = 26;
                break;
            case "VERB_DEAD":
            case 27:
                message.verb = 27;
                break;
            case "VERB_LAUGHING":
            case 28:
                message.verb = 28;
                break;
            case "VERB_LOOKINGOFFENDED":
            case 29:
                message.verb = 29;
                break;
            case "VERB_BEINGSHOT":
            case 30:
                message.verb = 30;
                break;
            case "VERB_PLAINTIVEGESTURE":
            case 31:
                message.verb = 31;
                break;
            case "VERB_MELTING":
            case 32:
                message.verb = 32;
                break;
            case "VERB_SHOOTING":
            case 33:
                message.verb = 33;
                break;
            case "VERB_TORTURING":
            case 34:
                message.verb = 34;
                break;
            case "VERB_COMMITTINGDEPRAVEDACT":
            case 35:
                message.verb = 35;
                break;
            case "VERB_PRAYING":
            case 36:
                message.verb = 36;
                break;
            case "VERB_CONTEMPLATING":
            case 37:
                message.verb = 37;
                break;
            case "VERB_COOKING":
            case 38:
                message.verb = 38;
                break;
            case "VERB_ENGRAVING":
            case 39:
                message.verb = 39;
                break;
            case "VERB_PROSTRATING":
            case 40:
                message.verb = 40;
                break;
            case "VERB_SUFFERING":
            case 41:
                message.verb = 41;
                break;
            case "VERB_BEINGIMPALED":
            case 42:
                message.verb = 42;
                break;
            case "VERB_BEINGCONTORTED":
            case 43:
                message.verb = 43;
                break;
            case "VERB_BEINGFLAYED":
            case 44:
                message.verb = 44;
                break;
            case "VERB_HANGINGFROM":
            case 45:
                message.verb = 45;
                break;
            case "VERB_BEINGMUTILATED":
            case 46:
                message.verb = 46;
                break;
            case "VERB_TRIUMPHANTPOSE":
            case 47:
                message.verb = 47;
                break;
            }
            switch (object.type) {
            case "TRANSITIVE_VERB":
            case 0:
                message.type = 0;
                break;
            case "INTRANSITIVE_VERB":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtImageProperty message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArtImageProperty
         * @static
         * @param {RemoteFortressReader.ArtImageProperty} message ArtImageProperty
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtImageProperty.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.subject = 0;
                object.object = 0;
                object.verb = options.enums === String ? "VERB_WITHERING" : 0;
                object.type = options.enums === String ? "TRANSITIVE_VERB" : 0;
            }
            if (message.subject != null && message.hasOwnProperty("subject"))
                object.subject = message.subject;
            if (message.object != null && message.hasOwnProperty("object"))
                object.object = message.object;
            if (message.verb != null && message.hasOwnProperty("verb"))
                object.verb = options.enums === String ? $root.RemoteFortressReader.ArtImageVerb[message.verb] : message.verb;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.ArtImagePropertyType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ArtImageProperty to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArtImageProperty
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtImageProperty.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtImageProperty;
    })();

    RemoteFortressReader.ArtImage = (function() {

        /**
         * Properties of an ArtImage.
         * @memberof RemoteFortressReader
         * @interface IArtImage
         * @property {Array.<RemoteFortressReader.IArtImageElement>|null} [elements] ArtImage elements
         * @property {RemoteFortressReader.IMatPair|null} [id] ArtImage id
         * @property {Array.<RemoteFortressReader.IArtImageProperty>|null} [properties] ArtImage properties
         */

        /**
         * Constructs a new ArtImage.
         * @memberof RemoteFortressReader
         * @classdesc Represents an ArtImage.
         * @implements IArtImage
         * @constructor
         * @param {RemoteFortressReader.IArtImage=} [properties] Properties to set
         */
        function ArtImage(properties) {
            this.elements = [];
            this.properties = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArtImage elements.
         * @member {Array.<RemoteFortressReader.IArtImageElement>} elements
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         */
        ArtImage.prototype.elements = $util.emptyArray;

        /**
         * ArtImage id.
         * @member {RemoteFortressReader.IMatPair|null|undefined} id
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         */
        ArtImage.prototype.id = null;

        /**
         * ArtImage properties.
         * @member {Array.<RemoteFortressReader.IArtImageProperty>} properties
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         */
        ArtImage.prototype.properties = $util.emptyArray;

        /**
         * Creates a new ArtImage instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.IArtImage=} [properties] Properties to set
         * @returns {RemoteFortressReader.ArtImage} ArtImage instance
         */
        ArtImage.create = function create(properties) {
            return new ArtImage(properties);
        };

        /**
         * Encodes the specified ArtImage message. Does not implicitly {@link RemoteFortressReader.ArtImage.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.IArtImage} message ArtImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    $root.RemoteFortressReader.ArtImageElement.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.RemoteFortressReader.MatPair.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.properties != null && message.properties.length)
                for (var i = 0; i < message.properties.length; ++i)
                    $root.RemoteFortressReader.ArtImageProperty.encode(message.properties[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArtImage message, length delimited. Does not implicitly {@link RemoteFortressReader.ArtImage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.IArtImage} message ArtImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArtImage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArtImage message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.ArtImage} ArtImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.ArtImage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push($root.RemoteFortressReader.ArtImageElement.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.id = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.properties && message.properties.length))
                        message.properties = [];
                    message.properties.push($root.RemoteFortressReader.ArtImageProperty.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArtImage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.ArtImage} ArtImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArtImage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArtImage message.
         * @function verify
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArtImage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i) {
                    var error = $root.RemoteFortressReader.ArtImageElement.verify(message.elements[i]);
                    if (error)
                        return "elements." + error;
                }
            }
            if (message.id != null && message.hasOwnProperty("id")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.properties != null && message.hasOwnProperty("properties")) {
                if (!Array.isArray(message.properties))
                    return "properties: array expected";
                for (var i = 0; i < message.properties.length; ++i) {
                    var error = $root.RemoteFortressReader.ArtImageProperty.verify(message.properties[i]);
                    if (error)
                        return "properties." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArtImage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.ArtImage} ArtImage
         */
        ArtImage.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.ArtImage)
                return object;
            var message = new $root.RemoteFortressReader.ArtImage();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".RemoteFortressReader.ArtImage.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i) {
                    if (typeof object.elements[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ArtImage.elements: object expected");
                    message.elements[i] = $root.RemoteFortressReader.ArtImageElement.fromObject(object.elements[i]);
                }
            }
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".RemoteFortressReader.ArtImage.id: object expected");
                message.id = $root.RemoteFortressReader.MatPair.fromObject(object.id);
            }
            if (object.properties) {
                if (!Array.isArray(object.properties))
                    throw TypeError(".RemoteFortressReader.ArtImage.properties: array expected");
                message.properties = [];
                for (var i = 0; i < object.properties.length; ++i) {
                    if (typeof object.properties[i] !== "object")
                        throw TypeError(".RemoteFortressReader.ArtImage.properties: object expected");
                    message.properties[i] = $root.RemoteFortressReader.ArtImageProperty.fromObject(object.properties[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArtImage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.ArtImage
         * @static
         * @param {RemoteFortressReader.ArtImage} message ArtImage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArtImage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.elements = [];
                object.properties = [];
            }
            if (options.defaults)
                object.id = null;
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = $root.RemoteFortressReader.ArtImageElement.toObject(message.elements[j], options);
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.RemoteFortressReader.MatPair.toObject(message.id, options);
            if (message.properties && message.properties.length) {
                object.properties = [];
                for (var j = 0; j < message.properties.length; ++j)
                    object.properties[j] = $root.RemoteFortressReader.ArtImageProperty.toObject(message.properties[j], options);
            }
            return object;
        };

        /**
         * Converts this ArtImage to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.ArtImage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArtImage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArtImage;
    })();

    RemoteFortressReader.Engraving = (function() {

        /**
         * Properties of an Engraving.
         * @memberof RemoteFortressReader
         * @interface IEngraving
         * @property {RemoteFortressReader.ICoord|null} [pos] Engraving pos
         * @property {number|null} [quality] Engraving quality
         * @property {number|null} [tile] Engraving tile
         * @property {RemoteFortressReader.IArtImage|null} [image] Engraving image
         * @property {boolean|null} [floor] Engraving floor
         * @property {boolean|null} [west] Engraving west
         * @property {boolean|null} [east] Engraving east
         * @property {boolean|null} [north] Engraving north
         * @property {boolean|null} [south] Engraving south
         * @property {boolean|null} [hidden] Engraving hidden
         * @property {boolean|null} [northwest] Engraving northwest
         * @property {boolean|null} [northeast] Engraving northeast
         * @property {boolean|null} [southwest] Engraving southwest
         * @property {boolean|null} [southeast] Engraving southeast
         */

        /**
         * Constructs a new Engraving.
         * @memberof RemoteFortressReader
         * @classdesc Represents an Engraving.
         * @implements IEngraving
         * @constructor
         * @param {RemoteFortressReader.IEngraving=} [properties] Properties to set
         */
        function Engraving(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Engraving pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.pos = null;

        /**
         * Engraving quality.
         * @member {number} quality
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.quality = 0;

        /**
         * Engraving tile.
         * @member {number} tile
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.tile = 0;

        /**
         * Engraving image.
         * @member {RemoteFortressReader.IArtImage|null|undefined} image
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.image = null;

        /**
         * Engraving floor.
         * @member {boolean} floor
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.floor = false;

        /**
         * Engraving west.
         * @member {boolean} west
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.west = false;

        /**
         * Engraving east.
         * @member {boolean} east
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.east = false;

        /**
         * Engraving north.
         * @member {boolean} north
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.north = false;

        /**
         * Engraving south.
         * @member {boolean} south
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.south = false;

        /**
         * Engraving hidden.
         * @member {boolean} hidden
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.hidden = false;

        /**
         * Engraving northwest.
         * @member {boolean} northwest
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.northwest = false;

        /**
         * Engraving northeast.
         * @member {boolean} northeast
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.northeast = false;

        /**
         * Engraving southwest.
         * @member {boolean} southwest
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.southwest = false;

        /**
         * Engraving southeast.
         * @member {boolean} southeast
         * @memberof RemoteFortressReader.Engraving
         * @instance
         */
        Engraving.prototype.southeast = false;

        /**
         * Creates a new Engraving instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.IEngraving=} [properties] Properties to set
         * @returns {RemoteFortressReader.Engraving} Engraving instance
         */
        Engraving.create = function create(properties) {
            return new Engraving(properties);
        };

        /**
         * Encodes the specified Engraving message. Does not implicitly {@link RemoteFortressReader.Engraving.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.IEngraving} message Engraving message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Engraving.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.quality);
            if (message.tile != null && Object.hasOwnProperty.call(message, "tile"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tile);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                $root.RemoteFortressReader.ArtImage.encode(message.image, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.floor != null && Object.hasOwnProperty.call(message, "floor"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.floor);
            if (message.west != null && Object.hasOwnProperty.call(message, "west"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.west);
            if (message.east != null && Object.hasOwnProperty.call(message, "east"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.east);
            if (message.north != null && Object.hasOwnProperty.call(message, "north"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.north);
            if (message.south != null && Object.hasOwnProperty.call(message, "south"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.south);
            if (message.hidden != null && Object.hasOwnProperty.call(message, "hidden"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hidden);
            if (message.northwest != null && Object.hasOwnProperty.call(message, "northwest"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.northwest);
            if (message.northeast != null && Object.hasOwnProperty.call(message, "northeast"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.northeast);
            if (message.southwest != null && Object.hasOwnProperty.call(message, "southwest"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.southwest);
            if (message.southeast != null && Object.hasOwnProperty.call(message, "southeast"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.southeast);
            return writer;
        };

        /**
         * Encodes the specified Engraving message, length delimited. Does not implicitly {@link RemoteFortressReader.Engraving.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.IEngraving} message Engraving message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Engraving.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Engraving message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Engraving} Engraving
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Engraving.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Engraving();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.quality = reader.int32();
                    break;
                case 3:
                    message.tile = reader.int32();
                    break;
                case 4:
                    message.image = $root.RemoteFortressReader.ArtImage.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.floor = reader.bool();
                    break;
                case 6:
                    message.west = reader.bool();
                    break;
                case 7:
                    message.east = reader.bool();
                    break;
                case 8:
                    message.north = reader.bool();
                    break;
                case 9:
                    message.south = reader.bool();
                    break;
                case 10:
                    message.hidden = reader.bool();
                    break;
                case 11:
                    message.northwest = reader.bool();
                    break;
                case 12:
                    message.northeast = reader.bool();
                    break;
                case 13:
                    message.southwest = reader.bool();
                    break;
                case 14:
                    message.southeast = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Engraving message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Engraving} Engraving
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Engraving.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Engraving message.
         * @function verify
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Engraving.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.quality != null && message.hasOwnProperty("quality"))
                if (!$util.isInteger(message.quality))
                    return "quality: integer expected";
            if (message.tile != null && message.hasOwnProperty("tile"))
                if (!$util.isInteger(message.tile))
                    return "tile: integer expected";
            if (message.image != null && message.hasOwnProperty("image")) {
                var error = $root.RemoteFortressReader.ArtImage.verify(message.image);
                if (error)
                    return "image." + error;
            }
            if (message.floor != null && message.hasOwnProperty("floor"))
                if (typeof message.floor !== "boolean")
                    return "floor: boolean expected";
            if (message.west != null && message.hasOwnProperty("west"))
                if (typeof message.west !== "boolean")
                    return "west: boolean expected";
            if (message.east != null && message.hasOwnProperty("east"))
                if (typeof message.east !== "boolean")
                    return "east: boolean expected";
            if (message.north != null && message.hasOwnProperty("north"))
                if (typeof message.north !== "boolean")
                    return "north: boolean expected";
            if (message.south != null && message.hasOwnProperty("south"))
                if (typeof message.south !== "boolean")
                    return "south: boolean expected";
            if (message.hidden != null && message.hasOwnProperty("hidden"))
                if (typeof message.hidden !== "boolean")
                    return "hidden: boolean expected";
            if (message.northwest != null && message.hasOwnProperty("northwest"))
                if (typeof message.northwest !== "boolean")
                    return "northwest: boolean expected";
            if (message.northeast != null && message.hasOwnProperty("northeast"))
                if (typeof message.northeast !== "boolean")
                    return "northeast: boolean expected";
            if (message.southwest != null && message.hasOwnProperty("southwest"))
                if (typeof message.southwest !== "boolean")
                    return "southwest: boolean expected";
            if (message.southeast != null && message.hasOwnProperty("southeast"))
                if (typeof message.southeast !== "boolean")
                    return "southeast: boolean expected";
            return null;
        };

        /**
         * Creates an Engraving message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Engraving} Engraving
         */
        Engraving.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Engraving)
                return object;
            var message = new $root.RemoteFortressReader.Engraving();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Engraving.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.quality != null)
                message.quality = object.quality | 0;
            if (object.tile != null)
                message.tile = object.tile | 0;
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".RemoteFortressReader.Engraving.image: object expected");
                message.image = $root.RemoteFortressReader.ArtImage.fromObject(object.image);
            }
            if (object.floor != null)
                message.floor = Boolean(object.floor);
            if (object.west != null)
                message.west = Boolean(object.west);
            if (object.east != null)
                message.east = Boolean(object.east);
            if (object.north != null)
                message.north = Boolean(object.north);
            if (object.south != null)
                message.south = Boolean(object.south);
            if (object.hidden != null)
                message.hidden = Boolean(object.hidden);
            if (object.northwest != null)
                message.northwest = Boolean(object.northwest);
            if (object.northeast != null)
                message.northeast = Boolean(object.northeast);
            if (object.southwest != null)
                message.southwest = Boolean(object.southwest);
            if (object.southeast != null)
                message.southeast = Boolean(object.southeast);
            return message;
        };

        /**
         * Creates a plain object from an Engraving message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Engraving
         * @static
         * @param {RemoteFortressReader.Engraving} message Engraving
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Engraving.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.quality = 0;
                object.tile = 0;
                object.image = null;
                object.floor = false;
                object.west = false;
                object.east = false;
                object.north = false;
                object.south = false;
                object.hidden = false;
                object.northwest = false;
                object.northeast = false;
                object.southwest = false;
                object.southeast = false;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = message.quality;
            if (message.tile != null && message.hasOwnProperty("tile"))
                object.tile = message.tile;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.RemoteFortressReader.ArtImage.toObject(message.image, options);
            if (message.floor != null && message.hasOwnProperty("floor"))
                object.floor = message.floor;
            if (message.west != null && message.hasOwnProperty("west"))
                object.west = message.west;
            if (message.east != null && message.hasOwnProperty("east"))
                object.east = message.east;
            if (message.north != null && message.hasOwnProperty("north"))
                object.north = message.north;
            if (message.south != null && message.hasOwnProperty("south"))
                object.south = message.south;
            if (message.hidden != null && message.hasOwnProperty("hidden"))
                object.hidden = message.hidden;
            if (message.northwest != null && message.hasOwnProperty("northwest"))
                object.northwest = message.northwest;
            if (message.northeast != null && message.hasOwnProperty("northeast"))
                object.northeast = message.northeast;
            if (message.southwest != null && message.hasOwnProperty("southwest"))
                object.southwest = message.southwest;
            if (message.southeast != null && message.hasOwnProperty("southeast"))
                object.southeast = message.southeast;
            return object;
        };

        /**
         * Converts this Engraving to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Engraving
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Engraving.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Engraving;
    })();

    /**
     * ArtImageVerb enum.
     * @name RemoteFortressReader.ArtImageVerb
     * @enum {string}
     * @property {number} VERB_WITHERING=0 VERB_WITHERING value
     * @property {number} VERB_SURROUNDEDBY=1 VERB_SURROUNDEDBY value
     * @property {number} VERB_MASSACRING=2 VERB_MASSACRING value
     * @property {number} VERB_FIGHTING=3 VERB_FIGHTING value
     * @property {number} VERB_LABORING=4 VERB_LABORING value
     * @property {number} VERB_GREETING=5 VERB_GREETING value
     * @property {number} VERB_REFUSING=6 VERB_REFUSING value
     * @property {number} VERB_SPEAKING=7 VERB_SPEAKING value
     * @property {number} VERB_EMBRACING=8 VERB_EMBRACING value
     * @property {number} VERB_STRIKINGDOWN=9 VERB_STRIKINGDOWN value
     * @property {number} VERB_MENACINGPOSE=10 VERB_MENACINGPOSE value
     * @property {number} VERB_TRAVELING=11 VERB_TRAVELING value
     * @property {number} VERB_RAISING=12 VERB_RAISING value
     * @property {number} VERB_HIDING=13 VERB_HIDING value
     * @property {number} VERB_LOOKINGCONFUSED=14 VERB_LOOKINGCONFUSED value
     * @property {number} VERB_LOOKINGTERRIFIED=15 VERB_LOOKINGTERRIFIED value
     * @property {number} VERB_DEVOURING=16 VERB_DEVOURING value
     * @property {number} VERB_ADMIRING=17 VERB_ADMIRING value
     * @property {number} VERB_BURNING=18 VERB_BURNING value
     * @property {number} VERB_WEEPING=19 VERB_WEEPING value
     * @property {number} VERB_LOOKINGDEJECTED=20 VERB_LOOKINGDEJECTED value
     * @property {number} VERB_CRINGING=21 VERB_CRINGING value
     * @property {number} VERB_SCREAMING=22 VERB_SCREAMING value
     * @property {number} VERB_SUBMISSIVEGESTURE=23 VERB_SUBMISSIVEGESTURE value
     * @property {number} VERB_FETALPOSITION=24 VERB_FETALPOSITION value
     * @property {number} VERB_SMEAREDINTOSPIRAL=25 VERB_SMEAREDINTOSPIRAL value
     * @property {number} VERB_FALLING=26 VERB_FALLING value
     * @property {number} VERB_DEAD=27 VERB_DEAD value
     * @property {number} VERB_LAUGHING=28 VERB_LAUGHING value
     * @property {number} VERB_LOOKINGOFFENDED=29 VERB_LOOKINGOFFENDED value
     * @property {number} VERB_BEINGSHOT=30 VERB_BEINGSHOT value
     * @property {number} VERB_PLAINTIVEGESTURE=31 VERB_PLAINTIVEGESTURE value
     * @property {number} VERB_MELTING=32 VERB_MELTING value
     * @property {number} VERB_SHOOTING=33 VERB_SHOOTING value
     * @property {number} VERB_TORTURING=34 VERB_TORTURING value
     * @property {number} VERB_COMMITTINGDEPRAVEDACT=35 VERB_COMMITTINGDEPRAVEDACT value
     * @property {number} VERB_PRAYING=36 VERB_PRAYING value
     * @property {number} VERB_CONTEMPLATING=37 VERB_CONTEMPLATING value
     * @property {number} VERB_COOKING=38 VERB_COOKING value
     * @property {number} VERB_ENGRAVING=39 VERB_ENGRAVING value
     * @property {number} VERB_PROSTRATING=40 VERB_PROSTRATING value
     * @property {number} VERB_SUFFERING=41 VERB_SUFFERING value
     * @property {number} VERB_BEINGIMPALED=42 VERB_BEINGIMPALED value
     * @property {number} VERB_BEINGCONTORTED=43 VERB_BEINGCONTORTED value
     * @property {number} VERB_BEINGFLAYED=44 VERB_BEINGFLAYED value
     * @property {number} VERB_HANGINGFROM=45 VERB_HANGINGFROM value
     * @property {number} VERB_BEINGMUTILATED=46 VERB_BEINGMUTILATED value
     * @property {number} VERB_TRIUMPHANTPOSE=47 VERB_TRIUMPHANTPOSE value
     */
    RemoteFortressReader.ArtImageVerb = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VERB_WITHERING"] = 0;
        values[valuesById[1] = "VERB_SURROUNDEDBY"] = 1;
        values[valuesById[2] = "VERB_MASSACRING"] = 2;
        values[valuesById[3] = "VERB_FIGHTING"] = 3;
        values[valuesById[4] = "VERB_LABORING"] = 4;
        values[valuesById[5] = "VERB_GREETING"] = 5;
        values[valuesById[6] = "VERB_REFUSING"] = 6;
        values[valuesById[7] = "VERB_SPEAKING"] = 7;
        values[valuesById[8] = "VERB_EMBRACING"] = 8;
        values[valuesById[9] = "VERB_STRIKINGDOWN"] = 9;
        values[valuesById[10] = "VERB_MENACINGPOSE"] = 10;
        values[valuesById[11] = "VERB_TRAVELING"] = 11;
        values[valuesById[12] = "VERB_RAISING"] = 12;
        values[valuesById[13] = "VERB_HIDING"] = 13;
        values[valuesById[14] = "VERB_LOOKINGCONFUSED"] = 14;
        values[valuesById[15] = "VERB_LOOKINGTERRIFIED"] = 15;
        values[valuesById[16] = "VERB_DEVOURING"] = 16;
        values[valuesById[17] = "VERB_ADMIRING"] = 17;
        values[valuesById[18] = "VERB_BURNING"] = 18;
        values[valuesById[19] = "VERB_WEEPING"] = 19;
        values[valuesById[20] = "VERB_LOOKINGDEJECTED"] = 20;
        values[valuesById[21] = "VERB_CRINGING"] = 21;
        values[valuesById[22] = "VERB_SCREAMING"] = 22;
        values[valuesById[23] = "VERB_SUBMISSIVEGESTURE"] = 23;
        values[valuesById[24] = "VERB_FETALPOSITION"] = 24;
        values[valuesById[25] = "VERB_SMEAREDINTOSPIRAL"] = 25;
        values[valuesById[26] = "VERB_FALLING"] = 26;
        values[valuesById[27] = "VERB_DEAD"] = 27;
        values[valuesById[28] = "VERB_LAUGHING"] = 28;
        values[valuesById[29] = "VERB_LOOKINGOFFENDED"] = 29;
        values[valuesById[30] = "VERB_BEINGSHOT"] = 30;
        values[valuesById[31] = "VERB_PLAINTIVEGESTURE"] = 31;
        values[valuesById[32] = "VERB_MELTING"] = 32;
        values[valuesById[33] = "VERB_SHOOTING"] = 33;
        values[valuesById[34] = "VERB_TORTURING"] = 34;
        values[valuesById[35] = "VERB_COMMITTINGDEPRAVEDACT"] = 35;
        values[valuesById[36] = "VERB_PRAYING"] = 36;
        values[valuesById[37] = "VERB_CONTEMPLATING"] = 37;
        values[valuesById[38] = "VERB_COOKING"] = 38;
        values[valuesById[39] = "VERB_ENGRAVING"] = 39;
        values[valuesById[40] = "VERB_PROSTRATING"] = 40;
        values[valuesById[41] = "VERB_SUFFERING"] = 41;
        values[valuesById[42] = "VERB_BEINGIMPALED"] = 42;
        values[valuesById[43] = "VERB_BEINGCONTORTED"] = 43;
        values[valuesById[44] = "VERB_BEINGFLAYED"] = 44;
        values[valuesById[45] = "VERB_HANGINGFROM"] = 45;
        values[valuesById[46] = "VERB_BEINGMUTILATED"] = 46;
        values[valuesById[47] = "VERB_TRIUMPHANTPOSE"] = 47;
        return values;
    })();

    /**
     * FlowType enum.
     * @name RemoteFortressReader.FlowType
     * @enum {string}
     * @property {number} Miasma=0 Miasma value
     * @property {number} Steam=1 Steam value
     * @property {number} Mist=2 Mist value
     * @property {number} MaterialDust=3 MaterialDust value
     * @property {number} MagmaMist=4 MagmaMist value
     * @property {number} Smoke=5 Smoke value
     * @property {number} Dragonfire=6 Dragonfire value
     * @property {number} Fire=7 Fire value
     * @property {number} Web=8 Web value
     * @property {number} MaterialGas=9 MaterialGas value
     * @property {number} MaterialVapor=10 MaterialVapor value
     * @property {number} OceanWave=11 OceanWave value
     * @property {number} SeaFoam=12 SeaFoam value
     * @property {number} ItemCloud=13 ItemCloud value
     * @property {number} CampFire=-1 CampFire value
     */
    RemoteFortressReader.FlowType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Miasma"] = 0;
        values[valuesById[1] = "Steam"] = 1;
        values[valuesById[2] = "Mist"] = 2;
        values[valuesById[3] = "MaterialDust"] = 3;
        values[valuesById[4] = "MagmaMist"] = 4;
        values[valuesById[5] = "Smoke"] = 5;
        values[valuesById[6] = "Dragonfire"] = 6;
        values[valuesById[7] = "Fire"] = 7;
        values[valuesById[8] = "Web"] = 8;
        values[valuesById[9] = "MaterialGas"] = 9;
        values[valuesById[10] = "MaterialVapor"] = 10;
        values[valuesById[11] = "OceanWave"] = 11;
        values[valuesById[12] = "SeaFoam"] = 12;
        values[valuesById[13] = "ItemCloud"] = 13;
        values[valuesById[-1] = "CampFire"] = -1;
        return values;
    })();

    RemoteFortressReader.FlowInfo = (function() {

        /**
         * Properties of a FlowInfo.
         * @memberof RemoteFortressReader
         * @interface IFlowInfo
         * @property {number|null} [index] FlowInfo index
         * @property {RemoteFortressReader.FlowType|null} [type] FlowInfo type
         * @property {number|null} [density] FlowInfo density
         * @property {RemoteFortressReader.ICoord|null} [pos] FlowInfo pos
         * @property {RemoteFortressReader.ICoord|null} [dest] FlowInfo dest
         * @property {boolean|null} [expanding] FlowInfo expanding
         * @property {boolean|null} [reuse] FlowInfo reuse
         * @property {number|null} [guideId] FlowInfo guideId
         * @property {RemoteFortressReader.IMatPair|null} [material] FlowInfo material
         * @property {RemoteFortressReader.IMatPair|null} [item] FlowInfo item
         */

        /**
         * Constructs a new FlowInfo.
         * @memberof RemoteFortressReader
         * @classdesc Represents a FlowInfo.
         * @implements IFlowInfo
         * @constructor
         * @param {RemoteFortressReader.IFlowInfo=} [properties] Properties to set
         */
        function FlowInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FlowInfo index.
         * @member {number} index
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.index = 0;

        /**
         * FlowInfo type.
         * @member {RemoteFortressReader.FlowType} type
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.type = 0;

        /**
         * FlowInfo density.
         * @member {number} density
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.density = 0;

        /**
         * FlowInfo pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.pos = null;

        /**
         * FlowInfo dest.
         * @member {RemoteFortressReader.ICoord|null|undefined} dest
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.dest = null;

        /**
         * FlowInfo expanding.
         * @member {boolean} expanding
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.expanding = false;

        /**
         * FlowInfo reuse.
         * @member {boolean} reuse
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.reuse = false;

        /**
         * FlowInfo guideId.
         * @member {number} guideId
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.guideId = 0;

        /**
         * FlowInfo material.
         * @member {RemoteFortressReader.IMatPair|null|undefined} material
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.material = null;

        /**
         * FlowInfo item.
         * @member {RemoteFortressReader.IMatPair|null|undefined} item
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         */
        FlowInfo.prototype.item = null;

        /**
         * Creates a new FlowInfo instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.IFlowInfo=} [properties] Properties to set
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo instance
         */
        FlowInfo.create = function create(properties) {
            return new FlowInfo(properties);
        };

        /**
         * Encodes the specified FlowInfo message. Does not implicitly {@link RemoteFortressReader.FlowInfo.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.IFlowInfo} message FlowInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.density != null && Object.hasOwnProperty.call(message, "density"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.density);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                $root.RemoteFortressReader.Coord.encode(message.dest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.expanding != null && Object.hasOwnProperty.call(message, "expanding"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.expanding);
            if (message.reuse != null && Object.hasOwnProperty.call(message, "reuse"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.reuse);
            if (message.guideId != null && Object.hasOwnProperty.call(message, "guideId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.guideId);
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                $root.RemoteFortressReader.MatPair.encode(message.material, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.RemoteFortressReader.MatPair.encode(message.item, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FlowInfo message, length delimited. Does not implicitly {@link RemoteFortressReader.FlowInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.IFlowInfo} message FlowInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FlowInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FlowInfo message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.FlowInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.density = reader.int32();
                    break;
                case 4:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.dest = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.expanding = reader.bool();
                    break;
                case 7:
                    message.reuse = reader.bool();
                    break;
                case 8:
                    message.guideId = reader.int32();
                    break;
                case 9:
                    message.material = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.item = $root.RemoteFortressReader.MatPair.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FlowInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FlowInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FlowInfo message.
         * @function verify
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FlowInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case -1:
                    break;
                }
            if (message.density != null && message.hasOwnProperty("density"))
                if (!$util.isInteger(message.density))
                    return "density: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.dest != null && message.hasOwnProperty("dest")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.dest);
                if (error)
                    return "dest." + error;
            }
            if (message.expanding != null && message.hasOwnProperty("expanding"))
                if (typeof message.expanding !== "boolean")
                    return "expanding: boolean expected";
            if (message.reuse != null && message.hasOwnProperty("reuse"))
                if (typeof message.reuse !== "boolean")
                    return "reuse: boolean expected";
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                if (!$util.isInteger(message.guideId))
                    return "guideId: integer expected";
            if (message.material != null && message.hasOwnProperty("material")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.material);
                if (error)
                    return "material." + error;
            }
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.RemoteFortressReader.MatPair.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a FlowInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.FlowInfo} FlowInfo
         */
        FlowInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.FlowInfo)
                return object;
            var message = new $root.RemoteFortressReader.FlowInfo();
            if (object.index != null)
                message.index = object.index | 0;
            switch (object.type) {
            case "Miasma":
            case 0:
                message.type = 0;
                break;
            case "Steam":
            case 1:
                message.type = 1;
                break;
            case "Mist":
            case 2:
                message.type = 2;
                break;
            case "MaterialDust":
            case 3:
                message.type = 3;
                break;
            case "MagmaMist":
            case 4:
                message.type = 4;
                break;
            case "Smoke":
            case 5:
                message.type = 5;
                break;
            case "Dragonfire":
            case 6:
                message.type = 6;
                break;
            case "Fire":
            case 7:
                message.type = 7;
                break;
            case "Web":
            case 8:
                message.type = 8;
                break;
            case "MaterialGas":
            case 9:
                message.type = 9;
                break;
            case "MaterialVapor":
            case 10:
                message.type = 10;
                break;
            case "OceanWave":
            case 11:
                message.type = 11;
                break;
            case "SeaFoam":
            case 12:
                message.type = 12;
                break;
            case "ItemCloud":
            case 13:
                message.type = 13;
                break;
            case "CampFire":
            case -1:
                message.type = -1;
                break;
            }
            if (object.density != null)
                message.density = object.density | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            if (object.dest != null) {
                if (typeof object.dest !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.dest: object expected");
                message.dest = $root.RemoteFortressReader.Coord.fromObject(object.dest);
            }
            if (object.expanding != null)
                message.expanding = Boolean(object.expanding);
            if (object.reuse != null)
                message.reuse = Boolean(object.reuse);
            if (object.guideId != null)
                message.guideId = object.guideId | 0;
            if (object.material != null) {
                if (typeof object.material !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.material: object expected");
                message.material = $root.RemoteFortressReader.MatPair.fromObject(object.material);
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".RemoteFortressReader.FlowInfo.item: object expected");
                message.item = $root.RemoteFortressReader.MatPair.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a FlowInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.FlowInfo
         * @static
         * @param {RemoteFortressReader.FlowInfo} message FlowInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FlowInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.type = options.enums === String ? "Miasma" : 0;
                object.density = 0;
                object.pos = null;
                object.dest = null;
                object.expanding = false;
                object.reuse = false;
                object.guideId = 0;
                object.material = null;
                object.item = null;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.RemoteFortressReader.FlowType[message.type] : message.type;
            if (message.density != null && message.hasOwnProperty("density"))
                object.density = message.density;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = $root.RemoteFortressReader.Coord.toObject(message.dest, options);
            if (message.expanding != null && message.hasOwnProperty("expanding"))
                object.expanding = message.expanding;
            if (message.reuse != null && message.hasOwnProperty("reuse"))
                object.reuse = message.reuse;
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                object.guideId = message.guideId;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = $root.RemoteFortressReader.MatPair.toObject(message.material, options);
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.RemoteFortressReader.MatPair.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this FlowInfo to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.FlowInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FlowInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FlowInfo;
    })();

    RemoteFortressReader.Wave = (function() {

        /**
         * Properties of a Wave.
         * @memberof RemoteFortressReader
         * @interface IWave
         * @property {RemoteFortressReader.ICoord|null} [dest] Wave dest
         * @property {RemoteFortressReader.ICoord|null} [pos] Wave pos
         */

        /**
         * Constructs a new Wave.
         * @memberof RemoteFortressReader
         * @classdesc Represents a Wave.
         * @implements IWave
         * @constructor
         * @param {RemoteFortressReader.IWave=} [properties] Properties to set
         */
        function Wave(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Wave dest.
         * @member {RemoteFortressReader.ICoord|null|undefined} dest
         * @memberof RemoteFortressReader.Wave
         * @instance
         */
        Wave.prototype.dest = null;

        /**
         * Wave pos.
         * @member {RemoteFortressReader.ICoord|null|undefined} pos
         * @memberof RemoteFortressReader.Wave
         * @instance
         */
        Wave.prototype.pos = null;

        /**
         * Creates a new Wave instance using the specified properties.
         * @function create
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.IWave=} [properties] Properties to set
         * @returns {RemoteFortressReader.Wave} Wave instance
         */
        Wave.create = function create(properties) {
            return new Wave(properties);
        };

        /**
         * Encodes the specified Wave message. Does not implicitly {@link RemoteFortressReader.Wave.verify|verify} messages.
         * @function encode
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.IWave} message Wave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wave.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                $root.RemoteFortressReader.Coord.encode(message.dest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.RemoteFortressReader.Coord.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Wave message, length delimited. Does not implicitly {@link RemoteFortressReader.Wave.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.IWave} message Wave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wave.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Wave message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteFortressReader.Wave} Wave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wave.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteFortressReader.Wave();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dest = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pos = $root.RemoteFortressReader.Coord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Wave message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteFortressReader.Wave} Wave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wave.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Wave message.
         * @function verify
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Wave.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.dest);
                if (error)
                    return "dest." + error;
            }
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.RemoteFortressReader.Coord.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a Wave message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteFortressReader.Wave} Wave
         */
        Wave.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteFortressReader.Wave)
                return object;
            var message = new $root.RemoteFortressReader.Wave();
            if (object.dest != null) {
                if (typeof object.dest !== "object")
                    throw TypeError(".RemoteFortressReader.Wave.dest: object expected");
                message.dest = $root.RemoteFortressReader.Coord.fromObject(object.dest);
            }
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".RemoteFortressReader.Wave.pos: object expected");
                message.pos = $root.RemoteFortressReader.Coord.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a Wave message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteFortressReader.Wave
         * @static
         * @param {RemoteFortressReader.Wave} message Wave
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Wave.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dest = null;
                object.pos = null;
            }
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = $root.RemoteFortressReader.Coord.toObject(message.dest, options);
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.RemoteFortressReader.Coord.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this Wave to JSON.
         * @function toJSON
         * @memberof RemoteFortressReader.Wave
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Wave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Wave;
    })();

    return RemoteFortressReader;
})();

$root.ItemdefInstrument = (function() {

    /**
     * Namespace ItemdefInstrument.
     * @exports ItemdefInstrument
     * @namespace
     */
    var ItemdefInstrument = {};

    ItemdefInstrument.InstrumentFlags = (function() {

        /**
         * Properties of an InstrumentFlags.
         * @memberof ItemdefInstrument
         * @interface IInstrumentFlags
         * @property {boolean|null} [indefinitePitch] InstrumentFlags indefinitePitch
         * @property {boolean|null} [placedAsBuilding] InstrumentFlags placedAsBuilding
         * @property {boolean|null} [metalMat] InstrumentFlags metalMat
         * @property {boolean|null} [stoneMat] InstrumentFlags stoneMat
         * @property {boolean|null} [woodMat] InstrumentFlags woodMat
         * @property {boolean|null} [glassMat] InstrumentFlags glassMat
         * @property {boolean|null} [ceramicMat] InstrumentFlags ceramicMat
         * @property {boolean|null} [shellMat] InstrumentFlags shellMat
         * @property {boolean|null} [boneMat] InstrumentFlags boneMat
         */

        /**
         * Constructs a new InstrumentFlags.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentFlags.
         * @implements IInstrumentFlags
         * @constructor
         * @param {ItemdefInstrument.IInstrumentFlags=} [properties] Properties to set
         */
        function InstrumentFlags(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentFlags indefinitePitch.
         * @member {boolean} indefinitePitch
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.indefinitePitch = false;

        /**
         * InstrumentFlags placedAsBuilding.
         * @member {boolean} placedAsBuilding
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.placedAsBuilding = false;

        /**
         * InstrumentFlags metalMat.
         * @member {boolean} metalMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.metalMat = false;

        /**
         * InstrumentFlags stoneMat.
         * @member {boolean} stoneMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.stoneMat = false;

        /**
         * InstrumentFlags woodMat.
         * @member {boolean} woodMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.woodMat = false;

        /**
         * InstrumentFlags glassMat.
         * @member {boolean} glassMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.glassMat = false;

        /**
         * InstrumentFlags ceramicMat.
         * @member {boolean} ceramicMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.ceramicMat = false;

        /**
         * InstrumentFlags shellMat.
         * @member {boolean} shellMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.shellMat = false;

        /**
         * InstrumentFlags boneMat.
         * @member {boolean} boneMat
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         */
        InstrumentFlags.prototype.boneMat = false;

        /**
         * Creates a new InstrumentFlags instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.IInstrumentFlags=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags instance
         */
        InstrumentFlags.create = function create(properties) {
            return new InstrumentFlags(properties);
        };

        /**
         * Encodes the specified InstrumentFlags message. Does not implicitly {@link ItemdefInstrument.InstrumentFlags.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.IInstrumentFlags} message InstrumentFlags message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentFlags.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.indefinitePitch != null && Object.hasOwnProperty.call(message, "indefinitePitch"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.indefinitePitch);
            if (message.placedAsBuilding != null && Object.hasOwnProperty.call(message, "placedAsBuilding"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.placedAsBuilding);
            if (message.metalMat != null && Object.hasOwnProperty.call(message, "metalMat"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.metalMat);
            if (message.stoneMat != null && Object.hasOwnProperty.call(message, "stoneMat"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.stoneMat);
            if (message.woodMat != null && Object.hasOwnProperty.call(message, "woodMat"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.woodMat);
            if (message.glassMat != null && Object.hasOwnProperty.call(message, "glassMat"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.glassMat);
            if (message.ceramicMat != null && Object.hasOwnProperty.call(message, "ceramicMat"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.ceramicMat);
            if (message.shellMat != null && Object.hasOwnProperty.call(message, "shellMat"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.shellMat);
            if (message.boneMat != null && Object.hasOwnProperty.call(message, "boneMat"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.boneMat);
            return writer;
        };

        /**
         * Encodes the specified InstrumentFlags message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentFlags.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.IInstrumentFlags} message InstrumentFlags message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentFlags.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentFlags message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentFlags.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentFlags();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.indefinitePitch = reader.bool();
                    break;
                case 2:
                    message.placedAsBuilding = reader.bool();
                    break;
                case 3:
                    message.metalMat = reader.bool();
                    break;
                case 4:
                    message.stoneMat = reader.bool();
                    break;
                case 5:
                    message.woodMat = reader.bool();
                    break;
                case 6:
                    message.glassMat = reader.bool();
                    break;
                case 7:
                    message.ceramicMat = reader.bool();
                    break;
                case 8:
                    message.shellMat = reader.bool();
                    break;
                case 9:
                    message.boneMat = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentFlags message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentFlags.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentFlags message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentFlags.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.indefinitePitch != null && message.hasOwnProperty("indefinitePitch"))
                if (typeof message.indefinitePitch !== "boolean")
                    return "indefinitePitch: boolean expected";
            if (message.placedAsBuilding != null && message.hasOwnProperty("placedAsBuilding"))
                if (typeof message.placedAsBuilding !== "boolean")
                    return "placedAsBuilding: boolean expected";
            if (message.metalMat != null && message.hasOwnProperty("metalMat"))
                if (typeof message.metalMat !== "boolean")
                    return "metalMat: boolean expected";
            if (message.stoneMat != null && message.hasOwnProperty("stoneMat"))
                if (typeof message.stoneMat !== "boolean")
                    return "stoneMat: boolean expected";
            if (message.woodMat != null && message.hasOwnProperty("woodMat"))
                if (typeof message.woodMat !== "boolean")
                    return "woodMat: boolean expected";
            if (message.glassMat != null && message.hasOwnProperty("glassMat"))
                if (typeof message.glassMat !== "boolean")
                    return "glassMat: boolean expected";
            if (message.ceramicMat != null && message.hasOwnProperty("ceramicMat"))
                if (typeof message.ceramicMat !== "boolean")
                    return "ceramicMat: boolean expected";
            if (message.shellMat != null && message.hasOwnProperty("shellMat"))
                if (typeof message.shellMat !== "boolean")
                    return "shellMat: boolean expected";
            if (message.boneMat != null && message.hasOwnProperty("boneMat"))
                if (typeof message.boneMat !== "boolean")
                    return "boneMat: boolean expected";
            return null;
        };

        /**
         * Creates an InstrumentFlags message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentFlags} InstrumentFlags
         */
        InstrumentFlags.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentFlags)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentFlags();
            if (object.indefinitePitch != null)
                message.indefinitePitch = Boolean(object.indefinitePitch);
            if (object.placedAsBuilding != null)
                message.placedAsBuilding = Boolean(object.placedAsBuilding);
            if (object.metalMat != null)
                message.metalMat = Boolean(object.metalMat);
            if (object.stoneMat != null)
                message.stoneMat = Boolean(object.stoneMat);
            if (object.woodMat != null)
                message.woodMat = Boolean(object.woodMat);
            if (object.glassMat != null)
                message.glassMat = Boolean(object.glassMat);
            if (object.ceramicMat != null)
                message.ceramicMat = Boolean(object.ceramicMat);
            if (object.shellMat != null)
                message.shellMat = Boolean(object.shellMat);
            if (object.boneMat != null)
                message.boneMat = Boolean(object.boneMat);
            return message;
        };

        /**
         * Creates a plain object from an InstrumentFlags message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentFlags
         * @static
         * @param {ItemdefInstrument.InstrumentFlags} message InstrumentFlags
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentFlags.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.indefinitePitch = false;
                object.placedAsBuilding = false;
                object.metalMat = false;
                object.stoneMat = false;
                object.woodMat = false;
                object.glassMat = false;
                object.ceramicMat = false;
                object.shellMat = false;
                object.boneMat = false;
            }
            if (message.indefinitePitch != null && message.hasOwnProperty("indefinitePitch"))
                object.indefinitePitch = message.indefinitePitch;
            if (message.placedAsBuilding != null && message.hasOwnProperty("placedAsBuilding"))
                object.placedAsBuilding = message.placedAsBuilding;
            if (message.metalMat != null && message.hasOwnProperty("metalMat"))
                object.metalMat = message.metalMat;
            if (message.stoneMat != null && message.hasOwnProperty("stoneMat"))
                object.stoneMat = message.stoneMat;
            if (message.woodMat != null && message.hasOwnProperty("woodMat"))
                object.woodMat = message.woodMat;
            if (message.glassMat != null && message.hasOwnProperty("glassMat"))
                object.glassMat = message.glassMat;
            if (message.ceramicMat != null && message.hasOwnProperty("ceramicMat"))
                object.ceramicMat = message.ceramicMat;
            if (message.shellMat != null && message.hasOwnProperty("shellMat"))
                object.shellMat = message.shellMat;
            if (message.boneMat != null && message.hasOwnProperty("boneMat"))
                object.boneMat = message.boneMat;
            return object;
        };

        /**
         * Converts this InstrumentFlags to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentFlags
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentFlags.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentFlags;
    })();

    /**
     * PitchChoiceType enum.
     * @name ItemdefInstrument.PitchChoiceType
     * @enum {string}
     * @property {number} MEMBRANE_POSITION=0 MEMBRANE_POSITION value
     * @property {number} SUBPART_CHOICE=1 SUBPART_CHOICE value
     * @property {number} KEYBOARD=2 KEYBOARD value
     * @property {number} STOPPING_FRET=3 STOPPING_FRET value
     * @property {number} STOPPING_AGAINST_BODY=4 STOPPING_AGAINST_BODY value
     * @property {number} STOPPING_HOLE=5 STOPPING_HOLE value
     * @property {number} STOPPING_HOLE_KEY=6 STOPPING_HOLE_KEY value
     * @property {number} SLIDE=7 SLIDE value
     * @property {number} HARMONIC_SERIES=8 HARMONIC_SERIES value
     * @property {number} VALVE_ROUTES_AIR=9 VALVE_ROUTES_AIR value
     * @property {number} BP_IN_BELL=10 BP_IN_BELL value
     * @property {number} FOOT_PEDALS=11 FOOT_PEDALS value
     */
    ItemdefInstrument.PitchChoiceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MEMBRANE_POSITION"] = 0;
        values[valuesById[1] = "SUBPART_CHOICE"] = 1;
        values[valuesById[2] = "KEYBOARD"] = 2;
        values[valuesById[3] = "STOPPING_FRET"] = 3;
        values[valuesById[4] = "STOPPING_AGAINST_BODY"] = 4;
        values[valuesById[5] = "STOPPING_HOLE"] = 5;
        values[valuesById[6] = "STOPPING_HOLE_KEY"] = 6;
        values[valuesById[7] = "SLIDE"] = 7;
        values[valuesById[8] = "HARMONIC_SERIES"] = 8;
        values[valuesById[9] = "VALVE_ROUTES_AIR"] = 9;
        values[valuesById[10] = "BP_IN_BELL"] = 10;
        values[valuesById[11] = "FOOT_PEDALS"] = 11;
        return values;
    })();

    /**
     * SoundProductionType enum.
     * @name ItemdefInstrument.SoundProductionType
     * @enum {string}
     * @property {number} PLUCKED_BY_BP=0 PLUCKED_BY_BP value
     * @property {number} PLUCKED=1 PLUCKED value
     * @property {number} BOWED=2 BOWED value
     * @property {number} STRUCK_BY_BP=3 STRUCK_BY_BP value
     * @property {number} STRUCK=4 STRUCK value
     * @property {number} VIBRATE_BP_AGAINST_OPENING=5 VIBRATE_BP_AGAINST_OPENING value
     * @property {number} BLOW_AGAINST_FIPPLE=6 BLOW_AGAINST_FIPPLE value
     * @property {number} BLOW_OVER_OPENING_SIDE=7 BLOW_OVER_OPENING_SIDE value
     * @property {number} BLOW_OVER_OPENING_END=8 BLOW_OVER_OPENING_END value
     * @property {number} BLOW_OVER_SINGLE_REED=9 BLOW_OVER_SINGLE_REED value
     * @property {number} BLOW_OVER_DOUBLE_REED=10 BLOW_OVER_DOUBLE_REED value
     * @property {number} BLOW_OVER_FREE_REED=11 BLOW_OVER_FREE_REED value
     * @property {number} STRUCK_TOGETHER=12 STRUCK_TOGETHER value
     * @property {number} SHAKEN=13 SHAKEN value
     * @property {number} SCRAPED=14 SCRAPED value
     * @property {number} FRICTION=15 FRICTION value
     * @property {number} RESONATOR=16 RESONATOR value
     * @property {number} BAG_OVER_REED=17 BAG_OVER_REED value
     * @property {number} AIR_OVER_REED=18 AIR_OVER_REED value
     * @property {number} AIR_OVER_FREE_REED=19 AIR_OVER_FREE_REED value
     * @property {number} AIR_AGAINST_FIPPLE=20 AIR_AGAINST_FIPPLE value
     */
    ItemdefInstrument.SoundProductionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PLUCKED_BY_BP"] = 0;
        values[valuesById[1] = "PLUCKED"] = 1;
        values[valuesById[2] = "BOWED"] = 2;
        values[valuesById[3] = "STRUCK_BY_BP"] = 3;
        values[valuesById[4] = "STRUCK"] = 4;
        values[valuesById[5] = "VIBRATE_BP_AGAINST_OPENING"] = 5;
        values[valuesById[6] = "BLOW_AGAINST_FIPPLE"] = 6;
        values[valuesById[7] = "BLOW_OVER_OPENING_SIDE"] = 7;
        values[valuesById[8] = "BLOW_OVER_OPENING_END"] = 8;
        values[valuesById[9] = "BLOW_OVER_SINGLE_REED"] = 9;
        values[valuesById[10] = "BLOW_OVER_DOUBLE_REED"] = 10;
        values[valuesById[11] = "BLOW_OVER_FREE_REED"] = 11;
        values[valuesById[12] = "STRUCK_TOGETHER"] = 12;
        values[valuesById[13] = "SHAKEN"] = 13;
        values[valuesById[14] = "SCRAPED"] = 14;
        values[valuesById[15] = "FRICTION"] = 15;
        values[valuesById[16] = "RESONATOR"] = 16;
        values[valuesById[17] = "BAG_OVER_REED"] = 17;
        values[valuesById[18] = "AIR_OVER_REED"] = 18;
        values[valuesById[19] = "AIR_OVER_FREE_REED"] = 19;
        values[valuesById[20] = "AIR_AGAINST_FIPPLE"] = 20;
        return values;
    })();

    /**
     * TuningType enum.
     * @name ItemdefInstrument.TuningType
     * @enum {string}
     * @property {number} PEGS=0 PEGS value
     * @property {number} ADJUSTABLE_BRIDGES=1 ADJUSTABLE_BRIDGES value
     * @property {number} CROOKS=2 CROOKS value
     * @property {number} TIGHTENING=3 TIGHTENING value
     * @property {number} LEVERS=4 LEVERS value
     */
    ItemdefInstrument.TuningType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PEGS"] = 0;
        values[valuesById[1] = "ADJUSTABLE_BRIDGES"] = 1;
        values[valuesById[2] = "CROOKS"] = 2;
        values[valuesById[3] = "TIGHTENING"] = 3;
        values[valuesById[4] = "LEVERS"] = 4;
        return values;
    })();

    ItemdefInstrument.InstrumentPiece = (function() {

        /**
         * Properties of an InstrumentPiece.
         * @memberof ItemdefInstrument
         * @interface IInstrumentPiece
         * @property {string|null} [type] InstrumentPiece type
         * @property {string|null} [id] InstrumentPiece id
         * @property {string|null} [name] InstrumentPiece name
         * @property {string|null} [namePlural] InstrumentPiece namePlural
         */

        /**
         * Constructs a new InstrumentPiece.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentPiece.
         * @implements IInstrumentPiece
         * @constructor
         * @param {ItemdefInstrument.IInstrumentPiece=} [properties] Properties to set
         */
        function InstrumentPiece(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentPiece type.
         * @member {string} type
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.type = "";

        /**
         * InstrumentPiece id.
         * @member {string} id
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.id = "";

        /**
         * InstrumentPiece name.
         * @member {string} name
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.name = "";

        /**
         * InstrumentPiece namePlural.
         * @member {string} namePlural
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         */
        InstrumentPiece.prototype.namePlural = "";

        /**
         * Creates a new InstrumentPiece instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.IInstrumentPiece=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece instance
         */
        InstrumentPiece.create = function create(properties) {
            return new InstrumentPiece(properties);
        };

        /**
         * Encodes the specified InstrumentPiece message. Does not implicitly {@link ItemdefInstrument.InstrumentPiece.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.IInstrumentPiece} message InstrumentPiece message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentPiece.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.namePlural != null && Object.hasOwnProperty.call(message, "namePlural"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.namePlural);
            return writer;
        };

        /**
         * Encodes the specified InstrumentPiece message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentPiece.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.IInstrumentPiece} message InstrumentPiece message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentPiece.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentPiece message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentPiece.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentPiece();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.namePlural = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentPiece message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentPiece.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentPiece message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentPiece.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.namePlural != null && message.hasOwnProperty("namePlural"))
                if (!$util.isString(message.namePlural))
                    return "namePlural: string expected";
            return null;
        };

        /**
         * Creates an InstrumentPiece message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentPiece} InstrumentPiece
         */
        InstrumentPiece.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentPiece)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentPiece();
            if (object.type != null)
                message.type = String(object.type);
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.namePlural != null)
                message.namePlural = String(object.namePlural);
            return message;
        };

        /**
         * Creates a plain object from an InstrumentPiece message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentPiece
         * @static
         * @param {ItemdefInstrument.InstrumentPiece} message InstrumentPiece
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentPiece.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                object.id = "";
                object.name = "";
                object.namePlural = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.namePlural != null && message.hasOwnProperty("namePlural"))
                object.namePlural = message.namePlural;
            return object;
        };

        /**
         * Converts this InstrumentPiece to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentPiece
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentPiece.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentPiece;
    })();

    ItemdefInstrument.InstrumentRegister = (function() {

        /**
         * Properties of an InstrumentRegister.
         * @memberof ItemdefInstrument
         * @interface IInstrumentRegister
         * @property {number|null} [pitchRangeMin] InstrumentRegister pitchRangeMin
         * @property {number|null} [pitchRangeMax] InstrumentRegister pitchRangeMax
         */

        /**
         * Constructs a new InstrumentRegister.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentRegister.
         * @implements IInstrumentRegister
         * @constructor
         * @param {ItemdefInstrument.IInstrumentRegister=} [properties] Properties to set
         */
        function InstrumentRegister(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentRegister pitchRangeMin.
         * @member {number} pitchRangeMin
         * @memberof ItemdefInstrument.InstrumentRegister
         * @instance
         */
        InstrumentRegister.prototype.pitchRangeMin = 0;

        /**
         * InstrumentRegister pitchRangeMax.
         * @member {number} pitchRangeMax
         * @memberof ItemdefInstrument.InstrumentRegister
         * @instance
         */
        InstrumentRegister.prototype.pitchRangeMax = 0;

        /**
         * Creates a new InstrumentRegister instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.IInstrumentRegister=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister instance
         */
        InstrumentRegister.create = function create(properties) {
            return new InstrumentRegister(properties);
        };

        /**
         * Encodes the specified InstrumentRegister message. Does not implicitly {@link ItemdefInstrument.InstrumentRegister.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.IInstrumentRegister} message InstrumentRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentRegister.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pitchRangeMin != null && Object.hasOwnProperty.call(message, "pitchRangeMin"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pitchRangeMin);
            if (message.pitchRangeMax != null && Object.hasOwnProperty.call(message, "pitchRangeMax"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pitchRangeMax);
            return writer;
        };

        /**
         * Encodes the specified InstrumentRegister message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentRegister.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.IInstrumentRegister} message InstrumentRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentRegister.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentRegister message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentRegister.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentRegister();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pitchRangeMin = reader.int32();
                    break;
                case 2:
                    message.pitchRangeMax = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentRegister message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentRegister.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentRegister message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentRegister.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                if (!$util.isInteger(message.pitchRangeMin))
                    return "pitchRangeMin: integer expected";
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                if (!$util.isInteger(message.pitchRangeMax))
                    return "pitchRangeMax: integer expected";
            return null;
        };

        /**
         * Creates an InstrumentRegister message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentRegister} InstrumentRegister
         */
        InstrumentRegister.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentRegister)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentRegister();
            if (object.pitchRangeMin != null)
                message.pitchRangeMin = object.pitchRangeMin | 0;
            if (object.pitchRangeMax != null)
                message.pitchRangeMax = object.pitchRangeMax | 0;
            return message;
        };

        /**
         * Creates a plain object from an InstrumentRegister message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentRegister
         * @static
         * @param {ItemdefInstrument.InstrumentRegister} message InstrumentRegister
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentRegister.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pitchRangeMin = 0;
                object.pitchRangeMax = 0;
            }
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                object.pitchRangeMin = message.pitchRangeMin;
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                object.pitchRangeMax = message.pitchRangeMax;
            return object;
        };

        /**
         * Converts this InstrumentRegister to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentRegister
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentRegister.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentRegister;
    })();

    ItemdefInstrument.InstrumentDef = (function() {

        /**
         * Properties of an InstrumentDef.
         * @memberof ItemdefInstrument
         * @interface IInstrumentDef
         * @property {ItemdefInstrument.IInstrumentFlags|null} [flags] InstrumentDef flags
         * @property {number|null} [size] InstrumentDef size
         * @property {number|null} [value] InstrumentDef value
         * @property {number|null} [materialSize] InstrumentDef materialSize
         * @property {Array.<ItemdefInstrument.IInstrumentPiece>|null} [pieces] InstrumentDef pieces
         * @property {number|null} [pitchRangeMin] InstrumentDef pitchRangeMin
         * @property {number|null} [pitchRangeMax] InstrumentDef pitchRangeMax
         * @property {number|null} [volumeMbMin] InstrumentDef volumeMbMin
         * @property {number|null} [volumeMbMax] InstrumentDef volumeMbMax
         * @property {Array.<ItemdefInstrument.SoundProductionType>|null} [soundProduction] InstrumentDef soundProduction
         * @property {Array.<string>|null} [soundProductionParm1] InstrumentDef soundProductionParm1
         * @property {Array.<string>|null} [soundProductionParm2] InstrumentDef soundProductionParm2
         * @property {Array.<ItemdefInstrument.PitchChoiceType>|null} [pitchChoice] InstrumentDef pitchChoice
         * @property {Array.<string>|null} [pitchChoiceParm1] InstrumentDef pitchChoiceParm1
         * @property {Array.<string>|null} [pitchChoiceParm2] InstrumentDef pitchChoiceParm2
         * @property {Array.<ItemdefInstrument.TuningType>|null} [tuning] InstrumentDef tuning
         * @property {Array.<string>|null} [tuningParm] InstrumentDef tuningParm
         * @property {Array.<ItemdefInstrument.IInstrumentRegister>|null} [registers] InstrumentDef registers
         * @property {string|null} [description] InstrumentDef description
         */

        /**
         * Constructs a new InstrumentDef.
         * @memberof ItemdefInstrument
         * @classdesc Represents an InstrumentDef.
         * @implements IInstrumentDef
         * @constructor
         * @param {ItemdefInstrument.IInstrumentDef=} [properties] Properties to set
         */
        function InstrumentDef(properties) {
            this.pieces = [];
            this.soundProduction = [];
            this.soundProductionParm1 = [];
            this.soundProductionParm2 = [];
            this.pitchChoice = [];
            this.pitchChoiceParm1 = [];
            this.pitchChoiceParm2 = [];
            this.tuning = [];
            this.tuningParm = [];
            this.registers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstrumentDef flags.
         * @member {ItemdefInstrument.IInstrumentFlags|null|undefined} flags
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.flags = null;

        /**
         * InstrumentDef size.
         * @member {number} size
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.size = 0;

        /**
         * InstrumentDef value.
         * @member {number} value
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.value = 0;

        /**
         * InstrumentDef materialSize.
         * @member {number} materialSize
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.materialSize = 0;

        /**
         * InstrumentDef pieces.
         * @member {Array.<ItemdefInstrument.IInstrumentPiece>} pieces
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pieces = $util.emptyArray;

        /**
         * InstrumentDef pitchRangeMin.
         * @member {number} pitchRangeMin
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchRangeMin = 0;

        /**
         * InstrumentDef pitchRangeMax.
         * @member {number} pitchRangeMax
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchRangeMax = 0;

        /**
         * InstrumentDef volumeMbMin.
         * @member {number} volumeMbMin
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.volumeMbMin = 0;

        /**
         * InstrumentDef volumeMbMax.
         * @member {number} volumeMbMax
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.volumeMbMax = 0;

        /**
         * InstrumentDef soundProduction.
         * @member {Array.<ItemdefInstrument.SoundProductionType>} soundProduction
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.soundProduction = $util.emptyArray;

        /**
         * InstrumentDef soundProductionParm1.
         * @member {Array.<string>} soundProductionParm1
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.soundProductionParm1 = $util.emptyArray;

        /**
         * InstrumentDef soundProductionParm2.
         * @member {Array.<string>} soundProductionParm2
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.soundProductionParm2 = $util.emptyArray;

        /**
         * InstrumentDef pitchChoice.
         * @member {Array.<ItemdefInstrument.PitchChoiceType>} pitchChoice
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchChoice = $util.emptyArray;

        /**
         * InstrumentDef pitchChoiceParm1.
         * @member {Array.<string>} pitchChoiceParm1
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchChoiceParm1 = $util.emptyArray;

        /**
         * InstrumentDef pitchChoiceParm2.
         * @member {Array.<string>} pitchChoiceParm2
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.pitchChoiceParm2 = $util.emptyArray;

        /**
         * InstrumentDef tuning.
         * @member {Array.<ItemdefInstrument.TuningType>} tuning
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.tuning = $util.emptyArray;

        /**
         * InstrumentDef tuningParm.
         * @member {Array.<string>} tuningParm
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.tuningParm = $util.emptyArray;

        /**
         * InstrumentDef registers.
         * @member {Array.<ItemdefInstrument.IInstrumentRegister>} registers
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.registers = $util.emptyArray;

        /**
         * InstrumentDef description.
         * @member {string} description
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         */
        InstrumentDef.prototype.description = "";

        /**
         * Creates a new InstrumentDef instance using the specified properties.
         * @function create
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.IInstrumentDef=} [properties] Properties to set
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef instance
         */
        InstrumentDef.create = function create(properties) {
            return new InstrumentDef(properties);
        };

        /**
         * Encodes the specified InstrumentDef message. Does not implicitly {@link ItemdefInstrument.InstrumentDef.verify|verify} messages.
         * @function encode
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.IInstrumentDef} message InstrumentDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                $root.ItemdefInstrument.InstrumentFlags.encode(message.flags, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.value);
            if (message.materialSize != null && Object.hasOwnProperty.call(message, "materialSize"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.materialSize);
            if (message.pieces != null && message.pieces.length)
                for (var i = 0; i < message.pieces.length; ++i)
                    $root.ItemdefInstrument.InstrumentPiece.encode(message.pieces[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.pitchRangeMin != null && Object.hasOwnProperty.call(message, "pitchRangeMin"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.pitchRangeMin);
            if (message.pitchRangeMax != null && Object.hasOwnProperty.call(message, "pitchRangeMax"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.pitchRangeMax);
            if (message.volumeMbMin != null && Object.hasOwnProperty.call(message, "volumeMbMin"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.volumeMbMin);
            if (message.volumeMbMax != null && Object.hasOwnProperty.call(message, "volumeMbMax"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.volumeMbMax);
            if (message.soundProduction != null && message.soundProduction.length)
                for (var i = 0; i < message.soundProduction.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.soundProduction[i]);
            if (message.soundProductionParm1 != null && message.soundProductionParm1.length)
                for (var i = 0; i < message.soundProductionParm1.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.soundProductionParm1[i]);
            if (message.soundProductionParm2 != null && message.soundProductionParm2.length)
                for (var i = 0; i < message.soundProductionParm2.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.soundProductionParm2[i]);
            if (message.pitchChoice != null && message.pitchChoice.length)
                for (var i = 0; i < message.pitchChoice.length; ++i)
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.pitchChoice[i]);
            if (message.pitchChoiceParm1 != null && message.pitchChoiceParm1.length)
                for (var i = 0; i < message.pitchChoiceParm1.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.pitchChoiceParm1[i]);
            if (message.pitchChoiceParm2 != null && message.pitchChoiceParm2.length)
                for (var i = 0; i < message.pitchChoiceParm2.length; ++i)
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.pitchChoiceParm2[i]);
            if (message.tuning != null && message.tuning.length)
                for (var i = 0; i < message.tuning.length; ++i)
                    writer.uint32(/* id 16, wireType 0 =*/128).int32(message.tuning[i]);
            if (message.tuningParm != null && message.tuningParm.length)
                for (var i = 0; i < message.tuningParm.length; ++i)
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.tuningParm[i]);
            if (message.registers != null && message.registers.length)
                for (var i = 0; i < message.registers.length; ++i)
                    $root.ItemdefInstrument.InstrumentRegister.encode(message.registers[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified InstrumentDef message, length delimited. Does not implicitly {@link ItemdefInstrument.InstrumentDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.IInstrumentDef} message InstrumentDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstrumentDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstrumentDef message from the specified reader or buffer.
         * @function decode
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ItemdefInstrument.InstrumentDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.flags = $root.ItemdefInstrument.InstrumentFlags.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.size = reader.int32();
                    break;
                case 3:
                    message.value = reader.int32();
                    break;
                case 4:
                    message.materialSize = reader.int32();
                    break;
                case 5:
                    if (!(message.pieces && message.pieces.length))
                        message.pieces = [];
                    message.pieces.push($root.ItemdefInstrument.InstrumentPiece.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.pitchRangeMin = reader.int32();
                    break;
                case 7:
                    message.pitchRangeMax = reader.int32();
                    break;
                case 8:
                    message.volumeMbMin = reader.int32();
                    break;
                case 9:
                    message.volumeMbMax = reader.int32();
                    break;
                case 10:
                    if (!(message.soundProduction && message.soundProduction.length))
                        message.soundProduction = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.soundProduction.push(reader.int32());
                    } else
                        message.soundProduction.push(reader.int32());
                    break;
                case 11:
                    if (!(message.soundProductionParm1 && message.soundProductionParm1.length))
                        message.soundProductionParm1 = [];
                    message.soundProductionParm1.push(reader.string());
                    break;
                case 12:
                    if (!(message.soundProductionParm2 && message.soundProductionParm2.length))
                        message.soundProductionParm2 = [];
                    message.soundProductionParm2.push(reader.string());
                    break;
                case 13:
                    if (!(message.pitchChoice && message.pitchChoice.length))
                        message.pitchChoice = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.pitchChoice.push(reader.int32());
                    } else
                        message.pitchChoice.push(reader.int32());
                    break;
                case 14:
                    if (!(message.pitchChoiceParm1 && message.pitchChoiceParm1.length))
                        message.pitchChoiceParm1 = [];
                    message.pitchChoiceParm1.push(reader.string());
                    break;
                case 15:
                    if (!(message.pitchChoiceParm2 && message.pitchChoiceParm2.length))
                        message.pitchChoiceParm2 = [];
                    message.pitchChoiceParm2.push(reader.string());
                    break;
                case 16:
                    if (!(message.tuning && message.tuning.length))
                        message.tuning = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tuning.push(reader.int32());
                    } else
                        message.tuning.push(reader.int32());
                    break;
                case 17:
                    if (!(message.tuningParm && message.tuningParm.length))
                        message.tuningParm = [];
                    message.tuningParm.push(reader.string());
                    break;
                case 18:
                    if (!(message.registers && message.registers.length))
                        message.registers = [];
                    message.registers.push($root.ItemdefInstrument.InstrumentRegister.decode(reader, reader.uint32()));
                    break;
                case 19:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstrumentDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstrumentDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstrumentDef message.
         * @function verify
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstrumentDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                var error = $root.ItemdefInstrument.InstrumentFlags.verify(message.flags);
                if (error)
                    return "flags." + error;
            }
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.materialSize != null && message.hasOwnProperty("materialSize"))
                if (!$util.isInteger(message.materialSize))
                    return "materialSize: integer expected";
            if (message.pieces != null && message.hasOwnProperty("pieces")) {
                if (!Array.isArray(message.pieces))
                    return "pieces: array expected";
                for (var i = 0; i < message.pieces.length; ++i) {
                    var error = $root.ItemdefInstrument.InstrumentPiece.verify(message.pieces[i]);
                    if (error)
                        return "pieces." + error;
                }
            }
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                if (!$util.isInteger(message.pitchRangeMin))
                    return "pitchRangeMin: integer expected";
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                if (!$util.isInteger(message.pitchRangeMax))
                    return "pitchRangeMax: integer expected";
            if (message.volumeMbMin != null && message.hasOwnProperty("volumeMbMin"))
                if (!$util.isInteger(message.volumeMbMin))
                    return "volumeMbMin: integer expected";
            if (message.volumeMbMax != null && message.hasOwnProperty("volumeMbMax"))
                if (!$util.isInteger(message.volumeMbMax))
                    return "volumeMbMax: integer expected";
            if (message.soundProduction != null && message.hasOwnProperty("soundProduction")) {
                if (!Array.isArray(message.soundProduction))
                    return "soundProduction: array expected";
                for (var i = 0; i < message.soundProduction.length; ++i)
                    switch (message.soundProduction[i]) {
                    default:
                        return "soundProduction: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                        break;
                    }
            }
            if (message.soundProductionParm1 != null && message.hasOwnProperty("soundProductionParm1")) {
                if (!Array.isArray(message.soundProductionParm1))
                    return "soundProductionParm1: array expected";
                for (var i = 0; i < message.soundProductionParm1.length; ++i)
                    if (!$util.isString(message.soundProductionParm1[i]))
                        return "soundProductionParm1: string[] expected";
            }
            if (message.soundProductionParm2 != null && message.hasOwnProperty("soundProductionParm2")) {
                if (!Array.isArray(message.soundProductionParm2))
                    return "soundProductionParm2: array expected";
                for (var i = 0; i < message.soundProductionParm2.length; ++i)
                    if (!$util.isString(message.soundProductionParm2[i]))
                        return "soundProductionParm2: string[] expected";
            }
            if (message.pitchChoice != null && message.hasOwnProperty("pitchChoice")) {
                if (!Array.isArray(message.pitchChoice))
                    return "pitchChoice: array expected";
                for (var i = 0; i < message.pitchChoice.length; ++i)
                    switch (message.pitchChoice[i]) {
                    default:
                        return "pitchChoice: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    }
            }
            if (message.pitchChoiceParm1 != null && message.hasOwnProperty("pitchChoiceParm1")) {
                if (!Array.isArray(message.pitchChoiceParm1))
                    return "pitchChoiceParm1: array expected";
                for (var i = 0; i < message.pitchChoiceParm1.length; ++i)
                    if (!$util.isString(message.pitchChoiceParm1[i]))
                        return "pitchChoiceParm1: string[] expected";
            }
            if (message.pitchChoiceParm2 != null && message.hasOwnProperty("pitchChoiceParm2")) {
                if (!Array.isArray(message.pitchChoiceParm2))
                    return "pitchChoiceParm2: array expected";
                for (var i = 0; i < message.pitchChoiceParm2.length; ++i)
                    if (!$util.isString(message.pitchChoiceParm2[i]))
                        return "pitchChoiceParm2: string[] expected";
            }
            if (message.tuning != null && message.hasOwnProperty("tuning")) {
                if (!Array.isArray(message.tuning))
                    return "tuning: array expected";
                for (var i = 0; i < message.tuning.length; ++i)
                    switch (message.tuning[i]) {
                    default:
                        return "tuning: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
            }
            if (message.tuningParm != null && message.hasOwnProperty("tuningParm")) {
                if (!Array.isArray(message.tuningParm))
                    return "tuningParm: array expected";
                for (var i = 0; i < message.tuningParm.length; ++i)
                    if (!$util.isString(message.tuningParm[i]))
                        return "tuningParm: string[] expected";
            }
            if (message.registers != null && message.hasOwnProperty("registers")) {
                if (!Array.isArray(message.registers))
                    return "registers: array expected";
                for (var i = 0; i < message.registers.length; ++i) {
                    var error = $root.ItemdefInstrument.InstrumentRegister.verify(message.registers[i]);
                    if (error)
                        return "registers." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates an InstrumentDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ItemdefInstrument.InstrumentDef} InstrumentDef
         */
        InstrumentDef.fromObject = function fromObject(object) {
            if (object instanceof $root.ItemdefInstrument.InstrumentDef)
                return object;
            var message = new $root.ItemdefInstrument.InstrumentDef();
            if (object.flags != null) {
                if (typeof object.flags !== "object")
                    throw TypeError(".ItemdefInstrument.InstrumentDef.flags: object expected");
                message.flags = $root.ItemdefInstrument.InstrumentFlags.fromObject(object.flags);
            }
            if (object.size != null)
                message.size = object.size | 0;
            if (object.value != null)
                message.value = object.value | 0;
            if (object.materialSize != null)
                message.materialSize = object.materialSize | 0;
            if (object.pieces) {
                if (!Array.isArray(object.pieces))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pieces: array expected");
                message.pieces = [];
                for (var i = 0; i < object.pieces.length; ++i) {
                    if (typeof object.pieces[i] !== "object")
                        throw TypeError(".ItemdefInstrument.InstrumentDef.pieces: object expected");
                    message.pieces[i] = $root.ItemdefInstrument.InstrumentPiece.fromObject(object.pieces[i]);
                }
            }
            if (object.pitchRangeMin != null)
                message.pitchRangeMin = object.pitchRangeMin | 0;
            if (object.pitchRangeMax != null)
                message.pitchRangeMax = object.pitchRangeMax | 0;
            if (object.volumeMbMin != null)
                message.volumeMbMin = object.volumeMbMin | 0;
            if (object.volumeMbMax != null)
                message.volumeMbMax = object.volumeMbMax | 0;
            if (object.soundProduction) {
                if (!Array.isArray(object.soundProduction))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.soundProduction: array expected");
                message.soundProduction = [];
                for (var i = 0; i < object.soundProduction.length; ++i)
                    switch (object.soundProduction[i]) {
                    default:
                    case "PLUCKED_BY_BP":
                    case 0:
                        message.soundProduction[i] = 0;
                        break;
                    case "PLUCKED":
                    case 1:
                        message.soundProduction[i] = 1;
                        break;
                    case "BOWED":
                    case 2:
                        message.soundProduction[i] = 2;
                        break;
                    case "STRUCK_BY_BP":
                    case 3:
                        message.soundProduction[i] = 3;
                        break;
                    case "STRUCK":
                    case 4:
                        message.soundProduction[i] = 4;
                        break;
                    case "VIBRATE_BP_AGAINST_OPENING":
                    case 5:
                        message.soundProduction[i] = 5;
                        break;
                    case "BLOW_AGAINST_FIPPLE":
                    case 6:
                        message.soundProduction[i] = 6;
                        break;
                    case "BLOW_OVER_OPENING_SIDE":
                    case 7:
                        message.soundProduction[i] = 7;
                        break;
                    case "BLOW_OVER_OPENING_END":
                    case 8:
                        message.soundProduction[i] = 8;
                        break;
                    case "BLOW_OVER_SINGLE_REED":
                    case 9:
                        message.soundProduction[i] = 9;
                        break;
                    case "BLOW_OVER_DOUBLE_REED":
                    case 10:
                        message.soundProduction[i] = 10;
                        break;
                    case "BLOW_OVER_FREE_REED":
                    case 11:
                        message.soundProduction[i] = 11;
                        break;
                    case "STRUCK_TOGETHER":
                    case 12:
                        message.soundProduction[i] = 12;
                        break;
                    case "SHAKEN":
                    case 13:
                        message.soundProduction[i] = 13;
                        break;
                    case "SCRAPED":
                    case 14:
                        message.soundProduction[i] = 14;
                        break;
                    case "FRICTION":
                    case 15:
                        message.soundProduction[i] = 15;
                        break;
                    case "RESONATOR":
                    case 16:
                        message.soundProduction[i] = 16;
                        break;
                    case "BAG_OVER_REED":
                    case 17:
                        message.soundProduction[i] = 17;
                        break;
                    case "AIR_OVER_REED":
                    case 18:
                        message.soundProduction[i] = 18;
                        break;
                    case "AIR_OVER_FREE_REED":
                    case 19:
                        message.soundProduction[i] = 19;
                        break;
                    case "AIR_AGAINST_FIPPLE":
                    case 20:
                        message.soundProduction[i] = 20;
                        break;
                    }
            }
            if (object.soundProductionParm1) {
                if (!Array.isArray(object.soundProductionParm1))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.soundProductionParm1: array expected");
                message.soundProductionParm1 = [];
                for (var i = 0; i < object.soundProductionParm1.length; ++i)
                    message.soundProductionParm1[i] = String(object.soundProductionParm1[i]);
            }
            if (object.soundProductionParm2) {
                if (!Array.isArray(object.soundProductionParm2))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.soundProductionParm2: array expected");
                message.soundProductionParm2 = [];
                for (var i = 0; i < object.soundProductionParm2.length; ++i)
                    message.soundProductionParm2[i] = String(object.soundProductionParm2[i]);
            }
            if (object.pitchChoice) {
                if (!Array.isArray(object.pitchChoice))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pitchChoice: array expected");
                message.pitchChoice = [];
                for (var i = 0; i < object.pitchChoice.length; ++i)
                    switch (object.pitchChoice[i]) {
                    default:
                    case "MEMBRANE_POSITION":
                    case 0:
                        message.pitchChoice[i] = 0;
                        break;
                    case "SUBPART_CHOICE":
                    case 1:
                        message.pitchChoice[i] = 1;
                        break;
                    case "KEYBOARD":
                    case 2:
                        message.pitchChoice[i] = 2;
                        break;
                    case "STOPPING_FRET":
                    case 3:
                        message.pitchChoice[i] = 3;
                        break;
                    case "STOPPING_AGAINST_BODY":
                    case 4:
                        message.pitchChoice[i] = 4;
                        break;
                    case "STOPPING_HOLE":
                    case 5:
                        message.pitchChoice[i] = 5;
                        break;
                    case "STOPPING_HOLE_KEY":
                    case 6:
                        message.pitchChoice[i] = 6;
                        break;
                    case "SLIDE":
                    case 7:
                        message.pitchChoice[i] = 7;
                        break;
                    case "HARMONIC_SERIES":
                    case 8:
                        message.pitchChoice[i] = 8;
                        break;
                    case "VALVE_ROUTES_AIR":
                    case 9:
                        message.pitchChoice[i] = 9;
                        break;
                    case "BP_IN_BELL":
                    case 10:
                        message.pitchChoice[i] = 10;
                        break;
                    case "FOOT_PEDALS":
                    case 11:
                        message.pitchChoice[i] = 11;
                        break;
                    }
            }
            if (object.pitchChoiceParm1) {
                if (!Array.isArray(object.pitchChoiceParm1))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pitchChoiceParm1: array expected");
                message.pitchChoiceParm1 = [];
                for (var i = 0; i < object.pitchChoiceParm1.length; ++i)
                    message.pitchChoiceParm1[i] = String(object.pitchChoiceParm1[i]);
            }
            if (object.pitchChoiceParm2) {
                if (!Array.isArray(object.pitchChoiceParm2))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.pitchChoiceParm2: array expected");
                message.pitchChoiceParm2 = [];
                for (var i = 0; i < object.pitchChoiceParm2.length; ++i)
                    message.pitchChoiceParm2[i] = String(object.pitchChoiceParm2[i]);
            }
            if (object.tuning) {
                if (!Array.isArray(object.tuning))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.tuning: array expected");
                message.tuning = [];
                for (var i = 0; i < object.tuning.length; ++i)
                    switch (object.tuning[i]) {
                    default:
                    case "PEGS":
                    case 0:
                        message.tuning[i] = 0;
                        break;
                    case "ADJUSTABLE_BRIDGES":
                    case 1:
                        message.tuning[i] = 1;
                        break;
                    case "CROOKS":
                    case 2:
                        message.tuning[i] = 2;
                        break;
                    case "TIGHTENING":
                    case 3:
                        message.tuning[i] = 3;
                        break;
                    case "LEVERS":
                    case 4:
                        message.tuning[i] = 4;
                        break;
                    }
            }
            if (object.tuningParm) {
                if (!Array.isArray(object.tuningParm))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.tuningParm: array expected");
                message.tuningParm = [];
                for (var i = 0; i < object.tuningParm.length; ++i)
                    message.tuningParm[i] = String(object.tuningParm[i]);
            }
            if (object.registers) {
                if (!Array.isArray(object.registers))
                    throw TypeError(".ItemdefInstrument.InstrumentDef.registers: array expected");
                message.registers = [];
                for (var i = 0; i < object.registers.length; ++i) {
                    if (typeof object.registers[i] !== "object")
                        throw TypeError(".ItemdefInstrument.InstrumentDef.registers: object expected");
                    message.registers[i] = $root.ItemdefInstrument.InstrumentRegister.fromObject(object.registers[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from an InstrumentDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ItemdefInstrument.InstrumentDef
         * @static
         * @param {ItemdefInstrument.InstrumentDef} message InstrumentDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstrumentDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pieces = [];
                object.soundProduction = [];
                object.soundProductionParm1 = [];
                object.soundProductionParm2 = [];
                object.pitchChoice = [];
                object.pitchChoiceParm1 = [];
                object.pitchChoiceParm2 = [];
                object.tuning = [];
                object.tuningParm = [];
                object.registers = [];
            }
            if (options.defaults) {
                object.flags = null;
                object.size = 0;
                object.value = 0;
                object.materialSize = 0;
                object.pitchRangeMin = 0;
                object.pitchRangeMax = 0;
                object.volumeMbMin = 0;
                object.volumeMbMax = 0;
                object.description = "";
            }
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = $root.ItemdefInstrument.InstrumentFlags.toObject(message.flags, options);
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.materialSize != null && message.hasOwnProperty("materialSize"))
                object.materialSize = message.materialSize;
            if (message.pieces && message.pieces.length) {
                object.pieces = [];
                for (var j = 0; j < message.pieces.length; ++j)
                    object.pieces[j] = $root.ItemdefInstrument.InstrumentPiece.toObject(message.pieces[j], options);
            }
            if (message.pitchRangeMin != null && message.hasOwnProperty("pitchRangeMin"))
                object.pitchRangeMin = message.pitchRangeMin;
            if (message.pitchRangeMax != null && message.hasOwnProperty("pitchRangeMax"))
                object.pitchRangeMax = message.pitchRangeMax;
            if (message.volumeMbMin != null && message.hasOwnProperty("volumeMbMin"))
                object.volumeMbMin = message.volumeMbMin;
            if (message.volumeMbMax != null && message.hasOwnProperty("volumeMbMax"))
                object.volumeMbMax = message.volumeMbMax;
            if (message.soundProduction && message.soundProduction.length) {
                object.soundProduction = [];
                for (var j = 0; j < message.soundProduction.length; ++j)
                    object.soundProduction[j] = options.enums === String ? $root.ItemdefInstrument.SoundProductionType[message.soundProduction[j]] : message.soundProduction[j];
            }
            if (message.soundProductionParm1 && message.soundProductionParm1.length) {
                object.soundProductionParm1 = [];
                for (var j = 0; j < message.soundProductionParm1.length; ++j)
                    object.soundProductionParm1[j] = message.soundProductionParm1[j];
            }
            if (message.soundProductionParm2 && message.soundProductionParm2.length) {
                object.soundProductionParm2 = [];
                for (var j = 0; j < message.soundProductionParm2.length; ++j)
                    object.soundProductionParm2[j] = message.soundProductionParm2[j];
            }
            if (message.pitchChoice && message.pitchChoice.length) {
                object.pitchChoice = [];
                for (var j = 0; j < message.pitchChoice.length; ++j)
                    object.pitchChoice[j] = options.enums === String ? $root.ItemdefInstrument.PitchChoiceType[message.pitchChoice[j]] : message.pitchChoice[j];
            }
            if (message.pitchChoiceParm1 && message.pitchChoiceParm1.length) {
                object.pitchChoiceParm1 = [];
                for (var j = 0; j < message.pitchChoiceParm1.length; ++j)
                    object.pitchChoiceParm1[j] = message.pitchChoiceParm1[j];
            }
            if (message.pitchChoiceParm2 && message.pitchChoiceParm2.length) {
                object.pitchChoiceParm2 = [];
                for (var j = 0; j < message.pitchChoiceParm2.length; ++j)
                    object.pitchChoiceParm2[j] = message.pitchChoiceParm2[j];
            }
            if (message.tuning && message.tuning.length) {
                object.tuning = [];
                for (var j = 0; j < message.tuning.length; ++j)
                    object.tuning[j] = options.enums === String ? $root.ItemdefInstrument.TuningType[message.tuning[j]] : message.tuning[j];
            }
            if (message.tuningParm && message.tuningParm.length) {
                object.tuningParm = [];
                for (var j = 0; j < message.tuningParm.length; ++j)
                    object.tuningParm[j] = message.tuningParm[j];
            }
            if (message.registers && message.registers.length) {
                object.registers = [];
                for (var j = 0; j < message.registers.length; ++j)
                    object.registers[j] = $root.ItemdefInstrument.InstrumentRegister.toObject(message.registers[j], options);
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this InstrumentDef to JSON.
         * @function toJSON
         * @memberof ItemdefInstrument.InstrumentDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstrumentDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstrumentDef;
    })();

    return ItemdefInstrument;
})();

$root.isoworldremote = (function() {

    /**
     * Namespace isoworldremote.
     * @exports isoworldremote
     * @namespace
     */
    var isoworldremote = {};

    /**
     * BasicMaterial enum.
     * @name isoworldremote.BasicMaterial
     * @enum {string}
     * @property {number} AIR=0 AIR value
     * @property {number} OTHER=1 OTHER value
     * @property {number} INORGANIC=2 INORGANIC value
     * @property {number} LIQUID=3 LIQUID value
     * @property {number} PLANT=4 PLANT value
     * @property {number} WOOD=5 WOOD value
     */
    isoworldremote.BasicMaterial = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AIR"] = 0;
        values[valuesById[1] = "OTHER"] = 1;
        values[valuesById[2] = "INORGANIC"] = 2;
        values[valuesById[3] = "LIQUID"] = 3;
        values[valuesById[4] = "PLANT"] = 4;
        values[valuesById[5] = "WOOD"] = 5;
        return values;
    })();

    /**
     * LiquidType enum.
     * @name isoworldremote.LiquidType
     * @enum {string}
     * @property {number} ICE=0 ICE value
     * @property {number} WATER=1 WATER value
     * @property {number} MAGMA=2 MAGMA value
     */
    isoworldremote.LiquidType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ICE"] = 0;
        values[valuesById[1] = "WATER"] = 1;
        values[valuesById[2] = "MAGMA"] = 2;
        return values;
    })();

    /**
     * BasicShape enum.
     * @name isoworldremote.BasicShape
     * @enum {string}
     * @property {number} NONE=0 NONE value
     * @property {number} OPEN=1 OPEN value
     * @property {number} WALL=3 WALL value
     * @property {number} FLOOR=4 FLOOR value
     * @property {number} RAMP_UP=5 RAMP_UP value
     * @property {number} RAMP_DOWN=6 RAMP_DOWN value
     */
    isoworldremote.BasicShape = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "OPEN"] = 1;
        values[valuesById[3] = "WALL"] = 3;
        values[valuesById[4] = "FLOOR"] = 4;
        values[valuesById[5] = "RAMP_UP"] = 5;
        values[valuesById[6] = "RAMP_DOWN"] = 6;
        return values;
    })();

    isoworldremote.ColorDefinition = (function() {

        /**
         * Properties of a ColorDefinition.
         * @memberof isoworldremote
         * @interface IColorDefinition
         * @property {number} red ColorDefinition red
         * @property {number} green ColorDefinition green
         * @property {number} blue ColorDefinition blue
         */

        /**
         * Constructs a new ColorDefinition.
         * @memberof isoworldremote
         * @classdesc Represents a ColorDefinition.
         * @implements IColorDefinition
         * @constructor
         * @param {isoworldremote.IColorDefinition=} [properties] Properties to set
         */
        function ColorDefinition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorDefinition red.
         * @member {number} red
         * @memberof isoworldremote.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.red = 0;

        /**
         * ColorDefinition green.
         * @member {number} green
         * @memberof isoworldremote.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.green = 0;

        /**
         * ColorDefinition blue.
         * @member {number} blue
         * @memberof isoworldremote.ColorDefinition
         * @instance
         */
        ColorDefinition.prototype.blue = 0;

        /**
         * Creates a new ColorDefinition instance using the specified properties.
         * @function create
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.IColorDefinition=} [properties] Properties to set
         * @returns {isoworldremote.ColorDefinition} ColorDefinition instance
         */
        ColorDefinition.create = function create(properties) {
            return new ColorDefinition(properties);
        };

        /**
         * Encodes the specified ColorDefinition message. Does not implicitly {@link isoworldremote.ColorDefinition.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.red);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.green);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.blue);
            return writer;
        };

        /**
         * Encodes the specified ColorDefinition message, length delimited. Does not implicitly {@link isoworldremote.ColorDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.IColorDefinition} message ColorDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.ColorDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.red = reader.int32();
                    break;
                case 2:
                    message.green = reader.int32();
                    break;
                case 3:
                    message.blue = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("red"))
                throw $util.ProtocolError("missing required 'red'", { instance: message });
            if (!message.hasOwnProperty("green"))
                throw $util.ProtocolError("missing required 'green'", { instance: message });
            if (!message.hasOwnProperty("blue"))
                throw $util.ProtocolError("missing required 'blue'", { instance: message });
            return message;
        };

        /**
         * Decodes a ColorDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.ColorDefinition} ColorDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorDefinition message.
         * @function verify
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.red))
                return "red: integer expected";
            if (!$util.isInteger(message.green))
                return "green: integer expected";
            if (!$util.isInteger(message.blue))
                return "blue: integer expected";
            return null;
        };

        /**
         * Creates a ColorDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.ColorDefinition} ColorDefinition
         */
        ColorDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.ColorDefinition)
                return object;
            var message = new $root.isoworldremote.ColorDefinition();
            if (object.red != null)
                message.red = object.red | 0;
            if (object.green != null)
                message.green = object.green | 0;
            if (object.blue != null)
                message.blue = object.blue | 0;
            return message;
        };

        /**
         * Creates a plain object from a ColorDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.ColorDefinition
         * @static
         * @param {isoworldremote.ColorDefinition} message ColorDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.red = 0;
                object.green = 0;
                object.blue = 0;
            }
            if (message.red != null && message.hasOwnProperty("red"))
                object.red = message.red;
            if (message.green != null && message.hasOwnProperty("green"))
                object.green = message.green;
            if (message.blue != null && message.hasOwnProperty("blue"))
                object.blue = message.blue;
            return object;
        };

        /**
         * Converts this ColorDefinition to JSON.
         * @function toJSON
         * @memberof isoworldremote.ColorDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ColorDefinition;
    })();

    isoworldremote.EmbarkTileLayer = (function() {

        /**
         * Properties of an EmbarkTileLayer.
         * @memberof isoworldremote
         * @interface IEmbarkTileLayer
         * @property {Array.<isoworldremote.BasicMaterial>|null} [matTypeTable] EmbarkTileLayer matTypeTable
         * @property {Array.<number>|null} [matSubtypeTable] EmbarkTileLayer matSubtypeTable
         * @property {Array.<isoworldremote.BasicShape>|null} [tileShapeTable] EmbarkTileLayer tileShapeTable
         * @property {Array.<isoworldremote.IColorDefinition>|null} [tileColorTable] EmbarkTileLayer tileColorTable
         */

        /**
         * Constructs a new EmbarkTileLayer.
         * @memberof isoworldremote
         * @classdesc Represents an EmbarkTileLayer.
         * @implements IEmbarkTileLayer
         * @constructor
         * @param {isoworldremote.IEmbarkTileLayer=} [properties] Properties to set
         */
        function EmbarkTileLayer(properties) {
            this.matTypeTable = [];
            this.matSubtypeTable = [];
            this.tileShapeTable = [];
            this.tileColorTable = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmbarkTileLayer matTypeTable.
         * @member {Array.<isoworldremote.BasicMaterial>} matTypeTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.matTypeTable = $util.emptyArray;

        /**
         * EmbarkTileLayer matSubtypeTable.
         * @member {Array.<number>} matSubtypeTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.matSubtypeTable = $util.emptyArray;

        /**
         * EmbarkTileLayer tileShapeTable.
         * @member {Array.<isoworldremote.BasicShape>} tileShapeTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.tileShapeTable = $util.emptyArray;

        /**
         * EmbarkTileLayer tileColorTable.
         * @member {Array.<isoworldremote.IColorDefinition>} tileColorTable
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         */
        EmbarkTileLayer.prototype.tileColorTable = $util.emptyArray;

        /**
         * Creates a new EmbarkTileLayer instance using the specified properties.
         * @function create
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.IEmbarkTileLayer=} [properties] Properties to set
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer instance
         */
        EmbarkTileLayer.create = function create(properties) {
            return new EmbarkTileLayer(properties);
        };

        /**
         * Encodes the specified EmbarkTileLayer message. Does not implicitly {@link isoworldremote.EmbarkTileLayer.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.IEmbarkTileLayer} message EmbarkTileLayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTileLayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.matTypeTable != null && message.matTypeTable.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.matTypeTable.length; ++i)
                    writer.int32(message.matTypeTable[i]);
                writer.ldelim();
            }
            if (message.matSubtypeTable != null && message.matSubtypeTable.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.matSubtypeTable.length; ++i)
                    writer.int32(message.matSubtypeTable[i]);
                writer.ldelim();
            }
            if (message.tileShapeTable != null && message.tileShapeTable.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (var i = 0; i < message.tileShapeTable.length; ++i)
                    writer.int32(message.tileShapeTable[i]);
                writer.ldelim();
            }
            if (message.tileColorTable != null && message.tileColorTable.length)
                for (var i = 0; i < message.tileColorTable.length; ++i)
                    $root.isoworldremote.ColorDefinition.encode(message.tileColorTable[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EmbarkTileLayer message, length delimited. Does not implicitly {@link isoworldremote.EmbarkTileLayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.IEmbarkTileLayer} message EmbarkTileLayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTileLayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmbarkTileLayer message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTileLayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.EmbarkTileLayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    if (!(message.matTypeTable && message.matTypeTable.length))
                        message.matTypeTable = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.matTypeTable.push(reader.int32());
                    } else
                        message.matTypeTable.push(reader.int32());
                    break;
                case 5:
                    if (!(message.matSubtypeTable && message.matSubtypeTable.length))
                        message.matSubtypeTable = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.matSubtypeTable.push(reader.int32());
                    } else
                        message.matSubtypeTable.push(reader.int32());
                    break;
                case 6:
                    if (!(message.tileShapeTable && message.tileShapeTable.length))
                        message.tileShapeTable = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tileShapeTable.push(reader.int32());
                    } else
                        message.tileShapeTable.push(reader.int32());
                    break;
                case 7:
                    if (!(message.tileColorTable && message.tileColorTable.length))
                        message.tileColorTable = [];
                    message.tileColorTable.push($root.isoworldremote.ColorDefinition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmbarkTileLayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTileLayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmbarkTileLayer message.
         * @function verify
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmbarkTileLayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.matTypeTable != null && message.hasOwnProperty("matTypeTable")) {
                if (!Array.isArray(message.matTypeTable))
                    return "matTypeTable: array expected";
                for (var i = 0; i < message.matTypeTable.length; ++i)
                    switch (message.matTypeTable[i]) {
                    default:
                        return "matTypeTable: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
            }
            if (message.matSubtypeTable != null && message.hasOwnProperty("matSubtypeTable")) {
                if (!Array.isArray(message.matSubtypeTable))
                    return "matSubtypeTable: array expected";
                for (var i = 0; i < message.matSubtypeTable.length; ++i)
                    if (!$util.isInteger(message.matSubtypeTable[i]))
                        return "matSubtypeTable: integer[] expected";
            }
            if (message.tileShapeTable != null && message.hasOwnProperty("tileShapeTable")) {
                if (!Array.isArray(message.tileShapeTable))
                    return "tileShapeTable: array expected";
                for (var i = 0; i < message.tileShapeTable.length; ++i)
                    switch (message.tileShapeTable[i]) {
                    default:
                        return "tileShapeTable: enum value[] expected";
                    case 0:
                    case 1:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
            }
            if (message.tileColorTable != null && message.hasOwnProperty("tileColorTable")) {
                if (!Array.isArray(message.tileColorTable))
                    return "tileColorTable: array expected";
                for (var i = 0; i < message.tileColorTable.length; ++i) {
                    var error = $root.isoworldremote.ColorDefinition.verify(message.tileColorTable[i]);
                    if (error)
                        return "tileColorTable." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EmbarkTileLayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.EmbarkTileLayer} EmbarkTileLayer
         */
        EmbarkTileLayer.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.EmbarkTileLayer)
                return object;
            var message = new $root.isoworldremote.EmbarkTileLayer();
            if (object.matTypeTable) {
                if (!Array.isArray(object.matTypeTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.matTypeTable: array expected");
                message.matTypeTable = [];
                for (var i = 0; i < object.matTypeTable.length; ++i)
                    switch (object.matTypeTable[i]) {
                    default:
                    case "AIR":
                    case 0:
                        message.matTypeTable[i] = 0;
                        break;
                    case "OTHER":
                    case 1:
                        message.matTypeTable[i] = 1;
                        break;
                    case "INORGANIC":
                    case 2:
                        message.matTypeTable[i] = 2;
                        break;
                    case "LIQUID":
                    case 3:
                        message.matTypeTable[i] = 3;
                        break;
                    case "PLANT":
                    case 4:
                        message.matTypeTable[i] = 4;
                        break;
                    case "WOOD":
                    case 5:
                        message.matTypeTable[i] = 5;
                        break;
                    }
            }
            if (object.matSubtypeTable) {
                if (!Array.isArray(object.matSubtypeTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.matSubtypeTable: array expected");
                message.matSubtypeTable = [];
                for (var i = 0; i < object.matSubtypeTable.length; ++i)
                    message.matSubtypeTable[i] = object.matSubtypeTable[i] | 0;
            }
            if (object.tileShapeTable) {
                if (!Array.isArray(object.tileShapeTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.tileShapeTable: array expected");
                message.tileShapeTable = [];
                for (var i = 0; i < object.tileShapeTable.length; ++i)
                    switch (object.tileShapeTable[i]) {
                    default:
                    case "NONE":
                    case 0:
                        message.tileShapeTable[i] = 0;
                        break;
                    case "OPEN":
                    case 1:
                        message.tileShapeTable[i] = 1;
                        break;
                    case "WALL":
                    case 3:
                        message.tileShapeTable[i] = 3;
                        break;
                    case "FLOOR":
                    case 4:
                        message.tileShapeTable[i] = 4;
                        break;
                    case "RAMP_UP":
                    case 5:
                        message.tileShapeTable[i] = 5;
                        break;
                    case "RAMP_DOWN":
                    case 6:
                        message.tileShapeTable[i] = 6;
                        break;
                    }
            }
            if (object.tileColorTable) {
                if (!Array.isArray(object.tileColorTable))
                    throw TypeError(".isoworldremote.EmbarkTileLayer.tileColorTable: array expected");
                message.tileColorTable = [];
                for (var i = 0; i < object.tileColorTable.length; ++i) {
                    if (typeof object.tileColorTable[i] !== "object")
                        throw TypeError(".isoworldremote.EmbarkTileLayer.tileColorTable: object expected");
                    message.tileColorTable[i] = $root.isoworldremote.ColorDefinition.fromObject(object.tileColorTable[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an EmbarkTileLayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.EmbarkTileLayer
         * @static
         * @param {isoworldremote.EmbarkTileLayer} message EmbarkTileLayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmbarkTileLayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.matTypeTable = [];
                object.matSubtypeTable = [];
                object.tileShapeTable = [];
                object.tileColorTable = [];
            }
            if (message.matTypeTable && message.matTypeTable.length) {
                object.matTypeTable = [];
                for (var j = 0; j < message.matTypeTable.length; ++j)
                    object.matTypeTable[j] = options.enums === String ? $root.isoworldremote.BasicMaterial[message.matTypeTable[j]] : message.matTypeTable[j];
            }
            if (message.matSubtypeTable && message.matSubtypeTable.length) {
                object.matSubtypeTable = [];
                for (var j = 0; j < message.matSubtypeTable.length; ++j)
                    object.matSubtypeTable[j] = message.matSubtypeTable[j];
            }
            if (message.tileShapeTable && message.tileShapeTable.length) {
                object.tileShapeTable = [];
                for (var j = 0; j < message.tileShapeTable.length; ++j)
                    object.tileShapeTable[j] = options.enums === String ? $root.isoworldremote.BasicShape[message.tileShapeTable[j]] : message.tileShapeTable[j];
            }
            if (message.tileColorTable && message.tileColorTable.length) {
                object.tileColorTable = [];
                for (var j = 0; j < message.tileColorTable.length; ++j)
                    object.tileColorTable[j] = $root.isoworldremote.ColorDefinition.toObject(message.tileColorTable[j], options);
            }
            return object;
        };

        /**
         * Converts this EmbarkTileLayer to JSON.
         * @function toJSON
         * @memberof isoworldremote.EmbarkTileLayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmbarkTileLayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmbarkTileLayer;
    })();

    isoworldremote.EmbarkTile = (function() {

        /**
         * Properties of an EmbarkTile.
         * @memberof isoworldremote
         * @interface IEmbarkTile
         * @property {number} worldX EmbarkTile worldX
         * @property {number} worldY EmbarkTile worldY
         * @property {number} worldZ EmbarkTile worldZ
         * @property {Array.<isoworldremote.IEmbarkTileLayer>|null} [tileLayer] EmbarkTile tileLayer
         * @property {number|null} [currentYear] EmbarkTile currentYear
         * @property {number|null} [currentSeason] EmbarkTile currentSeason
         * @property {boolean|null} [isValid] EmbarkTile isValid
         */

        /**
         * Constructs a new EmbarkTile.
         * @memberof isoworldremote
         * @classdesc Represents an EmbarkTile.
         * @implements IEmbarkTile
         * @constructor
         * @param {isoworldremote.IEmbarkTile=} [properties] Properties to set
         */
        function EmbarkTile(properties) {
            this.tileLayer = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmbarkTile worldX.
         * @member {number} worldX
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.worldX = 0;

        /**
         * EmbarkTile worldY.
         * @member {number} worldY
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.worldY = 0;

        /**
         * EmbarkTile worldZ.
         * @member {number} worldZ
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.worldZ = 0;

        /**
         * EmbarkTile tileLayer.
         * @member {Array.<isoworldremote.IEmbarkTileLayer>} tileLayer
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.tileLayer = $util.emptyArray;

        /**
         * EmbarkTile currentYear.
         * @member {number} currentYear
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.currentYear = 0;

        /**
         * EmbarkTile currentSeason.
         * @member {number} currentSeason
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.currentSeason = 0;

        /**
         * EmbarkTile isValid.
         * @member {boolean} isValid
         * @memberof isoworldremote.EmbarkTile
         * @instance
         */
        EmbarkTile.prototype.isValid = false;

        /**
         * Creates a new EmbarkTile instance using the specified properties.
         * @function create
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.IEmbarkTile=} [properties] Properties to set
         * @returns {isoworldremote.EmbarkTile} EmbarkTile instance
         */
        EmbarkTile.create = function create(properties) {
            return new EmbarkTile(properties);
        };

        /**
         * Encodes the specified EmbarkTile message. Does not implicitly {@link isoworldremote.EmbarkTile.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.IEmbarkTile} message EmbarkTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.worldX);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.worldY);
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.worldZ);
            if (message.tileLayer != null && message.tileLayer.length)
                for (var i = 0; i < message.tileLayer.length; ++i)
                    $root.isoworldremote.EmbarkTileLayer.encode(message.tileLayer[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.currentYear != null && Object.hasOwnProperty.call(message, "currentYear"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.currentYear);
            if (message.currentSeason != null && Object.hasOwnProperty.call(message, "currentSeason"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.currentSeason);
            if (message.isValid != null && Object.hasOwnProperty.call(message, "isValid"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isValid);
            return writer;
        };

        /**
         * Encodes the specified EmbarkTile message, length delimited. Does not implicitly {@link isoworldremote.EmbarkTile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.IEmbarkTile} message EmbarkTile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmbarkTile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmbarkTile message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.EmbarkTile} EmbarkTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.EmbarkTile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldX = reader.int32();
                    break;
                case 2:
                    message.worldY = reader.int32();
                    break;
                case 3:
                    message.worldZ = reader.sint32();
                    break;
                case 4:
                    if (!(message.tileLayer && message.tileLayer.length))
                        message.tileLayer = [];
                    message.tileLayer.push($root.isoworldremote.EmbarkTileLayer.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.currentYear = reader.int32();
                    break;
                case 6:
                    message.currentSeason = reader.int32();
                    break;
                case 7:
                    message.isValid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("worldX"))
                throw $util.ProtocolError("missing required 'worldX'", { instance: message });
            if (!message.hasOwnProperty("worldY"))
                throw $util.ProtocolError("missing required 'worldY'", { instance: message });
            if (!message.hasOwnProperty("worldZ"))
                throw $util.ProtocolError("missing required 'worldZ'", { instance: message });
            return message;
        };

        /**
         * Decodes an EmbarkTile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.EmbarkTile} EmbarkTile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmbarkTile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmbarkTile message.
         * @function verify
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmbarkTile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.worldX))
                return "worldX: integer expected";
            if (!$util.isInteger(message.worldY))
                return "worldY: integer expected";
            if (!$util.isInteger(message.worldZ))
                return "worldZ: integer expected";
            if (message.tileLayer != null && message.hasOwnProperty("tileLayer")) {
                if (!Array.isArray(message.tileLayer))
                    return "tileLayer: array expected";
                for (var i = 0; i < message.tileLayer.length; ++i) {
                    var error = $root.isoworldremote.EmbarkTileLayer.verify(message.tileLayer[i]);
                    if (error)
                        return "tileLayer." + error;
                }
            }
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                if (!$util.isInteger(message.currentYear))
                    return "currentYear: integer expected";
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                if (!$util.isInteger(message.currentSeason))
                    return "currentSeason: integer expected";
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                if (typeof message.isValid !== "boolean")
                    return "isValid: boolean expected";
            return null;
        };

        /**
         * Creates an EmbarkTile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.EmbarkTile} EmbarkTile
         */
        EmbarkTile.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.EmbarkTile)
                return object;
            var message = new $root.isoworldremote.EmbarkTile();
            if (object.worldX != null)
                message.worldX = object.worldX | 0;
            if (object.worldY != null)
                message.worldY = object.worldY | 0;
            if (object.worldZ != null)
                message.worldZ = object.worldZ | 0;
            if (object.tileLayer) {
                if (!Array.isArray(object.tileLayer))
                    throw TypeError(".isoworldremote.EmbarkTile.tileLayer: array expected");
                message.tileLayer = [];
                for (var i = 0; i < object.tileLayer.length; ++i) {
                    if (typeof object.tileLayer[i] !== "object")
                        throw TypeError(".isoworldremote.EmbarkTile.tileLayer: object expected");
                    message.tileLayer[i] = $root.isoworldremote.EmbarkTileLayer.fromObject(object.tileLayer[i]);
                }
            }
            if (object.currentYear != null)
                message.currentYear = object.currentYear | 0;
            if (object.currentSeason != null)
                message.currentSeason = object.currentSeason | 0;
            if (object.isValid != null)
                message.isValid = Boolean(object.isValid);
            return message;
        };

        /**
         * Creates a plain object from an EmbarkTile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.EmbarkTile
         * @static
         * @param {isoworldremote.EmbarkTile} message EmbarkTile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmbarkTile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tileLayer = [];
            if (options.defaults) {
                object.worldX = 0;
                object.worldY = 0;
                object.worldZ = 0;
                object.currentYear = 0;
                object.currentSeason = 0;
                object.isValid = false;
            }
            if (message.worldX != null && message.hasOwnProperty("worldX"))
                object.worldX = message.worldX;
            if (message.worldY != null && message.hasOwnProperty("worldY"))
                object.worldY = message.worldY;
            if (message.worldZ != null && message.hasOwnProperty("worldZ"))
                object.worldZ = message.worldZ;
            if (message.tileLayer && message.tileLayer.length) {
                object.tileLayer = [];
                for (var j = 0; j < message.tileLayer.length; ++j)
                    object.tileLayer[j] = $root.isoworldremote.EmbarkTileLayer.toObject(message.tileLayer[j], options);
            }
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                object.currentYear = message.currentYear;
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                object.currentSeason = message.currentSeason;
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                object.isValid = message.isValid;
            return object;
        };

        /**
         * Converts this EmbarkTile to JSON.
         * @function toJSON
         * @memberof isoworldremote.EmbarkTile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmbarkTile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmbarkTile;
    })();

    isoworldremote.TileRequest = (function() {

        /**
         * Properties of a TileRequest.
         * @memberof isoworldremote
         * @interface ITileRequest
         * @property {number|null} [wantX] TileRequest wantX
         * @property {number|null} [wantY] TileRequest wantY
         */

        /**
         * Constructs a new TileRequest.
         * @memberof isoworldremote
         * @classdesc Represents a TileRequest.
         * @implements ITileRequest
         * @constructor
         * @param {isoworldremote.ITileRequest=} [properties] Properties to set
         */
        function TileRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TileRequest wantX.
         * @member {number} wantX
         * @memberof isoworldremote.TileRequest
         * @instance
         */
        TileRequest.prototype.wantX = 0;

        /**
         * TileRequest wantY.
         * @member {number} wantY
         * @memberof isoworldremote.TileRequest
         * @instance
         */
        TileRequest.prototype.wantY = 0;

        /**
         * Creates a new TileRequest instance using the specified properties.
         * @function create
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.ITileRequest=} [properties] Properties to set
         * @returns {isoworldremote.TileRequest} TileRequest instance
         */
        TileRequest.create = function create(properties) {
            return new TileRequest(properties);
        };

        /**
         * Encodes the specified TileRequest message. Does not implicitly {@link isoworldremote.TileRequest.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.ITileRequest} message TileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TileRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wantX != null && Object.hasOwnProperty.call(message, "wantX"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.wantX);
            if (message.wantY != null && Object.hasOwnProperty.call(message, "wantY"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.wantY);
            return writer;
        };

        /**
         * Encodes the specified TileRequest message, length delimited. Does not implicitly {@link isoworldremote.TileRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.ITileRequest} message TileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TileRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TileRequest message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.TileRequest} TileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TileRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.TileRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.wantX = reader.int32();
                    break;
                case 2:
                    message.wantY = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TileRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.TileRequest} TileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TileRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TileRequest message.
         * @function verify
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TileRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wantX != null && message.hasOwnProperty("wantX"))
                if (!$util.isInteger(message.wantX))
                    return "wantX: integer expected";
            if (message.wantY != null && message.hasOwnProperty("wantY"))
                if (!$util.isInteger(message.wantY))
                    return "wantY: integer expected";
            return null;
        };

        /**
         * Creates a TileRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.TileRequest} TileRequest
         */
        TileRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.TileRequest)
                return object;
            var message = new $root.isoworldremote.TileRequest();
            if (object.wantX != null)
                message.wantX = object.wantX | 0;
            if (object.wantY != null)
                message.wantY = object.wantY | 0;
            return message;
        };

        /**
         * Creates a plain object from a TileRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.TileRequest
         * @static
         * @param {isoworldremote.TileRequest} message TileRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TileRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.wantX = 0;
                object.wantY = 0;
            }
            if (message.wantX != null && message.hasOwnProperty("wantX"))
                object.wantX = message.wantX;
            if (message.wantY != null && message.hasOwnProperty("wantY"))
                object.wantY = message.wantY;
            return object;
        };

        /**
         * Converts this TileRequest to JSON.
         * @function toJSON
         * @memberof isoworldremote.TileRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TileRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TileRequest;
    })();

    isoworldremote.MapRequest = (function() {

        /**
         * Properties of a MapRequest.
         * @memberof isoworldremote
         * @interface IMapRequest
         * @property {string|null} [saveFolder] MapRequest saveFolder
         */

        /**
         * Constructs a new MapRequest.
         * @memberof isoworldremote
         * @classdesc Represents a MapRequest.
         * @implements IMapRequest
         * @constructor
         * @param {isoworldremote.IMapRequest=} [properties] Properties to set
         */
        function MapRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapRequest saveFolder.
         * @member {string} saveFolder
         * @memberof isoworldremote.MapRequest
         * @instance
         */
        MapRequest.prototype.saveFolder = "";

        /**
         * Creates a new MapRequest instance using the specified properties.
         * @function create
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.IMapRequest=} [properties] Properties to set
         * @returns {isoworldremote.MapRequest} MapRequest instance
         */
        MapRequest.create = function create(properties) {
            return new MapRequest(properties);
        };

        /**
         * Encodes the specified MapRequest message. Does not implicitly {@link isoworldremote.MapRequest.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.IMapRequest} message MapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.saveFolder != null && Object.hasOwnProperty.call(message, "saveFolder"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.saveFolder);
            return writer;
        };

        /**
         * Encodes the specified MapRequest message, length delimited. Does not implicitly {@link isoworldremote.MapRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.IMapRequest} message MapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapRequest message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.MapRequest} MapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.MapRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.saveFolder = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.MapRequest} MapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapRequest message.
         * @function verify
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.saveFolder != null && message.hasOwnProperty("saveFolder"))
                if (!$util.isString(message.saveFolder))
                    return "saveFolder: string expected";
            return null;
        };

        /**
         * Creates a MapRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.MapRequest} MapRequest
         */
        MapRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.MapRequest)
                return object;
            var message = new $root.isoworldremote.MapRequest();
            if (object.saveFolder != null)
                message.saveFolder = String(object.saveFolder);
            return message;
        };

        /**
         * Creates a plain object from a MapRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.MapRequest
         * @static
         * @param {isoworldremote.MapRequest} message MapRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.saveFolder = "";
            if (message.saveFolder != null && message.hasOwnProperty("saveFolder"))
                object.saveFolder = message.saveFolder;
            return object;
        };

        /**
         * Converts this MapRequest to JSON.
         * @function toJSON
         * @memberof isoworldremote.MapRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapRequest;
    })();

    isoworldremote.MapReply = (function() {

        /**
         * Properties of a MapReply.
         * @memberof isoworldremote
         * @interface IMapReply
         * @property {boolean} available MapReply available
         * @property {number|null} [regionX] MapReply regionX
         * @property {number|null} [regionY] MapReply regionY
         * @property {number|null} [regionSizeX] MapReply regionSizeX
         * @property {number|null} [regionSizeY] MapReply regionSizeY
         * @property {number|null} [currentYear] MapReply currentYear
         * @property {number|null} [currentSeason] MapReply currentSeason
         */

        /**
         * Constructs a new MapReply.
         * @memberof isoworldremote
         * @classdesc Represents a MapReply.
         * @implements IMapReply
         * @constructor
         * @param {isoworldremote.IMapReply=} [properties] Properties to set
         */
        function MapReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapReply available.
         * @member {boolean} available
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.available = false;

        /**
         * MapReply regionX.
         * @member {number} regionX
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionX = 0;

        /**
         * MapReply regionY.
         * @member {number} regionY
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionY = 0;

        /**
         * MapReply regionSizeX.
         * @member {number} regionSizeX
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionSizeX = 0;

        /**
         * MapReply regionSizeY.
         * @member {number} regionSizeY
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.regionSizeY = 0;

        /**
         * MapReply currentYear.
         * @member {number} currentYear
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.currentYear = 0;

        /**
         * MapReply currentSeason.
         * @member {number} currentSeason
         * @memberof isoworldremote.MapReply
         * @instance
         */
        MapReply.prototype.currentSeason = 0;

        /**
         * Creates a new MapReply instance using the specified properties.
         * @function create
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.IMapReply=} [properties] Properties to set
         * @returns {isoworldremote.MapReply} MapReply instance
         */
        MapReply.create = function create(properties) {
            return new MapReply(properties);
        };

        /**
         * Encodes the specified MapReply message. Does not implicitly {@link isoworldremote.MapReply.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.IMapReply} message MapReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.available);
            if (message.regionX != null && Object.hasOwnProperty.call(message, "regionX"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.regionX);
            if (message.regionY != null && Object.hasOwnProperty.call(message, "regionY"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.regionY);
            if (message.regionSizeX != null && Object.hasOwnProperty.call(message, "regionSizeX"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.regionSizeX);
            if (message.regionSizeY != null && Object.hasOwnProperty.call(message, "regionSizeY"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.regionSizeY);
            if (message.currentYear != null && Object.hasOwnProperty.call(message, "currentYear"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.currentYear);
            if (message.currentSeason != null && Object.hasOwnProperty.call(message, "currentSeason"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.currentSeason);
            return writer;
        };

        /**
         * Encodes the specified MapReply message, length delimited. Does not implicitly {@link isoworldremote.MapReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.IMapReply} message MapReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapReply message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.MapReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.MapReply} MapReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.MapReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.available = reader.bool();
                    break;
                case 2:
                    message.regionX = reader.int32();
                    break;
                case 3:
                    message.regionY = reader.int32();
                    break;
                case 4:
                    message.regionSizeX = reader.int32();
                    break;
                case 5:
                    message.regionSizeY = reader.int32();
                    break;
                case 6:
                    message.currentYear = reader.int32();
                    break;
                case 7:
                    message.currentSeason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("available"))
                throw $util.ProtocolError("missing required 'available'", { instance: message });
            return message;
        };

        /**
         * Decodes a MapReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.MapReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.MapReply} MapReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapReply message.
         * @function verify
         * @memberof isoworldremote.MapReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.available !== "boolean")
                return "available: boolean expected";
            if (message.regionX != null && message.hasOwnProperty("regionX"))
                if (!$util.isInteger(message.regionX))
                    return "regionX: integer expected";
            if (message.regionY != null && message.hasOwnProperty("regionY"))
                if (!$util.isInteger(message.regionY))
                    return "regionY: integer expected";
            if (message.regionSizeX != null && message.hasOwnProperty("regionSizeX"))
                if (!$util.isInteger(message.regionSizeX))
                    return "regionSizeX: integer expected";
            if (message.regionSizeY != null && message.hasOwnProperty("regionSizeY"))
                if (!$util.isInteger(message.regionSizeY))
                    return "regionSizeY: integer expected";
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                if (!$util.isInteger(message.currentYear))
                    return "currentYear: integer expected";
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                if (!$util.isInteger(message.currentSeason))
                    return "currentSeason: integer expected";
            return null;
        };

        /**
         * Creates a MapReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.MapReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.MapReply} MapReply
         */
        MapReply.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.MapReply)
                return object;
            var message = new $root.isoworldremote.MapReply();
            if (object.available != null)
                message.available = Boolean(object.available);
            if (object.regionX != null)
                message.regionX = object.regionX | 0;
            if (object.regionY != null)
                message.regionY = object.regionY | 0;
            if (object.regionSizeX != null)
                message.regionSizeX = object.regionSizeX | 0;
            if (object.regionSizeY != null)
                message.regionSizeY = object.regionSizeY | 0;
            if (object.currentYear != null)
                message.currentYear = object.currentYear | 0;
            if (object.currentSeason != null)
                message.currentSeason = object.currentSeason | 0;
            return message;
        };

        /**
         * Creates a plain object from a MapReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.MapReply
         * @static
         * @param {isoworldremote.MapReply} message MapReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.available = false;
                object.regionX = 0;
                object.regionY = 0;
                object.regionSizeX = 0;
                object.regionSizeY = 0;
                object.currentYear = 0;
                object.currentSeason = 0;
            }
            if (message.available != null && message.hasOwnProperty("available"))
                object.available = message.available;
            if (message.regionX != null && message.hasOwnProperty("regionX"))
                object.regionX = message.regionX;
            if (message.regionY != null && message.hasOwnProperty("regionY"))
                object.regionY = message.regionY;
            if (message.regionSizeX != null && message.hasOwnProperty("regionSizeX"))
                object.regionSizeX = message.regionSizeX;
            if (message.regionSizeY != null && message.hasOwnProperty("regionSizeY"))
                object.regionSizeY = message.regionSizeY;
            if (message.currentYear != null && message.hasOwnProperty("currentYear"))
                object.currentYear = message.currentYear;
            if (message.currentSeason != null && message.hasOwnProperty("currentSeason"))
                object.currentSeason = message.currentSeason;
            return object;
        };

        /**
         * Converts this MapReply to JSON.
         * @function toJSON
         * @memberof isoworldremote.MapReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapReply;
    })();

    isoworldremote.RawNames = (function() {

        /**
         * Properties of a RawNames.
         * @memberof isoworldremote
         * @interface IRawNames
         * @property {boolean} available RawNames available
         * @property {Array.<string>|null} [inorganic] RawNames inorganic
         * @property {Array.<string>|null} [organic] RawNames organic
         */

        /**
         * Constructs a new RawNames.
         * @memberof isoworldremote
         * @classdesc Represents a RawNames.
         * @implements IRawNames
         * @constructor
         * @param {isoworldremote.IRawNames=} [properties] Properties to set
         */
        function RawNames(properties) {
            this.inorganic = [];
            this.organic = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RawNames available.
         * @member {boolean} available
         * @memberof isoworldremote.RawNames
         * @instance
         */
        RawNames.prototype.available = false;

        /**
         * RawNames inorganic.
         * @member {Array.<string>} inorganic
         * @memberof isoworldremote.RawNames
         * @instance
         */
        RawNames.prototype.inorganic = $util.emptyArray;

        /**
         * RawNames organic.
         * @member {Array.<string>} organic
         * @memberof isoworldremote.RawNames
         * @instance
         */
        RawNames.prototype.organic = $util.emptyArray;

        /**
         * Creates a new RawNames instance using the specified properties.
         * @function create
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.IRawNames=} [properties] Properties to set
         * @returns {isoworldremote.RawNames} RawNames instance
         */
        RawNames.create = function create(properties) {
            return new RawNames(properties);
        };

        /**
         * Encodes the specified RawNames message. Does not implicitly {@link isoworldremote.RawNames.verify|verify} messages.
         * @function encode
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.IRawNames} message RawNames message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RawNames.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.available);
            if (message.inorganic != null && message.inorganic.length)
                for (var i = 0; i < message.inorganic.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inorganic[i]);
            if (message.organic != null && message.organic.length)
                for (var i = 0; i < message.organic.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.organic[i]);
            return writer;
        };

        /**
         * Encodes the specified RawNames message, length delimited. Does not implicitly {@link isoworldremote.RawNames.verify|verify} messages.
         * @function encodeDelimited
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.IRawNames} message RawNames message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RawNames.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RawNames message from the specified reader or buffer.
         * @function decode
         * @memberof isoworldremote.RawNames
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {isoworldremote.RawNames} RawNames
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RawNames.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.isoworldremote.RawNames();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.available = reader.bool();
                    break;
                case 2:
                    if (!(message.inorganic && message.inorganic.length))
                        message.inorganic = [];
                    message.inorganic.push(reader.string());
                    break;
                case 3:
                    if (!(message.organic && message.organic.length))
                        message.organic = [];
                    message.organic.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("available"))
                throw $util.ProtocolError("missing required 'available'", { instance: message });
            return message;
        };

        /**
         * Decodes a RawNames message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof isoworldremote.RawNames
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {isoworldremote.RawNames} RawNames
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RawNames.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RawNames message.
         * @function verify
         * @memberof isoworldremote.RawNames
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RawNames.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.available !== "boolean")
                return "available: boolean expected";
            if (message.inorganic != null && message.hasOwnProperty("inorganic")) {
                if (!Array.isArray(message.inorganic))
                    return "inorganic: array expected";
                for (var i = 0; i < message.inorganic.length; ++i)
                    if (!$util.isString(message.inorganic[i]))
                        return "inorganic: string[] expected";
            }
            if (message.organic != null && message.hasOwnProperty("organic")) {
                if (!Array.isArray(message.organic))
                    return "organic: array expected";
                for (var i = 0; i < message.organic.length; ++i)
                    if (!$util.isString(message.organic[i]))
                        return "organic: string[] expected";
            }
            return null;
        };

        /**
         * Creates a RawNames message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof isoworldremote.RawNames
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {isoworldremote.RawNames} RawNames
         */
        RawNames.fromObject = function fromObject(object) {
            if (object instanceof $root.isoworldremote.RawNames)
                return object;
            var message = new $root.isoworldremote.RawNames();
            if (object.available != null)
                message.available = Boolean(object.available);
            if (object.inorganic) {
                if (!Array.isArray(object.inorganic))
                    throw TypeError(".isoworldremote.RawNames.inorganic: array expected");
                message.inorganic = [];
                for (var i = 0; i < object.inorganic.length; ++i)
                    message.inorganic[i] = String(object.inorganic[i]);
            }
            if (object.organic) {
                if (!Array.isArray(object.organic))
                    throw TypeError(".isoworldremote.RawNames.organic: array expected");
                message.organic = [];
                for (var i = 0; i < object.organic.length; ++i)
                    message.organic[i] = String(object.organic[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a RawNames message. Also converts values to other types if specified.
         * @function toObject
         * @memberof isoworldremote.RawNames
         * @static
         * @param {isoworldremote.RawNames} message RawNames
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RawNames.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.inorganic = [];
                object.organic = [];
            }
            if (options.defaults)
                object.available = false;
            if (message.available != null && message.hasOwnProperty("available"))
                object.available = message.available;
            if (message.inorganic && message.inorganic.length) {
                object.inorganic = [];
                for (var j = 0; j < message.inorganic.length; ++j)
                    object.inorganic[j] = message.inorganic[j];
            }
            if (message.organic && message.organic.length) {
                object.organic = [];
                for (var j = 0; j < message.organic.length; ++j)
                    object.organic[j] = message.organic[j];
            }
            return object;
        };

        /**
         * Converts this RawNames to JSON.
         * @function toJSON
         * @memberof isoworldremote.RawNames
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RawNames.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RawNames;
    })();

    return isoworldremote;
})();

module.exports = $root;
